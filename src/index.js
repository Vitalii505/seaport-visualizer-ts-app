/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@pixi/accessibility/lib/AccessibilityManager.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/accessibility/lib/AccessibilityManager.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), display = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.js"), events = __webpack_require__(/*! @pixi/events */ "./node_modules/@pixi/events/lib/index.js"), accessibleTarget = __webpack_require__(/*! ./accessibleTarget.js */ "./node_modules/@pixi/accessibility/lib/accessibleTarget.js");
display.DisplayObject.mixin(accessibleTarget.accessibleTarget);
const KEY_CODE_TAB = 9, DIV_TOUCH_SIZE = 100, DIV_TOUCH_POS_X = 0, DIV_TOUCH_POS_Y = 0, DIV_TOUCH_ZINDEX = 2, DIV_HOOK_SIZE = 1, DIV_HOOK_POS_X = -1e3, DIV_HOOK_POS_Y = -1e3, DIV_HOOK_ZINDEX = 2;
class AccessibilityManager {
  // 2fps
  /**
   * @param {PIXI.CanvasRenderer|PIXI.Renderer} renderer - A reference to the current renderer
   */
  constructor(renderer) {
    this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (core.utils.isMobile.tablet || core.utils.isMobile.phone) && this.createTouchHook();
    const div = document.createElement("div");
    div.style.width = `${DIV_TOUCH_SIZE}px`, div.style.height = `${DIV_TOUCH_SIZE}px`, div.style.position = "absolute", div.style.top = `${DIV_TOUCH_POS_X}px`, div.style.left = `${DIV_TOUCH_POS_Y}px`, div.style.zIndex = DIV_TOUCH_ZINDEX.toString(), this.div = div, this.renderer = renderer, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1);
  }
  /**
   * Value of `true` if accessibility is currently active and accessibility layers are showing.
   * @member {boolean}
   * @readonly
   */
  get isActive() {
    return this._isActive;
  }
  /**
   * Value of `true` if accessibility is enabled for touch devices.
   * @member {boolean}
   * @readonly
   */
  get isMobileAccessibility() {
    return this._isMobileAccessibility;
  }
  /**
   * Creates the touch hooks.
   * @private
   */
  createTouchHook() {
    const hookDiv = document.createElement("button");
    hookDiv.style.width = `${DIV_HOOK_SIZE}px`, hookDiv.style.height = `${DIV_HOOK_SIZE}px`, hookDiv.style.position = "absolute", hookDiv.style.top = `${DIV_HOOK_POS_X}px`, hookDiv.style.left = `${DIV_HOOK_POS_Y}px`, hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString(), hookDiv.style.backgroundColor = "#FF0000", hookDiv.title = "select to enable accessibility for this content", hookDiv.addEventListener("focus", () => {
      this._isMobileAccessibility = !0, this.activate(), this.destroyTouchHook();
    }), document.body.appendChild(hookDiv), this._hookDiv = hookDiv;
  }
  /**
   * Destroys the touch hooks.
   * @private
   */
  destroyTouchHook() {
    this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
  }
  /**
   * Activating will cause the Accessibility layer to be shown.
   * This is called when a user presses the tab key.
   * @private
   */
  activate() {
    this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), this.renderer.view.parentNode?.appendChild(this.div));
  }
  /**
   * Deactivating will cause the Accessibility layer to be hidden.
   * This is called when a user moves the mouse.
   * @private
   */
  deactivate() {
    !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), this.div.parentNode?.removeChild(this.div));
  }
  /**
   * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
   * @private
   * @param {PIXI.Container} displayObject - The DisplayObject to check.
   */
  updateAccessibleObjects(displayObject) {
    if (!displayObject.visible || !displayObject.accessibleChildren)
      return;
    displayObject.accessible && displayObject.isInteractive() && (displayObject._accessibleActive || this.addChild(displayObject), displayObject.renderId = this.renderId);
    const children = displayObject.children;
    if (children)
      for (let i = 0; i < children.length; i++)
        this.updateAccessibleObjects(children[i]);
  }
  /**
   * Before each render this function will ensure that all divs are mapped correctly to their DisplayObjects.
   * @private
   */
  update() {
    const now = performance.now();
    if (core.utils.isMobile.android.device && now < this.androidUpdateCount || (this.androidUpdateCount = now + this.androidUpdateFrequency, !this.renderer.renderingToScreen))
      return;
    this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);
    const { x, y, width, height } = this.renderer.view.getBoundingClientRect(), { width: viewWidth, height: viewHeight, resolution } = this.renderer, sx = width / viewWidth * resolution, sy = height / viewHeight * resolution;
    let div = this.div;
    div.style.left = `${x}px`, div.style.top = `${y}px`, div.style.width = `${viewWidth}px`, div.style.height = `${viewHeight}px`;
    for (let i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      if (child.renderId !== this.renderId)
        child._accessibleActive = !1, core.utils.removeItems(this.children, i, 1), this.div.removeChild(child._accessibleDiv), this.pool.push(child._accessibleDiv), child._accessibleDiv = null, i--;
      else {
        div = child._accessibleDiv;
        let hitArea = child.hitArea;
        const wt = child.worldTransform;
        child.hitArea ? (div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`, div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`, div.style.width = `${hitArea.width * wt.a * sx}px`, div.style.height = `${hitArea.height * wt.d * sy}px`) : (hitArea = child.getBounds(), this.capHitArea(hitArea), div.style.left = `${hitArea.x * sx}px`, div.style.top = `${hitArea.y * sy}px`, div.style.width = `${hitArea.width * sx}px`, div.style.height = `${hitArea.height * sy}px`, div.title !== child.accessibleTitle && child.accessibleTitle !== null && (div.title = child.accessibleTitle), div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null && div.setAttribute("aria-label", child.accessibleHint)), (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) && (div.title = child.accessibleTitle, div.tabIndex = child.tabIndex, this.debug && this.updateDebugHTML(div));
      }
    }
    this.renderId++;
  }
  /**
   * private function that will visually add the information to the
   * accessability div
   * @param {HTMLElement} div -
   */
  updateDebugHTML(div) {
    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
  }
  /**
   * Adjust the hit area based on the bounds of a display object
   * @param {PIXI.Rectangle} hitArea - Bounds of the child
   */
  capHitArea(hitArea) {
    hitArea.x < 0 && (hitArea.width += hitArea.x, hitArea.x = 0), hitArea.y < 0 && (hitArea.height += hitArea.y, hitArea.y = 0);
    const { width: viewWidth, height: viewHeight } = this.renderer;
    hitArea.x + hitArea.width > viewWidth && (hitArea.width = viewWidth - hitArea.x), hitArea.y + hitArea.height > viewHeight && (hitArea.height = viewHeight - hitArea.y);
  }
  /**
   * Adds a DisplayObject to the accessibility manager
   * @private
   * @param {PIXI.DisplayObject} displayObject - The child to make accessible.
   */
  addChild(displayObject) {
    let div = this.pool.pop();
    div || (div = document.createElement("button"), div.style.width = `${DIV_TOUCH_SIZE}px`, div.style.height = `${DIV_TOUCH_SIZE}px`, div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", div.style.position = "absolute", div.style.zIndex = DIV_TOUCH_ZINDEX.toString(), div.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? div.setAttribute("aria-live", "off") : div.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? div.setAttribute("aria-relevant", "additions") : div.setAttribute("aria-relevant", "text"), div.addEventListener("click", this._onClick.bind(this)), div.addEventListener("focus", this._onFocus.bind(this)), div.addEventListener("focusout", this._onFocusOut.bind(this))), div.style.pointerEvents = displayObject.accessiblePointerEvents, div.type = displayObject.accessibleType, displayObject.accessibleTitle && displayObject.accessibleTitle !== null ? div.title = displayObject.accessibleTitle : (!displayObject.accessibleHint || displayObject.accessibleHint === null) && (div.title = `displayObject ${displayObject.tabIndex}`), displayObject.accessibleHint && displayObject.accessibleHint !== null && div.setAttribute("aria-label", displayObject.accessibleHint), this.debug && this.updateDebugHTML(div), displayObject._accessibleActive = !0, displayObject._accessibleDiv = div, div.displayObject = displayObject, this.children.push(displayObject), this.div.appendChild(displayObject._accessibleDiv), displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
  }
  /**
   * Dispatch events with the EventSystem.
   * @param e
   * @param type
   * @private
   */
  _dispatchEvent(e, type) {
    const { displayObject: target } = e.target, boundry = this.renderer.events.rootBoundary, event = Object.assign(new events.FederatedEvent(boundry), { target });
    boundry.rootTarget = this.renderer.lastObjectRendered, type.forEach((type2) => boundry.dispatchEvent(event, type2));
  }
  /**
   * Maps the div button press to pixi's EventSystem (click)
   * @private
   * @param {MouseEvent} e - The click event.
   */
  _onClick(e) {
    this._dispatchEvent(e, ["click", "pointertap", "tap"]);
  }
  /**
   * Maps the div focus events to pixi's EventSystem (mouseover)
   * @private
   * @param {FocusEvent} e - The focus event.
   */
  _onFocus(e) {
    e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(e, ["mouseover"]);
  }
  /**
   * Maps the div focus events to pixi's EventSystem (mouseout)
   * @private
   * @param {FocusEvent} e - The focusout event.
   */
  _onFocusOut(e) {
    e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "polite"), this._dispatchEvent(e, ["mouseout"]);
  }
  /**
   * Is called when a key is pressed
   * @private
   * @param {KeyboardEvent} e - The keydown event.
   */
  _onKeyDown(e) {
    e.keyCode === KEY_CODE_TAB && this.activate();
  }
  /**
   * Is called when the mouse moves across the renderer element
   * @private
   * @param {MouseEvent} e - The mouse event.
   */
  _onMouseMove(e) {
    e.movementX === 0 && e.movementY === 0 || this.deactivate();
  }
  /** Destroys the accessibility manager */
  destroy() {
    this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;
  }
}
AccessibilityManager.extension = {
  name: "accessibility",
  type: [
    core.ExtensionType.RendererPlugin,
    core.ExtensionType.CanvasRendererPlugin
  ]
};
core.extensions.add(AccessibilityManager);
exports.AccessibilityManager = AccessibilityManager;
//# sourceMappingURL=AccessibilityManager.js.map


/***/ }),

/***/ "./node_modules/@pixi/accessibility/lib/accessibleTarget.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/accessibility/lib/accessibleTarget.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const accessibleTarget = {
  /**
   *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
   *   shadow div with attributes set
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  accessible: !1,
  /**
   * Sets the title attribute of the shadow div
   * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
   * @member {?string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleTitle: null,
  /**
   * Sets the aria-label attribute of the shadow div
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleHint: null,
  /**
   * @member {number}
   * @memberof PIXI.DisplayObject#
   * @private
   * @todo Needs docs.
   */
  tabIndex: 0,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleActive: !1,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleDiv: null,
  /**
   * Specify the type of div the accessible layer is. Screen readers treat the element differently
   * depending on this type. Defaults to button.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'button'
   */
  accessibleType: "button",
  /**
   * Specify the pointer-events the accessible div will use
   * Defaults to auto.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'auto'
   */
  accessiblePointerEvents: "auto",
  /**
   * Setting to false will prevent any children inside this container to
   * be accessible. Defaults to true.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @default true
   */
  accessibleChildren: !0,
  renderId: -1
};
exports.accessibleTarget = accessibleTarget;
//# sourceMappingURL=accessibleTarget.js.map


/***/ }),

/***/ "./node_modules/@pixi/accessibility/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/accessibility/lib/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var AccessibilityManager = __webpack_require__(/*! ./AccessibilityManager.js */ "./node_modules/@pixi/accessibility/lib/AccessibilityManager.js"), accessibleTarget = __webpack_require__(/*! ./accessibleTarget.js */ "./node_modules/@pixi/accessibility/lib/accessibleTarget.js");
exports.AccessibilityManager = AccessibilityManager.AccessibilityManager;
exports.accessibleTarget = accessibleTarget.accessibleTarget;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/app/lib/Application.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/app/lib/Application.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), display = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.js");
const _Application = class _Application2 {
  /**
   * @param options - The optional application and renderer parameters.
   */
  constructor(options) {
    this.stage = new display.Container(), options = Object.assign({
      forceCanvas: !1
    }, options), this.renderer = core.autoDetectRenderer(options), _Application2._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  /** Render the current stage. */
  render() {
    this.renderer.render(this.stage);
  }
  /**
   * Reference to the renderer's canvas element.
   * @member {PIXI.ICanvas}
   * @readonly
   */
  get view() {
    return this.renderer?.view;
  }
  /**
   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
   * @member {PIXI.Rectangle}
   * @readonly
   */
  get screen() {
    return this.renderer?.screen;
  }
  /**
   * Destroy and don't use after this.
   * @param {boolean} [removeView=false] - Automatically remove canvas from DOM.
   * @param {object|boolean} [stageOptions] - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [stageOptions.children=false] - if set to true, all the children will have their destroy
   *  method called as well. 'stageOptions' will be passed on to those calls.
   * @param {boolean} [stageOptions.texture=false] - Only used for child Sprites if stageOptions.children is set
   *  to true. Should it destroy the texture of the child sprite
   * @param {boolean} [stageOptions.baseTexture=false] - Only used for child Sprites if stageOptions.children is set
   *  to true. Should it destroy the base texture of the child sprite
   */
  destroy(removeView, stageOptions) {
    const plugins = _Application2._plugins.slice(0);
    plugins.reverse(), plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    }), this.stage.destroy(stageOptions), this.stage = null, this.renderer.destroy(removeView), this.renderer = null;
  }
};
_Application._plugins = [];
let Application = _Application;
core.extensions.handleByList(core.ExtensionType.Application, Application._plugins);
exports.Application = Application;
//# sourceMappingURL=Application.js.map


/***/ }),

/***/ "./node_modules/@pixi/app/lib/ResizePlugin.js":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/app/lib/ResizePlugin.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
class ResizePlugin {
  /**
   * Initialize the plugin with scope of application instance
   * @static
   * @private
   * @param {object} [options] - See application options
   */
  static init(options) {
    Object.defineProperty(
      this,
      "resizeTo",
      /**
       * The HTML element or window to automatically resize the
       * renderer's view element to match width and height.
       * @member {Window|HTMLElement}
       * @name resizeTo
       * @memberof PIXI.Application#
       */
      {
        set(dom) {
          globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = dom, dom && (globalThis.addEventListener("resize", this.queueResize), this.resize());
        },
        get() {
          return this._resizeTo;
        }
      }
    ), this.queueResize = () => {
      this._resizeTo && (this.cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize()));
    }, this.cancelResize = () => {
      this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null);
    }, this.resize = () => {
      if (!this._resizeTo)
        return;
      this.cancelResize();
      let width, height;
      if (this._resizeTo === globalThis.window)
        width = globalThis.innerWidth, height = globalThis.innerHeight;
      else {
        const { clientWidth, clientHeight } = this._resizeTo;
        width = clientWidth, height = clientHeight;
      }
      this.renderer.resize(width, height), this.render();
    }, this._resizeId = null, this._resizeTo = null, this.resizeTo = options.resizeTo || null;
  }
  /**
   * Clean up the ticker, scoped to application
   * @static
   * @private
   */
  static destroy() {
    globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
  }
}
ResizePlugin.extension = core.ExtensionType.Application;
core.extensions.add(ResizePlugin);
exports.ResizePlugin = ResizePlugin;
//# sourceMappingURL=ResizePlugin.js.map


/***/ }),

/***/ "./node_modules/@pixi/app/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@pixi/app/lib/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Application = __webpack_require__(/*! ./Application.js */ "./node_modules/@pixi/app/lib/Application.js"), ResizePlugin = __webpack_require__(/*! ./ResizePlugin.js */ "./node_modules/@pixi/app/lib/ResizePlugin.js");
exports.Application = Application.Application;
exports.ResizePlugin = ResizePlugin.ResizePlugin;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/AssetExtension.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/AssetExtension.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
const assetKeyMap = {
  loader: core.ExtensionType.LoadParser,
  resolver: core.ExtensionType.ResolveParser,
  cache: core.ExtensionType.CacheParser,
  detection: core.ExtensionType.DetectionParser
};
core.extensions.handle(core.ExtensionType.Asset, (extension) => {
  const ref = extension.ref;
  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => core.extensions.add(Object.assign(
    ref[key],
    // Allow the function to optionally define it's own
    // ExtensionMetadata, the use cases here is priority for LoaderParsers
    { extension: ref[key].extension ?? type }
  )));
}, (extension) => {
  const ref = extension.ref;
  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => core.extensions.remove(ref[key]));
});
//# sourceMappingURL=AssetExtension.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/Assets.js":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/Assets.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), BackgroundLoader = __webpack_require__(/*! ./BackgroundLoader.js */ "./node_modules/@pixi/assets/lib/BackgroundLoader.js"), Cache = __webpack_require__(/*! ./cache/Cache.js */ "./node_modules/@pixi/assets/lib/cache/Cache.js"), Loader = __webpack_require__(/*! ./loader/Loader.js */ "./node_modules/@pixi/assets/lib/loader/Loader.js");
__webpack_require__(/*! ./loader/parsers/index.js */ "./node_modules/@pixi/assets/lib/loader/parsers/index.js");
var Resolver = __webpack_require__(/*! ./resolver/Resolver.js */ "./node_modules/@pixi/assets/lib/resolver/Resolver.js"), convertToList = __webpack_require__(/*! ./utils/convertToList.js */ "./node_modules/@pixi/assets/lib/utils/convertToList.js"), isSingleItem = __webpack_require__(/*! ./utils/isSingleItem.js */ "./node_modules/@pixi/assets/lib/utils/isSingleItem.js"), loadTextures = __webpack_require__(/*! ./loader/parsers/textures/loadTextures.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.js");
class AssetsClass {
  constructor() {
    this._detections = [], this._initialized = !1, this.resolver = new Resolver.Resolver(), this.loader = new Loader.Loader(), this.cache = Cache.Cache, this._backgroundLoader = new BackgroundLoader.BackgroundLoader(this.loader), this._backgroundLoader.active = !0, this.reset();
  }
  /**
   * Best practice is to call this function before any loading commences
   * Initiating is the best time to add any customization to the way things are loaded.
   *
   * you do not need to call this for the Asset class to work, only if you want to set any initial properties
   * @param options - options to initialize the Asset manager with
   */
  async init(options = {}) {
    if (this._initialized) {
      console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
      return;
    }
    if (this._initialized = !0, options.defaultSearchParams && this.resolver.setDefaultSearchParams(options.defaultSearchParams), options.basePath && (this.resolver.basePath = options.basePath), options.bundleIdentifier && this.resolver.setBundleIdentifier(options.bundleIdentifier), options.manifest) {
      let manifest = options.manifest;
      typeof manifest == "string" && (manifest = await this.load(manifest)), this.resolver.addManifest(manifest);
    }
    const resolutionPref = options.texturePreference?.resolution ?? 1, resolution = typeof resolutionPref == "number" ? [resolutionPref] : resolutionPref, formats = await this._detectFormats({
      preferredFormats: options.texturePreference?.format,
      skipDetections: options.skipDetections,
      detections: this._detections
    });
    this.resolver.prefer({
      params: {
        format: formats,
        resolution
      }
    }), options.preferences && this.setPreferences(options.preferences);
  }
  add(aliases, srcs, data, format, loadParser) {
    this.resolver.add(aliases, srcs, data, format, loadParser);
  }
  async load(urls, onProgress) {
    this._initialized || await this.init();
    const singleAsset = isSingleItem.isSingleItem(urls), urlArray = convertToList.convertToList(urls).map((url) => {
      if (typeof url != "string") {
        const aliases = this.resolver.getAlias(url);
        return aliases.some((alias) => !this.resolver.hasKey(alias)) && this.add(url), Array.isArray(aliases) ? aliases[0] : aliases;
      }
      return this.resolver.hasKey(url) || this.add({ alias: url, src: url }), url;
    }), resolveResults = this.resolver.resolve(urlArray), out = await this._mapLoadToResolve(resolveResults, onProgress);
    return singleAsset ? out[urlArray[0]] : out;
  }
  /**
   * This adds a bundle of assets in one go so that you can load them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const assets = await Assets.loadBundle('animals');
   * @param bundleId - the id of the bundle to add
   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(bundleId, assets) {
    this.resolver.addBundle(bundleId, assets);
  }
  /**
   * Bundles are a way to load multiple assets at once.
   * If a manifest has been provided to the init function then you can load a bundle, or bundles.
   * you can also add bundles via `addBundle`
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * await Asset.init({ manifest });
   *
   * // Load a bundle...
   * loadScreenAssets = await Assets.loadBundle('load-screen');
   * // Load another bundle...
   * gameScreenAssets = await Assets.loadBundle('game-screen');
   * @param bundleIds - the bundle id or ids to load
   * @param onProgress - Optional function that is called when progress on asset loading is made.
   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)
   * of the assets loaded. Do not use this function to detect when assets are complete and available,
   * instead use the Promise returned by this function.
   * @returns all the bundles assets or a hash of assets for each bundle specified
   */
  async loadBundle(bundleIds, onProgress) {
    this._initialized || await this.init();
    let singleAsset = !1;
    typeof bundleIds == "string" && (singleAsset = !0, bundleIds = [bundleIds]);
    const resolveResults = this.resolver.resolveBundle(bundleIds), out = {}, keys = Object.keys(resolveResults);
    let count = 0, total = 0;
    const _onProgress = () => {
      onProgress?.(++count / total);
    }, promises = keys.map((bundleId) => {
      const resolveResult = resolveResults[bundleId];
      return total += Object.keys(resolveResult).length, this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
        out[bundleId] = resolveResult2;
      });
    });
    return await Promise.all(promises), singleAsset ? out[bundleIds[0]] : out;
  }
  /**
   * Initiate a background load of some assets. It will passively begin to load these assets in the background.
   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately
   *
   * An example of this might be that you would background load game assets after your inital load.
   * then when you got to actually load your game screen assets when a player goes to the game - the loading
   * would already have stared or may even be complete, saving you having to show an interim load bar.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.backgroundLoad('bunny.png');
   *
   * // later on in your app...
   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!
   * @param urls - the url / urls you want to background load
   */
  async backgroundLoad(urls) {
    this._initialized || await this.init(), typeof urls == "string" && (urls = [urls]);
    const resolveResults = this.resolver.resolve(urls);
    this._backgroundLoader.add(Object.values(resolveResults));
  }
  /**
   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.
   * this can only be used if the loader has been initiated with a manifest
   * @example
   * import { Assets } from 'pixi.js';
   *
   * await Assets.init({
   *     manifest: {
   *         bundles: [
   *             {
   *                 name: 'load-screen',
   *                 assets: [...],
   *             },
   *             ...
   *         ],
   *     },
   * });
   *
   * Assets.backgroundLoadBundle('load-screen');
   *
   * // Later on in your app...
   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!
   * @param bundleIds - the bundleId / bundleIds you want to background load
   */
  async backgroundLoadBundle(bundleIds) {
    this._initialized || await this.init(), typeof bundleIds == "string" && (bundleIds = [bundleIds]);
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    Object.values(resolveResults).forEach((resolveResult) => {
      this._backgroundLoader.add(Object.values(resolveResult));
    });
  }
  /**
   * Only intended for development purposes.
   * This will wipe the resolver and caches.
   * You will need to reinitialize the Asset
   */
  reset() {
    this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1;
  }
  get(keys) {
    if (typeof keys == "string")
      return Cache.Cache.get(keys);
    const assets = {};
    for (let i = 0; i < keys.length; i++)
      assets[i] = Cache.Cache.get(keys[i]);
    return assets;
  }
  /**
   * helper function to map resolved assets back to loaded assets
   * @param resolveResults - the resolve results from the resolver
   * @param onProgress - the progress callback
   */
  async _mapLoadToResolve(resolveResults, onProgress) {
    const resolveArray = Object.values(resolveResults), resolveKeys = Object.keys(resolveResults);
    this._backgroundLoader.active = !1;
    const loadedAssets = await this.loader.load(resolveArray, onProgress);
    this._backgroundLoader.active = !0;
    const out = {};
    return resolveArray.forEach((resolveResult, i) => {
      const asset = loadedAssets[resolveResult.src], keys = [resolveResult.src];
      resolveResult.alias && keys.push(...resolveResult.alias), out[resolveKeys[i]] = asset, Cache.Cache.set(keys, asset);
    }), out;
  }
  /**
   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function
   * this will make sure to destroy any assets and release them from memory.
   * Once unloaded, you will need to load the asset again.
   *
   * Use this to help manage assets if you find that you have a large app and you want to free up memory.
   *
   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,
   * Pixi won't break but you will end up with missing assets. Not a good look for the user!
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Load a URL:
   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture
   *
   * await Assets.unload('http://some.url.com/image.png')
   *
   * // myImageTexture will be destroyed now.
   *
   * // Unload multiple assets:
   * const textures = await Assets.unload(['thumper', 'chicko']);
   * @param urls - the urls to unload
   */
  async unload(urls) {
    this._initialized || await this.init();
    const urlArray = convertToList.convertToList(urls).map((url) => typeof url != "string" ? url.src : url), resolveResults = this.resolver.resolve(urlArray);
    await this._unloadFromResolved(resolveResults);
  }
  /**
   * Bundles are a way to manage multiple assets at once.
   * this will unload all files in a bundle.
   *
   * once a bundle has been unloaded, you need to load it again to have access to the assets.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle({
   *     'thumper': 'http://some.url.com/thumper.png',
   * })
   *
   * const assets = await Assets.loadBundle('thumper');
   *
   * // Now to unload...
   *
   * await Assets.unloadBundle('thumper');
   *
   * // All assets in the assets object will now have been destroyed and purged from the cache
   * @param bundleIds - the bundle id or ids to unload
   */
  async unloadBundle(bundleIds) {
    this._initialized || await this.init(), bundleIds = convertToList.convertToList(bundleIds);
    const resolveResults = this.resolver.resolveBundle(bundleIds), promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
    await Promise.all(promises);
  }
  async _unloadFromResolved(resolveResult) {
    const resolveArray = Object.values(resolveResult);
    resolveArray.forEach((resolveResult2) => {
      Cache.Cache.remove(resolveResult2.src);
    }), await this.loader.unload(resolveArray);
  }
  /**
   * Detects the supported formats for the browser, and returns an array of supported formats, respecting
   * the users preferred formats order.
   * @param options - the options to use when detecting formats
   * @param options.preferredFormats - the preferred formats to use
   * @param options.skipDetections - if we should skip the detections altogether
   * @param options.detections - the detections to use
   * @returns - the detected formats
   */
  async _detectFormats(options) {
    let formats = [];
    options.preferredFormats && (formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats]);
    for (const detection of options.detections)
      options.skipDetections || await detection.test() ? formats = await detection.add(formats) : options.skipDetections || (formats = await detection.remove(formats));
    return formats = formats.filter((format, index) => formats.indexOf(format) === index), formats;
  }
  /** All the detection parsers currently added to the Assets class. */
  get detections() {
    return this._detections;
  }
  /**
   * @deprecated since 7.2.0
   * @see {@link Assets.setPreferences}
   */
  get preferWorkers() {
    return loadTextures.loadTextures.config.preferWorkers;
  }
  set preferWorkers(value) {
    core.utils.deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead."), this.setPreferences({ preferWorkers: value });
  }
  /**
   * General setter for preferences. This is a helper function to set preferences on all parsers.
   * @param preferences - the preferences to set
   */
  setPreferences(preferences) {
    this.loader.parsers.forEach((parser) => {
      parser.config && Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
        parser.config[key] = preferences[key];
      });
    });
  }
}
const Assets = new AssetsClass();
core.extensions.handleByList(core.ExtensionType.LoadParser, Assets.loader.parsers).handleByList(core.ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(core.ExtensionType.CacheParser, Assets.cache.parsers).handleByList(core.ExtensionType.DetectionParser, Assets.detections);
exports.Assets = Assets;
exports.AssetsClass = AssetsClass;
//# sourceMappingURL=Assets.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/BackgroundLoader.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/BackgroundLoader.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class BackgroundLoader {
  /**
   * @param loader
   * @param verbose - should the loader log to the console
   */
  constructor(loader, verbose = !1) {
    this._loader = loader, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = verbose;
  }
  /**
   * Adds an array of assets to load.
   * @param assetUrls - assets to load
   */
  add(assetUrls) {
    assetUrls.forEach((a) => {
      this._assetList.push(a);
    }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next();
  }
  /**
   * Loads the next set of assets. Will try to load as many assets as it can at the same time.
   *
   * The max assets it will try to load at one time will be 4.
   */
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = !0;
      const toLoad = [], toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i = 0; i < toLoadAmount; i++)
        toLoad.push(this._assetList.pop());
      await this._loader.load(toLoad), this._isLoading = !1, this._next();
    }
  }
  /**
   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.
   * @returns whether the class is active
   */
  get active() {
    return this._isActive;
  }
  set active(value) {
    this._isActive !== value && (this._isActive = value, value && !this._isLoading && this._next());
  }
}
exports.BackgroundLoader = BackgroundLoader;
//# sourceMappingURL=BackgroundLoader.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/cache/Cache.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/cache/Cache.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
__webpack_require__(/*! ../utils/index.js */ "./node_modules/@pixi/assets/lib/utils/index.js");
var convertToList = __webpack_require__(/*! ../utils/convertToList.js */ "./node_modules/@pixi/assets/lib/utils/convertToList.js");
class CacheClass {
  constructor() {
    this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();
  }
  /** Clear all entries. */
  reset() {
    this._cacheMap.clear(), this._cache.clear();
  }
  /**
   * Check if the key exists
   * @param key - The key to check
   */
  has(key) {
    return this._cache.has(key);
  }
  /**
   * Fetch entry by key
   * @param key - The key of the entry to get
   */
  get(key) {
    const result = this._cache.get(key);
    return result || console.warn(`[Assets] Asset id ${key} was not found in the Cache`), result;
  }
  /**
   * Set a value by key or keys name
   * @param key - The key or keys to set
   * @param value - The value to store in the cache or from which cacheable assets will be derived.
   */
  set(key, value) {
    const keys = convertToList.convertToList(key);
    let cacheableAssets;
    for (let i = 0; i < this.parsers.length; i++) {
      const parser = this.parsers[i];
      if (parser.test(value)) {
        cacheableAssets = parser.getCacheableAssets(keys, value);
        break;
      }
    }
    cacheableAssets || (cacheableAssets = {}, keys.forEach((key2) => {
      cacheableAssets[key2] = value;
    }));
    const cacheKeys = Object.keys(cacheableAssets), cachedAssets = {
      cacheKeys,
      keys
    };
    if (keys.forEach((key2) => {
      this._cacheMap.set(key2, cachedAssets);
    }), cacheKeys.forEach((key2) => {
      this._cache.has(key2) && this._cache.get(key2) !== value && console.warn("[Cache] already has key:", key2), this._cache.set(key2, cacheableAssets[key2]);
    }), value instanceof core.Texture) {
      const texture = value;
      keys.forEach((key2) => {
        texture.baseTexture !== core.Texture.EMPTY.baseTexture && core.BaseTexture.addToCache(texture.baseTexture, key2), core.Texture.addToCache(texture, key2);
      });
    }
  }
  /**
   * Remove entry by key
   *
   * This function will also remove any associated alias from the cache also.
   * @param key - The key of the entry to remove
   */
  remove(key) {
    if (!this._cacheMap.has(key)) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
      return;
    }
    const cacheMap = this._cacheMap.get(key);
    cacheMap.cacheKeys.forEach((key2) => {
      this._cache.delete(key2);
    }), cacheMap.keys.forEach((key2) => {
      this._cacheMap.delete(key2);
    });
  }
  /** All loader parsers registered */
  get parsers() {
    return this._parsers;
  }
}
const Cache = new CacheClass();
exports.Cache = Cache;
//# sourceMappingURL=Cache.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/cache/CacheParser.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/cache/CacheParser.js ***!
  \************************************************************/
/***/ (() => {

"use strict";

//# sourceMappingURL=CacheParser.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/cache/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/cache/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Cache = __webpack_require__(/*! ./Cache.js */ "./node_modules/@pixi/assets/lib/cache/Cache.js");
__webpack_require__(/*! ./CacheParser.js */ "./node_modules/@pixi/assets/lib/cache/CacheParser.js");
__webpack_require__(/*! ./parsers/index.js */ "./node_modules/@pixi/assets/lib/cache/parsers/index.js");
exports.Cache = Cache.Cache;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
const cacheTextureArray = {
  extension: core.ExtensionType.CacheParser,
  test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof core.Texture),
  getCacheableAssets: (keys, asset) => {
    const out = {};
    return keys.forEach((key) => {
      asset.forEach((item, i) => {
        out[key + (i === 0 ? "" : i + 1)] = item;
      });
    }), out;
  }
};
core.extensions.add(cacheTextureArray);
exports.cacheTextureArray = cacheTextureArray;
//# sourceMappingURL=cacheTextureArray.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/cache/parsers/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/cache/parsers/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var cacheTextureArray = __webpack_require__(/*! ./cacheTextureArray.js */ "./node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.js");
exports.cacheTextureArray = cacheTextureArray.cacheTextureArray;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/detections/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/detections/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ./parsers/index.js */ "./node_modules/@pixi/assets/lib/detections/parsers/index.js");
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/detections/parsers/detectAvif.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/detections/parsers/detectAvif.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), testImageFormat = __webpack_require__(/*! ../utils/testImageFormat.js */ "./node_modules/@pixi/assets/lib/detections/utils/testImageFormat.js");
const detectAvif = {
  extension: {
    type: core.ExtensionType.DetectionParser,
    priority: 1
  },
  test: async () => testImageFormat.testImageFormat(
    // eslint-disable-next-line max-len
    "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
  ),
  add: async (formats) => [...formats, "avif"],
  remove: async (formats) => formats.filter((f) => f !== "avif")
};
core.extensions.add(detectAvif);
exports.detectAvif = detectAvif;
//# sourceMappingURL=detectAvif.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
const imageFormats = ["png", "jpg", "jpeg"], detectDefaults = {
  extension: {
    type: core.ExtensionType.DetectionParser,
    priority: -1
  },
  test: () => Promise.resolve(!0),
  add: async (formats) => [...formats, ...imageFormats],
  remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))
};
core.extensions.add(detectDefaults);
exports.detectDefaults = detectDefaults;
//# sourceMappingURL=detectDefaults.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/detections/parsers/detectMp4.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/detections/parsers/detectMp4.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), testVideoFormat = __webpack_require__(/*! ../utils/testVideoFormat.js */ "./node_modules/@pixi/assets/lib/detections/utils/testVideoFormat.js");
const detectMp4 = {
  extension: {
    type: core.ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => testVideoFormat.testVideoFormat("video/mp4"),
  add: async (formats) => [...formats, "mp4", "m4v"],
  remove: async (formats) => formats.filter((f) => f !== "mp4" && f !== "m4v")
};
core.extensions.add(detectMp4);
exports.detectMp4 = detectMp4;
//# sourceMappingURL=detectMp4.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/detections/parsers/detectOgv.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/detections/parsers/detectOgv.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), testVideoFormat = __webpack_require__(/*! ../utils/testVideoFormat.js */ "./node_modules/@pixi/assets/lib/detections/utils/testVideoFormat.js");
const detectOgv = {
  extension: {
    type: core.ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => testVideoFormat.testVideoFormat("video/ogg"),
  add: async (formats) => [...formats, "ogv"],
  remove: async (formats) => formats.filter((f) => f !== "ogv")
};
core.extensions.add(detectOgv);
exports.detectOgv = detectOgv;
//# sourceMappingURL=detectOgv.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/detections/parsers/detectWebm.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/detections/parsers/detectWebm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), testVideoFormat = __webpack_require__(/*! ../utils/testVideoFormat.js */ "./node_modules/@pixi/assets/lib/detections/utils/testVideoFormat.js");
const detectWebm = {
  extension: {
    type: core.ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => testVideoFormat.testVideoFormat("video/webm"),
  add: async (formats) => [...formats, "webm"],
  remove: async (formats) => formats.filter((f) => f !== "webm")
};
core.extensions.add(detectWebm);
exports.detectWebm = detectWebm;
//# sourceMappingURL=detectWebm.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/detections/parsers/detectWebp.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/detections/parsers/detectWebp.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), testImageFormat = __webpack_require__(/*! ../utils/testImageFormat.js */ "./node_modules/@pixi/assets/lib/detections/utils/testImageFormat.js");
const detectWebp = {
  extension: {
    type: core.ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => testImageFormat.testImageFormat(
    "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
  ),
  add: async (formats) => [...formats, "webp"],
  remove: async (formats) => formats.filter((f) => f !== "webp")
};
core.extensions.add(detectWebp);
exports.detectWebp = detectWebp;
//# sourceMappingURL=detectWebp.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/detections/parsers/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/detections/parsers/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var detectAvif = __webpack_require__(/*! ./detectAvif.js */ "./node_modules/@pixi/assets/lib/detections/parsers/detectAvif.js"), detectWebp = __webpack_require__(/*! ./detectWebp.js */ "./node_modules/@pixi/assets/lib/detections/parsers/detectWebp.js"), detectDefaults = __webpack_require__(/*! ./detectDefaults.js */ "./node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.js"), detectWebm = __webpack_require__(/*! ./detectWebm.js */ "./node_modules/@pixi/assets/lib/detections/parsers/detectWebm.js"), detectMp4 = __webpack_require__(/*! ./detectMp4.js */ "./node_modules/@pixi/assets/lib/detections/parsers/detectMp4.js"), detectOgv = __webpack_require__(/*! ./detectOgv.js */ "./node_modules/@pixi/assets/lib/detections/parsers/detectOgv.js");
exports.detectAvif = detectAvif.detectAvif;
exports.detectWebp = detectWebp.detectWebp;
exports.detectDefaults = detectDefaults.detectDefaults;
exports.detectWebm = detectWebm.detectWebm;
exports.detectMp4 = detectMp4.detectMp4;
exports.detectOgv = detectOgv.detectOgv;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/detections/utils/testImageFormat.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/detections/utils/testImageFormat.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

async function testImageFormat(imageData) {
  if ("Image" in globalThis)
    return new Promise((resolve) => {
      const image = new Image();
      image.onload = () => {
        resolve(!0);
      }, image.onerror = () => {
        resolve(!1);
      }, image.src = imageData;
    });
  if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
    try {
      const blob = await (await fetch(imageData)).blob();
      await createImageBitmap(blob);
    } catch {
      return !1;
    }
    return !0;
  }
  return !1;
}
exports.testImageFormat = testImageFormat;
//# sourceMappingURL=testImageFormat.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/detections/utils/testVideoFormat.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/detections/utils/testVideoFormat.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
function testVideoFormat(mimeType) {
  return inWorker ? !1 : document.createElement("video").canPlayType(mimeType) !== "";
}
exports.testVideoFormat = testVideoFormat;
//# sourceMappingURL=testVideoFormat.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ./AssetExtension.js */ "./node_modules/@pixi/assets/lib/AssetExtension.js");
var Assets = __webpack_require__(/*! ./Assets.js */ "./node_modules/@pixi/assets/lib/Assets.js");
__webpack_require__(/*! ./cache/index.js */ "./node_modules/@pixi/assets/lib/cache/index.js");
__webpack_require__(/*! ./detections/index.js */ "./node_modules/@pixi/assets/lib/detections/index.js");
__webpack_require__(/*! ./loader/index.js */ "./node_modules/@pixi/assets/lib/loader/index.js");
__webpack_require__(/*! ./resolver/index.js */ "./node_modules/@pixi/assets/lib/resolver/index.js");
__webpack_require__(/*! ./types.js */ "./node_modules/@pixi/assets/lib/types.js");
__webpack_require__(/*! ./utils/index.js */ "./node_modules/@pixi/assets/lib/utils/index.js");
var Cache = __webpack_require__(/*! ./cache/Cache.js */ "./node_modules/@pixi/assets/lib/cache/Cache.js"), cacheTextureArray = __webpack_require__(/*! ./cache/parsers/cacheTextureArray.js */ "./node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.js"), detectAvif = __webpack_require__(/*! ./detections/parsers/detectAvif.js */ "./node_modules/@pixi/assets/lib/detections/parsers/detectAvif.js"), detectWebp = __webpack_require__(/*! ./detections/parsers/detectWebp.js */ "./node_modules/@pixi/assets/lib/detections/parsers/detectWebp.js"), detectDefaults = __webpack_require__(/*! ./detections/parsers/detectDefaults.js */ "./node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.js"), detectWebm = __webpack_require__(/*! ./detections/parsers/detectWebm.js */ "./node_modules/@pixi/assets/lib/detections/parsers/detectWebm.js"), detectMp4 = __webpack_require__(/*! ./detections/parsers/detectMp4.js */ "./node_modules/@pixi/assets/lib/detections/parsers/detectMp4.js"), detectOgv = __webpack_require__(/*! ./detections/parsers/detectOgv.js */ "./node_modules/@pixi/assets/lib/detections/parsers/detectOgv.js"), LoaderParser = __webpack_require__(/*! ./loader/parsers/LoaderParser.js */ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js"), loadJson = __webpack_require__(/*! ./loader/parsers/loadJson.js */ "./node_modules/@pixi/assets/lib/loader/parsers/loadJson.js"), loadTxt = __webpack_require__(/*! ./loader/parsers/loadTxt.js */ "./node_modules/@pixi/assets/lib/loader/parsers/loadTxt.js"), loadWebFont = __webpack_require__(/*! ./loader/parsers/loadWebFont.js */ "./node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.js"), loadSVG = __webpack_require__(/*! ./loader/parsers/textures/loadSVG.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.js"), loadTextures = __webpack_require__(/*! ./loader/parsers/textures/loadTextures.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.js"), loadVideo = __webpack_require__(/*! ./loader/parsers/textures/loadVideo.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadVideo.js"), createTexture = __webpack_require__(/*! ./loader/parsers/textures/utils/createTexture.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.js"), resolveTextureUrl = __webpack_require__(/*! ./resolver/parsers/resolveTextureUrl.js */ "./node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.js"), checkDataUrl = __webpack_require__(/*! ./utils/checkDataUrl.js */ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.js"), checkExtension = __webpack_require__(/*! ./utils/checkExtension.js */ "./node_modules/@pixi/assets/lib/utils/checkExtension.js"), convertToList = __webpack_require__(/*! ./utils/convertToList.js */ "./node_modules/@pixi/assets/lib/utils/convertToList.js"), copySearchParams = __webpack_require__(/*! ./utils/copySearchParams.js */ "./node_modules/@pixi/assets/lib/utils/copySearchParams.js"), createStringVariations = __webpack_require__(/*! ./utils/createStringVariations.js */ "./node_modules/@pixi/assets/lib/utils/createStringVariations.js"), isSingleItem = __webpack_require__(/*! ./utils/isSingleItem.js */ "./node_modules/@pixi/assets/lib/utils/isSingleItem.js");
exports.Assets = Assets.Assets;
exports.AssetsClass = Assets.AssetsClass;
exports.Cache = Cache.Cache;
exports.cacheTextureArray = cacheTextureArray.cacheTextureArray;
exports.detectAvif = detectAvif.detectAvif;
exports.detectWebp = detectWebp.detectWebp;
exports.detectDefaults = detectDefaults.detectDefaults;
exports.detectWebm = detectWebm.detectWebm;
exports.detectMp4 = detectMp4.detectMp4;
exports.detectOgv = detectOgv.detectOgv;
exports.LoaderParserPriority = LoaderParser.LoaderParserPriority;
exports.loadJson = loadJson.loadJson;
exports.loadTxt = loadTxt.loadTxt;
exports.getFontFamilyName = loadWebFont.getFontFamilyName;
exports.loadWebFont = loadWebFont.loadWebFont;
exports.loadSVG = loadSVG.loadSVG;
exports.loadImageBitmap = loadTextures.loadImageBitmap;
exports.loadTextures = loadTextures.loadTextures;
exports.loadVideo = loadVideo.loadVideo;
exports.createTexture = createTexture.createTexture;
exports.resolveTextureUrl = resolveTextureUrl.resolveTextureUrl;
exports.checkDataUrl = checkDataUrl.checkDataUrl;
exports.checkExtension = checkExtension.checkExtension;
exports.convertToList = convertToList.convertToList;
exports.copySearchParams = copySearchParams.copySearchParams;
exports.createStringVariations = createStringVariations.createStringVariations;
exports.isSingleItem = isSingleItem.isSingleItem;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/Loader.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/Loader.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
__webpack_require__(/*! ../utils/index.js */ "./node_modules/@pixi/assets/lib/utils/index.js");
var isSingleItem = __webpack_require__(/*! ../utils/isSingleItem.js */ "./node_modules/@pixi/assets/lib/utils/isSingleItem.js"), convertToList = __webpack_require__(/*! ../utils/convertToList.js */ "./node_modules/@pixi/assets/lib/utils/convertToList.js");
class Loader {
  constructor() {
    this._parsers = [], this._parsersValidated = !1, this.parsers = new Proxy(this._parsers, {
      set: (target, key, value) => (this._parsersValidated = !1, target[key] = value, !0)
    }), this.promiseCache = {};
  }
  /** function used for testing */
  reset() {
    this._parsersValidated = !1, this.promiseCache = {};
  }
  /**
   * Used internally to generate a promise for the asset to be loaded.
   * @param url - The URL to be loaded
   * @param data - any custom additional information relevant to the asset being loaded
   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
   */
  _getLoadPromiseAndParser(url, data) {
    const result = {
      promise: null,
      parser: null
    };
    return result.promise = (async () => {
      let asset = null, parser = null;
      if (data.loadParser && (parser = this._parserHash[data.loadParser], parser || console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`)), !parser) {
        for (let i = 0; i < this.parsers.length; i++) {
          const parserX = this.parsers[i];
          if (parserX.load && parserX.test?.(url, data, this)) {
            parser = parserX;
            break;
          }
        }
        if (!parser)
          return console.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null;
      }
      asset = await parser.load(url, data, this), result.parser = parser;
      for (let i = 0; i < this.parsers.length; i++) {
        const parser2 = this.parsers[i];
        parser2.parse && parser2.parse && await parser2.testParse?.(asset, data, this) && (asset = await parser2.parse(asset, data, this) || asset, result.parser = parser2);
      }
      return asset;
    })(), result;
  }
  async load(assetsToLoadIn, onProgress) {
    this._parsersValidated || this._validateParsers();
    let count = 0;
    const assets = {}, singleAsset = isSingleItem.isSingleItem(assetsToLoadIn), assetsToLoad = convertToList.convertToList(assetsToLoadIn, (item) => ({
      alias: [item],
      src: item
    })), total = assetsToLoad.length, promises = assetsToLoad.map(async (asset) => {
      const url = core.utils.path.toAbsolute(asset.src);
      if (!assets[asset.src])
        try {
          this.promiseCache[url] || (this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset)), assets[asset.src] = await this.promiseCache[url].promise, onProgress && onProgress(++count / total);
        } catch (e) {
          throw delete this.promiseCache[url], delete assets[asset.src], new Error(`[Loader.load] Failed to load ${url}.
${e}`);
        }
    });
    return await Promise.all(promises), singleAsset ? assets[assetsToLoad[0].src] : assets;
  }
  /**
   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
   * The parser that created the asset, will be the one that unloads it.
   * @example
   * // Single asset:
   * const asset = await Loader.load('cool.png');
   *
   * await Loader.unload('cool.png');
   *
   * console.log(asset.destroyed); // true
   * @param assetsToUnloadIn - urls that you want to unload, or a single one!
   */
  async unload(assetsToUnloadIn) {
    const promises = convertToList.convertToList(assetsToUnloadIn, (item) => ({
      alias: [item],
      src: item
    })).map(async (asset) => {
      const url = core.utils.path.toAbsolute(asset.src), loadPromise = this.promiseCache[url];
      if (loadPromise) {
        const loadedAsset = await loadPromise.promise;
        delete this.promiseCache[url], loadPromise.parser?.unload?.(loadedAsset, asset, this);
      }
    });
    await Promise.all(promises);
  }
  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */
  _validateParsers() {
    this._parsersValidated = !0, this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => (hash[parser.name] && console.warn(`[Assets] loadParser name conflict "${parser.name}"`), { ...hash, [parser.name]: parser }), {});
  }
}
exports.Loader = Loader;
//# sourceMappingURL=Loader.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ./parsers/index.js */ "./node_modules/@pixi/assets/lib/loader/parsers/index.js");
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => (LoaderParserPriority2[LoaderParserPriority2.Low = 0] = "Low", LoaderParserPriority2[LoaderParserPriority2.Normal = 1] = "Normal", LoaderParserPriority2[LoaderParserPriority2.High = 2] = "High", LoaderParserPriority2))(LoaderParserPriority || {});
exports.LoaderParserPriority = LoaderParserPriority;
//# sourceMappingURL=LoaderParser.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

let UUID = 0, MAX_WORKERS;
const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=", checkImageBitmapCode = {
  id: "checkImageBitmap",
  code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
}, workerCode = {
  id: "loadImageBitmap",
  code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
};
let workerURL;
class WorkerManagerClass {
  constructor() {
    this._initialized = !1, this._createdWorkers = 0, this.workerPool = [], this.queue = [], this.resolveHash = {};
  }
  isImageBitmapSupported() {
    return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise((resolve) => {
      const workerURL2 = URL.createObjectURL(new Blob(
        [checkImageBitmapCode.code],
        { type: "application/javascript" }
      )), worker = new Worker(workerURL2);
      worker.addEventListener("message", (event) => {
        worker.terminate(), URL.revokeObjectURL(workerURL2), resolve(event.data);
      });
    }), this._isImageBitmapSupported);
  }
  loadImageBitmap(src) {
    return this._run("loadImageBitmap", [src]);
  }
  async _initWorkers() {
    this._initialized || (this._initialized = !0);
  }
  getWorker() {
    MAX_WORKERS === void 0 && (MAX_WORKERS = navigator.hardwareConcurrency || 4);
    let worker = this.workerPool.pop();
    return !worker && this._createdWorkers < MAX_WORKERS && (workerURL || (workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }))), this._createdWorkers++, worker = new Worker(workerURL), worker.addEventListener("message", (event) => {
      this.complete(event.data), this.returnWorker(event.target), this.next();
    })), worker;
  }
  returnWorker(worker) {
    this.workerPool.push(worker);
  }
  complete(data) {
    data.error !== void 0 ? this.resolveHash[data.uuid].reject(data.error) : this.resolveHash[data.uuid].resolve(data.data), this.resolveHash[data.uuid] = null;
  }
  async _run(id, args) {
    await this._initWorkers();
    const promise = new Promise((resolve, reject) => {
      this.queue.push({ id, arguments: args, resolve, reject });
    });
    return this.next(), promise;
  }
  next() {
    if (!this.queue.length)
      return;
    const worker = this.getWorker();
    if (!worker)
      return;
    const toDo = this.queue.pop(), id = toDo.id;
    this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject }, worker.postMessage({
      data: toDo.arguments,
      uuid: UUID++,
      id
    });
  }
}
const WorkerManager = new WorkerManagerClass();
exports.WorkerManager = WorkerManager;
//# sourceMappingURL=WorkerManager.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var LoaderParser = __webpack_require__(/*! ./LoaderParser.js */ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js"), loadJson = __webpack_require__(/*! ./loadJson.js */ "./node_modules/@pixi/assets/lib/loader/parsers/loadJson.js"), loadTxt = __webpack_require__(/*! ./loadTxt.js */ "./node_modules/@pixi/assets/lib/loader/parsers/loadTxt.js"), loadWebFont = __webpack_require__(/*! ./loadWebFont.js */ "./node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.js");
__webpack_require__(/*! ./textures/index.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/index.js");
exports.LoaderParserPriority = LoaderParser.LoaderParserPriority;
exports.loadJson = loadJson.loadJson;
exports.loadTxt = loadTxt.loadTxt;
exports.getFontFamilyName = loadWebFont.getFontFamilyName;
exports.loadWebFont = loadWebFont.loadWebFont;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/loadJson.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/loadJson.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), checkDataUrl = __webpack_require__(/*! ../../utils/checkDataUrl.js */ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.js"), checkExtension = __webpack_require__(/*! ../../utils/checkExtension.js */ "./node_modules/@pixi/assets/lib/utils/checkExtension.js"), LoaderParser = __webpack_require__(/*! ./LoaderParser.js */ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js");
const validJSONExtension = ".json", validJSONMIME = "application/json", loadJson = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.Low
  },
  name: "loadJson",
  test(url) {
    return checkDataUrl.checkDataUrl(url, validJSONMIME) || checkExtension.checkExtension(url, validJSONExtension);
  },
  async load(url) {
    return await (await core.settings.ADAPTER.fetch(url)).json();
  }
};
core.extensions.add(loadJson);
exports.loadJson = loadJson;
//# sourceMappingURL=loadJson.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/loadTxt.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/loadTxt.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), checkDataUrl = __webpack_require__(/*! ../../utils/checkDataUrl.js */ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.js"), checkExtension = __webpack_require__(/*! ../../utils/checkExtension.js */ "./node_modules/@pixi/assets/lib/utils/checkExtension.js"), LoaderParser = __webpack_require__(/*! ./LoaderParser.js */ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js");
const validTXTExtension = ".txt", validTXTMIME = "text/plain", loadTxt = {
  name: "loadTxt",
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.Low
  },
  test(url) {
    return checkDataUrl.checkDataUrl(url, validTXTMIME) || checkExtension.checkExtension(url, validTXTExtension);
  },
  async load(url) {
    return await (await core.settings.ADAPTER.fetch(url)).text();
  }
};
core.extensions.add(loadTxt);
exports.loadTxt = loadTxt;
//# sourceMappingURL=loadTxt.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), checkDataUrl = __webpack_require__(/*! ../../utils/checkDataUrl.js */ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.js"), checkExtension = __webpack_require__(/*! ../../utils/checkExtension.js */ "./node_modules/@pixi/assets/lib/utils/checkExtension.js"), LoaderParser = __webpack_require__(/*! ./LoaderParser.js */ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js");
const validWeights = [
  "normal",
  "bold",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
], validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"], validFontMIMEs = [
  "font/ttf",
  "font/otf",
  "font/woff",
  "font/woff2"
], CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function getFontFamilyName(url) {
  const ext = core.utils.path.extname(url), nameTokens = core.utils.path.basename(url, ext).replace(/(-|_)/g, " ").toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens)
    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = !1;
      break;
    }
  let fontFamilyName = nameTokens.join(" ");
  return valid || (fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`), fontFamilyName;
}
const validURICharactersRegex = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
function encodeURIWhenNeeded(uri) {
  return validURICharactersRegex.test(uri) ? uri : encodeURI(uri);
}
const loadWebFont = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.Low
  },
  name: "loadWebFont",
  test(url) {
    return checkDataUrl.checkDataUrl(url, validFontMIMEs) || checkExtension.checkExtension(url, validFontExtensions);
  },
  async load(url, options) {
    const fonts = core.settings.ADAPTER.getFontFaceSet();
    if (fonts) {
      const fontFaces = [], name = options.data?.family ?? getFontFamilyName(url), weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"], data = options.data ?? {};
      for (let i = 0; i < weights.length; i++) {
        const weight = weights[i], font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {
          ...data,
          weight
        });
        await font.load(), fonts.add(font), fontFaces.push(font);
      }
      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
    }
    return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"), null;
  },
  unload(font) {
    (Array.isArray(font) ? font : [font]).forEach((t) => core.settings.ADAPTER.getFontFaceSet().delete(t));
  }
};
core.extensions.add(loadWebFont);
exports.getFontFamilyName = getFontFamilyName;
exports.loadWebFont = loadWebFont;
//# sourceMappingURL=loadWebFont.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/textures/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/textures/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var loadSVG = __webpack_require__(/*! ./loadSVG.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.js"), loadTextures = __webpack_require__(/*! ./loadTextures.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.js"), loadVideo = __webpack_require__(/*! ./loadVideo.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadVideo.js");
__webpack_require__(/*! ./utils/index.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.js");
exports.loadSVG = loadSVG.loadSVG;
exports.loadImageBitmap = loadTextures.loadImageBitmap;
exports.loadTextures = loadTextures.loadTextures;
exports.loadVideo = loadVideo.loadVideo;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), checkDataUrl = __webpack_require__(/*! ../../../utils/checkDataUrl.js */ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.js"), checkExtension = __webpack_require__(/*! ../../../utils/checkExtension.js */ "./node_modules/@pixi/assets/lib/utils/checkExtension.js"), LoaderParser = __webpack_require__(/*! ../LoaderParser.js */ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js"), loadTextures = __webpack_require__(/*! ./loadTextures.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.js"), createTexture = __webpack_require__(/*! ./utils/createTexture.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.js");
const validSVGExtension = ".svg", validSVGMIME = "image/svg+xml", loadSVG = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.High
  },
  name: "loadSVG",
  test(url) {
    return checkDataUrl.checkDataUrl(url, validSVGMIME) || checkExtension.checkExtension(url, validSVGExtension);
  },
  async testParse(data) {
    return core.SVGResource.test(data);
  },
  async parse(asset, data, loader) {
    const src = new core.SVGResource(asset, data?.data?.resourceOptions);
    await src.load();
    const base = new core.BaseTexture(src, {
      resolution: core.utils.getResolutionOfUrl(asset),
      ...data?.data
    });
    return base.resource.src = data.src, createTexture.createTexture(base, loader, data.src);
  },
  async load(url, _options) {
    return (await core.settings.ADAPTER.fetch(url)).text();
  },
  unload: loadTextures.loadTextures.unload
};
core.extensions.add(loadSVG);
exports.loadSVG = loadSVG;
//# sourceMappingURL=loadSVG.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), checkDataUrl = __webpack_require__(/*! ../../../utils/checkDataUrl.js */ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.js"), checkExtension = __webpack_require__(/*! ../../../utils/checkExtension.js */ "./node_modules/@pixi/assets/lib/utils/checkExtension.js"), LoaderParser = __webpack_require__(/*! ../LoaderParser.js */ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js"), WorkerManager = __webpack_require__(/*! ../WorkerManager.js */ "./node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.js"), createTexture = __webpack_require__(/*! ./utils/createTexture.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.js");
const validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"], validImageMIMEs = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/avif"
];
async function loadImageBitmap(url) {
  const response = await core.settings.ADAPTER.fetch(url);
  if (!response.ok)
    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);
  const imageBlob = await response.blob();
  return await createImageBitmap(imageBlob);
}
const loadTextures = {
  name: "loadTextures",
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.High
  },
  config: {
    preferWorkers: !0,
    preferCreateImageBitmap: !0,
    crossOrigin: "anonymous"
  },
  test(url) {
    return checkDataUrl.checkDataUrl(url, validImageMIMEs) || checkExtension.checkExtension(url, validImageExtensions);
  },
  async load(url, asset, loader) {
    const useImageBitmap = globalThis.createImageBitmap && this.config.preferCreateImageBitmap;
    let src;
    useImageBitmap ? this.config.preferWorkers && await WorkerManager.WorkerManager.isImageBitmapSupported() ? src = await WorkerManager.WorkerManager.loadImageBitmap(url) : src = await loadImageBitmap(url) : src = await new Promise((resolve, reject) => {
      const src2 = new Image();
      src2.crossOrigin = this.config.crossOrigin, src2.src = url, src2.complete ? resolve(src2) : (src2.onload = () => resolve(src2), src2.onerror = (e) => reject(e));
    });
    const options = { ...asset.data };
    options.resolution ?? (options.resolution = core.utils.getResolutionOfUrl(url)), useImageBitmap && options.resourceOptions?.ownsImageBitmap === void 0 && (options.resourceOptions = { ...options.resourceOptions }, options.resourceOptions.ownsImageBitmap = !0);
    const base = new core.BaseTexture(src, options);
    return base.resource.src = url, createTexture.createTexture(base, loader, url);
  },
  unload(texture) {
    texture.destroy(!0);
  }
};
core.extensions.add(loadTextures);
exports.loadImageBitmap = loadImageBitmap;
exports.loadTextures = loadTextures;
//# sourceMappingURL=loadTextures.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadVideo.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/textures/loadVideo.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), checkDataUrl = __webpack_require__(/*! ../../../utils/checkDataUrl.js */ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.js"), checkExtension = __webpack_require__(/*! ../../../utils/checkExtension.js */ "./node_modules/@pixi/assets/lib/utils/checkExtension.js"), LoaderParser = __webpack_require__(/*! ../LoaderParser.js */ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.js"), createTexture = __webpack_require__(/*! ./utils/createTexture.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.js");
const validVideoExtensions = [".mp4", ".m4v", ".webm", ".ogv"], validVideoMIMEs = [
  "video/mp4",
  "video/webm",
  "video/ogg"
], loadVideo = {
  name: "loadVideo",
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: LoaderParser.LoaderParserPriority.High
  },
  config: {
    defaultAutoPlay: !0
  },
  test(url) {
    return checkDataUrl.checkDataUrl(url, validVideoMIMEs) || checkExtension.checkExtension(url, validVideoExtensions);
  },
  async load(url, loadAsset, loader) {
    let texture;
    const blob = await (await core.settings.ADAPTER.fetch(url)).blob(), blobURL = URL.createObjectURL(blob);
    try {
      const options = {
        autoPlay: this.config.defaultAutoPlay,
        ...loadAsset?.data?.resourceOptions
      }, src = new core.VideoResource(blobURL, options);
      await src.load();
      const base = new core.BaseTexture(src, {
        alphaMode: await core.utils.detectVideoAlphaMode(),
        resolution: core.utils.getResolutionOfUrl(url),
        ...loadAsset?.data
      });
      base.resource.src = url, texture = createTexture.createTexture(base, loader, url), texture.baseTexture.once("destroyed", () => {
        URL.revokeObjectURL(blobURL);
      });
    } catch (e) {
      throw URL.revokeObjectURL(blobURL), e;
    }
    return texture;
  },
  unload(texture) {
    texture.destroy(!0);
  }
};
core.extensions.add(loadVideo);
exports.loadVideo = loadVideo;
//# sourceMappingURL=loadVideo.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), Cache = __webpack_require__(/*! ../../../../cache/Cache.js */ "./node_modules/@pixi/assets/lib/cache/Cache.js");
function createTexture(base, loader, url) {
  base.resource.internal = !0;
  const texture = new core.Texture(base), unload = () => {
    delete loader.promiseCache[url], Cache.Cache.has(url) && Cache.Cache.remove(url);
  };
  return texture.baseTexture.once("destroyed", () => {
    url in loader.promiseCache && (console.warn("[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture."), unload());
  }), texture.once("destroyed", () => {
    base.destroyed || (console.warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), unload());
  }), texture;
}
exports.createTexture = createTexture;
//# sourceMappingURL=createTexture.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var createTexture = __webpack_require__(/*! ./createTexture.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.js");
exports.createTexture = createTexture.createTexture;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/resolver/Resolver.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/resolver/Resolver.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), convertToList = __webpack_require__(/*! ../utils/convertToList.js */ "./node_modules/@pixi/assets/lib/utils/convertToList.js"), createStringVariations = __webpack_require__(/*! ../utils/createStringVariations.js */ "./node_modules/@pixi/assets/lib/utils/createStringVariations.js"), isSingleItem = __webpack_require__(/*! ../utils/isSingleItem.js */ "./node_modules/@pixi/assets/lib/utils/isSingleItem.js");
class Resolver {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
    }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
  }
  /**
   * Override how the resolver deals with generating bundle ids.
   * must be called before any bundles are added
   * @param bundleIdentifier - the bundle identifier options
   */
  setBundleIdentifier(bundleIdentifier) {
    if (this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector, this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar")
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
  }
  /**
   * Let the resolver know which assets you prefer to use when resolving assets.
   * Multiple prefer user defined rules can be added.
   * @example
   * resolver.prefer({
   *     // first look for something with the correct format, and then then correct resolution
   *     priority: ['format', 'resolution'],
   *     params:{
   *         format:'webp', // prefer webp images
   *         resolution: 2, // prefer a resolution of 2
   *     }
   * })
   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
   * resolver.resolveUrl('foo') // => 'bar@2x.webp'
   * @param preferOrders - the prefer options
   */
  prefer(...preferOrders) {
    preferOrders.forEach((prefer) => {
      this._preferredOrder.push(prefer), prefer.priority || (prefer.priority = Object.keys(prefer.params));
    }), this._resolverHash = {};
  }
  /**
   * Set the base path to prepend to all urls when resolving
   * @example
   * resolver.basePath = 'https://home.com/';
   * resolver.add('foo', 'bar.ong');
   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
   * @param basePath - the base path to use
   */
  set basePath(basePath) {
    this._basePath = basePath;
  }
  get basePath() {
    return this._basePath;
  }
  /**
   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
   * default value for browsers is `window.location.origin`
   * @example
   * // Application hosted on https://home.com/some-path/index.html
   * resolver.basePath = 'https://home.com/some-path/';
   * resolver.rootPath = 'https://home.com/';
   * resolver.add('foo', '/bar.png');
   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
   * @param rootPath - the root path to use
   */
  set rootPath(rootPath) {
    this._rootPath = rootPath;
  }
  get rootPath() {
    return this._rootPath;
  }
  /**
   * All the active URL parsers that help the parser to extract information and create
   * an asset object-based on parsing the URL itself.
   *
   * Can be added using the extensions API
   * @example
   * resolver.add('foo', [
   *     {
   *         resolution: 2,
   *         format: 'png',
   *         src: 'image@2x.png',
   *     },
   *     {
   *         resolution:1,
   *         format:'png',
   *         src: 'image.png',
   *     },
   * ]);
   *
   * // With a url parser the information such as resolution and file format could extracted from the url itself:
   * extensions.add({
   *     extension: ExtensionType.ResolveParser,
   *     test: loadTextures.test, // test if url ends in an image
   *     parse: (value: string) =>
   *     ({
   *         resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
   *         format: value.split('.').pop(),
   *         src: value,
   *     }),
   * });
   *
   * // Now resolution and format can be extracted from the url
   * resolver.add('foo', [
   *     'image@2x.png',
   *     'image.png',
   * ]);
   */
  get parsers() {
    return this._parsers;
  }
  /** Used for testing, this resets the resolver to its initial state */
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
  }
  /**
   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
   * @param searchParams - the default url parameters to append when resolving urls
   */
  setDefaultSearchParams(searchParams) {
    if (typeof searchParams == "string")
      this._defaultSearchParams = searchParams;
    else {
      const queryValues = searchParams;
      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
    }
  }
  /**
   * Returns the aliases for a given asset
   * @param asset - the asset to get the aliases for
   */
  getAlias(asset) {
    const { alias, name, src, srcs } = asset;
    return convertToList.convertToList(
      alias || name || src || srcs,
      (value) => typeof value == "string" ? value : Array.isArray(value) ? value.map((v) => v?.src ?? v?.srcs ?? v) : value?.src || value?.srcs ? value.src ?? value.srcs : value,
      !0
    );
  }
  /**
   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
   * generally a manifest would be built using a tool.
   * @param manifest - the manifest to add to the resolver
   */
  addManifest(manifest) {
    this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = manifest, manifest.bundles.forEach((bundle) => {
      this.addBundle(bundle.name, bundle.assets);
    });
  }
  /**
   * This adds a bundle of assets in one go so that you can resolve them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * resolver.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const resolvedAssets = await resolver.resolveBundle('animals');
   * @param bundleId - The id of the bundle to add
   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(bundleId, assets) {
    const assetNames = [];
    Array.isArray(assets) ? assets.forEach((asset) => {
      const srcs = asset.src ?? asset.srcs, aliases = asset.alias ?? asset.name;
      let ids;
      if (typeof aliases == "string") {
        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
        assetNames.push(bundleAssetId), ids = [aliases, bundleAssetId];
      } else {
        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
        assetNames.push(...bundleIds), ids = [...aliases, ...bundleIds];
      }
      this.add({
        ...asset,
        alias: ids,
        src: srcs
      });
    }) : Object.keys(assets).forEach((key) => {
      const aliases = [key, this._createBundleAssetId(bundleId, key)];
      if (typeof assets[key] == "string")
        this.add({
          alias: aliases,
          src: assets[key]
        });
      else if (Array.isArray(assets[key]))
        this.add({
          alias: aliases,
          src: assets[key]
        });
      else {
        const asset = assets[key], assetSrc = asset.src ?? asset.srcs;
        this.add({
          ...asset,
          alias: aliases,
          src: Array.isArray(assetSrc) ? assetSrc : [assetSrc]
        });
      }
      assetNames.push(...aliases);
    }), this._bundles[bundleId] = assetNames;
  }
  add(aliases, srcs, data, format, loadParser) {
    const assets = [];
    typeof aliases == "string" || Array.isArray(aliases) && typeof aliases[0] == "string" ? (core.utils.deprecation("7.2.0", `Assets.add now uses an object instead of individual parameters.
Please use Assets.add({ alias, src, data, format, loadParser }) instead.`), assets.push({ alias: aliases, src: srcs, data, format, loadParser })) : Array.isArray(aliases) ? assets.push(...aliases) : assets.push(aliases);
    let keyCheck;
    keyCheck = (key) => {
      this.hasKey(key) && console.warn(`[Resolver] already has key: ${key} overwriting`);
    }, convertToList.convertToList(assets).forEach((asset) => {
      const { src, srcs: srcs2 } = asset;
      let { data: data2, format: format2, loadParser: loadParser2 } = asset;
      const srcsToUse = convertToList.convertToList(src || srcs2).map((src2) => typeof src2 == "string" ? createStringVariations.createStringVariations(src2) : Array.isArray(src2) ? src2 : [src2]), aliasesToUse = this.getAlias(asset);
      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
      const resolvedAssets = [];
      srcsToUse.forEach((srcs3) => {
        srcs3.forEach((src2) => {
          let formattedAsset = {};
          if (typeof src2 != "object") {
            formattedAsset.src = src2;
            for (let i = 0; i < this._parsers.length; i++) {
              const parser = this._parsers[i];
              if (parser.test(src2)) {
                formattedAsset = parser.parse(src2);
                break;
              }
            }
          } else
            data2 = src2.data ?? data2, format2 = src2.format ?? format2, loadParser2 = src2.loadParser ?? loadParser2, formattedAsset = {
              ...formattedAsset,
              ...src2
            };
          if (!aliasesToUse)
            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
          formattedAsset = this.buildResolvedAsset(formattedAsset, {
            aliases: aliasesToUse,
            data: data2,
            format: format2,
            loadParser: loadParser2
          }), resolvedAssets.push(formattedAsset);
        });
      }), aliasesToUse.forEach((alias) => {
        this._assetMap[alias] = resolvedAssets;
      });
    });
  }
  // TODO: this needs an overload like load did in Assets
  /**
   * If the resolver has had a manifest set via setManifest, this will return the assets urls for
   * a given bundleId or bundleIds.
   * @example
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * resolver.setManifest(manifest);
   * const resolved = resolver.resolveBundle('load-screen');
   * @param bundleIds - The bundle ids to resolve
   * @returns All the bundles assets or a hash of assets for each bundle specified
   */
  resolveBundle(bundleIds) {
    const singleAsset = isSingleItem.isSingleItem(bundleIds);
    bundleIds = convertToList.convertToList(bundleIds);
    const out = {};
    return bundleIds.forEach((bundleId) => {
      const assetNames = this._bundles[bundleId];
      if (assetNames) {
        const results = this.resolve(assetNames), assets = {};
        for (const key in results) {
          const asset = results[key];
          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
        }
        out[bundleId] = assets;
      }
    }), singleAsset ? out[bundleIds[0]] : out;
  }
  /**
   * Does exactly what resolve does, but returns just the URL rather than the whole asset object
   * @param key - The key or keys to resolve
   * @returns - The URLs associated with the key(s)
   */
  resolveUrl(key) {
    const result = this.resolve(key);
    if (typeof key != "string") {
      const out = {};
      for (const i in result)
        out[i] = result[i].src;
      return out;
    }
    return result.src;
  }
  resolve(keys) {
    const singleAsset = isSingleItem.isSingleItem(keys);
    keys = convertToList.convertToList(keys);
    const result = {};
    return keys.forEach((key) => {
      if (!this._resolverHash[key])
        if (this._assetMap[key]) {
          let assets = this._assetMap[key];
          const bestAsset = assets[0], preferredOrder = this._getPreferredOrder(assets);
          preferredOrder?.priority.forEach((priorityKey) => {
            preferredOrder.params[priorityKey].forEach((value) => {
              const filteredAssets = assets.filter((asset) => asset[priorityKey] ? asset[priorityKey] === value : !1);
              filteredAssets.length && (assets = filteredAssets);
            });
          }), this._resolverHash[key] = assets[0] ?? bestAsset;
        } else
          this._resolverHash[key] = this.buildResolvedAsset({
            alias: [key],
            src: key
          }, {});
      result[key] = this._resolverHash[key];
    }), singleAsset ? result[keys[0]] : result;
  }
  /**
   * Checks if an asset with a given key exists in the resolver
   * @param key - The key of the asset
   */
  hasKey(key) {
    return !!this._assetMap[key];
  }
  /**
   * Checks if a bundle with the given key exists in the resolver
   * @param key - The key of the bundle
   */
  hasBundle(key) {
    return !!this._bundles[key];
  }
  /**
   * Internal function for figuring out what prefer criteria an asset should use.
   * @param assets
   */
  _getPreferredOrder(assets) {
    for (let i = 0; i < assets.length; i++) {
      const asset = assets[0], preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
      if (preferred)
        return preferred;
    }
    return this._preferredOrder[0];
  }
  /**
   * Appends the default url parameters to the url
   * @param url - The url to append the default parameters to
   * @returns - The url with the default parameters appended
   */
  _appendDefaultSearchParams(url) {
    if (!this._defaultSearchParams)
      return url;
    const paramConnector = /\?/.test(url) ? "&" : "?";
    return `${url}${paramConnector}${this._defaultSearchParams}`;
  }
  buildResolvedAsset(formattedAsset, data) {
    const { aliases, data: assetData, loadParser, format } = data;
    return (this._basePath || this._rootPath) && (formattedAsset.src = core.utils.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath)), formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src], formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src), formattedAsset.data = { ...assetData || {}, ...formattedAsset.data }, formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser, formattedAsset.format = format ?? core.utils.path.extname(formattedAsset.src).slice(1), formattedAsset.srcs = formattedAsset.src, formattedAsset.name = formattedAsset.alias, formattedAsset;
  }
}
exports.Resolver = Resolver;
//# sourceMappingURL=Resolver.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/resolver/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/resolver/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ./parsers/index.js */ "./node_modules/@pixi/assets/lib/resolver/parsers/index.js");
__webpack_require__(/*! ./types.js */ "./node_modules/@pixi/assets/lib/resolver/types.js");
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/resolver/parsers/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/resolver/parsers/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var resolveTextureUrl = __webpack_require__(/*! ./resolveTextureUrl.js */ "./node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.js");
exports.resolveTextureUrl = resolveTextureUrl.resolveTextureUrl;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
__webpack_require__(/*! ../../loader/index.js */ "./node_modules/@pixi/assets/lib/loader/index.js");
var loadTextures = __webpack_require__(/*! ../../loader/parsers/textures/loadTextures.js */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.js");
const resolveTextureUrl = {
  extension: core.ExtensionType.ResolveParser,
  test: loadTextures.loadTextures.test,
  parse: (value) => ({
    resolution: parseFloat(core.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
    format: core.utils.path.extname(value).slice(1),
    src: value
  })
};
core.extensions.add(resolveTextureUrl);
exports.resolveTextureUrl = resolveTextureUrl;
//# sourceMappingURL=resolveTextureUrl.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/resolver/types.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/resolver/types.js ***!
  \*********************************************************/
/***/ (() => {

"use strict";

//# sourceMappingURL=types.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/types.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/types.js ***!
  \************************************************/
/***/ (() => {

"use strict";

//# sourceMappingURL=types.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/utils/checkDataUrl.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function checkDataUrl(url, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes)
      if (url.startsWith(`data:${mime}`))
        return !0;
    return !1;
  }
  return url.startsWith(`data:${mimes}`);
}
exports.checkDataUrl = checkDataUrl;
//# sourceMappingURL=checkDataUrl.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/utils/checkExtension.js":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/utils/checkExtension.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
function checkExtension(url, extension) {
  const tempURL = url.split("?")[0], ext = core.utils.path.extname(tempURL).toLowerCase();
  return Array.isArray(extension) ? extension.includes(ext) : ext === extension;
}
exports.checkExtension = checkExtension;
//# sourceMappingURL=checkExtension.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/utils/convertToList.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/utils/convertToList.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const convertToList = (input, transform, forceTransform = !1) => (Array.isArray(input) || (input = [input]), transform ? input.map((item) => typeof item == "string" || forceTransform ? transform(item) : item) : input);
exports.convertToList = convertToList;
//# sourceMappingURL=convertToList.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/utils/copySearchParams.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/utils/copySearchParams.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const copySearchParams = (targetUrl, sourceUrl) => {
  const searchParams = sourceUrl.split("?")[1];
  return searchParams && (targetUrl += `?${searchParams}`), targetUrl;
};
exports.copySearchParams = copySearchParams;
//# sourceMappingURL=copySearchParams.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/utils/createStringVariations.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/utils/createStringVariations.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function processX(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i = 0; i < id.length; i++) {
    const value = id[i];
    depth < ids.length - 1 ? processX(base.replace(result[depth], value), ids, depth + 1, result, tags) : tags.push(base.replace(result[depth], value));
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g, result = string.match(regex), tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    }), processX(string, ids, 0, result, tags);
  } else
    tags.push(string);
  return tags;
}
exports.createStringVariations = createStringVariations;
//# sourceMappingURL=createStringVariations.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/utils/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/utils/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var checkDataUrl = __webpack_require__(/*! ./checkDataUrl.js */ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.js"), checkExtension = __webpack_require__(/*! ./checkExtension.js */ "./node_modules/@pixi/assets/lib/utils/checkExtension.js"), convertToList = __webpack_require__(/*! ./convertToList.js */ "./node_modules/@pixi/assets/lib/utils/convertToList.js"), copySearchParams = __webpack_require__(/*! ./copySearchParams.js */ "./node_modules/@pixi/assets/lib/utils/copySearchParams.js"), createStringVariations = __webpack_require__(/*! ./createStringVariations.js */ "./node_modules/@pixi/assets/lib/utils/createStringVariations.js"), isSingleItem = __webpack_require__(/*! ./isSingleItem.js */ "./node_modules/@pixi/assets/lib/utils/isSingleItem.js");
exports.checkDataUrl = checkDataUrl.checkDataUrl;
exports.checkExtension = checkExtension.checkExtension;
exports.convertToList = convertToList.convertToList;
exports.copySearchParams = copySearchParams.copySearchParams;
exports.createStringVariations = createStringVariations.createStringVariations;
exports.isSingleItem = isSingleItem.isSingleItem;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/utils/isSingleItem.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/utils/isSingleItem.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const isSingleItem = (item) => !Array.isArray(item);
exports.isSingleItem = isSingleItem;
//# sourceMappingURL=isSingleItem.js.map


/***/ }),

/***/ "./node_modules/@pixi/color/lib/Color.js":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/color/lib/Color.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var colord = __webpack_require__(/*! @pixi/colord */ "./node_modules/@pixi/colord/index.js"), namesPlugin = __webpack_require__(/*! @pixi/colord/plugins/names */ "./node_modules/@pixi/colord/plugins/names.js");
colord.extend([namesPlugin]);
const _Color = class _Color2 {
  /**
   * @param {PIXI.ColorSource} value - Optional value to use, if not provided, white is used.
   */
  constructor(value = 16777215) {
    this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = value;
  }
  /** Get red component (0 - 1) */
  get red() {
    return this._components[0];
  }
  /** Get green component (0 - 1) */
  get green() {
    return this._components[1];
  }
  /** Get blue component (0 - 1) */
  get blue() {
    return this._components[2];
  }
  /** Get alpha component (0 - 1) */
  get alpha() {
    return this._components[3];
  }
  /**
   * Set the value, suitable for chaining
   * @param value
   * @see PIXI.Color.value
   */
  setValue(value) {
    return this.value = value, this;
  }
  /**
   * The current color source.
   *
   * When setting:
   * - Setting to an instance of `Color` will copy its color source and components.
   * - Otherwise, `Color` will try to normalize the color source and set the components.
   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
   *
   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
   *
   * When getting:
   * - A return value of `null` means the previous value was overridden (e.g., {@link PIXI.Color.multiply multiply},
   *   {@link PIXI.Color.premultiply premultiply} or {@link PIXI.Color.round round}).
   * - Otherwise, the color source used when setting is returned.
   * @type {PIXI.ColorSource}
   */
  set value(value) {
    if (value instanceof _Color2)
      this._value = this.cloneSource(value._value), this._int = value._int, this._components.set(value._components);
    else {
      if (value === null)
        throw new Error("Cannot set PIXI.Color#value to null");
      (this._value === null || !this.isSourceEqual(this._value, value)) && (this.normalize(value), this._value = this.cloneSource(value));
    }
  }
  get value() {
    return this._value;
  }
  /**
   * Copy a color source internally.
   * @param value - Color source
   */
  cloneSource(value) {
    return typeof value == "string" || typeof value == "number" || value instanceof Number || value === null ? value : Array.isArray(value) || ArrayBuffer.isView(value) ? value.slice(0) : typeof value == "object" && value !== null ? { ...value } : value;
  }
  /**
   * Equality check for color sources.
   * @param value1 - First color source
   * @param value2 - Second color source
   * @returns `true` if the color sources are equal, `false` otherwise.
   */
  isSourceEqual(value1, value2) {
    const type1 = typeof value1;
    if (type1 !== typeof value2)
      return !1;
    if (type1 === "number" || type1 === "string" || value1 instanceof Number)
      return value1 === value2;
    if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2))
      return value1.length !== value2.length ? !1 : value1.every((v, i) => v === value2[i]);
    if (value1 !== null && value2 !== null) {
      const keys1 = Object.keys(value1), keys2 = Object.keys(value2);
      return keys1.length !== keys2.length ? !1 : keys1.every((key) => value1[key] === value2[key]);
    }
    return value1 === value2;
  }
  /**
   * Convert to a RGBA color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
   */
  toRgba() {
    const [r, g, b, a] = this._components;
    return { r, g, b, a };
  }
  /**
   * Convert to a RGB color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
   */
  toRgb() {
    const [r, g, b] = this._components;
    return { r, g, b };
  }
  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */
  toRgbaString() {
    const [r, g, b] = this.toUint8RgbArray();
    return `rgba(${r},${g},${b},${this.alpha})`;
  }
  toUint8RgbArray(out) {
    const [r, g, b] = this._components;
    return out = out ?? [], out[0] = Math.round(r * 255), out[1] = Math.round(g * 255), out[2] = Math.round(b * 255), out;
  }
  toRgbArray(out) {
    out = out ?? [];
    const [r, g, b] = this._components;
    return out[0] = r, out[1] = g, out[2] = b, out;
  }
  /**
   * Convert to a hexadecimal number.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toNumber(); // returns 16777215
   */
  toNumber() {
    return this._int;
  }
  /**
   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
   * @example
   * import { Color } from 'pixi.js';
   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
   * @returns {number} - The color as a number in little endian format.
   */
  toLittleEndianNumber() {
    const value = this._int;
    return (value >> 16) + (value & 65280) + ((value & 255) << 16);
  }
  /**
   * Multiply with another color. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param {PIXI.ColorSource} value - The color to multiply by.
   */
  multiply(value) {
    const [r, g, b, a] = _Color2.temp.setValue(value)._components;
    return this._components[0] *= r, this._components[1] *= g, this._components[2] *= b, this._components[3] *= a, this.refreshInt(), this._value = null, this;
  }
  /**
   * Converts color to a premultiplied alpha format. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {PIXI.Color} - Itself.
   */
  premultiply(alpha, applyToRGB = !0) {
    return applyToRGB && (this._components[0] *= alpha, this._components[1] *= alpha, this._components[2] *= alpha), this._components[3] = alpha, this.refreshInt(), this._value = null, this;
  }
  /**
   * Premultiplies alpha with current color.
   * @param {number} alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {number} tint multiplied by alpha
   */
  toPremultiplied(alpha, applyToRGB = !0) {
    if (alpha === 1)
      return (255 << 24) + this._int;
    if (alpha === 0)
      return applyToRGB ? 0 : this._int;
    let r = this._int >> 16 & 255, g = this._int >> 8 & 255, b = this._int & 255;
    return applyToRGB && (r = r * alpha + 0.5 | 0, g = g * alpha + 0.5 | 0, b = b * alpha + 0.5 | 0), (alpha * 255 << 24) + (r << 16) + (g << 8) + b;
  }
  /**
   * Convert to a hexidecimal string.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHex(); // returns "#ffffff"
   */
  toHex() {
    const hexString = this._int.toString(16);
    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
  }
  /**
   * Convert to a hexidecimal string with alpha.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHexa(); // returns "#ffffffff"
   */
  toHexa() {
    const alphaString = Math.round(this._components[3] * 255).toString(16);
    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
  }
  /**
   * Set alpha, suitable for chaining.
   * @param alpha
   */
  setAlpha(alpha) {
    return this._components[3] = this._clamp(alpha), this;
  }
  /**
   * Rounds the specified color according to the step. This action is destructive, and will
   * override the previous `value` property to be `null`. The alpha component is not rounded.
   * @param steps - Number of steps which will be used as a cap when rounding colors
   * @deprecated since 7.3.0
   */
  round(steps) {
    const [r, g, b] = this._components;
    return this._components[0] = Math.round(r * steps) / steps, this._components[1] = Math.round(g * steps) / steps, this._components[2] = Math.round(b * steps) / steps, this.refreshInt(), this._value = null, this;
  }
  toArray(out) {
    out = out ?? [];
    const [r, g, b, a] = this._components;
    return out[0] = r, out[1] = g, out[2] = b, out[3] = a, out;
  }
  /**
   * Normalize the input value into rgba
   * @param value - Input value
   */
  normalize(value) {
    let r, g, b, a;
    if ((typeof value == "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
      const int = value;
      r = (int >> 16 & 255) / 255, g = (int >> 8 & 255) / 255, b = (int & 255) / 255, a = 1;
    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4)
      value = this._clamp(value), [r, g, b, a = 1] = value;
    else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4)
      value = this._clamp(value, 0, 255), [r, g, b, a = 255] = value, r /= 255, g /= 255, b /= 255, a /= 255;
    else if (typeof value == "string" || typeof value == "object") {
      if (typeof value == "string") {
        const match = _Color2.HEX_PATTERN.exec(value);
        match && (value = `#${match[2]}`);
      }
      const color = colord.colord(value);
      color.isValid() && ({ r, g, b, a } = color.rgba, r /= 255, g /= 255, b /= 255);
    }
    if (r !== void 0)
      this._components[0] = r, this._components[1] = g, this._components[2] = b, this._components[3] = a, this.refreshInt();
    else
      throw new Error(`Unable to convert color ${value}`);
  }
  /** Refresh the internal color rgb number */
  refreshInt() {
    this._clamp(this._components);
    const [r, g, b] = this._components;
    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);
  }
  /**
   * Clamps values to a range. Will override original values
   * @param value - Value(s) to clamp
   * @param min - Minimum value
   * @param max - Maximum value
   */
  _clamp(value, min = 0, max = 1) {
    return typeof value == "number" ? Math.min(Math.max(value, min), max) : (value.forEach((v, i) => {
      value[i] = Math.min(Math.max(v, min), max);
    }), value);
  }
};
_Color.shared = new _Color(), /**
* Temporary Color object for static uses internally.
* As to not conflict with Color.shared.
* @ignore
*/
_Color.temp = new _Color(), /** Pattern for hex strings */
_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let Color = _Color;
exports.Color = Color;
//# sourceMappingURL=Color.js.map


/***/ }),

/***/ "./node_modules/@pixi/color/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/color/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Color = __webpack_require__(/*! ./Color.js */ "./node_modules/@pixi/color/lib/Color.js");
exports.Color = Color.Color;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/colord/index.js":
/*!********************************************!*\
  !*** ./node_modules/@pixi/colord/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

Object.defineProperty(exports, "__esModule", ({value:!0}));var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},o=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},a=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},s=/^#([0-9a-f]{3,8})$/i,i=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,o=Math.max(t,n,e),a=o-Math.min(t,n,e),s=a?o===t?(n-e)/a:o===n?2+(e-t)/a:4+(t-n)/a:0;return{h:60*(s<0?s+6:s),s:o?a/o*100:0,v:o/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var o=Math.floor(t),a=e*(1-n),s=e*(1-(t-o)*n),i=e*(1-(1-t+o)*n),h=o%6;return{r:255*[e,s,a,a,i,e][h],g:255*[i,e,e,s,a,a][h],b:255*[a,a,i,e,e,s][h],a:u}},d=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},g=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},p=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,c=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(r){var t=s.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:o({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||c.exec(t);if(!n)return null;var e,u,o=d({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(o)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,a=r.a,s=void 0===a?1:a;return t(n)&&t(e)&&t(u)?o({r:Number(n),g:Number(e),b:Number(u),a:Number(s)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,o=r.a,a=void 0===o?1:o;if(!t(n)||!t(e)||!t(u))return null;var s=d({h:Number(n),s:Number(e),l:Number(u),a:Number(a)});return f(s)},"hsl"],[function(r){var n=r.h,o=r.s,a=r.v,s=r.a,i=void 0===s?1:s;if(!t(n)||!t(o)||!t(a))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(o),v:Number(a),a:Number(i)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},M=function(r,t){var n=p(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},I=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},H=function(r,t){var n=p(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},$=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(I(this.rgba),2)},r.prototype.isDark=function(){return I(this.rgba)<.5},r.prototype.isLight=function(){return I(this.rgba)>=.5},r.prototype.toHex=function(){return r=a(this.rgba),t=r.r,e=r.g,u=r.b,s=(o=r.a)<1?i(n(255*o)):"","#"+i(t)+i(e)+i(u)+s;var r,t,e,u,o,s},r.prototype.toRgb=function(){return a(this.rgba)},r.prototype.toRgbString=function(){return r=a(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u},r.prototype.toHsl=function(){return g(p(this.rgba))},r.prototype.toHslString=function(){return r=g(p(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return j({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),j(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),j(M(this.rgba,-r))},r.prototype.grayscale=function(){return j(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),j(H(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),j(H(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?j({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=p(this.rgba);return"number"==typeof r?j({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===j(r).toHex()},r}(),j=function(r){return r instanceof $?r:new $(r)},w=[];exports.Colord=$,exports.colord=j,exports.extend=function(r){r.forEach(function(r){w.indexOf(r)<0&&(r($,y),w.push(r))})},exports.getFormat=function(r){return x(r)[1]},exports.random=function(){return new $({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};


/***/ }),

/***/ "./node_modules/@pixi/colord/plugins/names.js":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/colord/plugins/names.js ***!
  \****************************************************/
/***/ ((module) => {

module.exports=function(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,o=r[this.toHex()];if(o)return o;if(null==f?void 0:f.closest){var n=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=n,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])};


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/const.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/const.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var INTERNAL_FORMATS = /* @__PURE__ */ ((INTERNAL_FORMATS2) => (INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", INTERNAL_FORMATS2))(INTERNAL_FORMATS || {});
const INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
  // WEBGL_compressed_texture_s3tc
  33776: 0.5,
  33777: 0.5,
  33778: 1,
  33779: 1,
  // WEBGL_compressed_texture_s3tc
  35916: 0.5,
  35917: 0.5,
  35918: 1,
  35919: 1,
  // WEBGL_compressed_texture_etc
  37488: 0.5,
  37489: 0.5,
  37490: 1,
  37491: 1,
  37492: 0.5,
  37496: 1,
  37493: 0.5,
  37497: 1,
  37494: 0.5,
  // ~~
  37495: 0.5,
  // ~~
  // WEBGL_compressed_texture_pvrtc
  35840: 0.5,
  35842: 0.5,
  35841: 0.25,
  35843: 0.25,
  // WEBGL_compressed_texture_etc1
  36196: 0.5,
  // @see https://www.khronos.org/registry/OpenGL/extensions/AMD/AMD_compressed_ATC_texture.txt
  // WEBGL_compressed_texture_atc
  35986: 0.5,
  35986: 1,
  34798: 1,
  // @see https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt
  // WEBGL_compressed_texture_astc
  /* eslint-disable-next-line camelcase */
  37808: 1
};
exports.INTERNAL_FORMATS = INTERNAL_FORMATS;
exports.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ./const.js */ "./node_modules/@pixi/compressed-textures/lib/const.js");
__webpack_require__(/*! ./loaders/index.js */ "./node_modules/@pixi/compressed-textures/lib/loaders/index.js");
__webpack_require__(/*! ./parsers/index.js */ "./node_modules/@pixi/compressed-textures/lib/parsers/index.js");
__webpack_require__(/*! ./resources/index.js */ "./node_modules/@pixi/compressed-textures/lib/resources/index.js");
var detectCompressedTextures = __webpack_require__(/*! ./loaders/detectCompressedTextures.js */ "./node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.js"), loadDDS = __webpack_require__(/*! ./loaders/loadDDS.js */ "./node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.js"), loadKTX = __webpack_require__(/*! ./loaders/loadKTX.js */ "./node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.js"), resolveCompressedTextureUrl = __webpack_require__(/*! ./loaders/resolveCompressedTextureUrl.js */ "./node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.js"), parseDDS = __webpack_require__(/*! ./parsers/parseDDS.js */ "./node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.js"), parseKTX = __webpack_require__(/*! ./parsers/parseKTX.js */ "./node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.js"), BlobResource = __webpack_require__(/*! ./resources/BlobResource.js */ "./node_modules/@pixi/compressed-textures/lib/resources/BlobResource.js"), CompressedTextureResource = __webpack_require__(/*! ./resources/CompressedTextureResource.js */ "./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.js");
exports.INTERNAL_FORMATS = _const.INTERNAL_FORMATS;
exports.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL;
exports.detectCompressedTextures = detectCompressedTextures.detectCompressedTextures;
exports.loadDDS = loadDDS.loadDDS;
exports.loadKTX = loadKTX.loadKTX;
exports.resolveCompressedTextureUrl = resolveCompressedTextureUrl.resolveCompressedTextureUrl;
exports.parseDDS = parseDDS.parseDDS;
exports.FORMATS_TO_COMPONENTS = parseKTX.FORMATS_TO_COMPONENTS;
exports.TYPES_TO_BYTES_PER_COMPONENT = parseKTX.TYPES_TO_BYTES_PER_COMPONENT;
exports.TYPES_TO_BYTES_PER_PIXEL = parseKTX.TYPES_TO_BYTES_PER_PIXEL;
exports.parseKTX = parseKTX.parseKTX;
exports.BlobResource = BlobResource.BlobResource;
exports.CompressedTextureResource = CompressedTextureResource.CompressedTextureResource;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/loaders/compressedTextureExtensions.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/loaders/compressedTextureExtensions.js ***!
  \*******************************************************************************************/
/***/ (() => {

"use strict";

//# sourceMappingURL=compressedTextureExtensions.js.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
let storedGl, extensions;
function getCompressedTextureExtensions() {
  extensions = {
    s3tc: storedGl.getExtension("WEBGL_compressed_texture_s3tc"),
    s3tc_sRGB: storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
    /* eslint-disable-line camelcase */
    etc: storedGl.getExtension("WEBGL_compressed_texture_etc"),
    etc1: storedGl.getExtension("WEBGL_compressed_texture_etc1"),
    pvrtc: storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
    atc: storedGl.getExtension("WEBGL_compressed_texture_atc"),
    astc: storedGl.getExtension("WEBGL_compressed_texture_astc")
  };
}
const detectCompressedTextures = {
  extension: {
    type: core.ExtensionType.DetectionParser,
    priority: 2
  },
  test: async () => {
    const gl = core.settings.ADAPTER.createCanvas().getContext("webgl");
    return gl ? (storedGl = gl, !0) : (console.warn("WebGL not available for compressed textures."), !1);
  },
  add: async (formats) => {
    extensions || getCompressedTextureExtensions();
    const textureFormats = [];
    for (const extensionName in extensions)
      extensions[extensionName] && textureFormats.push(extensionName);
    return [...textureFormats, ...formats];
  },
  remove: async (formats) => (extensions || getCompressedTextureExtensions(), formats.filter((f) => !(f in extensions)))
};
core.extensions.add(detectCompressedTextures);
exports.detectCompressedTextures = detectCompressedTextures;
//# sourceMappingURL=detectCompressedTextures.js.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/loaders/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/loaders/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ./compressedTextureExtensions.js */ "./node_modules/@pixi/compressed-textures/lib/loaders/compressedTextureExtensions.js");
var detectCompressedTextures = __webpack_require__(/*! ./detectCompressedTextures.js */ "./node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.js"), loadDDS = __webpack_require__(/*! ./loadDDS.js */ "./node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.js"), loadKTX = __webpack_require__(/*! ./loadKTX.js */ "./node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.js"), resolveCompressedTextureUrl = __webpack_require__(/*! ./resolveCompressedTextureUrl.js */ "./node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.js");
exports.detectCompressedTextures = detectCompressedTextures.detectCompressedTextures;
exports.loadDDS = loadDDS.loadDDS;
exports.loadKTX = loadKTX.loadKTX;
exports.resolveCompressedTextureUrl = resolveCompressedTextureUrl.resolveCompressedTextureUrl;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var assets = __webpack_require__(/*! @pixi/assets */ "./node_modules/@pixi/assets/lib/index.js"), core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
__webpack_require__(/*! ../parsers/index.js */ "./node_modules/@pixi/compressed-textures/lib/parsers/index.js");
var parseDDS = __webpack_require__(/*! ../parsers/parseDDS.js */ "./node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.js");
const loadDDS = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: assets.LoaderParserPriority.High
  },
  name: "loadDDS",
  test(url) {
    return assets.checkExtension(url, ".dds");
  },
  async load(url, asset, loader) {
    const arrayBuffer = await (await core.settings.ADAPTER.fetch(url)).arrayBuffer(), textures = parseDDS.parseDDS(arrayBuffer).map((resource) => {
      const base = new core.BaseTexture(resource, {
        mipmap: core.MIPMAP_MODES.OFF,
        alphaMode: core.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
        resolution: core.utils.getResolutionOfUrl(url),
        ...asset.data
      });
      return assets.createTexture(base, loader, url);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    Array.isArray(texture) ? texture.forEach((t) => t.destroy(!0)) : texture.destroy(!0);
  }
};
core.extensions.add(loadDDS);
exports.loadDDS = loadDDS;
//# sourceMappingURL=loadDDS.js.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var assets = __webpack_require__(/*! @pixi/assets */ "./node_modules/@pixi/assets/lib/index.js"), core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
__webpack_require__(/*! ../parsers/index.js */ "./node_modules/@pixi/compressed-textures/lib/parsers/index.js");
var parseKTX = __webpack_require__(/*! ../parsers/parseKTX.js */ "./node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.js");
const loadKTX = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: assets.LoaderParserPriority.High
  },
  name: "loadKTX",
  test(url) {
    return assets.checkExtension(url, ".ktx");
  },
  async load(url, asset, loader) {
    const arrayBuffer = await (await core.settings.ADAPTER.fetch(url)).arrayBuffer(), { compressed, uncompressed, kvData } = parseKTX.parseKTX(url, arrayBuffer), resources = compressed ?? uncompressed, options = {
      mipmap: core.MIPMAP_MODES.OFF,
      alphaMode: core.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
      resolution: core.utils.getResolutionOfUrl(url),
      ...asset.data
    }, textures = resources.map((resource) => {
      resources === uncompressed && Object.assign(options, {
        type: resource.type,
        format: resource.format
      });
      const res = resource.resource ?? resource, base = new core.BaseTexture(res, options);
      return base.ktxKeyValueData = kvData, assets.createTexture(base, loader, url);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    Array.isArray(texture) ? texture.forEach((t) => t.destroy(!0)) : texture.destroy(!0);
  }
};
core.extensions.add(loadKTX);
exports.loadKTX = loadKTX;
//# sourceMappingURL=loadKTX.js.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
const resolveCompressedTextureUrl = {
  extension: core.ExtensionType.ResolveParser,
  test: (value) => {
    const extension = core.utils.path.extname(value).slice(1);
    return ["basis", "ktx", "dds"].includes(extension);
  },
  parse: (value) => {
    const extension = core.utils.path.extname(value).slice(1);
    if (extension === "ktx") {
      const extensions2 = [
        ".s3tc.ktx",
        ".s3tc_sRGB.ktx",
        ".etc.ktx",
        ".etc1.ktx",
        ".pvrt.ktx",
        ".atc.ktx",
        ".astc.ktx"
      ];
      if (extensions2.some((ext) => value.endsWith(ext)))
        return {
          resolution: parseFloat(core.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
          format: extensions2.find((ext) => value.endsWith(ext)),
          src: value
        };
    }
    return {
      resolution: parseFloat(core.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
      format: extension,
      src: value
    };
  }
};
core.extensions.add(resolveCompressedTextureUrl);
exports.resolveCompressedTextureUrl = resolveCompressedTextureUrl;
//# sourceMappingURL=resolveCompressedTextureUrl.js.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/parsers/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/parsers/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var parseDDS = __webpack_require__(/*! ./parseDDS.js */ "./node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.js"), parseKTX = __webpack_require__(/*! ./parseKTX.js */ "./node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.js");
exports.parseDDS = parseDDS.parseDDS;
exports.FORMATS_TO_COMPONENTS = parseKTX.FORMATS_TO_COMPONENTS;
exports.TYPES_TO_BYTES_PER_COMPONENT = parseKTX.TYPES_TO_BYTES_PER_COMPONENT;
exports.TYPES_TO_BYTES_PER_PIXEL = parseKTX.TYPES_TO_BYTES_PER_PIXEL;
exports.parseKTX = parseKTX.parseKTX;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/@pixi/compressed-textures/lib/const.js");
__webpack_require__(/*! ../resources/index.js */ "./node_modules/@pixi/compressed-textures/lib/resources/index.js");
var CompressedTextureResource = __webpack_require__(/*! ../resources/CompressedTextureResource.js */ "./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.js");
const DDS_MAGIC_SIZE = 4, DDS_HEADER_SIZE = 124, DDS_HEADER_PF_SIZE = 32, DDS_HEADER_DX10_SIZE = 20, DDS_MAGIC = 542327876, DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
}, DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
}, DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
}, PF_FLAGS = 1, DDPF_ALPHA = 2, DDPF_FOURCC = 4, DDPF_RGB = 64, DDPF_YUV = 512, DDPF_LUMINANCE = 131072, FOURCC_DXT1 = 827611204, FOURCC_DXT3 = 861165636, FOURCC_DXT5 = 894720068, FOURCC_DX10 = 808540228, DDS_RESOURCE_MISC_TEXTURECUBE = 4, FOURCC_TO_FORMAT = {
  [FOURCC_DXT1]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [FOURCC_DXT3]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [FOURCC_DXT5]: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT
}, DXGI_TO_FORMAT = {
  // WEBGL_compressed_texture_s3tc
  70: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  71: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  73: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  74: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  76: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  77: _const.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  // WEBGL_compressed_texture_s3tc_srgb
  72: _const.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
  75: _const.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
  78: _const.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
};
function parseDDS(arrayBuffer) {
  const data = new Uint32Array(arrayBuffer);
  if (data[0] !== DDS_MAGIC)
    throw new Error("Invalid DDS file magic word");
  const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT), height = header[DDS_FIELDS.HEIGHT], width = header[DDS_FIELDS.WIDTH], mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT], pixelFormat = new Uint32Array(
    arrayBuffer,
    DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT,
    DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT
  ), formatFlags = pixelFormat[PF_FLAGS];
  if (formatFlags & DDPF_FOURCC) {
    const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
    if (fourCC !== FOURCC_DX10) {
      const internalFormat2 = FOURCC_TO_FORMAT[fourCC], dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, texData = new Uint8Array(arrayBuffer, dataOffset2);
      return [new CompressedTextureResource.CompressedTextureResource(texData, {
        format: internalFormat2,
        width,
        height,
        levels: mipmapCount
        // CompressedTextureResource will separate the levelBuffers for us!
      })];
    }
    const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, dx10Header = new Uint32Array(
      data.buffer,
      dx10Offset,
      DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT
    ), dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT], resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION], miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG], arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE], internalFormat = DXGI_TO_FORMAT[dxgiFormat];
    if (internalFormat === void 0)
      throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
    if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE)
      throw new Error("DDSParser does not support cubemap textures");
    if (resourceDimension === 6)
      throw new Error("DDSParser does not supported 3D texture data");
    const imageBuffers = new Array(), dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
    if (arraySize === 1)
      imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
    else {
      const pixelSize = _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];
      let imageSize = 0, levelWidth = width, levelHeight = height;
      for (let i = 0; i < mipmapCount; i++) {
        const alignedLevelWidth = Math.max(1, levelWidth + 3 & -4), alignedLevelHeight = Math.max(1, levelHeight + 3 & -4), levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
        imageSize += levelSize, levelWidth = levelWidth >>> 1, levelHeight = levelHeight >>> 1;
      }
      let imageOffset = dataOffset;
      for (let i = 0; i < arraySize; i++)
        imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize)), imageOffset += imageSize;
    }
    return imageBuffers.map((buffer) => new CompressedTextureResource.CompressedTextureResource(buffer, {
      format: internalFormat,
      width,
      height,
      levels: mipmapCount
    }));
  }
  throw formatFlags & DDPF_RGB ? new Error("DDSParser does not support uncompressed texture data.") : formatFlags & DDPF_YUV ? new Error("DDSParser does not supported YUV uncompressed texture data.") : formatFlags & DDPF_LUMINANCE ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : formatFlags & DDPF_ALPHA ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
exports.parseDDS = parseDDS;
//# sourceMappingURL=parseDDS.js.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), _const = __webpack_require__(/*! ../const.js */ "./node_modules/@pixi/compressed-textures/lib/const.js");
__webpack_require__(/*! ../resources/index.js */ "./node_modules/@pixi/compressed-textures/lib/resources/index.js");
var CompressedTextureResource = __webpack_require__(/*! ../resources/CompressedTextureResource.js */ "./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.js");
const FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], ENDIANNESS = 67305985, KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
}, FILE_HEADER_SIZE = 64, TYPES_TO_BYTES_PER_COMPONENT = {
  [core.TYPES.UNSIGNED_BYTE]: 1,
  [core.TYPES.UNSIGNED_SHORT]: 2,
  [core.TYPES.INT]: 4,
  [core.TYPES.UNSIGNED_INT]: 4,
  [core.TYPES.FLOAT]: 4,
  [core.TYPES.HALF_FLOAT]: 8
}, FORMATS_TO_COMPONENTS = {
  [core.FORMATS.RGBA]: 4,
  [core.FORMATS.RGB]: 3,
  [core.FORMATS.RG]: 2,
  [core.FORMATS.RED]: 1,
  [core.FORMATS.LUMINANCE]: 1,
  [core.FORMATS.LUMINANCE_ALPHA]: 2,
  [core.FORMATS.ALPHA]: 1
}, TYPES_TO_BYTES_PER_PIXEL = {
  [core.TYPES.UNSIGNED_SHORT_4_4_4_4]: 2,
  [core.TYPES.UNSIGNED_SHORT_5_5_5_1]: 2,
  [core.TYPES.UNSIGNED_SHORT_5_6_5]: 2
};
function parseKTX(url, arrayBuffer, loadKeyValueData = !1) {
  const dataView = new DataView(arrayBuffer);
  if (!validate(url, dataView))
    return null;
  const littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, !0) === ENDIANNESS, glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian), glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian), glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian), pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian), pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1, pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1, numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1, numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian), numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian), bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
  if (pixelHeight === 0 || pixelDepth !== 1)
    throw new Error("Only 2D textures are supported");
  if (numberOfFaces !== 1)
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  if (numberOfArrayElements !== 1)
    throw new Error("WebGL does not support array textures");
  const blockWidth = 4, blockHeight = 4, alignedWidth = pixelWidth + 3 & -4, alignedHeight = pixelHeight + 3 & -4, imageBuffers = new Array(numberOfArrayElements);
  let imagePixels = pixelWidth * pixelHeight;
  glType === 0 && (imagePixels = alignedWidth * alignedHeight);
  let imagePixelByteSize;
  if (glType !== 0 ? TYPES_TO_BYTES_PER_COMPONENT[glType] ? imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat] : imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType] : imagePixelByteSize = _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat], imagePixelByteSize === void 0)
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  const kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;
  let mipByteSize = imagePixels * imagePixelByteSize, mipWidth = pixelWidth, mipHeight = pixelHeight, alignedMipWidth = alignedWidth, alignedMipHeight = alignedHeight, imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
  for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
    const imageSize = dataView.getUint32(imageOffset, littleEndian);
    let elementOffset = imageOffset + 4;
    for (let arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
      let mips = imageBuffers[arrayElement];
      mips || (mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels)), mips[mipmapLevel] = {
        levelID: mipmapLevel,
        // don't align mipWidth when texture not compressed! (glType not zero)
        levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
        levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
        levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
      }, elementOffset += mipByteSize;
    }
    imageOffset += imageSize + 4, imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset, mipWidth = mipWidth >> 1 || 1, mipHeight = mipHeight >> 1 || 1, alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1), alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1), mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
  }
  return glType !== 0 ? {
    uncompressed: imageBuffers.map((levelBuffers) => {
      let buffer = levelBuffers[0].levelBuffer, convertToInt = !1;
      return glType === core.TYPES.FLOAT ? buffer = new Float32Array(
        levelBuffers[0].levelBuffer.buffer,
        levelBuffers[0].levelBuffer.byteOffset,
        levelBuffers[0].levelBuffer.byteLength / 4
      ) : glType === core.TYPES.UNSIGNED_INT ? (convertToInt = !0, buffer = new Uint32Array(
        levelBuffers[0].levelBuffer.buffer,
        levelBuffers[0].levelBuffer.byteOffset,
        levelBuffers[0].levelBuffer.byteLength / 4
      )) : glType === core.TYPES.INT && (convertToInt = !0, buffer = new Int32Array(
        levelBuffers[0].levelBuffer.buffer,
        levelBuffers[0].levelBuffer.byteOffset,
        levelBuffers[0].levelBuffer.byteLength / 4
      )), {
        resource: new core.BufferResource(
          buffer,
          {
            width: levelBuffers[0].levelWidth,
            height: levelBuffers[0].levelHeight
          }
        ),
        type: glType,
        format: convertToInt ? convertFormatToInteger(glFormat) : glFormat
      };
    }),
    kvData
  } : {
    compressed: imageBuffers.map((levelBuffers) => new CompressedTextureResource.CompressedTextureResource(null, {
      format: glInternalFormat,
      width: pixelWidth,
      height: pixelHeight,
      levels: numberOfMipmapLevels,
      levelBuffers
    })),
    kvData
  };
}
function validate(url, dataView) {
  for (let i = 0; i < FILE_IDENTIFIER.length; i++)
    if (dataView.getUint8(i) !== FILE_IDENTIFIER[i])
      return console.error(`${url} is not a valid *.ktx file!`), !1;
  return !0;
}
function convertFormatToInteger(format) {
  switch (format) {
    case core.FORMATS.RGBA:
      return core.FORMATS.RGBA_INTEGER;
    case core.FORMATS.RGB:
      return core.FORMATS.RGB_INTEGER;
    case core.FORMATS.RG:
      return core.FORMATS.RG_INTEGER;
    case core.FORMATS.RED:
      return core.FORMATS.RED_INTEGER;
    default:
      return format;
  }
}
function parseKvData(dataView, bytesOfKeyValueData, littleEndian) {
  const kvData = /* @__PURE__ */ new Map();
  let bytesIntoKeyValueData = 0;
  for (; bytesIntoKeyValueData < bytesOfKeyValueData; ) {
    const keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian), keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4, valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
    if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    let keyNulByte = 0;
    for (; keyNulByte < keyAndValueByteSize && dataView.getUint8(keyAndValueByteOffset + keyNulByte) !== 0; keyNulByte++)
      ;
    if (keyNulByte === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    const key = new TextDecoder().decode(
      new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte)
    ), value = new DataView(
      dataView.buffer,
      keyAndValueByteOffset + keyNulByte + 1,
      keyAndValueByteSize - keyNulByte - 1
    );
    kvData.set(key, value), bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
  }
  return kvData;
}
exports.FORMATS_TO_COMPONENTS = FORMATS_TO_COMPONENTS;
exports.TYPES_TO_BYTES_PER_COMPONENT = TYPES_TO_BYTES_PER_COMPONENT;
exports.TYPES_TO_BYTES_PER_PIXEL = TYPES_TO_BYTES_PER_PIXEL;
exports.parseKTX = parseKTX;
//# sourceMappingURL=parseKTX.js.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/resources/BlobResource.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/resources/BlobResource.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
class BlobResource extends core.BufferResource {
  /**
   * @param source - The buffer/URL of the texture file.
   * @param {PIXI.IBlobResourceOptions} [options]
   * @param {boolean} [options.autoLoad=false] - Whether to fetch the data immediately;
   *  you can fetch it later via {@link PIXI.BlobResource#load}.
   * @param {number} [options.width=1] - The width in pixels.
   * @param {number} [options.height=1] - The height in pixels.
   * @param {1|2|4|8} [options.unpackAlignment=4] - The alignment of the pixel rows.
   */
  constructor(source, options = { width: 1, height: 1, autoLoad: !0 }) {
    let origin, data;
    typeof source == "string" ? (origin = source, data = new Uint8Array()) : (origin = null, data = source), super(data, options), this.origin = origin, this.buffer = data ? new core.ViewableBuffer(data) : null, this._load = null, this.loaded = !1, this.origin !== null && options.autoLoad !== !1 && this.load(), this.origin === null && this.buffer && (this._load = Promise.resolve(this), this.loaded = !0, this.onBlobLoaded(this.buffer.rawBinaryData));
  }
  onBlobLoaded(_data) {
  }
  /** Loads the blob */
  load() {
    return this._load ? this._load : (this._load = fetch(this.origin).then((response) => response.blob()).then((blob) => blob.arrayBuffer()).then((arrayBuffer) => (this.data = new Uint32Array(arrayBuffer), this.buffer = new core.ViewableBuffer(arrayBuffer), this.loaded = !0, this.onBlobLoaded(arrayBuffer), this.update(), this)), this._load);
  }
}
exports.BlobResource = BlobResource;
//# sourceMappingURL=BlobResource.js.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/@pixi/compressed-textures/lib/const.js"), BlobResource = __webpack_require__(/*! ./BlobResource.js */ "./node_modules/@pixi/compressed-textures/lib/resources/BlobResource.js");
class CompressedTextureResource extends BlobResource.BlobResource {
  /**
   * @param source - the buffer/URL holding the compressed texture data
   * @param options
   * @param {PIXI.INTERNAL_FORMATS} options.format - the compression format
   * @param {number} options.width - the image width in pixels.
   * @param {number} options.height - the image height in pixels.
   * @param {number} [options.level=1] - the mipmap levels stored in the compressed texture, including level 0.
   * @param {number} [options.levelBuffers] - the buffers for each mipmap level. `CompressedTextureResource` can allows you
   *      to pass `null` for `source`, for cases where each level is stored in non-contiguous memory.
   */
  constructor(source, options) {
    super(source, options), this.format = options.format, this.levels = options.levels || 1, this._width = options.width, this._height = options.height, this._extension = CompressedTextureResource._formatToExtension(this.format), (options.levelBuffers || this.buffer) && (this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(
      source instanceof Uint8Array ? source : this.buffer.uint8View,
      this.format,
      this.levels,
      4,
      4,
      // PVRTC has 8x4 blocks in 2bpp mode
      this.width,
      this.height
    ));
  }
  /**
   * @override
   * @param renderer - A reference to the current renderer
   * @param _texture - the texture
   * @param _glTexture - texture instance for this webgl context
   */
  upload(renderer, _texture, _glTexture) {
    const gl = renderer.gl;
    if (!renderer.context.extensions[this._extension])
      throw new Error(`${this._extension} textures are not supported on the current machine`);
    if (!this._levelBuffers)
      return !1;
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
    for (let i = 0, j = this.levels; i < j; i++) {
      const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i];
      gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
    }
    return !0;
  }
  /** @protected */
  onBlobLoaded() {
    this._levelBuffers = CompressedTextureResource._createLevelBuffers(
      this.buffer.uint8View,
      this.format,
      this.levels,
      4,
      4,
      // PVRTC has 8x4 blocks in 2bpp mode
      this.width,
      this.height
    );
  }
  /**
   * Returns the key (to ContextSystem#extensions) for the WebGL extension supporting the compression format
   * @private
   * @param format - the compression format to get the extension for.
   */
  static _formatToExtension(format) {
    if (format >= 33776 && format <= 33779)
      return "s3tc";
    if (format >= 37488 && format <= 37497)
      return "etc";
    if (format >= 35840 && format <= 35843)
      return "pvrtc";
    if (format >= 36196)
      return "etc1";
    if (format >= 35986 && format <= 34798)
      return "atc";
    throw new Error("Invalid (compressed) texture format given!");
  }
  /**
   * Pre-creates buffer views for each mipmap level
   * @private
   * @param buffer -
   * @param format - compression formats
   * @param levels - mipmap levels
   * @param blockWidth -
   * @param blockHeight -
   * @param imageWidth - width of the image in pixels
   * @param imageHeight - height of the image in pixels
   */
  static _createLevelBuffers(buffer, format, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
    const buffers = new Array(levels);
    let offset = buffer.byteOffset, levelWidth = imageWidth, levelHeight = imageHeight, alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1), alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1), levelSize = alignedLevelWidth * alignedLevelHeight * _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];
    for (let i = 0; i < levels; i++)
      buffers[i] = {
        levelID: i,
        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
        levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)
      }, offset += levelSize, levelWidth = levelWidth >> 1 || 1, levelHeight = levelHeight >> 1 || 1, alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1), alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1), levelSize = alignedLevelWidth * alignedLevelHeight * _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];
    return buffers;
  }
}
exports.CompressedTextureResource = CompressedTextureResource;
//# sourceMappingURL=CompressedTextureResource.js.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/resources/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/resources/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var BlobResource = __webpack_require__(/*! ./BlobResource.js */ "./node_modules/@pixi/compressed-textures/lib/resources/BlobResource.js"), CompressedTextureResource = __webpack_require__(/*! ./CompressedTextureResource.js */ "./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.js");
exports.BlobResource = BlobResource.BlobResource;
exports.CompressedTextureResource = CompressedTextureResource.CompressedTextureResource;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/constants/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/constants/lib/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var ENV = /* @__PURE__ */ ((ENV2) => (ENV2[ENV2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", ENV2[ENV2.WEBGL = 1] = "WEBGL", ENV2[ENV2.WEBGL2 = 2] = "WEBGL2", ENV2))(ENV || {}), RENDERER_TYPE = /* @__PURE__ */ ((RENDERER_TYPE2) => (RENDERER_TYPE2[RENDERER_TYPE2.UNKNOWN = 0] = "UNKNOWN", RENDERER_TYPE2[RENDERER_TYPE2.WEBGL = 1] = "WEBGL", RENDERER_TYPE2[RENDERER_TYPE2.CANVAS = 2] = "CANVAS", RENDERER_TYPE2))(RENDERER_TYPE || {}), BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => (BUFFER_BITS2[BUFFER_BITS2.COLOR = 16384] = "COLOR", BUFFER_BITS2[BUFFER_BITS2.DEPTH = 256] = "DEPTH", BUFFER_BITS2[BUFFER_BITS2.STENCIL = 1024] = "STENCIL", BUFFER_BITS2))(BUFFER_BITS || {}), BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES2) => (BLEND_MODES2[BLEND_MODES2.NORMAL = 0] = "NORMAL", BLEND_MODES2[BLEND_MODES2.ADD = 1] = "ADD", BLEND_MODES2[BLEND_MODES2.MULTIPLY = 2] = "MULTIPLY", BLEND_MODES2[BLEND_MODES2.SCREEN = 3] = "SCREEN", BLEND_MODES2[BLEND_MODES2.OVERLAY = 4] = "OVERLAY", BLEND_MODES2[BLEND_MODES2.DARKEN = 5] = "DARKEN", BLEND_MODES2[BLEND_MODES2.LIGHTEN = 6] = "LIGHTEN", BLEND_MODES2[BLEND_MODES2.COLOR_DODGE = 7] = "COLOR_DODGE", BLEND_MODES2[BLEND_MODES2.COLOR_BURN = 8] = "COLOR_BURN", BLEND_MODES2[BLEND_MODES2.HARD_LIGHT = 9] = "HARD_LIGHT", BLEND_MODES2[BLEND_MODES2.SOFT_LIGHT = 10] = "SOFT_LIGHT", BLEND_MODES2[BLEND_MODES2.DIFFERENCE = 11] = "DIFFERENCE", BLEND_MODES2[BLEND_MODES2.EXCLUSION = 12] = "EXCLUSION", BLEND_MODES2[BLEND_MODES2.HUE = 13] = "HUE", BLEND_MODES2[BLEND_MODES2.SATURATION = 14] = "SATURATION", BLEND_MODES2[BLEND_MODES2.COLOR = 15] = "COLOR", BLEND_MODES2[BLEND_MODES2.LUMINOSITY = 16] = "LUMINOSITY", BLEND_MODES2[BLEND_MODES2.NORMAL_NPM = 17] = "NORMAL_NPM", BLEND_MODES2[BLEND_MODES2.ADD_NPM = 18] = "ADD_NPM", BLEND_MODES2[BLEND_MODES2.SCREEN_NPM = 19] = "SCREEN_NPM", BLEND_MODES2[BLEND_MODES2.NONE = 20] = "NONE", BLEND_MODES2[BLEND_MODES2.SRC_OVER = 0] = "SRC_OVER", BLEND_MODES2[BLEND_MODES2.SRC_IN = 21] = "SRC_IN", BLEND_MODES2[BLEND_MODES2.SRC_OUT = 22] = "SRC_OUT", BLEND_MODES2[BLEND_MODES2.SRC_ATOP = 23] = "SRC_ATOP", BLEND_MODES2[BLEND_MODES2.DST_OVER = 24] = "DST_OVER", BLEND_MODES2[BLEND_MODES2.DST_IN = 25] = "DST_IN", BLEND_MODES2[BLEND_MODES2.DST_OUT = 26] = "DST_OUT", BLEND_MODES2[BLEND_MODES2.DST_ATOP = 27] = "DST_ATOP", BLEND_MODES2[BLEND_MODES2.ERASE = 26] = "ERASE", BLEND_MODES2[BLEND_MODES2.SUBTRACT = 28] = "SUBTRACT", BLEND_MODES2[BLEND_MODES2.XOR = 29] = "XOR", BLEND_MODES2))(BLEND_MODES || {}), DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => (DRAW_MODES2[DRAW_MODES2.POINTS = 0] = "POINTS", DRAW_MODES2[DRAW_MODES2.LINES = 1] = "LINES", DRAW_MODES2[DRAW_MODES2.LINE_LOOP = 2] = "LINE_LOOP", DRAW_MODES2[DRAW_MODES2.LINE_STRIP = 3] = "LINE_STRIP", DRAW_MODES2[DRAW_MODES2.TRIANGLES = 4] = "TRIANGLES", DRAW_MODES2[DRAW_MODES2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", DRAW_MODES2[DRAW_MODES2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", DRAW_MODES2))(DRAW_MODES || {}), FORMATS = /* @__PURE__ */ ((FORMATS2) => (FORMATS2[FORMATS2.RGBA = 6408] = "RGBA", FORMATS2[FORMATS2.RGB = 6407] = "RGB", FORMATS2[FORMATS2.RG = 33319] = "RG", FORMATS2[FORMATS2.RED = 6403] = "RED", FORMATS2[FORMATS2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", FORMATS2[FORMATS2.RGB_INTEGER = 36248] = "RGB_INTEGER", FORMATS2[FORMATS2.RG_INTEGER = 33320] = "RG_INTEGER", FORMATS2[FORMATS2.RED_INTEGER = 36244] = "RED_INTEGER", FORMATS2[FORMATS2.ALPHA = 6406] = "ALPHA", FORMATS2[FORMATS2.LUMINANCE = 6409] = "LUMINANCE", FORMATS2[FORMATS2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", FORMATS2[FORMATS2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", FORMATS2[FORMATS2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", FORMATS2))(FORMATS || {}), TARGETS = /* @__PURE__ */ ((TARGETS2) => (TARGETS2[TARGETS2.TEXTURE_2D = 3553] = "TEXTURE_2D", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", TARGETS2[TARGETS2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", TARGETS2))(TARGETS || {}), TYPES = /* @__PURE__ */ ((TYPES2) => (TYPES2[TYPES2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", TYPES2[TYPES2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", TYPES2[TYPES2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", TYPES2[TYPES2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", TYPES2[TYPES2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", TYPES2[TYPES2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", TYPES2[TYPES2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", TYPES2[TYPES2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", TYPES2[TYPES2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", TYPES2[TYPES2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", TYPES2[TYPES2.BYTE = 5120] = "BYTE", TYPES2[TYPES2.SHORT = 5122] = "SHORT", TYPES2[TYPES2.INT = 5124] = "INT", TYPES2[TYPES2.FLOAT = 5126] = "FLOAT", TYPES2[TYPES2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", TYPES2[TYPES2.HALF_FLOAT = 36193] = "HALF_FLOAT", TYPES2))(TYPES || {}), SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => (SAMPLER_TYPES2[SAMPLER_TYPES2.FLOAT = 0] = "FLOAT", SAMPLER_TYPES2[SAMPLER_TYPES2.INT = 1] = "INT", SAMPLER_TYPES2[SAMPLER_TYPES2.UINT = 2] = "UINT", SAMPLER_TYPES2))(SAMPLER_TYPES || {}), SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => (SCALE_MODES2[SCALE_MODES2.NEAREST = 0] = "NEAREST", SCALE_MODES2[SCALE_MODES2.LINEAR = 1] = "LINEAR", SCALE_MODES2))(SCALE_MODES || {}), WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => (WRAP_MODES2[WRAP_MODES2.CLAMP = 33071] = "CLAMP", WRAP_MODES2[WRAP_MODES2.REPEAT = 10497] = "REPEAT", WRAP_MODES2[WRAP_MODES2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", WRAP_MODES2))(WRAP_MODES || {}), MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => (MIPMAP_MODES2[MIPMAP_MODES2.OFF = 0] = "OFF", MIPMAP_MODES2[MIPMAP_MODES2.POW2 = 1] = "POW2", MIPMAP_MODES2[MIPMAP_MODES2.ON = 2] = "ON", MIPMAP_MODES2[MIPMAP_MODES2.ON_MANUAL = 3] = "ON_MANUAL", MIPMAP_MODES2))(MIPMAP_MODES || {}), ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => (ALPHA_MODES2[ALPHA_MODES2.NPM = 0] = "NPM", ALPHA_MODES2[ALPHA_MODES2.UNPACK = 1] = "UNPACK", ALPHA_MODES2[ALPHA_MODES2.PMA = 2] = "PMA", ALPHA_MODES2[ALPHA_MODES2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", ALPHA_MODES2[ALPHA_MODES2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", ALPHA_MODES2[ALPHA_MODES2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA", ALPHA_MODES2))(ALPHA_MODES || {}), CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => (CLEAR_MODES2[CLEAR_MODES2.NO = 0] = "NO", CLEAR_MODES2[CLEAR_MODES2.YES = 1] = "YES", CLEAR_MODES2[CLEAR_MODES2.AUTO = 2] = "AUTO", CLEAR_MODES2[CLEAR_MODES2.BLEND = 0] = "BLEND", CLEAR_MODES2[CLEAR_MODES2.CLEAR = 1] = "CLEAR", CLEAR_MODES2[CLEAR_MODES2.BLIT = 2] = "BLIT", CLEAR_MODES2))(CLEAR_MODES || {}), GC_MODES = /* @__PURE__ */ ((GC_MODES2) => (GC_MODES2[GC_MODES2.AUTO = 0] = "AUTO", GC_MODES2[GC_MODES2.MANUAL = 1] = "MANUAL", GC_MODES2))(GC_MODES || {}), PRECISION = /* @__PURE__ */ ((PRECISION2) => (PRECISION2.LOW = "lowp", PRECISION2.MEDIUM = "mediump", PRECISION2.HIGH = "highp", PRECISION2))(PRECISION || {}), MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => (MASK_TYPES2[MASK_TYPES2.NONE = 0] = "NONE", MASK_TYPES2[MASK_TYPES2.SCISSOR = 1] = "SCISSOR", MASK_TYPES2[MASK_TYPES2.STENCIL = 2] = "STENCIL", MASK_TYPES2[MASK_TYPES2.SPRITE = 3] = "SPRITE", MASK_TYPES2[MASK_TYPES2.COLOR = 4] = "COLOR", MASK_TYPES2))(MASK_TYPES || {}), COLOR_MASK_BITS = /* @__PURE__ */ ((COLOR_MASK_BITS2) => (COLOR_MASK_BITS2[COLOR_MASK_BITS2.RED = 1] = "RED", COLOR_MASK_BITS2[COLOR_MASK_BITS2.GREEN = 2] = "GREEN", COLOR_MASK_BITS2[COLOR_MASK_BITS2.BLUE = 4] = "BLUE", COLOR_MASK_BITS2[COLOR_MASK_BITS2.ALPHA = 8] = "ALPHA", COLOR_MASK_BITS2))(COLOR_MASK_BITS || {}), MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => (MSAA_QUALITY2[MSAA_QUALITY2.NONE = 0] = "NONE", MSAA_QUALITY2[MSAA_QUALITY2.LOW = 2] = "LOW", MSAA_QUALITY2[MSAA_QUALITY2.MEDIUM = 4] = "MEDIUM", MSAA_QUALITY2[MSAA_QUALITY2.HIGH = 8] = "HIGH", MSAA_QUALITY2))(MSAA_QUALITY || {}), BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => (BUFFER_TYPE2[BUFFER_TYPE2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", BUFFER_TYPE2[BUFFER_TYPE2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", BUFFER_TYPE2[BUFFER_TYPE2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", BUFFER_TYPE2))(BUFFER_TYPE || {});
exports.ALPHA_MODES = ALPHA_MODES;
exports.BLEND_MODES = BLEND_MODES;
exports.BUFFER_BITS = BUFFER_BITS;
exports.BUFFER_TYPE = BUFFER_TYPE;
exports.CLEAR_MODES = CLEAR_MODES;
exports.COLOR_MASK_BITS = COLOR_MASK_BITS;
exports.DRAW_MODES = DRAW_MODES;
exports.ENV = ENV;
exports.FORMATS = FORMATS;
exports.GC_MODES = GC_MODES;
exports.MASK_TYPES = MASK_TYPES;
exports.MIPMAP_MODES = MIPMAP_MODES;
exports.MSAA_QUALITY = MSAA_QUALITY;
exports.PRECISION = PRECISION;
exports.RENDERER_TYPE = RENDERER_TYPE;
exports.SAMPLER_TYPES = SAMPLER_TYPES;
exports.SCALE_MODES = SCALE_MODES;
exports.TARGETS = TARGETS;
exports.TYPES = TYPES;
exports.WRAP_MODES = WRAP_MODES;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/IRenderer.js":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/core/lib/IRenderer.js ***!
  \**************************************************/
/***/ (() => {

"use strict";

//# sourceMappingURL=IRenderer.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/Renderer.js":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/core/lib/Renderer.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), math = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.js"), settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js"), utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js"), UniformGroup = __webpack_require__(/*! ./shader/UniformGroup.js */ "./node_modules/@pixi/core/lib/shader/UniformGroup.js"), SystemManager = __webpack_require__(/*! ./system/SystemManager.js */ "./node_modules/@pixi/core/lib/system/SystemManager.js");
const _Renderer = class _Renderer2 extends SystemManager.SystemManager {
  /**
   * @param {PIXI.IRendererOptions} [options] - See {@link PIXI.settings.RENDER_OPTIONS} for defaults.
   */
  constructor(options) {
    super(), this.type = constants.RENDERER_TYPE.WEBGL, options = Object.assign({}, settings.settings.RENDER_OPTIONS, options), this.gl = null, this.CONTEXT_UID = 0, this.globalUniforms = new UniformGroup.UniformGroup({
      projectionMatrix: new math.Matrix()
    }, !0);
    const systemConfig = {
      runners: [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "reset",
        "update",
        "postrender",
        "prerender",
        "resize"
      ],
      systems: _Renderer2.__systems,
      priority: [
        "_view",
        "textureGenerator",
        "background",
        "_plugin",
        "startup",
        // low level WebGL systems
        "context",
        "state",
        "texture",
        "buffer",
        "geometry",
        "framebuffer",
        "transformFeedback",
        // high level pixi specific rendering
        "mask",
        "scissor",
        "stencil",
        "projection",
        "textureGC",
        "filter",
        "renderTexture",
        "batch",
        "objectRenderer",
        "_multisample"
      ]
    };
    this.setup(systemConfig), "useContextAlpha" in options && (utils.deprecation("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"), options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== "notMultiplied", options.backgroundAlpha = options.useContextAlpha === !1 ? 1 : options.backgroundAlpha), this._plugin.rendererPlugins = _Renderer2.__plugins, this.options = options, this.startup.run(this.options);
  }
  /**
   * Create renderer if WebGL is available. Overrideable
   * by the **@pixi/canvas-renderer** package to allow fallback.
   * throws error if WebGL is not available.
   * @param options
   * @private
   */
  static test(options) {
    return options?.forceCanvas ? !1 : utils.isWebGLSupported();
  }
  /**
   * Renders the object to its WebGL view.
   * @param displayObject - The object to be rendered.
   * @param {object} [options] - Object to use for render options.
   * @param {PIXI.RenderTexture} [options.renderTexture] - The render texture to render to.
   * @param {boolean} [options.clear=true] - Should the canvas be cleared before the new render.
   * @param {PIXI.Matrix} [options.transform] - A transform to apply to the render texture before rendering.
   * @param {boolean} [options.skipUpdateTransform=false] - Should we skip the update transform pass?
   */
  render(displayObject, options) {
    this.objectRenderer.render(displayObject, options);
  }
  /**
   * Resizes the WebGL view to the specified width and height.
   * @param desiredScreenWidth - The desired width of the screen.
   * @param desiredScreenHeight - The desired height of the screen.
   */
  resize(desiredScreenWidth, desiredScreenHeight) {
    this._view.resizeView(desiredScreenWidth, desiredScreenHeight);
  }
  /**
   * Resets the WebGL state so you can render things however you fancy!
   * @returns Returns itself.
   */
  reset() {
    return this.runners.reset.emit(), this;
  }
  /** Clear the frame buffer. */
  clear() {
    this.renderTexture.bind(), this.renderTexture.clear();
  }
  /**
   * Removes everything from the renderer (event listeners, spritebatch, etc...)
   * @param [removeView=false] - Removes the Canvas element from the DOM.
   *  See: https://github.com/pixijs/pixijs/issues/2233
   */
  destroy(removeView = !1) {
    this.runners.destroy.items.reverse(), this.emitWithCustomOptions(this.runners.destroy, {
      _view: removeView
    }), super.destroy();
  }
  /** Collection of plugins */
  get plugins() {
    return this._plugin.plugins;
  }
  /** The number of msaa samples of the canvas. */
  get multisample() {
    return this._multisample.multisample;
  }
  /**
   * Same as view.width, actual number of pixels in the canvas by horizontal.
   * @member {number}
   * @readonly
   * @default 800
   */
  get width() {
    return this._view.element.width;
  }
  /**
   * Same as view.height, actual number of pixels in the canvas by vertical.
   * @default 600
   */
  get height() {
    return this._view.element.height;
  }
  /** The resolution / device pixel ratio of the renderer. */
  get resolution() {
    return this._view.resolution;
  }
  set resolution(value) {
    this._view.resolution = value, this.runners.resolutionChange.emit(value);
  }
  /** Whether CSS dimensions of canvas view should be resized to screen dimensions automatically. */
  get autoDensity() {
    return this._view.autoDensity;
  }
  /** The canvas element that everything is drawn to.*/
  get view() {
    return this._view.element;
  }
  /**
   * Measurements of the screen. (0, 0, screenWidth, screenHeight).
   *
   * Its safe to use as filterArea or hitArea for the whole stage.
   * @member {PIXI.Rectangle}
   */
  get screen() {
    return this._view.screen;
  }
  /** the last object rendered by the renderer. Useful for other plugins like interaction managers */
  get lastObjectRendered() {
    return this.objectRenderer.lastObjectRendered;
  }
  /** Flag if we are rendering to the screen vs renderTexture */
  get renderingToScreen() {
    return this.objectRenderer.renderingToScreen;
  }
  /** When logging Pixi to the console, this is the name we will show */
  get rendererLogId() {
    return `WebGL ${this.context.webGLVersion}`;
  }
  /**
   * This sets weather the screen is totally cleared between each frame withthe background color and alpha
   * @deprecated since 7.0.0
   */
  get clearBeforeRender() {
    return utils.deprecation("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."), this.background.clearBeforeRender;
  }
  /**
   * Pass-thru setting for the canvas' context `alpha` property. This is typically
   * not something you need to fiddle with. If you want transparency, use `backgroundAlpha`.
   * @deprecated since 7.0.0
   * @member {boolean}
   */
  get useContextAlpha() {
    return utils.deprecation("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."), this.context.useContextAlpha;
  }
  /**
   * readonly drawing buffer preservation
   * we can only know this if Pixi created the context
   * @deprecated since 7.0.0
   */
  get preserveDrawingBuffer() {
    return utils.deprecation("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"), this.context.preserveDrawingBuffer;
  }
  /**
   * The background color to fill if not transparent
   * @member {number}
   * @deprecated since 7.0.0
   */
  get backgroundColor() {
    return utils.deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color;
  }
  set backgroundColor(value) {
    utils.deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color = value;
  }
  /**
   * The background color alpha. Setting this to 0 will make the canvas transparent.
   * @member {number}
   * @deprecated since 7.0.0
   */
  get backgroundAlpha() {
    return utils.deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha;
  }
  /**
   * @deprecated since 7.0.0
   */
  set backgroundAlpha(value) {
    utils.deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha = value;
  }
  /**
   * @deprecated since 7.0.0
   */
  get powerPreference() {
    return utils.deprecation("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"), this.context.powerPreference;
  }
  /**
   * Useful function that returns a texture of the display object that can then be used to create sprites
   * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.
   * @param displayObject - The displayObject the object will be generated from.
   * @param {IGenerateTextureOptions} options - Generate texture options.
   * @param {PIXI.Rectangle} options.region - The region of the displayObject, that shall be rendered,
   *        if no region is specified, defaults to the local bounds of the displayObject.
   * @param {number} [options.resolution] - If not given, the renderer's resolution is used.
   * @param {PIXI.MSAA_QUALITY} [options.multisample] - If not given, the renderer's multisample is used.
   * @returns A texture of the graphics object.
   */
  generateTexture(displayObject, options) {
    return this.textureGenerator.generateTexture(displayObject, options);
  }
};
_Renderer.extension = {
  type: extensions.ExtensionType.Renderer,
  priority: 1
}, /**
* Collection of installed plugins. These are included by default in PIXI, but can be excluded
* by creating a custom build. Consult the README for more information about creating custom
* builds and excluding plugins.
* @private
*/
_Renderer.__plugins = {}, /**
* The collection of installed systems.
* @private
*/
_Renderer.__systems = {};
let Renderer = _Renderer;
extensions.extensions.handleByMap(extensions.ExtensionType.RendererPlugin, Renderer.__plugins);
extensions.extensions.handleByMap(extensions.ExtensionType.RendererSystem, Renderer.__systems);
extensions.extensions.add(Renderer);
exports.Renderer = Renderer;
//# sourceMappingURL=Renderer.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/autoDetectRenderer.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/autoDetectRenderer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js");
const renderers = [];
extensions.extensions.handleByList(extensions.ExtensionType.Renderer, renderers);
function autoDetectRenderer(options) {
  for (const RendererType of renderers)
    if (RendererType.test(options))
      return new RendererType(options);
  throw new Error("Unable to auto-detect a suitable renderer.");
}
exports.autoDetectRenderer = autoDetectRenderer;
//# sourceMappingURL=autoDetectRenderer.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/background/BackgroundSystem.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/background/BackgroundSystem.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var color = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.js"), extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js");
class BackgroundSystem {
  constructor() {
    this.clearBeforeRender = !0, this._backgroundColor = new color.Color(0), this.alpha = 1;
  }
  /**
   * initiates the background system
   * @param {PIXI.IRendererOptions} options - the options for the background colors
   */
  init(options) {
    this.clearBeforeRender = options.clearBeforeRender;
    const { backgroundColor, background, backgroundAlpha } = options, color2 = background ?? backgroundColor;
    color2 !== void 0 && (this.color = color2), this.alpha = backgroundAlpha;
  }
  /**
   * The background color to fill if not transparent.
   * @member {PIXI.ColorSource}
   */
  get color() {
    return this._backgroundColor.value;
  }
  set color(value) {
    this._backgroundColor.setValue(value);
  }
  /**
   * The background color alpha. Setting this to 0 will make the canvas transparent.
   * @member {number}
   */
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(value) {
    this._backgroundColor.setAlpha(value);
  }
  /** The background color object. */
  get backgroundColor() {
    return this._backgroundColor;
  }
  destroy() {
  }
}
BackgroundSystem.defaultOptions = {
  /**
   * {@link PIXI.IRendererOptions.backgroundAlpha}
   * @default 1
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  backgroundAlpha: 1,
  /**
   * {@link PIXI.IRendererOptions.backgroundColor}
   * @default 0x000000
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  backgroundColor: 0,
  /**
   * {@link PIXI.IRendererOptions.clearBeforeRender}
   * @default true
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  clearBeforeRender: !0
}, /** @ignore */
BackgroundSystem.extension = {
  type: [
    extensions.ExtensionType.RendererSystem,
    extensions.ExtensionType.CanvasRendererSystem
  ],
  name: "background"
};
extensions.extensions.add(BackgroundSystem);
exports.BackgroundSystem = BackgroundSystem;
//# sourceMappingURL=BackgroundSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchDrawCall.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchDrawCall.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js");
class BatchDrawCall {
  constructor() {
    this.texArray = null, this.blend = 0, this.type = constants.DRAW_MODES.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
  }
}
exports.BatchDrawCall = BatchDrawCall;
//# sourceMappingURL=BatchDrawCall.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchGeometry.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchGeometry.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), Buffer = __webpack_require__(/*! ../geometry/Buffer.js */ "./node_modules/@pixi/core/lib/geometry/Buffer.js"), Geometry = __webpack_require__(/*! ../geometry/Geometry.js */ "./node_modules/@pixi/core/lib/geometry/Geometry.js");
class BatchGeometry extends Geometry.Geometry {
  /**
   * @param {boolean} [_static=false] - Optimization flag, where `false`
   *        is updated every frame, `true` doesn't change frame-to-frame.
   */
  constructor(_static = !1) {
    super(), this._buffer = new Buffer.Buffer(null, _static, !1), this._indexBuffer = new Buffer.Buffer(null, _static, !0), this.addAttribute("aVertexPosition", this._buffer, 2, !1, constants.TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, constants.TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, !0, constants.TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, constants.TYPES.FLOAT).addIndex(this._indexBuffer);
  }
}
exports.BatchGeometry = BatchGeometry;
//# sourceMappingURL=BatchGeometry.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchRenderer.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchRenderer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var color = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.js"), constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js"), utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js"), ViewableBuffer = __webpack_require__(/*! ../geometry/ViewableBuffer.js */ "./node_modules/@pixi/core/lib/geometry/ViewableBuffer.js"), checkMaxIfStatementsInShader = __webpack_require__(/*! ../shader/utils/checkMaxIfStatementsInShader.js */ "./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js"), State = __webpack_require__(/*! ../state/State.js */ "./node_modules/@pixi/core/lib/state/State.js"), BaseTexture = __webpack_require__(/*! ../textures/BaseTexture.js */ "./node_modules/@pixi/core/lib/textures/BaseTexture.js"), BatchDrawCall = __webpack_require__(/*! ./BatchDrawCall.js */ "./node_modules/@pixi/core/lib/batch/BatchDrawCall.js"), BatchGeometry = __webpack_require__(/*! ./BatchGeometry.js */ "./node_modules/@pixi/core/lib/batch/BatchGeometry.js"), BatchShaderGenerator = __webpack_require__(/*! ./BatchShaderGenerator.js */ "./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.js"), BatchTextureArray = __webpack_require__(/*! ./BatchTextureArray.js */ "./node_modules/@pixi/core/lib/batch/BatchTextureArray.js"), canUploadSameBuffer = __webpack_require__(/*! ./canUploadSameBuffer.js */ "./node_modules/@pixi/core/lib/batch/canUploadSameBuffer.js"), maxRecommendedTextures = __webpack_require__(/*! ./maxRecommendedTextures.js */ "./node_modules/@pixi/core/lib/batch/maxRecommendedTextures.js"), ObjectRenderer = __webpack_require__(/*! ./ObjectRenderer.js */ "./node_modules/@pixi/core/lib/batch/ObjectRenderer.js"), texture$1 = __webpack_require__(/*! ./texture.frag.js */ "./node_modules/@pixi/core/lib/batch/texture.frag.js"), texture = __webpack_require__(/*! ./texture.vert.js */ "./node_modules/@pixi/core/lib/batch/texture.vert.js");
const _BatchRenderer = class _BatchRenderer2 extends ObjectRenderer.ObjectRenderer {
  /**
   * This will hook onto the renderer's `contextChange`
   * and `prerender` signals.
   * @param {PIXI.Renderer} renderer - The renderer this works for.
   */
  constructor(renderer) {
    super(renderer), this.setShaderGenerator(), this.geometryClass = BatchGeometry.BatchGeometry, this.vertexSize = 6, this.state = State.State.for2d(), this.size = _BatchRenderer2.defaultBatchSize * 4, this._vertexCount = 0, this._indexCount = 0, this._bufferedElements = [], this._bufferedTextures = [], this._bufferSize = 0, this._shader = null, this._packedGeometries = [], this._packedGeometryPoolSize = 2, this._flushId = 0, this._aBuffers = {}, this._iBuffers = {}, this.maxTextures = 1, this.renderer.on("prerender", this.onPrerender, this), renderer.runners.contextChange.add(this), this._dcIndex = 0, this._aIndex = 0, this._iIndex = 0, this._attributeBuffer = null, this._indexBuffer = null, this._tempBoundTextures = [];
  }
  /**
   * The maximum textures that this device supports.
   * @static
   * @default 32
   */
  static get defaultMaxTextures() {
    return this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures.maxRecommendedTextures(32), this._defaultMaxTextures;
  }
  static set defaultMaxTextures(value) {
    this._defaultMaxTextures = value;
  }
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   */
  static get canUploadSameBuffer() {
    return this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer.canUploadSameBuffer(), this._canUploadSameBuffer;
  }
  static set canUploadSameBuffer(value) {
    this._canUploadSameBuffer = value;
  }
  /**
   * @see PIXI.BatchRenderer#maxTextures
   * @deprecated since 7.1.0
   * @readonly
   */
  get MAX_TEXTURES() {
    return utils.deprecation("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"), this.maxTextures;
  }
  /**
   * The default vertex shader source
   * @readonly
   */
  static get defaultVertexSrc() {
    return texture.default;
  }
  /**
   * The default fragment shader source
   * @readonly
   */
  static get defaultFragmentTemplate() {
    return texture$1.default;
  }
  /**
   * Set the shader generator.
   * @param {object} [options]
   * @param {string} [options.vertex=PIXI.BatchRenderer.defaultVertexSrc] - Vertex shader source
   * @param {string} [options.fragment=PIXI.BatchRenderer.defaultFragmentTemplate] - Fragment shader template
   */
  setShaderGenerator({
    vertex = _BatchRenderer2.defaultVertexSrc,
    fragment = _BatchRenderer2.defaultFragmentTemplate
  } = {}) {
    this.shaderGenerator = new BatchShaderGenerator.BatchShaderGenerator(vertex, fragment);
  }
  /**
   * Handles the `contextChange` signal.
   *
   * It calculates `this.maxTextures` and allocating the packed-geometry object pool.
   */
  contextChange() {
    const gl = this.renderer.gl;
    settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(
      gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
      _BatchRenderer2.defaultMaxTextures
    ), this.maxTextures = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader(
      this.maxTextures,
      gl
    )), this._shader = this.shaderGenerator.generateShader(this.maxTextures);
    for (let i = 0; i < this._packedGeometryPoolSize; i++)
      this._packedGeometries[i] = new this.geometryClass();
    this.initFlushBuffers();
  }
  /** Makes sure that static and dynamic flush pooled objects have correct dimensions. */
  initFlushBuffers() {
    const {
      _drawCallPool,
      _textureArrayPool
    } = _BatchRenderer2, MAX_SPRITES = this.size / 4, MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;
    for (; _drawCallPool.length < MAX_SPRITES; )
      _drawCallPool.push(new BatchDrawCall.BatchDrawCall());
    for (; _textureArrayPool.length < MAX_TA; )
      _textureArrayPool.push(new BatchTextureArray.BatchTextureArray());
    for (let i = 0; i < this.maxTextures; i++)
      this._tempBoundTextures[i] = null;
  }
  /** Handles the `prerender` signal. It ensures that flushes start from the first geometry object again. */
  onPrerender() {
    this._flushId = 0;
  }
  /**
   * Buffers the "batchable" object. It need not be rendered immediately.
   * @param {PIXI.DisplayObject} element - the element to render when
   *    using this renderer
   */
  render(element) {
    element._texture.valid && (this._vertexCount + element.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += element.vertexData.length / 2, this._indexCount += element.indices.length, this._bufferedTextures[this._bufferSize] = element._texture.baseTexture, this._bufferedElements[this._bufferSize++] = element);
  }
  buildTexturesAndDrawCalls() {
    const {
      _bufferedTextures: textures,
      maxTextures
    } = this, textureArrays = _BatchRenderer2._textureArrayPool, batch = this.renderer.batch, boundTextures = this._tempBoundTextures, touch = this.renderer.textureGC.count;
    let TICK = ++BaseTexture.BaseTexture._globalBatch, countTexArrays = 0, texArray = textureArrays[0], start = 0;
    batch.copyBoundTextures(boundTextures, maxTextures);
    for (let i = 0; i < this._bufferSize; ++i) {
      const tex = textures[i];
      textures[i] = null, tex._batchEnabled !== TICK && (texArray.count >= maxTextures && (batch.boundArray(texArray, boundTextures, TICK, maxTextures), this.buildDrawCalls(texArray, start, i), start = i, texArray = textureArrays[++countTexArrays], ++TICK), tex._batchEnabled = TICK, tex.touched = touch, texArray.elements[texArray.count++] = tex);
    }
    texArray.count > 0 && (batch.boundArray(texArray, boundTextures, TICK, maxTextures), this.buildDrawCalls(texArray, start, this._bufferSize), ++countTexArrays, ++TICK);
    for (let i = 0; i < boundTextures.length; i++)
      boundTextures[i] = null;
    BaseTexture.BaseTexture._globalBatch = TICK;
  }
  /**
   * Populating drawcalls for rendering
   * @param texArray
   * @param start
   * @param finish
   */
  buildDrawCalls(texArray, start, finish) {
    const {
      _bufferedElements: elements,
      _attributeBuffer,
      _indexBuffer,
      vertexSize
    } = this, drawCalls = _BatchRenderer2._drawCallPool;
    let dcIndex = this._dcIndex, aIndex = this._aIndex, iIndex = this._iIndex, drawCall = drawCalls[dcIndex];
    drawCall.start = this._iIndex, drawCall.texArray = texArray;
    for (let i = start; i < finish; ++i) {
      const sprite = elements[i], tex = sprite._texture.baseTexture, spriteBlendMode = utils.premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
      elements[i] = null, start < i && drawCall.blend !== spriteBlendMode && (drawCall.size = iIndex - drawCall.start, start = i, drawCall = drawCalls[++dcIndex], drawCall.texArray = texArray, drawCall.start = iIndex), this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex), aIndex += sprite.vertexData.length / 2 * vertexSize, iIndex += sprite.indices.length, drawCall.blend = spriteBlendMode;
    }
    start < finish && (drawCall.size = iIndex - drawCall.start, ++dcIndex), this._dcIndex = dcIndex, this._aIndex = aIndex, this._iIndex = iIndex;
  }
  /**
   * Bind textures for current rendering
   * @param texArray
   */
  bindAndClearTexArray(texArray) {
    const textureSystem = this.renderer.texture;
    for (let j = 0; j < texArray.count; j++)
      textureSystem.bind(texArray.elements[j], texArray.ids[j]), texArray.elements[j] = null;
    texArray.count = 0;
  }
  updateGeometry() {
    const {
      _packedGeometries: packedGeometries,
      _attributeBuffer: attributeBuffer,
      _indexBuffer: indexBuffer
    } = this;
    _BatchRenderer2.canUploadSameBuffer ? (packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, packedGeometries[this._flushId] = new this.geometryClass()), packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.bind(packedGeometries[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
  }
  drawBatches() {
    const dcCount = this._dcIndex, { gl, state: stateSystem } = this.renderer, drawCalls = _BatchRenderer2._drawCallPool;
    let curTexArray = null;
    for (let i = 0; i < dcCount; i++) {
      const { texArray, type, size, start, blend } = drawCalls[i];
      curTexArray !== texArray && (curTexArray = texArray, this.bindAndClearTexArray(texArray)), this.state.blendMode = blend, stateSystem.set(this.state), gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);
    }
  }
  /** Renders the content _now_ and empties the current batch. */
  flush() {
    this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
  }
  /** Starts a new sprite batch. */
  start() {
    this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.maxTextures), this.renderer.shader.bind(this._shader), _BatchRenderer2.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
  }
  /** Stops and flushes the current batch. */
  stop() {
    this.flush();
  }
  /** Destroys this `BatchRenderer`. It cannot be used again. */
  destroy() {
    for (let i = 0; i < this._packedGeometryPoolSize; i++)
      this._packedGeometries[i] && this._packedGeometries[i].destroy();
    this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), super.destroy();
  }
  /**
   * Fetches an attribute buffer from `this._aBuffers` that can hold atleast `size` floats.
   * @param size - minimum capacity required
   * @returns - buffer than can hold atleast `size` floats
   */
  getAttributeBuffer(size) {
    const roundedP2 = utils.nextPow2(Math.ceil(size / 8)), roundedSizeIndex = utils.log2(roundedP2), roundedSize = roundedP2 * 8;
    this._aBuffers.length <= roundedSizeIndex && (this._iBuffers.length = roundedSizeIndex + 1);
    let buffer = this._aBuffers[roundedSize];
    return buffer || (this._aBuffers[roundedSize] = buffer = new ViewableBuffer.ViewableBuffer(roundedSize * this.vertexSize * 4)), buffer;
  }
  /**
   * Fetches an index buffer from `this._iBuffers` that can
   * have at least `size` capacity.
   * @param size - minimum required capacity
   * @returns - buffer that can fit `size` indices.
   */
  getIndexBuffer(size) {
    const roundedP2 = utils.nextPow2(Math.ceil(size / 12)), roundedSizeIndex = utils.log2(roundedP2), roundedSize = roundedP2 * 12;
    this._iBuffers.length <= roundedSizeIndex && (this._iBuffers.length = roundedSizeIndex + 1);
    let buffer = this._iBuffers[roundedSizeIndex];
    return buffer || (this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize)), buffer;
  }
  /**
   * Takes the four batching parameters of `element`, interleaves
   * and pushes them into the batching attribute/index buffers given.
   *
   * It uses these properties: `vertexData` `uvs`, `textureId` and
   * `indicies`. It also uses the "tint" of the base-texture, if
   * present.
   * @param {PIXI.DisplayObject} element - element being rendered
   * @param attributeBuffer - attribute buffer.
   * @param indexBuffer - index buffer
   * @param aIndex - number of floats already in the attribute buffer
   * @param iIndex - number of indices already in `indexBuffer`
   */
  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
    const {
      uint32View,
      float32View
    } = attributeBuffer, packedVertices = aIndex / this.vertexSize, uvs = element.uvs, indicies = element.indices, vertexData = element.vertexData, textureId = element._texture.baseTexture._batchLocation, alpha = Math.min(element.worldAlpha, 1), argb = color.Color.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);
    for (let i = 0; i < vertexData.length; i += 2)
      float32View[aIndex++] = vertexData[i], float32View[aIndex++] = vertexData[i + 1], float32View[aIndex++] = uvs[i], float32View[aIndex++] = uvs[i + 1], uint32View[aIndex++] = argb, float32View[aIndex++] = textureId;
    for (let i = 0; i < indicies.length; i++)
      indexBuffer[iIndex++] = packedVertices + indicies[i];
  }
};
_BatchRenderer.defaultBatchSize = 4096, /** @ignore */
_BatchRenderer.extension = {
  name: "batch",
  type: extensions.ExtensionType.RendererPlugin
}, /**
* Pool of `BatchDrawCall` objects that `flush` used
* to create "batches" of the objects being rendered.
*
* These are never re-allocated again.
* Shared between all batch renderers because it can be only one "flush" working at the moment.
* @member {PIXI.BatchDrawCall[]}
*/
_BatchRenderer._drawCallPool = [], /**
* Pool of `BatchDrawCall` objects that `flush` used
* to create "batches" of the objects being rendered.
*
* These are never re-allocated again.
* Shared between all batch renderers because it can be only one "flush" working at the moment.
* @member {PIXI.BatchTextureArray[]}
*/
_BatchRenderer._textureArrayPool = [];
let BatchRenderer = _BatchRenderer;
extensions.extensions.add(BatchRenderer);
exports.BatchRenderer = BatchRenderer;
//# sourceMappingURL=BatchRenderer.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var math = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.js"), Program = __webpack_require__(/*! ../shader/Program.js */ "./node_modules/@pixi/core/lib/shader/Program.js"), Shader = __webpack_require__(/*! ../shader/Shader.js */ "./node_modules/@pixi/core/lib/shader/Shader.js"), UniformGroup = __webpack_require__(/*! ../shader/UniformGroup.js */ "./node_modules/@pixi/core/lib/shader/UniformGroup.js");
class BatchShaderGenerator {
  /**
   * @param vertexSrc - Vertex shader
   * @param fragTemplate - Fragment shader template
   */
  constructor(vertexSrc, fragTemplate) {
    if (this.vertexSrc = vertexSrc, this.fragTemplate = fragTemplate, this.programCache = {}, this.defaultGroupCache = {}, !fragTemplate.includes("%count%"))
      throw new Error('Fragment template must contain "%count%".');
    if (!fragTemplate.includes("%forloop%"))
      throw new Error('Fragment template must contain "%forloop%".');
  }
  generateShader(maxTextures) {
    if (!this.programCache[maxTextures]) {
      const sampleValues = new Int32Array(maxTextures);
      for (let i = 0; i < maxTextures; i++)
        sampleValues[i] = i;
      this.defaultGroupCache[maxTextures] = UniformGroup.UniformGroup.from({ uSamplers: sampleValues }, !0);
      let fragmentSrc = this.fragTemplate;
      fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`), fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures)), this.programCache[maxTextures] = new Program.Program(this.vertexSrc, fragmentSrc);
    }
    const uniforms = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new math.Matrix(),
      default: this.defaultGroupCache[maxTextures]
    };
    return new Shader.Shader(this.programCache[maxTextures], uniforms);
  }
  generateSampleSrc(maxTextures) {
    let src = "";
    src += `
`, src += `
`;
    for (let i = 0; i < maxTextures; i++)
      i > 0 && (src += `
else `), i < maxTextures - 1 && (src += `if(vTextureId < ${i}.5)`), src += `
{`, src += `
	color = texture2D(uSamplers[${i}], vTextureCoord);`, src += `
}`;
    return src += `
`, src += `
`, src;
  }
}
exports.BatchShaderGenerator = BatchShaderGenerator;
//# sourceMappingURL=BatchShaderGenerator.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchSystem.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchSystem.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), ObjectRenderer = __webpack_require__(/*! ./ObjectRenderer.js */ "./node_modules/@pixi/core/lib/batch/ObjectRenderer.js");
class BatchSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.emptyRenderer = new ObjectRenderer.ObjectRenderer(renderer), this.currentRenderer = this.emptyRenderer;
  }
  /**
   * Changes the current renderer to the one given in parameter
   * @param objectRenderer - The object renderer to use.
   */
  setObjectRenderer(objectRenderer) {
    this.currentRenderer !== objectRenderer && (this.currentRenderer.stop(), this.currentRenderer = objectRenderer, this.currentRenderer.start());
  }
  /**
   * This should be called if you wish to do some custom rendering
   * It will basically render anything that may be batched up such as sprites
   */
  flush() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  /** Reset the system to an empty renderer */
  reset() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  /**
   * Handy function for batch renderers: copies bound textures in first maxTextures locations to array
   * sets actual _batchLocation for them
   * @param arr - arr copy destination
   * @param maxTextures - number of copied elements
   */
  copyBoundTextures(arr, maxTextures) {
    const { boundTextures } = this.renderer.texture;
    for (let i = maxTextures - 1; i >= 0; --i)
      arr[i] = boundTextures[i] || null, arr[i] && (arr[i]._batchLocation = i);
  }
  /**
   * Assigns batch locations to textures in array based on boundTextures state.
   * All textures in texArray should have `_batchEnabled = _batchId`,
   * and their count should be less than `maxTextures`.
   * @param texArray - textures to bound
   * @param boundTextures - current state of bound textures
   * @param batchId - marker for _batchEnabled param of textures in texArray
   * @param maxTextures - number of texture locations to manipulate
   */
  boundArray(texArray, boundTextures, batchId, maxTextures) {
    const { elements, ids, count } = texArray;
    let j = 0;
    for (let i = 0; i < count; i++) {
      const tex = elements[i], loc = tex._batchLocation;
      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
        ids[i] = loc;
        continue;
      }
      for (; j < maxTextures; ) {
        const bound = boundTextures[j];
        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {
          j++;
          continue;
        }
        ids[i] = j, tex._batchLocation = j, boundTextures[j] = tex;
        break;
      }
    }
  }
  /**
   * @ignore
   */
  destroy() {
    this.renderer = null;
  }
}
BatchSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "batch"
};
extensions.extensions.add(BatchSystem);
exports.BatchSystem = BatchSystem;
//# sourceMappingURL=BatchSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchTextureArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchTextureArray.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class BatchTextureArray {
  constructor() {
    this.elements = [], this.ids = [], this.count = 0;
  }
  clear() {
    for (let i = 0; i < this.count; i++)
      this.elements[i] = null;
    this.count = 0;
  }
}
exports.BatchTextureArray = BatchTextureArray;
//# sourceMappingURL=BatchTextureArray.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/ObjectRenderer.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/ObjectRenderer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class ObjectRenderer {
  /**
   * @param renderer - The renderer this manager works for.
   */
  constructor(renderer) {
    this.renderer = renderer;
  }
  /** Stub method that should be used to empty the current batch by rendering objects now. */
  flush() {
  }
  /** Generic destruction method that frees all resources. This should be called by subclasses. */
  destroy() {
    this.renderer = null;
  }
  /**
   * Stub method that initializes any state required before
   * rendering starts. It is different from the `prerender`
   * signal, which occurs every frame, in that it is called
   * whenever an object requests _this_ renderer specifically.
   */
  start() {
  }
  /** Stops the renderer. It should free up any state and become dormant. */
  stop() {
    this.flush();
  }
  /**
   * Keeps the object to render. It doesn't have to be
   * rendered immediately.
   * @param {PIXI.DisplayObject} _object - The object to render.
   */
  render(_object) {
  }
}
exports.ObjectRenderer = ObjectRenderer;
//# sourceMappingURL=ObjectRenderer.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/canUploadSameBuffer.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/canUploadSameBuffer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js");
function canUploadSameBuffer() {
  return !settings.isMobile.apple.device;
}
exports.canUploadSameBuffer = canUploadSameBuffer;
//# sourceMappingURL=canUploadSameBuffer.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/maxRecommendedTextures.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/maxRecommendedTextures.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js");
function maxRecommendedTextures(max) {
  let allowMax = !0;
  const navigator = settings.settings.ADAPTER.getNavigator();
  if (settings.isMobile.tablet || settings.isMobile.phone) {
    if (settings.isMobile.apple.device) {
      const match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      match && parseInt(match[1], 10) < 11 && (allowMax = !1);
    }
    if (settings.isMobile.android.device) {
      const match = navigator.userAgent.match(/Android\s([0-9.]*)/);
      match && parseInt(match[1], 10) < 7 && (allowMax = !1);
    }
  }
  return allowMax ? max : 4;
}
exports.maxRecommendedTextures = maxRecommendedTextures;
//# sourceMappingURL=maxRecommendedTextures.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/texture.frag.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/texture.frag.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var defaultFragment = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`;
exports["default"] = defaultFragment;
//# sourceMappingURL=texture.frag.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/texture.vert.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/texture.vert.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var defaultVertex = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`;
exports["default"] = defaultVertex;
//# sourceMappingURL=texture.vert.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/context/ContextSystem.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/context/ContextSystem.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js");
let CONTEXT_UID_COUNTER = 0;
class ContextSystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.renderer = renderer, this.webGLVersion = 1, this.extensions = {}, this.supports = {
      uint32Indices: !1
    }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this);
  }
  /**
   * `true` if the context is lost
   * @readonly
   */
  get isLost() {
    return !this.gl || this.gl.isContextLost();
  }
  /**
   * Handles the context change event.
   * @param {WebGLRenderingContext} gl - New WebGL context.
   */
  contextChange(gl) {
    this.gl = gl, this.renderer.gl = gl, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
  }
  init(options) {
    if (options.context)
      this.initFromContext(options.context);
    else {
      const alpha = this.renderer.background.alpha < 1, premultipliedAlpha = options.premultipliedAlpha;
      this.preserveDrawingBuffer = options.preserveDrawingBuffer, this.useContextAlpha = options.useContextAlpha, this.powerPreference = options.powerPreference, this.initFromOptions({
        alpha,
        premultipliedAlpha,
        antialias: options.antialias,
        stencil: !0,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: options.powerPreference
      });
    }
  }
  /**
   * Initializes the context.
   * @protected
   * @param {WebGLRenderingContext} gl - WebGL context
   */
  initFromContext(gl) {
    this.gl = gl, this.validateContext(gl), this.renderer.gl = gl, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, this.renderer.runners.contextChange.emit(gl);
    const view = this.renderer.view;
    view.addEventListener !== void 0 && (view.addEventListener("webglcontextlost", this.handleContextLost, !1), view.addEventListener("webglcontextrestored", this.handleContextRestored, !1));
  }
  /**
   * Initialize from context options
   * @protected
   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
   * @param {object} options - context attributes
   */
  initFromOptions(options) {
    const gl = this.createContext(this.renderer.view, options);
    this.initFromContext(gl);
  }
  /**
   * Helper class to create a WebGL Context
   * @param canvas - the canvas element that we will get the context from
   * @param options - An options object that gets passed in to the canvas element containing the
   *    context attributes
   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
   * @returns {WebGLRenderingContext} the WebGL context
   */
  createContext(canvas, options) {
    let gl;
    if (settings.settings.PREFER_ENV >= constants.ENV.WEBGL2 && (gl = canvas.getContext("webgl2", options)), gl)
      this.webGLVersion = 2;
    else if (this.webGLVersion = 1, gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options), !gl)
      throw new Error("This browser does not support WebGL. Try using the canvas renderer");
    return this.gl = gl, this.getExtensions(), this.gl;
  }
  /** Auto-populate the {@link PIXI.ContextSystem.extensions extensions}. */
  getExtensions() {
    const { gl } = this, common = {
      loseContext: gl.getExtension("WEBGL_lose_context"),
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      // eslint-disable-line camelcase
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc")
    };
    this.webGLVersion === 1 ? Object.assign(this.extensions, common, {
      drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
      depthTexture: gl.getExtension("WEBGL_depth_texture"),
      vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
      uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
      // Floats and half-floats
      floatTexture: gl.getExtension("OES_texture_float"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      textureHalfFloat: gl.getExtension("OES_texture_half_float"),
      textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
    }) : this.webGLVersion === 2 && Object.assign(this.extensions, common, {
      // Floats and half-floats
      colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
    });
  }
  /**
   * Handles a lost webgl context
   * @param {WebGLContextEvent} event - The context lost event.
   */
  handleContextLost(event) {
    event.preventDefault(), setTimeout(() => {
      this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext();
    }, 0);
  }
  /** Handles a restored webgl context. */
  handleContextRestored() {
    this.renderer.runners.contextChange.emit(this.gl);
  }
  destroy() {
    const view = this.renderer.view;
    this.renderer = null, view.removeEventListener !== void 0 && (view.removeEventListener("webglcontextlost", this.handleContextLost), view.removeEventListener("webglcontextrestored", this.handleContextRestored)), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
  }
  /** Handle the post-render runner event. */
  postrender() {
    this.renderer.objectRenderer.renderingToScreen && this.gl.flush();
  }
  /**
   * Validate context.
   * @param {WebGLRenderingContext} gl - Render context.
   */
  validateContext(gl) {
    const attributes = gl.getContextAttributes(), isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
    isWebGl2 && (this.webGLVersion = 2), attributes && !attributes.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    const hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = hasuint32, hasuint32 || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
  }
}
ContextSystem.defaultOptions = {
  /**
   * {@link PIXI.IRendererOptions.context}
   * @default null
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  context: null,
  /**
   * {@link PIXI.IRendererOptions.antialias}
   * @default false
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  antialias: !1,
  /**
   * {@link PIXI.IRendererOptions.premultipliedAlpha}
   * @default true
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  premultipliedAlpha: !0,
  /**
   * {@link PIXI.IRendererOptions.preserveDrawingBuffer}
   * @default false
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  preserveDrawingBuffer: !1,
  /**
   * {@link PIXI.IRendererOptions.powerPreference}
   * @default default
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  powerPreference: "default"
}, /** @ignore */
ContextSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "context"
};
extensions.extensions.add(ContextSystem);
exports.ContextSystem = ContextSystem;
//# sourceMappingURL=ContextSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/Filter.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/Filter.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), Program = __webpack_require__(/*! ../shader/Program.js */ "./node_modules/@pixi/core/lib/shader/Program.js"), Shader = __webpack_require__(/*! ../shader/Shader.js */ "./node_modules/@pixi/core/lib/shader/Shader.js"), State = __webpack_require__(/*! ../state/State.js */ "./node_modules/@pixi/core/lib/state/State.js"), defaultFilter$1 = __webpack_require__(/*! ./defaultFilter.frag.js */ "./node_modules/@pixi/core/lib/filters/defaultFilter.frag.js"), defaultFilter = __webpack_require__(/*! ./defaultFilter.vert.js */ "./node_modules/@pixi/core/lib/filters/defaultFilter.vert.js");
const _Filter = class _Filter2 extends Shader.Shader {
  /**
   * @param vertexSrc - The source of the vertex shader.
   * @param fragmentSrc - The source of the fragment shader.
   * @param uniforms - Custom uniforms to use to augment the built-in ones.
   */
  constructor(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.Program.from(
      vertexSrc || _Filter2.defaultVertexSrc,
      fragmentSrc || _Filter2.defaultFragmentSrc
    );
    super(program, uniforms), this.padding = 0, this.resolution = _Filter2.defaultResolution, this.multisample = _Filter2.defaultMultisample, this.enabled = !0, this.autoFit = !0, this.state = new State.State();
  }
  /**
   * Applies the filter
   * @param {PIXI.FilterSystem} filterManager - The renderer to retrieve the filter from
   * @param {PIXI.RenderTexture} input - The input render target.
   * @param {PIXI.RenderTexture} output - The target to output to.
   * @param {PIXI.CLEAR_MODES} [clearMode] - Should the output be cleared before rendering to it.
   * @param {object} [_currentState] - It's current state of filter.
   *        There are some useful properties in the currentState :
   *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution
   */
  apply(filterManager, input, output, clearMode, _currentState) {
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /**
   * Sets the blend mode of the filter.
   * @default PIXI.BLEND_MODES.NORMAL
   */
  get blendMode() {
    return this.state.blendMode;
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  /**
   * The resolution of the filter. Setting this to be lower will lower the quality but
   * increase the performance of the filter.
   * If set to `null` or `0`, the resolution of the current render target is used.
   * @default PIXI.Filter.defaultResolution
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._resolution = value;
  }
  /**
   * The default vertex shader source
   * @readonly
   */
  static get defaultVertexSrc() {
    return defaultFilter.default;
  }
  /**
   * The default fragment shader source
   * @readonly
   */
  static get defaultFragmentSrc() {
    return defaultFilter$1.default;
  }
};
_Filter.defaultResolution = 1, /**
* Default filter samples for any filter.
* @static
* @type {PIXI.MSAA_QUALITY|null}
* @default PIXI.MSAA_QUALITY.NONE
*/
_Filter.defaultMultisample = constants.MSAA_QUALITY.NONE;
let Filter = _Filter;
exports.Filter = Filter;
//# sourceMappingURL=Filter.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/FilterState.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/FilterState.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), math = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.js");
class FilterState {
  constructor() {
    this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = constants.MSAA_QUALITY.NONE, this.sourceFrame = new math.Rectangle(), this.destinationFrame = new math.Rectangle(), this.bindingSourceFrame = new math.Rectangle(), this.bindingDestinationFrame = new math.Rectangle(), this.filters = [], this.transform = null;
  }
  /** Clears the state */
  clear() {
    this.target = null, this.filters = null, this.renderTexture = null;
  }
}
exports.FilterState = FilterState;
//# sourceMappingURL=FilterState.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/FilterSystem.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/FilterSystem.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), math = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.js"), RenderTexturePool = __webpack_require__(/*! ../renderTexture/RenderTexturePool.js */ "./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.js"), UniformGroup = __webpack_require__(/*! ../shader/UniformGroup.js */ "./node_modules/@pixi/core/lib/shader/UniformGroup.js"), Quad = __webpack_require__(/*! ../utils/Quad.js */ "./node_modules/@pixi/core/lib/utils/Quad.js"), QuadUv = __webpack_require__(/*! ../utils/QuadUv.js */ "./node_modules/@pixi/core/lib/utils/QuadUv.js"), FilterState = __webpack_require__(/*! ./FilterState.js */ "./node_modules/@pixi/core/lib/filters/FilterState.js");
const tempPoints = [new math.Point(), new math.Point(), new math.Point(), new math.Point()], tempMatrix = new math.Matrix();
class FilterSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool.RenderTexturePool(), this.statePool = [], this.quad = new Quad.Quad(), this.quadUv = new QuadUv.QuadUv(), this.tempRect = new math.Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup.UniformGroup({
      outputFrame: new math.Rectangle(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      // legacy variables
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, !0), this.forceClear = !1, this.useMaxPadding = !1;
  }
  init() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  /**
   * Pushes a set of filters to be applied later to the system. This will redirect further rendering into an
   * input render-texture for the rest of the filtering pipeline.
   * @param {PIXI.DisplayObject} target - The target of the filter to render.
   * @param filters - The filters to apply.
   */
  push(target, filters) {
    const renderer = this.renderer, filterStack = this.defaultFilterStack, state = this.statePool.pop() || new FilterState.FilterState(), renderTextureSystem = renderer.renderTexture;
    let currentResolution, currentMultisample;
    if (renderTextureSystem.current) {
      const renderTexture = renderTextureSystem.current;
      currentResolution = renderTexture.resolution, currentMultisample = renderTexture.multisample;
    } else
      currentResolution = renderer.resolution, currentMultisample = renderer.multisample;
    let resolution = filters[0].resolution || currentResolution, multisample = filters[0].multisample ?? currentMultisample, padding = filters[0].padding, autoFit = filters[0].autoFit, legacy = filters[0].legacy ?? !0;
    for (let i = 1; i < filters.length; i++) {
      const filter = filters[i];
      resolution = Math.min(resolution, filter.resolution || currentResolution), multisample = Math.min(multisample, filter.multisample ?? currentMultisample), padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding, autoFit = autoFit && filter.autoFit, legacy = legacy || (filter.legacy ?? !0);
    }
    filterStack.length === 1 && (this.defaultFilterStack[0].renderTexture = renderTextureSystem.current), filterStack.push(state), state.resolution = resolution, state.multisample = multisample, state.legacy = legacy, state.target = target, state.sourceFrame.copyFrom(target.filterArea || target.getBounds(!0)), state.sourceFrame.pad(padding);
    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
    renderer.projection.transform && this.transformAABB(
      tempMatrix.copyFrom(renderer.projection.transform).invert(),
      sourceFrameProjected
    ), autoFit ? (state.sourceFrame.fit(sourceFrameProjected), (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) && (state.sourceFrame.width = 0, state.sourceFrame.height = 0)) : state.sourceFrame.intersects(sourceFrameProjected) || (state.sourceFrame.width = 0, state.sourceFrame.height = 0), this.roundFrame(
      state.sourceFrame,
      renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,
      renderTextureSystem.sourceFrame,
      renderTextureSystem.destinationFrame,
      renderer.projection.transform
    ), state.renderTexture = this.getOptimalFilterTexture(
      state.sourceFrame.width,
      state.sourceFrame.height,
      resolution,
      multisample
    ), state.filters = filters, state.destinationFrame.width = state.renderTexture.width, state.destinationFrame.height = state.renderTexture.height;
    const destinationFrame = this.tempRect;
    destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = state.sourceFrame.width, destinationFrame.height = state.sourceFrame.height, state.renderTexture.filterFrame = state.sourceFrame, state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame), state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame), state.transform = renderer.projection.transform, renderer.projection.transform = null, renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame), renderer.framebuffer.clear(0, 0, 0, 0);
  }
  /** Pops off the filter and applies it. */
  pop() {
    const filterStack = this.defaultFilterStack, state = filterStack.pop(), filters = state.filters;
    this.activeState = state;
    const globalUniforms = this.globalUniforms.uniforms;
    globalUniforms.outputFrame = state.sourceFrame, globalUniforms.resolution = state.resolution;
    const inputSize = globalUniforms.inputSize, inputPixel = globalUniforms.inputPixel, inputClamp = globalUniforms.inputClamp;
    if (inputSize[0] = state.destinationFrame.width, inputSize[1] = state.destinationFrame.height, inputSize[2] = 1 / inputSize[0], inputSize[3] = 1 / inputSize[1], inputPixel[0] = Math.round(inputSize[0] * state.resolution), inputPixel[1] = Math.round(inputSize[1] * state.resolution), inputPixel[2] = 1 / inputPixel[0], inputPixel[3] = 1 / inputPixel[1], inputClamp[0] = 0.5 * inputPixel[2], inputClamp[1] = 0.5 * inputPixel[3], inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2], inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3], state.legacy) {
      const filterArea = globalUniforms.filterArea;
      filterArea[0] = state.destinationFrame.width, filterArea[1] = state.destinationFrame.height, filterArea[2] = state.sourceFrame.x, filterArea[3] = state.sourceFrame.y, globalUniforms.filterClamp = globalUniforms.inputClamp;
    }
    this.globalUniforms.update();
    const lastState = filterStack[filterStack.length - 1];
    if (this.renderer.framebuffer.blit(), filters.length === 1)
      filters[0].apply(this, state.renderTexture, lastState.renderTexture, constants.CLEAR_MODES.BLEND, state), this.returnFilterTexture(state.renderTexture);
    else {
      let flip = state.renderTexture, flop = this.getOptimalFilterTexture(
        flip.width,
        flip.height,
        state.resolution
      );
      flop.filterFrame = flip.filterFrame;
      let i = 0;
      for (i = 0; i < filters.length - 1; ++i) {
        i === 1 && state.multisample > 1 && (flop = this.getOptimalFilterTexture(
          flip.width,
          flip.height,
          state.resolution
        ), flop.filterFrame = flip.filterFrame), filters[i].apply(this, flip, flop, constants.CLEAR_MODES.CLEAR, state);
        const t = flip;
        flip = flop, flop = t;
      }
      filters[i].apply(this, flip, lastState.renderTexture, constants.CLEAR_MODES.BLEND, state), i > 1 && state.multisample > 1 && this.returnFilterTexture(state.renderTexture), this.returnFilterTexture(flip), this.returnFilterTexture(flop);
    }
    state.clear(), this.statePool.push(state);
  }
  /**
   * Binds a renderTexture with corresponding `filterFrame`, clears it if mode corresponds.
   * @param filterTexture - renderTexture to bind, should belong to filter pool or filter stack
   * @param clearMode - clearMode, by default its CLEAR/YES. See {@link PIXI.CLEAR_MODES}
   */
  bindAndClear(filterTexture, clearMode = constants.CLEAR_MODES.CLEAR) {
    const {
      renderTexture: renderTextureSystem,
      state: stateSystem
    } = this.renderer;
    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, filterTexture?.filterFrame) {
      const destinationFrame = this.tempRect;
      destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = filterTexture.filterFrame.width, destinationFrame.height = filterTexture.filterFrame.height, renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
    } else
      filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? renderTextureSystem.bind(filterTexture) : this.renderer.renderTexture.bind(
        filterTexture,
        this.activeState.bindingSourceFrame,
        this.activeState.bindingDestinationFrame
      );
    const autoClear = stateSystem.stateId & 1 || this.forceClear;
    (clearMode === constants.CLEAR_MODES.CLEAR || clearMode === constants.CLEAR_MODES.BLIT && autoClear) && this.renderer.framebuffer.clear(0, 0, 0, 0);
  }
  /**
   * Draws a filter using the default rendering process.
   *
   * This should be called only by {@link PIXI.Filter#apply}.
   * @param filter - The filter to draw.
   * @param input - The input render target.
   * @param output - The target to output to.
   * @param clearMode - Should the output be cleared before rendering to it
   */
  applyFilter(filter, input, output, clearMode) {
    const renderer = this.renderer;
    renderer.state.set(filter.state), this.bindAndClear(output, clearMode), filter.uniforms.uSampler = input, filter.uniforms.filterGlobals = this.globalUniforms, renderer.shader.bind(filter), filter.legacy = !!filter.program.attributeData.aTextureCoord, filter.legacy ? (this.quadUv.map(input._frame, input.filterFrame), renderer.geometry.bind(this.quadUv), renderer.geometry.draw(constants.DRAW_MODES.TRIANGLES)) : (renderer.geometry.bind(this.quad), renderer.geometry.draw(constants.DRAW_MODES.TRIANGLE_STRIP));
  }
  /**
   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
   *
   * Use `outputMatrix * vTextureCoord` in the shader.
   * @param outputMatrix - The matrix to output to.
   * @param {PIXI.Sprite} sprite - The sprite to map to.
   * @returns The mapped matrix.
   */
  calculateSpriteMatrix(outputMatrix, sprite) {
    const { sourceFrame, destinationFrame } = this.activeState, { orig } = sprite._texture, mappedMatrix = outputMatrix.set(
      destinationFrame.width,
      0,
      0,
      destinationFrame.height,
      sourceFrame.x,
      sourceFrame.y
    ), worldTransform = sprite.worldTransform.copyTo(math.Matrix.TEMP_MATRIX);
    return worldTransform.invert(), mappedMatrix.prepend(worldTransform), mappedMatrix.scale(1 / orig.width, 1 / orig.height), mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y), mappedMatrix;
  }
  /** Destroys this Filter System. */
  destroy() {
    this.renderer = null, this.texturePool.clear(!1);
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param minWidth - The minimum width of the render texture in real pixels.
   * @param minHeight - The minimum height of the render texture in real pixels.
   * @param resolution - The resolution of the render texture.
   * @param multisample - Number of samples of the render texture.
   * @returns - The new render texture.
   */
  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = constants.MSAA_QUALITY.NONE) {
    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
  }
  /**
   * Gets extra render texture to use inside current filter
   * To be compliant with older filters, you can use params in any order
   * @param input - renderTexture from which size and resolution will be copied
   * @param resolution - override resolution of the renderTexture
   * @param multisample - number of samples of the renderTexture
   */
  getFilterTexture(input, resolution, multisample) {
    if (typeof input == "number") {
      const swap = input;
      input = resolution, resolution = swap;
    }
    input = input || this.activeState.renderTexture;
    const filterTexture = this.texturePool.getOptimalTexture(
      input.width,
      input.height,
      resolution || input.resolution,
      multisample || constants.MSAA_QUALITY.NONE
    );
    return filterTexture.filterFrame = input.filterFrame, filterTexture;
  }
  /**
   * Frees a render texture back into the pool.
   * @param renderTexture - The renderTarget to free
   */
  returnFilterTexture(renderTexture) {
    this.texturePool.returnTexture(renderTexture);
  }
  /** Empties the texture pool. */
  emptyPool() {
    this.texturePool.clear(!0);
  }
  /** Calls `texturePool.resize()`, affects fullScreen renderTextures. */
  resize() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  /**
   * @param matrix - first param
   * @param rect - second param
   */
  transformAABB(matrix, rect) {
    const lt = tempPoints[0], lb = tempPoints[1], rt = tempPoints[2], rb = tempPoints[3];
    lt.set(rect.left, rect.top), lb.set(rect.left, rect.bottom), rt.set(rect.right, rect.top), rb.set(rect.right, rect.bottom), matrix.apply(lt, lt), matrix.apply(lb, lb), matrix.apply(rt, rt), matrix.apply(rb, rb);
    const x0 = Math.min(lt.x, lb.x, rt.x, rb.x), y0 = Math.min(lt.y, lb.y, rt.y, rb.y), x1 = Math.max(lt.x, lb.x, rt.x, rb.x), y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
    rect.x = x0, rect.y = y0, rect.width = x1 - x0, rect.height = y1 - y0;
  }
  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (!(frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0)) {
      if (transform) {
        const { a, b, c, d } = transform;
        if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4))
          return;
      }
      transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity(), transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(
        bindingDestinationFrame.width / bindingSourceFrame.width,
        bindingDestinationFrame.height / bindingSourceFrame.height
      ).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.transformAABB(transform, frame), frame.ceil(resolution), this.transformAABB(transform.invert(), frame);
    }
  }
}
FilterSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "filter"
};
extensions.extensions.add(FilterSystem);
exports.FilterSystem = FilterSystem;
//# sourceMappingURL=FilterSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/IFilterTarget.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/IFilterTarget.js ***!
  \**************************************************************/
/***/ (() => {

"use strict";

//# sourceMappingURL=IFilterTarget.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/defaultFilter.frag.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/defaultFilter.frag.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var defaultFragment = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`;
exports["default"] = defaultFragment;
//# sourceMappingURL=defaultFilter.frag.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/defaultFilter.vert.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/defaultFilter.vert.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var defaultVertex = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
exports["default"] = defaultVertex;
//# sourceMappingURL=defaultFilter.vert.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var math = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.js"), TextureMatrix = __webpack_require__(/*! ../../textures/TextureMatrix.js */ "./node_modules/@pixi/core/lib/textures/TextureMatrix.js"), Filter = __webpack_require__(/*! ../Filter.js */ "./node_modules/@pixi/core/lib/filters/Filter.js"), spriteMaskFilter$1 = __webpack_require__(/*! ./spriteMaskFilter.frag.js */ "./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.frag.js"), spriteMaskFilter = __webpack_require__(/*! ./spriteMaskFilter.vert.js */ "./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.vert.js");
class SpriteMaskFilter extends Filter.Filter {
  /** @ignore */
  constructor(vertexSrc, fragmentSrc, uniforms) {
    let sprite = null;
    typeof vertexSrc != "string" && fragmentSrc === void 0 && uniforms === void 0 && (sprite = vertexSrc, vertexSrc = void 0, fragmentSrc = void 0, uniforms = void 0), super(vertexSrc || spriteMaskFilter.default, fragmentSrc || spriteMaskFilter$1.default, uniforms), this.maskSprite = sprite, this.maskMatrix = new math.Matrix();
  }
  /**
   * Sprite mask
   * @type {PIXI.DisplayObject}
   */
  get maskSprite() {
    return this._maskSprite;
  }
  set maskSprite(value) {
    this._maskSprite = value, this._maskSprite && (this._maskSprite.renderable = !1);
  }
  /**
   * Applies the filter
   * @param filterManager - The renderer to retrieve the filter from
   * @param input - The input render target.
   * @param output - The target to output to.
   * @param clearMode - Should the output be cleared before rendering to it.
   */
  apply(filterManager, input, output, clearMode) {
    const maskSprite = this._maskSprite, tex = maskSprite._texture;
    tex.valid && (tex.uvMatrix || (tex.uvMatrix = new TextureMatrix.TextureMatrix(tex, 0)), tex.uvMatrix.update(), this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = tex, this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord), this.uniforms.alpha = maskSprite.worldAlpha, this.uniforms.maskClamp = tex.uvMatrix.uClampFrame, filterManager.applyFilter(this, input, output, clearMode));
  }
}
exports.SpriteMaskFilter = SpriteMaskFilter;
//# sourceMappingURL=SpriteMaskFilter.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.frag.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.frag.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var fragment = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`;
exports["default"] = fragment;
//# sourceMappingURL=spriteMaskFilter.frag.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.vert.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.vert.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var vertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`;
exports["default"] = vertex;
//# sourceMappingURL=spriteMaskFilter.vert.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/fragments/default.vert.js":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/fragments/default.vert.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var $defaultVertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`;
exports["default"] = $defaultVertex;
//# sourceMappingURL=default.vert.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/fragments/defaultFilter.vert.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/fragments/defaultFilter.vert.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var $defaultFilterVertex = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
exports["default"] = $defaultFilterVertex;
//# sourceMappingURL=defaultFilter.vert.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/fragments/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/fragments/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _default = __webpack_require__(/*! ./default.vert.js */ "./node_modules/@pixi/core/lib/fragments/default.vert.js"), defaultFilter = __webpack_require__(/*! ./defaultFilter.vert.js */ "./node_modules/@pixi/core/lib/fragments/defaultFilter.vert.js");
const defaultVertex = _default.default, defaultFilterVertex = defaultFilter.default;
exports.defaultFilterVertex = defaultFilterVertex;
exports.defaultVertex = defaultVertex;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/framebuffer/Framebuffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/framebuffer/Framebuffer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.js"), BaseTexture = __webpack_require__(/*! ../textures/BaseTexture.js */ "./node_modules/@pixi/core/lib/textures/BaseTexture.js");
class Framebuffer {
  /**
   * @param width - Width of the frame buffer
   * @param height - Height of the frame buffer
   */
  constructor(width, height) {
    if (this.width = Math.round(width), this.height = Math.round(height), !this.width || !this.height)
      throw new Error("Framebuffer width or height is zero");
    this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new runner.Runner("disposeFramebuffer"), this.multisample = constants.MSAA_QUALITY.NONE;
  }
  /**
   * Reference to the colorTexture.
   * @readonly
   */
  get colorTexture() {
    return this.colorTextures[0];
  }
  /**
   * Add texture to the colorTexture array.
   * @param index - Index of the array to add the texture to
   * @param texture - Texture to add to the array
   */
  addColorTexture(index = 0, texture) {
    return this.colorTextures[index] = texture || new BaseTexture.BaseTexture(null, {
      scaleMode: constants.SCALE_MODES.NEAREST,
      resolution: 1,
      mipmap: constants.MIPMAP_MODES.OFF,
      width: this.width,
      height: this.height
    }), this.dirtyId++, this.dirtyFormat++, this;
  }
  /**
   * Add a depth texture to the frame buffer.
   * @param texture - Texture to add.
   */
  addDepthTexture(texture) {
    return this.depthTexture = texture || new BaseTexture.BaseTexture(null, {
      scaleMode: constants.SCALE_MODES.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: constants.MIPMAP_MODES.OFF,
      format: constants.FORMATS.DEPTH_COMPONENT,
      type: constants.TYPES.UNSIGNED_SHORT
    }), this.dirtyId++, this.dirtyFormat++, this;
  }
  /** Enable depth on the frame buffer. */
  enableDepth() {
    return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;
  }
  /** Enable stencil on the frame buffer. */
  enableStencil() {
    return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;
  }
  /**
   * Resize the frame buffer
   * @param width - Width of the frame buffer to resize to
   * @param height - Height of the frame buffer to resize to
   */
  resize(width, height) {
    if (width = Math.round(width), height = Math.round(height), !width || !height)
      throw new Error("Framebuffer width and height must not be zero");
    if (!(width === this.width && height === this.height)) {
      this.width = width, this.height = height, this.dirtyId++, this.dirtySize++;
      for (let i = 0; i < this.colorTextures.length; i++) {
        const texture = this.colorTextures[i], resolution = texture.resolution;
        texture.setSize(width / resolution, height / resolution);
      }
      if (this.depthTexture) {
        const resolution = this.depthTexture.resolution;
        this.depthTexture.setSize(width / resolution, height / resolution);
      }
    }
  }
  /** Disposes WebGL resources that are connected to this geometry. */
  dispose() {
    this.disposeRunner.emit(this, !1);
  }
  /** Destroys and removes the depth texture added to this framebuffer. */
  destroyDepthTexture() {
    this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
  }
}
exports.Framebuffer = Framebuffer;
//# sourceMappingURL=Framebuffer.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), math = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.js"), settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js"), Framebuffer = __webpack_require__(/*! ./Framebuffer.js */ "./node_modules/@pixi/core/lib/framebuffer/Framebuffer.js"), GLFramebuffer = __webpack_require__(/*! ./GLFramebuffer.js */ "./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.js");
const tempRectangle = new math.Rectangle();
class FramebufferSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer.Framebuffer(10, 10), this.msaaSamples = null;
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    this.disposeAll(!0);
    const gl = this.gl = this.renderer.gl;
    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new math.Rectangle(), this.hasMRT = !0, this.writeDepthTexture = !0, this.renderer.context.webGLVersion === 1) {
      let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers, nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
      settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY && (nativeDrawBuffersExtension = null, nativeDepthTextureExtension = null), nativeDrawBuffersExtension ? gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures) : (this.hasMRT = !1, gl.drawBuffers = () => {
      }), nativeDepthTextureExtension || (this.writeDepthTexture = !1);
    } else
      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
  }
  /**
   * Bind a framebuffer.
   * @param framebuffer
   * @param frame - frame, default is framebuffer size
   * @param mipLevel - optional mip level to set on the framebuffer - defaults to 0
   */
  bind(framebuffer, frame, mipLevel = 0) {
    const { gl } = this;
    if (framebuffer) {
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
      this.current !== framebuffer && (this.current = framebuffer, gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer)), fbo.mipLevel !== mipLevel && (framebuffer.dirtyId++, framebuffer.dirtyFormat++, fbo.mipLevel = mipLevel), fbo.dirtyId !== framebuffer.dirtyId && (fbo.dirtyId = framebuffer.dirtyId, fbo.dirtyFormat !== framebuffer.dirtyFormat ? (fbo.dirtyFormat = framebuffer.dirtyFormat, fbo.dirtySize = framebuffer.dirtySize, this.updateFramebuffer(framebuffer, mipLevel)) : fbo.dirtySize !== framebuffer.dirtySize && (fbo.dirtySize = framebuffer.dirtySize, this.resizeFramebuffer(framebuffer)));
      for (let i = 0; i < framebuffer.colorTextures.length; i++) {
        const tex = framebuffer.colorTextures[i];
        this.renderer.texture.unbind(tex.parentTextureArray || tex);
      }
      if (framebuffer.depthTexture && this.renderer.texture.unbind(framebuffer.depthTexture), frame) {
        const mipWidth = frame.width >> mipLevel, mipHeight = frame.height >> mipLevel, scale = mipWidth / frame.width;
        this.setViewport(
          frame.x * scale,
          frame.y * scale,
          mipWidth,
          mipHeight
        );
      } else {
        const mipWidth = framebuffer.width >> mipLevel, mipHeight = framebuffer.height >> mipLevel;
        this.setViewport(0, 0, mipWidth, mipHeight);
      }
    } else
      this.current && (this.current = null, gl.bindFramebuffer(gl.FRAMEBUFFER, null)), frame ? this.setViewport(frame.x, frame.y, frame.width, frame.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
  }
  /**
   * Set the WebGLRenderingContext's viewport.
   * @param x - X position of viewport
   * @param y - Y position of viewport
   * @param width - Width of viewport
   * @param height - Height of viewport
   */
  setViewport(x, y, width, height) {
    const v = this.viewport;
    x = Math.round(x), y = Math.round(y), width = Math.round(width), height = Math.round(height), (v.width !== width || v.height !== height || v.x !== x || v.y !== y) && (v.x = x, v.y = y, v.width = width, v.height = height, this.gl.viewport(x, y, width, height));
  }
  /**
   * Get the size of the current width and height. Returns object with `width` and `height` values.
   * @readonly
   */
  get size() {
    return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
  }
  /**
   * Clear the color of the context
   * @param r - Red value from 0 to 1
   * @param g - Green value from 0 to 1
   * @param b - Blue value from 0 to 1
   * @param a - Alpha value from 0 to 1
   * @param {PIXI.BUFFER_BITS} [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks
   *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.
   */
  clear(r, g, b, a, mask = constants.BUFFER_BITS.COLOR | constants.BUFFER_BITS.DEPTH) {
    const { gl } = this;
    gl.clearColor(r, g, b, a), gl.clear(mask);
  }
  /**
   * Initialize framebuffer for this context
   * @protected
   * @param framebuffer
   * @returns - created GLFramebuffer
   */
  initFramebuffer(framebuffer) {
    const { gl } = this, fbo = new GLFramebuffer.GLFramebuffer(gl.createFramebuffer());
    return fbo.multisample = this.detectSamples(framebuffer.multisample), framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo, this.managedFramebuffers.push(framebuffer), framebuffer.disposeRunner.add(this), fbo;
  }
  /**
   * Resize the framebuffer
   * @param framebuffer
   * @protected
   */
  resizeFramebuffer(framebuffer) {
    const { gl } = this, fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (fbo.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      let stencilFormat;
      this.renderer.context.webGLVersion === 1 ? stencilFormat = gl.DEPTH_STENCIL : framebuffer.depth && framebuffer.stencil ? stencilFormat = gl.DEPTH24_STENCIL8 : framebuffer.depth ? stencilFormat = gl.DEPTH_COMPONENT24 : stencilFormat = gl.STENCIL_INDEX8, fbo.msaaBuffer ? gl.renderbufferStorageMultisample(
        gl.RENDERBUFFER,
        fbo.multisample,
        stencilFormat,
        framebuffer.width,
        framebuffer.height
      ) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, framebuffer.width, framebuffer.height);
    }
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    gl.drawBuffers || (count = Math.min(count, 1));
    for (let i = 0; i < count; i++) {
      const texture = colorTextures[i], parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0), i === 0 && fbo.msaaBuffer && (gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer), gl.renderbufferStorageMultisample(
        gl.RENDERBUFFER,
        fbo.multisample,
        parentTexture._glTextures[this.CONTEXT_UID].internalFormat,
        framebuffer.width,
        framebuffer.height
      ));
    }
    framebuffer.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(framebuffer.depthTexture, 0);
  }
  /**
   * Update the framebuffer
   * @param framebuffer
   * @param mipLevel
   * @protected
   */
  updateFramebuffer(framebuffer, mipLevel) {
    const { gl } = this, fbo = framebuffer.glFramebuffers[this.CONTEXT_UID], colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    gl.drawBuffers || (count = Math.min(count, 1)), fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer) ? fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer() : fbo.msaaBuffer && (gl.deleteRenderbuffer(fbo.msaaBuffer), fbo.msaaBuffer = null, fbo.blitFramebuffer && (fbo.blitFramebuffer.dispose(), fbo.blitFramebuffer = null));
    const activeTextures = [];
    for (let i = 0; i < count; i++) {
      const texture = colorTextures[i], parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0), i === 0 && fbo.msaaBuffer ? (gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer), gl.renderbufferStorageMultisample(
        gl.RENDERBUFFER,
        fbo.multisample,
        parentTexture._glTextures[this.CONTEXT_UID].internalFormat,
        framebuffer.width,
        framebuffer.height
      ), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer)) : (gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0 + i,
        texture.target,
        parentTexture._glTextures[this.CONTEXT_UID].texture,
        mipLevel
      ), activeTextures.push(gl.COLOR_ATTACHMENT0 + i));
    }
    if (activeTextures.length > 1 && gl.drawBuffers(activeTextures), framebuffer.depthTexture && this.writeDepthTexture) {
      const depthTexture = framebuffer.depthTexture;
      this.renderer.texture.bind(depthTexture, 0), gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.DEPTH_ATTACHMENT,
        gl.TEXTURE_2D,
        depthTexture._glTextures[this.CONTEXT_UID].texture,
        mipLevel
      );
    }
    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
      fbo.stencil = fbo.stencil || gl.createRenderbuffer();
      let stencilAttachment, stencilFormat;
      this.renderer.context.webGLVersion === 1 ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH_STENCIL) : framebuffer.depth && framebuffer.stencil ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH24_STENCIL8) : framebuffer.depth ? (stencilAttachment = gl.DEPTH_ATTACHMENT, stencilFormat = gl.DEPTH_COMPONENT24) : (stencilAttachment = gl.STENCIL_ATTACHMENT, stencilFormat = gl.STENCIL_INDEX8), gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil), fbo.msaaBuffer ? gl.renderbufferStorageMultisample(
        gl.RENDERBUFFER,
        fbo.multisample,
        stencilFormat,
        framebuffer.width,
        framebuffer.height
      ) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, framebuffer.width, framebuffer.height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, stencilAttachment, gl.RENDERBUFFER, fbo.stencil);
    } else
      fbo.stencil && (gl.deleteRenderbuffer(fbo.stencil), fbo.stencil = null);
  }
  /**
   * Returns true if the frame buffer can be multisampled.
   * @param framebuffer
   */
  canMultisampleFramebuffer(framebuffer) {
    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
  }
  /**
   * Detects number of samples that is not more than a param but as close to it as possible
   * @param samples - number of samples
   * @returns - recommended number of samples
   */
  detectSamples(samples) {
    const { msaaSamples } = this;
    let res = constants.MSAA_QUALITY.NONE;
    if (samples <= 1 || msaaSamples === null)
      return res;
    for (let i = 0; i < msaaSamples.length; i++)
      if (msaaSamples[i] <= samples) {
        res = msaaSamples[i];
        break;
      }
    return res === 1 && (res = constants.MSAA_QUALITY.NONE), res;
  }
  /**
   * Only works with WebGL2
   *
   * blits framebuffer to another of the same or bigger size
   * after that target framebuffer is bound
   *
   * Fails with WebGL warning if blits multisample framebuffer to different size
   * @param framebuffer - by default it blits "into itself", from renderBuffer to texture.
   * @param sourcePixels - source rectangle in pixels
   * @param destPixels - dest rectangle in pixels, assumed to be the same as sourcePixels
   */
  blit(framebuffer, sourcePixels, destPixels) {
    const { current, renderer, gl, CONTEXT_UID } = this;
    if (renderer.context.webGLVersion !== 2 || !current)
      return;
    const fbo = current.glFramebuffers[CONTEXT_UID];
    if (!fbo)
      return;
    if (!framebuffer) {
      if (!fbo.msaaBuffer)
        return;
      const colorTexture = current.colorTextures[0];
      if (!colorTexture)
        return;
      fbo.blitFramebuffer || (fbo.blitFramebuffer = new Framebuffer.Framebuffer(current.width, current.height), fbo.blitFramebuffer.addColorTexture(0, colorTexture)), framebuffer = fbo.blitFramebuffer, framebuffer.colorTextures[0] !== colorTexture && (framebuffer.colorTextures[0] = colorTexture, framebuffer.dirtyId++, framebuffer.dirtyFormat++), (framebuffer.width !== current.width || framebuffer.height !== current.height) && (framebuffer.width = current.width, framebuffer.height = current.height, framebuffer.dirtyId++, framebuffer.dirtySize++);
    }
    sourcePixels || (sourcePixels = tempRectangle, sourcePixels.width = current.width, sourcePixels.height = current.height), destPixels || (destPixels = sourcePixels);
    const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
    this.bind(framebuffer), gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer), gl.blitFramebuffer(
      sourcePixels.left,
      sourcePixels.top,
      sourcePixels.right,
      sourcePixels.bottom,
      destPixels.left,
      destPixels.top,
      destPixels.right,
      destPixels.bottom,
      gl.COLOR_BUFFER_BIT,
      sameSize ? gl.NEAREST : gl.LINEAR
    ), gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer);
  }
  /**
   * Disposes framebuffer.
   * @param framebuffer - framebuffer that has to be disposed of
   * @param contextLost - If context was lost, we suppress all delete function calls
   */
  disposeFramebuffer(framebuffer, contextLost) {
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID], gl = this.gl;
    if (!fbo)
      return;
    delete framebuffer.glFramebuffers[this.CONTEXT_UID];
    const index = this.managedFramebuffers.indexOf(framebuffer);
    index >= 0 && this.managedFramebuffers.splice(index, 1), framebuffer.disposeRunner.remove(this), contextLost || (gl.deleteFramebuffer(fbo.framebuffer), fbo.msaaBuffer && gl.deleteRenderbuffer(fbo.msaaBuffer), fbo.stencil && gl.deleteRenderbuffer(fbo.stencil)), fbo.blitFramebuffer && this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);
  }
  /**
   * Disposes all framebuffers, but not textures bound to them.
   * @param [contextLost=false] - If context was lost, we suppress all delete function calls
   */
  disposeAll(contextLost) {
    const list = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (let i = 0; i < list.length; i++)
      this.disposeFramebuffer(list[i], contextLost);
  }
  /**
   * Forcing creation of stencil buffer for current framebuffer, if it wasn't done before.
   * Used by MaskSystem, when its time to use stencil mask for Graphics element.
   *
   * Its an alternative for public lazy `framebuffer.enableStencil`, in case we need stencil without rebind.
   * @private
   */
  forceStencil() {
    const framebuffer = this.current;
    if (!framebuffer)
      return;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (!fbo || fbo.stencil && framebuffer.stencil)
      return;
    framebuffer.stencil = !0;
    const w = framebuffer.width, h = framebuffer.height, gl = this.gl, stencil = fbo.stencil = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
    let stencilAttachment, stencilFormat;
    this.renderer.context.webGLVersion === 1 ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH_STENCIL) : framebuffer.depth ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH24_STENCIL8) : (stencilAttachment = gl.STENCIL_ATTACHMENT, stencilFormat = gl.STENCIL_INDEX8), fbo.msaaBuffer ? gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, stencilFormat, w, h) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, w, h), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, stencilAttachment, gl.RENDERBUFFER, stencil);
  }
  /** Resets framebuffer stored state, binds screen framebuffer. Should be called before renderTexture reset(). */
  reset() {
    this.current = this.unknownFramebuffer, this.viewport = new math.Rectangle();
  }
  destroy() {
    this.renderer = null;
  }
}
FramebufferSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "framebuffer"
};
extensions.extensions.add(FramebufferSystem);
exports.FramebufferSystem = FramebufferSystem;
//# sourceMappingURL=FramebufferSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js");
class GLFramebuffer {
  constructor(framebuffer) {
    this.framebuffer = framebuffer, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = constants.MSAA_QUALITY.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
  }
}
exports.GLFramebuffer = GLFramebuffer;
//# sourceMappingURL=GLFramebuffer.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js");
class MultisampleSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  contextChange(gl) {
    let samples;
    if (this.renderer.context.webGLVersion === 1) {
      const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null), samples = gl.getParameter(gl.SAMPLES), gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    } else {
      const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null), samples = gl.getParameter(gl.SAMPLES), gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
    }
    samples >= constants.MSAA_QUALITY.HIGH ? this.multisample = constants.MSAA_QUALITY.HIGH : samples >= constants.MSAA_QUALITY.MEDIUM ? this.multisample = constants.MSAA_QUALITY.MEDIUM : samples >= constants.MSAA_QUALITY.LOW ? this.multisample = constants.MSAA_QUALITY.LOW : this.multisample = constants.MSAA_QUALITY.NONE;
  }
  destroy() {
  }
}
MultisampleSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "_multisample"
};
extensions.extensions.add(MultisampleSystem);
exports.MultisampleSystem = MultisampleSystem;
//# sourceMappingURL=MultisampleSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/Attribute.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/Attribute.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js");
class Attribute {
  /**
   * @param buffer - the id of the buffer that this attribute will look for
   * @param size - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2.
   * @param normalized - should the data be normalized.
   * @param {PIXI.TYPES} [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available
   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)
   * @param [start=0] - How far into the array to start reading values (used for interleaving data)
   * @param [instance=false] - Whether the geometry is instanced.
   * @param [divisor=1] - Divisor to use when doing instanced rendering
   */
  constructor(buffer, size = 0, normalized = !1, type = constants.TYPES.FLOAT, stride, start, instance, divisor = 1) {
    this.buffer = buffer, this.size = size, this.normalized = normalized, this.type = type, this.stride = stride, this.start = start, this.instance = instance, this.divisor = divisor;
  }
  /** Destroys the Attribute. */
  destroy() {
    this.buffer = null;
  }
  /**
   * Helper function that creates an Attribute based on the information provided
   * @param buffer - the id of the buffer that this attribute will look for
   * @param [size=0] - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
   * @param [normalized=false] - should the data be normalized.
   * @param [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available
   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)
   * @returns - A new {@link PIXI.Attribute} based on the information provided
   */
  static from(buffer, size, normalized, type, stride) {
    return new Attribute(buffer, size, normalized, type, stride);
  }
}
exports.Attribute = Attribute;
//# sourceMappingURL=Attribute.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/Buffer.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/Buffer.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.js");
let UID = 0;
class Buffer {
  /**
   * @param {PIXI.IArrayBuffer} data - the data to store in the buffer.
   * @param _static - `true` for static buffer
   * @param index - `true` for index buffer
   */
  constructor(data, _static = !0, index = !1) {
    this.data = data || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = index, this.static = _static, this.id = UID++, this.disposeRunner = new runner.Runner("disposeBuffer");
  }
  // TODO could explore flagging only a partial upload?
  /**
   * Flags this buffer as requiring an upload to the GPU.
   * @param {PIXI.IArrayBuffer|number[]} [data] - the data to update in the buffer.
   */
  update(data) {
    data instanceof Array && (data = new Float32Array(data)), this.data = data || this.data, this._updateID++;
  }
  /** Disposes WebGL resources that are connected to this geometry. */
  dispose() {
    this.disposeRunner.emit(this, !1);
  }
  /** Destroys the buffer. */
  destroy() {
    this.dispose(), this.data = null;
  }
  /**
   * Flags whether this is an index buffer.
   *
   * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make
   * the buffer of type `ARRAY_BUFFER`.
   *
   * For backwards compatibility.
   */
  set index(value) {
    this.type = value ? constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : constants.BUFFER_TYPE.ARRAY_BUFFER;
  }
  get index() {
    return this.type === constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
  }
  /**
   * Helper function that creates a buffer based on an array or TypedArray
   * @param {ArrayBufferView | number[]} data - the TypedArray that the buffer will store. If this is a regular Array it will be converted to a Float32Array.
   * @returns - A new Buffer based on the data provided.
   */
  static from(data) {
    return data instanceof Array && (data = new Float32Array(data)), new Buffer(data);
  }
}
exports.Buffer = Buffer;
//# sourceMappingURL=Buffer.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/BufferSystem.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/BufferSystem.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), GLBuffer = __webpack_require__(/*! ./GLBuffer.js */ "./node_modules/@pixi/core/lib/geometry/GLBuffer.js");
class BufferSystem {
  /**
   * @param {PIXI.Renderer} renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.managedBuffers = {}, this.boundBufferBases = {};
  }
  /**
   * @ignore
   */
  destroy() {
    this.renderer = null;
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  /**
   * This binds specified buffer. On first run, it will create the webGL buffers for the context too
   * @param buffer - the buffer to bind to the renderer
   */
  bind(buffer) {
    const { gl, CONTEXT_UID } = this, glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBuffer(buffer.type, glBuffer.buffer);
  }
  unbind(type) {
    const { gl } = this;
    gl.bindBuffer(type, null);
  }
  /**
   * Binds an uniform buffer to at the given index.
   *
   * A cache is used so a buffer will not be bound again if already bound.
   * @param buffer - the buffer to bind
   * @param index - the base index to bind it to.
   */
  bindBufferBase(buffer, index) {
    const { gl, CONTEXT_UID } = this;
    if (this.boundBufferBases[index] !== buffer) {
      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      this.boundBufferBases[index] = buffer, gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
    }
  }
  /**
   * Binds a buffer whilst also binding its range.
   * This will make the buffer start from the offset supplied rather than 0 when it is read.
   * @param buffer - the buffer to bind
   * @param index - the base index to bind at, defaults to 0
   * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
   */
  bindBufferRange(buffer, index, offset) {
    const { gl, CONTEXT_UID } = this;
    offset = offset || 0;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
  }
  /**
   * Will ensure the data in the buffer is uploaded to the GPU.
   * @param {PIXI.Buffer} buffer - the buffer to update
   */
  update(buffer) {
    const { gl, CONTEXT_UID } = this, glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    if (buffer._updateID !== glBuffer.updateID)
      if (glBuffer.updateID = buffer._updateID, gl.bindBuffer(buffer.type, glBuffer.buffer), glBuffer.byteLength >= buffer.data.byteLength)
        gl.bufferSubData(buffer.type, 0, buffer.data);
      else {
        const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
        glBuffer.byteLength = buffer.data.byteLength, gl.bufferData(buffer.type, buffer.data, drawType);
      }
  }
  /**
   * Disposes buffer
   * @param {PIXI.Buffer} buffer - buffer with data
   * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
   */
  dispose(buffer, contextLost) {
    if (!this.managedBuffers[buffer.id])
      return;
    delete this.managedBuffers[buffer.id];
    const glBuffer = buffer._glBuffers[this.CONTEXT_UID], gl = this.gl;
    buffer.disposeRunner.remove(this), glBuffer && (contextLost || gl.deleteBuffer(glBuffer.buffer), delete buffer._glBuffers[this.CONTEXT_UID]);
  }
  /**
   * dispose all WebGL resources of all managed buffers
   * @param {boolean} [contextLost=false] - If context was lost, we suppress `gl.delete` calls
   */
  disposeAll(contextLost) {
    const all = Object.keys(this.managedBuffers);
    for (let i = 0; i < all.length; i++)
      this.dispose(this.managedBuffers[all[i]], contextLost);
  }
  /**
   * creates and attaches a GLBuffer object tied to the current context.
   * @param buffer
   * @protected
   */
  createGLBuffer(buffer) {
    const { CONTEXT_UID, gl } = this;
    return buffer._glBuffers[CONTEXT_UID] = new GLBuffer.GLBuffer(gl.createBuffer()), this.managedBuffers[buffer.id] = buffer, buffer.disposeRunner.add(this), buffer._glBuffers[CONTEXT_UID];
  }
}
BufferSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "buffer"
};
extensions.extensions.add(BufferSystem);
exports.BufferSystem = BufferSystem;
//# sourceMappingURL=BufferSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/GLBuffer.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/GLBuffer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class GLBuffer {
  constructor(buffer) {
    this.buffer = buffer || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
  }
}
exports.GLBuffer = GLBuffer;
//# sourceMappingURL=GLBuffer.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/Geometry.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/Geometry.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.js"), utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js"), Attribute = __webpack_require__(/*! ./Attribute.js */ "./node_modules/@pixi/core/lib/geometry/Attribute.js"), Buffer = __webpack_require__(/*! ./Buffer.js */ "./node_modules/@pixi/core/lib/geometry/Buffer.js"), interleaveTypedArrays = __webpack_require__(/*! ./utils/interleaveTypedArrays.js */ "./node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.js");
const byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
let UID = 0;
const map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
class Geometry {
  /**
   * @param buffers - An array of buffers. optional.
   * @param attributes - Of the geometry, optional structure of the attributes layout
   */
  constructor(buffers = [], attributes = {}) {
    this.buffers = buffers, this.indexBuffer = null, this.attributes = attributes, this.glVertexArrayObjects = {}, this.id = UID++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new runner.Runner("disposeGeometry"), this.refCount = 0;
  }
  /**
   *
   * Adds an attribute to the geometry
   * Note: `stride` and `start` should be `undefined` if you dont know them, not 0!
   * @param id - the name of the attribute (matching up to a shader)
   * @param {PIXI.Buffer|number[]} buffer - the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.
   * @param size - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
   * @param normalized - should the data be normalized.
   * @param [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available
   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)
   * @param [start=0] - How far into the array to start reading values (used for interleaving data)
   * @param instance - Instancing flag
   * @returns - Returns self, useful for chaining.
   */
  addAttribute(id, buffer, size = 0, normalized = !1, type, stride, start, instance = !1) {
    if (!buffer)
      throw new Error("You must pass a buffer when creating an attribute");
    buffer instanceof Buffer.Buffer || (buffer instanceof Array && (buffer = new Float32Array(buffer)), buffer = new Buffer.Buffer(buffer));
    const ids = id.split("|");
    if (ids.length > 1) {
      for (let i = 0; i < ids.length; i++)
        this.addAttribute(ids[i], buffer, size, normalized, type);
      return this;
    }
    let bufferIndex = this.buffers.indexOf(buffer);
    return bufferIndex === -1 && (this.buffers.push(buffer), bufferIndex = this.buffers.length - 1), this.attributes[id] = new Attribute.Attribute(bufferIndex, size, normalized, type, stride, start, instance), this.instanced = this.instanced || instance, this;
  }
  /**
   * Returns the requested attribute.
   * @param id - The name of the attribute required
   * @returns - The attribute requested.
   */
  getAttribute(id) {
    return this.attributes[id];
  }
  /**
   * Returns the requested buffer.
   * @param id - The name of the buffer required.
   * @returns - The buffer requested.
   */
  getBuffer(id) {
    return this.buffers[this.getAttribute(id).buffer];
  }
  /**
   *
   * Adds an index buffer to the geometry
   * The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, …). There is only ONE index buffer.
   * @param {PIXI.Buffer|number[]} [buffer] - The buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.
   * @returns - Returns self, useful for chaining.
   */
  addIndex(buffer) {
    return buffer instanceof Buffer.Buffer || (buffer instanceof Array && (buffer = new Uint16Array(buffer)), buffer = new Buffer.Buffer(buffer)), buffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER, this.indexBuffer = buffer, this.buffers.includes(buffer) || this.buffers.push(buffer), this;
  }
  /**
   * Returns the index buffer
   * @returns - The index buffer.
   */
  getIndex() {
    return this.indexBuffer;
  }
  /**
   * This function modifies the structure so that all current attributes become interleaved into a single buffer
   * This can be useful if your model remains static as it offers a little performance boost
   * @returns - Returns self, useful for chaining.
   */
  interleave() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
      return this;
    const arrays = [], sizes = [], interleavedBuffer = new Buffer.Buffer();
    let i;
    for (i in this.attributes) {
      const attribute = this.attributes[i], buffer = this.buffers[attribute.buffer];
      arrays.push(buffer.data), sizes.push(attribute.size * byteSizeMap[attribute.type] / 4), attribute.buffer = 0;
    }
    for (interleavedBuffer.data = interleaveTypedArrays.interleaveTypedArrays(arrays, sizes), i = 0; i < this.buffers.length; i++)
      this.buffers[i] !== this.indexBuffer && this.buffers[i].destroy();
    return this.buffers = [interleavedBuffer], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
  }
  /** Get the size of the geometries, in vertices. */
  getSize() {
    for (const i in this.attributes) {
      const attribute = this.attributes[i];
      return this.buffers[attribute.buffer].data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  }
  /** Disposes WebGL resources that are connected to this geometry. */
  dispose() {
    this.disposeRunner.emit(this, !1);
  }
  /** Destroys the geometry. */
  destroy() {
    this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
  }
  /**
   * Returns a clone of the geometry.
   * @returns - A new clone of this geometry.
   */
  clone() {
    const geometry = new Geometry();
    for (let i = 0; i < this.buffers.length; i++)
      geometry.buffers[i] = new Buffer.Buffer(this.buffers[i].data.slice(0));
    for (const i in this.attributes) {
      const attrib = this.attributes[i];
      geometry.attributes[i] = new Attribute.Attribute(
        attrib.buffer,
        attrib.size,
        attrib.normalized,
        attrib.type,
        attrib.stride,
        attrib.start,
        attrib.instance
      );
    }
    return this.indexBuffer && (geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)], geometry.indexBuffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER), geometry;
  }
  /**
   * Merges an array of geometries into a new single one.
   *
   * Geometry attribute styles must match for this operation to work.
   * @param geometries - array of geometries to merge
   * @returns - Shiny new geometry!
   */
  static merge(geometries) {
    const geometryOut = new Geometry(), arrays = [], sizes = [], offsets = [];
    let geometry;
    for (let i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (let j = 0; j < geometry.buffers.length; j++)
        sizes[j] = sizes[j] || 0, sizes[j] += geometry.buffers[j].data.length, offsets[j] = 0;
    }
    for (let i = 0; i < geometry.buffers.length; i++)
      arrays[i] = new map[utils.getBufferType(geometry.buffers[i].data)](sizes[i]), geometryOut.buffers[i] = new Buffer.Buffer(arrays[i]);
    for (let i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (let j = 0; j < geometry.buffers.length; j++)
        arrays[j].set(geometry.buffers[j].data, offsets[j]), offsets[j] += geometry.buffers[j].data.length;
    }
    if (geometryOut.attributes = geometry.attributes, geometry.indexBuffer) {
      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)], geometryOut.indexBuffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      let offset = 0, stride = 0, offset2 = 0, bufferIndexToCount = 0;
      for (let i = 0; i < geometry.buffers.length; i++)
        if (geometry.buffers[i] !== geometry.indexBuffer) {
          bufferIndexToCount = i;
          break;
        }
      for (const i in geometry.attributes) {
        const attribute = geometry.attributes[i];
        (attribute.buffer | 0) === bufferIndexToCount && (stride += attribute.size * byteSizeMap[attribute.type] / 4);
      }
      for (let i = 0; i < geometries.length; i++) {
        const indexBufferData = geometries[i].indexBuffer.data;
        for (let j = 0; j < indexBufferData.length; j++)
          geometryOut.indexBuffer.data[j + offset2] += offset;
        offset += geometries[i].buffers[bufferIndexToCount].data.length / stride, offset2 += indexBufferData.length;
      }
    }
    return geometryOut;
  }
}
exports.Geometry = Geometry;
//# sourceMappingURL=Geometry.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/GeometrySystem.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/GeometrySystem.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js");
const byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
class GeometrySystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.renderer = renderer, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    this.disposeAll(!0);
    const gl = this.gl = this.renderer.gl, context = this.renderer.context;
    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, context.webGLVersion !== 2) {
      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
      settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY && (nativeVaoExtension = null), nativeVaoExtension ? (gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES(), gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao), gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao)) : (this.hasVao = !1, gl.createVertexArray = () => null, gl.bindVertexArray = () => null, gl.deleteVertexArray = () => null);
    }
    if (context.webGLVersion !== 2) {
      const instanceExt = gl.getExtension("ANGLE_instanced_arrays");
      instanceExt ? (gl.vertexAttribDivisor = (a, b) => instanceExt.vertexAttribDivisorANGLE(a, b), gl.drawElementsInstanced = (a, b, c, d, e) => instanceExt.drawElementsInstancedANGLE(a, b, c, d, e), gl.drawArraysInstanced = (a, b, c, d) => instanceExt.drawArraysInstancedANGLE(a, b, c, d)) : this.hasInstance = !1;
    }
    this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;
  }
  /**
   * Binds geometry so that is can be drawn. Creating a Vao if required
   * @param geometry - Instance of geometry to bind.
   * @param shader - Instance of shader to use vao for.
   */
  bind(geometry, shader) {
    shader = shader || this.renderer.shader.shader;
    const { gl } = this;
    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID], incRefCount = !1;
    vaos || (this.managedGeometries[geometry.id] = geometry, geometry.disposeRunner.add(this), geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {}, incRefCount = !0);
    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
    this._activeGeometry = geometry, this._activeVao !== vao && (this._activeVao = vao, this.hasVao ? gl.bindVertexArray(vao) : this.activateVao(geometry, shader.program)), this.updateBuffers();
  }
  /** Reset and unbind any active VAO and geometry. */
  reset() {
    this.unbind();
  }
  /** Update buffers of the currently bound geometry. */
  updateBuffers() {
    const geometry = this._activeGeometry, bufferSystem = this.renderer.buffer;
    for (let i = 0; i < geometry.buffers.length; i++) {
      const buffer = geometry.buffers[i];
      bufferSystem.update(buffer);
    }
  }
  /**
   * Check compatibility between a geometry and a program
   * @param geometry - Geometry instance.
   * @param program - Program instance.
   */
  checkCompatibility(geometry, program) {
    const geometryAttributes = geometry.attributes, shaderAttributes = program.attributeData;
    for (const j in shaderAttributes)
      if (!geometryAttributes[j])
        throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);
  }
  /**
   * Takes a geometry and program and generates a unique signature for them.
   * @param geometry - To get signature from.
   * @param program - To test geometry against.
   * @returns - Unique signature of the geometry and program
   */
  getSignature(geometry, program) {
    const attribs = geometry.attributes, shaderAttributes = program.attributeData, strings = ["g", geometry.id];
    for (const i in attribs)
      shaderAttributes[i] && strings.push(i, shaderAttributes[i].location);
    return strings.join("-");
  }
  /**
   * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
   * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
   * attribute locations.
   * @param geometry - Instance of geometry to to generate Vao for.
   * @param shader - Instance of the shader.
   * @param incRefCount - Increment refCount of all geometry buffers.
   */
  initGeometryVao(geometry, shader, incRefCount = !0) {
    const gl = this.gl, CONTEXT_UID = this.CONTEXT_UID, bufferSystem = this.renderer.buffer, program = shader.program;
    program.glPrograms[CONTEXT_UID] || this.renderer.shader.generateProgram(shader), this.checkCompatibility(geometry, program);
    const signature = this.getSignature(geometry, program), vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let vao = vaoObjectHash[signature];
    if (vao)
      return vaoObjectHash[program.id] = vao, vao;
    const buffers = geometry.buffers, attributes = geometry.attributes, tempStride = {}, tempStart = {};
    for (const j in buffers)
      tempStride[j] = 0, tempStart[j] = 0;
    for (const j in attributes)
      !attributes[j].size && program.attributeData[j] ? attributes[j].size = program.attributeData[j].size : attributes[j].size || console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`), tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];
    for (const j in attributes) {
      const attribute = attributes[j], attribSize = attribute.size;
      attribute.stride === void 0 && (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type] ? attribute.stride = 0 : attribute.stride = tempStride[attribute.buffer]), attribute.start === void 0 && (attribute.start = tempStart[attribute.buffer], tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type]);
    }
    vao = gl.createVertexArray(), gl.bindVertexArray(vao);
    for (let i = 0; i < buffers.length; i++) {
      const buffer = buffers[i];
      bufferSystem.bind(buffer), incRefCount && buffer._glBuffers[CONTEXT_UID].refCount++;
    }
    return this.activateVao(geometry, program), vaoObjectHash[program.id] = vao, vaoObjectHash[signature] = vao, gl.bindVertexArray(null), bufferSystem.unbind(constants.BUFFER_TYPE.ARRAY_BUFFER), vao;
  }
  /**
   * Disposes geometry.
   * @param geometry - Geometry with buffers. Only VAO will be disposed
   * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
   */
  disposeGeometry(geometry, contextLost) {
    if (!this.managedGeometries[geometry.id])
      return;
    delete this.managedGeometries[geometry.id];
    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID], gl = this.gl, buffers = geometry.buffers, bufferSystem = this.renderer?.buffer;
    if (geometry.disposeRunner.remove(this), !!vaos) {
      if (bufferSystem)
        for (let i = 0; i < buffers.length; i++) {
          const buf = buffers[i]._glBuffers[this.CONTEXT_UID];
          buf && (buf.refCount--, buf.refCount === 0 && !contextLost && bufferSystem.dispose(buffers[i], contextLost));
        }
      if (!contextLost) {
        for (const vaoId in vaos)
          if (vaoId[0] === "g") {
            const vao = vaos[vaoId];
            this._activeVao === vao && this.unbind(), gl.deleteVertexArray(vao);
          }
      }
      delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
    }
  }
  /**
   * Dispose all WebGL resources of all managed geometries.
   * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
   */
  disposeAll(contextLost) {
    const all = Object.keys(this.managedGeometries);
    for (let i = 0; i < all.length; i++)
      this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
  }
  /**
   * Activate vertex array object.
   * @param geometry - Geometry instance.
   * @param program - Shader program instance.
   */
  activateVao(geometry, program) {
    const gl = this.gl, CONTEXT_UID = this.CONTEXT_UID, bufferSystem = this.renderer.buffer, buffers = geometry.buffers, attributes = geometry.attributes;
    geometry.indexBuffer && bufferSystem.bind(geometry.indexBuffer);
    let lastBuffer = null;
    for (const j in attributes) {
      const attribute = attributes[j], buffer = buffers[attribute.buffer], glBuffer = buffer._glBuffers[CONTEXT_UID];
      if (program.attributeData[j]) {
        lastBuffer !== glBuffer && (bufferSystem.bind(buffer), lastBuffer = glBuffer);
        const location = program.attributeData[j].location;
        if (gl.enableVertexAttribArray(location), gl.vertexAttribPointer(
          location,
          attribute.size,
          attribute.type || gl.FLOAT,
          attribute.normalized,
          attribute.stride,
          attribute.start
        ), attribute.instance)
          if (this.hasInstance)
            gl.vertexAttribDivisor(location, attribute.divisor);
          else
            throw new Error("geometry error, GPU Instancing is not supported on this device");
      }
    }
  }
  /**
   * Draws the currently bound geometry.
   * @param type - The type primitive to render.
   * @param size - The number of elements to be rendered. If not specified, all vertices after the
   *  starting vertex will be drawn.
   * @param start - The starting vertex in the geometry to start drawing from. If not specified,
   *  drawing will start from the first vertex.
   * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
   *  all instances will be drawn.
   */
  draw(type, size, start, instanceCount) {
    const { gl } = this, geometry = this._activeGeometry;
    if (geometry.indexBuffer) {
      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT, glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex ? geometry.instanced ? gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1) : gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize) : console.warn("unsupported index buffer type: uint32");
    } else
      geometry.instanced ? gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1) : gl.drawArrays(type, start, size || geometry.getSize());
    return this;
  }
  /** Unbind/reset everything. */
  unbind() {
    this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
  }
  destroy() {
    this.renderer = null;
  }
}
GeometrySystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "geometry"
};
extensions.extensions.add(GeometrySystem);
exports.GeometrySystem = GeometrySystem;
//# sourceMappingURL=GeometrySystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/ViewableBuffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/ViewableBuffer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class ViewableBuffer {
  constructor(sizeOrBuffer) {
    typeof sizeOrBuffer == "number" ? this.rawBinaryData = new ArrayBuffer(sizeOrBuffer) : sizeOrBuffer instanceof Uint8Array ? this.rawBinaryData = sizeOrBuffer.buffer : this.rawBinaryData = sizeOrBuffer, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
  }
  /** View on the raw binary data as a `Int8Array`. */
  get int8View() {
    return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
  }
  /** View on the raw binary data as a `Uint8Array`. */
  get uint8View() {
    return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
  }
  /**  View on the raw binary data as a `Int16Array`. */
  get int16View() {
    return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
  }
  /** View on the raw binary data as a `Uint16Array`. */
  get uint16View() {
    return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
  }
  /** View on the raw binary data as a `Int32Array`. */
  get int32View() {
    return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
  }
  /**
   * Returns the view of the given type.
   * @param type - One of `int8`, `uint8`, `int16`,
   *    `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - typed array of given type
   */
  view(type) {
    return this[`${type}View`];
  }
  /** Destroys all buffer references. Do not use after calling this. */
  destroy() {
    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
  }
  static sizeOf(type) {
    switch (type) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${type} isn't a valid view type`);
    }
  }
}
exports.ViewableBuffer = ViewableBuffer;
//# sourceMappingURL=ViewableBuffer.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js");
const map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(arrays, sizes) {
  let outSize = 0, stride = 0;
  const views = {};
  for (let i = 0; i < arrays.length; i++)
    stride += sizes[i], outSize += arrays[i].length;
  const buffer = new ArrayBuffer(outSize * 4);
  let out = null, littleOffset = 0;
  for (let i = 0; i < arrays.length; i++) {
    const size = sizes[i], array = arrays[i], type = utils.getBufferType(array);
    views[type] || (views[type] = new map[type](buffer)), out = views[type];
    for (let j = 0; j < array.length; j++) {
      const indexStart = (j / size | 0) * stride + littleOffset, index = j % size;
      out[indexStart + index] = array[j];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}
exports.interleaveTypedArrays = interleaveTypedArrays;
//# sourceMappingURL=interleaveTypedArrays.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/core/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ./settings.js */ "./node_modules/@pixi/core/lib/settings.js");
var color = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.js"), constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), math = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.js"), runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.js"), settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js"), ticker = __webpack_require__(/*! @pixi/ticker */ "./node_modules/@pixi/ticker/lib/index.js"), utils$1 = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js"), autoDetectRenderer = __webpack_require__(/*! ./autoDetectRenderer.js */ "./node_modules/@pixi/core/lib/autoDetectRenderer.js"), BackgroundSystem = __webpack_require__(/*! ./background/BackgroundSystem.js */ "./node_modules/@pixi/core/lib/background/BackgroundSystem.js"), BatchDrawCall = __webpack_require__(/*! ./batch/BatchDrawCall.js */ "./node_modules/@pixi/core/lib/batch/BatchDrawCall.js"), BatchGeometry = __webpack_require__(/*! ./batch/BatchGeometry.js */ "./node_modules/@pixi/core/lib/batch/BatchGeometry.js"), BatchRenderer = __webpack_require__(/*! ./batch/BatchRenderer.js */ "./node_modules/@pixi/core/lib/batch/BatchRenderer.js"), BatchShaderGenerator = __webpack_require__(/*! ./batch/BatchShaderGenerator.js */ "./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.js"), BatchSystem = __webpack_require__(/*! ./batch/BatchSystem.js */ "./node_modules/@pixi/core/lib/batch/BatchSystem.js"), BatchTextureArray = __webpack_require__(/*! ./batch/BatchTextureArray.js */ "./node_modules/@pixi/core/lib/batch/BatchTextureArray.js"), ObjectRenderer = __webpack_require__(/*! ./batch/ObjectRenderer.js */ "./node_modules/@pixi/core/lib/batch/ObjectRenderer.js"), ContextSystem = __webpack_require__(/*! ./context/ContextSystem.js */ "./node_modules/@pixi/core/lib/context/ContextSystem.js"), Filter = __webpack_require__(/*! ./filters/Filter.js */ "./node_modules/@pixi/core/lib/filters/Filter.js"), FilterState = __webpack_require__(/*! ./filters/FilterState.js */ "./node_modules/@pixi/core/lib/filters/FilterState.js"), FilterSystem = __webpack_require__(/*! ./filters/FilterSystem.js */ "./node_modules/@pixi/core/lib/filters/FilterSystem.js");
__webpack_require__(/*! ./filters/IFilterTarget.js */ "./node_modules/@pixi/core/lib/filters/IFilterTarget.js");
var SpriteMaskFilter = __webpack_require__(/*! ./filters/spriteMask/SpriteMaskFilter.js */ "./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.js"), index = __webpack_require__(/*! ./fragments/index.js */ "./node_modules/@pixi/core/lib/fragments/index.js"), Framebuffer = __webpack_require__(/*! ./framebuffer/Framebuffer.js */ "./node_modules/@pixi/core/lib/framebuffer/Framebuffer.js"), FramebufferSystem = __webpack_require__(/*! ./framebuffer/FramebufferSystem.js */ "./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.js"), GLFramebuffer = __webpack_require__(/*! ./framebuffer/GLFramebuffer.js */ "./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.js"), MultisampleSystem = __webpack_require__(/*! ./framebuffer/MultisampleSystem.js */ "./node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.js"), Attribute = __webpack_require__(/*! ./geometry/Attribute.js */ "./node_modules/@pixi/core/lib/geometry/Attribute.js"), Buffer = __webpack_require__(/*! ./geometry/Buffer.js */ "./node_modules/@pixi/core/lib/geometry/Buffer.js"), BufferSystem = __webpack_require__(/*! ./geometry/BufferSystem.js */ "./node_modules/@pixi/core/lib/geometry/BufferSystem.js"), Geometry = __webpack_require__(/*! ./geometry/Geometry.js */ "./node_modules/@pixi/core/lib/geometry/Geometry.js"), GeometrySystem = __webpack_require__(/*! ./geometry/GeometrySystem.js */ "./node_modules/@pixi/core/lib/geometry/GeometrySystem.js"), ViewableBuffer = __webpack_require__(/*! ./geometry/ViewableBuffer.js */ "./node_modules/@pixi/core/lib/geometry/ViewableBuffer.js");
__webpack_require__(/*! ./IRenderer.js */ "./node_modules/@pixi/core/lib/IRenderer.js");
var MaskData = __webpack_require__(/*! ./mask/MaskData.js */ "./node_modules/@pixi/core/lib/mask/MaskData.js"), MaskSystem = __webpack_require__(/*! ./mask/MaskSystem.js */ "./node_modules/@pixi/core/lib/mask/MaskSystem.js"), ScissorSystem = __webpack_require__(/*! ./mask/ScissorSystem.js */ "./node_modules/@pixi/core/lib/mask/ScissorSystem.js"), StencilSystem = __webpack_require__(/*! ./mask/StencilSystem.js */ "./node_modules/@pixi/core/lib/mask/StencilSystem.js"), PluginSystem = __webpack_require__(/*! ./plugin/PluginSystem.js */ "./node_modules/@pixi/core/lib/plugin/PluginSystem.js"), ProjectionSystem = __webpack_require__(/*! ./projection/ProjectionSystem.js */ "./node_modules/@pixi/core/lib/projection/ProjectionSystem.js"), ObjectRendererSystem = __webpack_require__(/*! ./render/ObjectRendererSystem.js */ "./node_modules/@pixi/core/lib/render/ObjectRendererSystem.js"), Renderer = __webpack_require__(/*! ./Renderer.js */ "./node_modules/@pixi/core/lib/Renderer.js"), BaseRenderTexture = __webpack_require__(/*! ./renderTexture/BaseRenderTexture.js */ "./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js"), GenerateTextureSystem = __webpack_require__(/*! ./renderTexture/GenerateTextureSystem.js */ "./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.js"), RenderTexture = __webpack_require__(/*! ./renderTexture/RenderTexture.js */ "./node_modules/@pixi/core/lib/renderTexture/RenderTexture.js"), RenderTexturePool = __webpack_require__(/*! ./renderTexture/RenderTexturePool.js */ "./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.js"), RenderTextureSystem = __webpack_require__(/*! ./renderTexture/RenderTextureSystem.js */ "./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.js"), GLProgram = __webpack_require__(/*! ./shader/GLProgram.js */ "./node_modules/@pixi/core/lib/shader/GLProgram.js"), Program = __webpack_require__(/*! ./shader/Program.js */ "./node_modules/@pixi/core/lib/shader/Program.js"), Shader = __webpack_require__(/*! ./shader/Shader.js */ "./node_modules/@pixi/core/lib/shader/Shader.js"), ShaderSystem = __webpack_require__(/*! ./shader/ShaderSystem.js */ "./node_modules/@pixi/core/lib/shader/ShaderSystem.js"), UniformGroup = __webpack_require__(/*! ./shader/UniformGroup.js */ "./node_modules/@pixi/core/lib/shader/UniformGroup.js"), checkMaxIfStatementsInShader = __webpack_require__(/*! ./shader/utils/checkMaxIfStatementsInShader.js */ "./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js"), generateProgram = __webpack_require__(/*! ./shader/utils/generateProgram.js */ "./node_modules/@pixi/core/lib/shader/utils/generateProgram.js"), generateUniformBufferSync = __webpack_require__(/*! ./shader/utils/generateUniformBufferSync.js */ "./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.js"), getTestContext = __webpack_require__(/*! ./shader/utils/getTestContext.js */ "./node_modules/@pixi/core/lib/shader/utils/getTestContext.js"), uniformParsers = __webpack_require__(/*! ./shader/utils/uniformParsers.js */ "./node_modules/@pixi/core/lib/shader/utils/uniformParsers.js"), unsafeEvalSupported = __webpack_require__(/*! ./shader/utils/unsafeEvalSupported.js */ "./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js"), StartupSystem = __webpack_require__(/*! ./startup/StartupSystem.js */ "./node_modules/@pixi/core/lib/startup/StartupSystem.js"), State = __webpack_require__(/*! ./state/State.js */ "./node_modules/@pixi/core/lib/state/State.js"), StateSystem = __webpack_require__(/*! ./state/StateSystem.js */ "./node_modules/@pixi/core/lib/state/StateSystem.js");
__webpack_require__(/*! ./system/ISystem.js */ "./node_modules/@pixi/core/lib/system/ISystem.js");
__webpack_require__(/*! ./systems.js */ "./node_modules/@pixi/core/lib/systems.js");
var BaseTexture = __webpack_require__(/*! ./textures/BaseTexture.js */ "./node_modules/@pixi/core/lib/textures/BaseTexture.js"), GLTexture = __webpack_require__(/*! ./textures/GLTexture.js */ "./node_modules/@pixi/core/lib/textures/GLTexture.js");
__webpack_require__(/*! ./textures/resources/index.js */ "./node_modules/@pixi/core/lib/textures/resources/index.js");
var Texture = __webpack_require__(/*! ./textures/Texture.js */ "./node_modules/@pixi/core/lib/textures/Texture.js"), TextureGCSystem = __webpack_require__(/*! ./textures/TextureGCSystem.js */ "./node_modules/@pixi/core/lib/textures/TextureGCSystem.js"), TextureMatrix = __webpack_require__(/*! ./textures/TextureMatrix.js */ "./node_modules/@pixi/core/lib/textures/TextureMatrix.js"), TextureSystem = __webpack_require__(/*! ./textures/TextureSystem.js */ "./node_modules/@pixi/core/lib/textures/TextureSystem.js"), TextureUvs = __webpack_require__(/*! ./textures/TextureUvs.js */ "./node_modules/@pixi/core/lib/textures/TextureUvs.js"), TransformFeedback = __webpack_require__(/*! ./transformFeedback/TransformFeedback.js */ "./node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.js"), TransformFeedbackSystem = __webpack_require__(/*! ./transformFeedback/TransformFeedbackSystem.js */ "./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.js"), Quad = __webpack_require__(/*! ./utils/Quad.js */ "./node_modules/@pixi/core/lib/utils/Quad.js"), QuadUv = __webpack_require__(/*! ./utils/QuadUv.js */ "./node_modules/@pixi/core/lib/utils/QuadUv.js"), ViewSystem = __webpack_require__(/*! ./view/ViewSystem.js */ "./node_modules/@pixi/core/lib/view/ViewSystem.js"), SystemManager = __webpack_require__(/*! ./system/SystemManager.js */ "./node_modules/@pixi/core/lib/system/SystemManager.js"), BaseImageResource = __webpack_require__(/*! ./textures/resources/BaseImageResource.js */ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js"), Resource = __webpack_require__(/*! ./textures/resources/Resource.js */ "./node_modules/@pixi/core/lib/textures/resources/Resource.js"), AbstractMultiResource = __webpack_require__(/*! ./textures/resources/AbstractMultiResource.js */ "./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js"), ArrayResource = __webpack_require__(/*! ./textures/resources/ArrayResource.js */ "./node_modules/@pixi/core/lib/textures/resources/ArrayResource.js"), autoDetectResource = __webpack_require__(/*! ./textures/resources/autoDetectResource.js */ "./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js"), BufferResource = __webpack_require__(/*! ./textures/resources/BufferResource.js */ "./node_modules/@pixi/core/lib/textures/resources/BufferResource.js"), CanvasResource = __webpack_require__(/*! ./textures/resources/CanvasResource.js */ "./node_modules/@pixi/core/lib/textures/resources/CanvasResource.js"), CubeResource = __webpack_require__(/*! ./textures/resources/CubeResource.js */ "./node_modules/@pixi/core/lib/textures/resources/CubeResource.js"), ImageBitmapResource = __webpack_require__(/*! ./textures/resources/ImageBitmapResource.js */ "./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.js"), ImageResource = __webpack_require__(/*! ./textures/resources/ImageResource.js */ "./node_modules/@pixi/core/lib/textures/resources/ImageResource.js"), SVGResource = __webpack_require__(/*! ./textures/resources/SVGResource.js */ "./node_modules/@pixi/core/lib/textures/resources/SVGResource.js"), VideoResource = __webpack_require__(/*! ./textures/resources/VideoResource.js */ "./node_modules/@pixi/core/lib/textures/resources/VideoResource.js");
function _interopNamespaceDefault(e) {
  var n = /* @__PURE__ */ Object.create(null);
  return e && Object.keys(e).forEach(function(k) {
    if (k !== "default") {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: !0,
        get: function() {
          return e[k];
        }
      });
    }
  }), n.default = e, n;
}
var utils__namespace = /* @__PURE__ */ _interopNamespaceDefault(utils$1);
const VERSION = "7.3.2";
exports.utils = utils__namespace;
exports.autoDetectRenderer = autoDetectRenderer.autoDetectRenderer;
exports.BackgroundSystem = BackgroundSystem.BackgroundSystem;
exports.BatchDrawCall = BatchDrawCall.BatchDrawCall;
exports.BatchGeometry = BatchGeometry.BatchGeometry;
exports.BatchRenderer = BatchRenderer.BatchRenderer;
exports.BatchShaderGenerator = BatchShaderGenerator.BatchShaderGenerator;
exports.BatchSystem = BatchSystem.BatchSystem;
exports.BatchTextureArray = BatchTextureArray.BatchTextureArray;
exports.ObjectRenderer = ObjectRenderer.ObjectRenderer;
exports.ContextSystem = ContextSystem.ContextSystem;
exports.Filter = Filter.Filter;
exports.FilterState = FilterState.FilterState;
exports.FilterSystem = FilterSystem.FilterSystem;
exports.SpriteMaskFilter = SpriteMaskFilter.SpriteMaskFilter;
exports.defaultFilterVertex = index.defaultFilterVertex;
exports.defaultVertex = index.defaultVertex;
exports.Framebuffer = Framebuffer.Framebuffer;
exports.FramebufferSystem = FramebufferSystem.FramebufferSystem;
exports.GLFramebuffer = GLFramebuffer.GLFramebuffer;
exports.MultisampleSystem = MultisampleSystem.MultisampleSystem;
exports.Attribute = Attribute.Attribute;
exports.Buffer = Buffer.Buffer;
exports.BufferSystem = BufferSystem.BufferSystem;
exports.Geometry = Geometry.Geometry;
exports.GeometrySystem = GeometrySystem.GeometrySystem;
exports.ViewableBuffer = ViewableBuffer.ViewableBuffer;
exports.MaskData = MaskData.MaskData;
exports.MaskSystem = MaskSystem.MaskSystem;
exports.ScissorSystem = ScissorSystem.ScissorSystem;
exports.StencilSystem = StencilSystem.StencilSystem;
exports.PluginSystem = PluginSystem.PluginSystem;
exports.ProjectionSystem = ProjectionSystem.ProjectionSystem;
exports.ObjectRendererSystem = ObjectRendererSystem.ObjectRendererSystem;
exports.Renderer = Renderer.Renderer;
exports.BaseRenderTexture = BaseRenderTexture.BaseRenderTexture;
exports.GenerateTextureSystem = GenerateTextureSystem.GenerateTextureSystem;
exports.RenderTexture = RenderTexture.RenderTexture;
exports.RenderTexturePool = RenderTexturePool.RenderTexturePool;
exports.RenderTextureSystem = RenderTextureSystem.RenderTextureSystem;
exports.GLProgram = GLProgram.GLProgram;
exports.IGLUniformData = GLProgram.IGLUniformData;
exports.Program = Program.Program;
exports.Shader = Shader.Shader;
exports.ShaderSystem = ShaderSystem.ShaderSystem;
exports.UniformGroup = UniformGroup.UniformGroup;
exports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader;
exports.generateProgram = generateProgram.generateProgram;
exports.createUBOElements = generateUniformBufferSync.createUBOElements;
exports.generateUniformBufferSync = generateUniformBufferSync.generateUniformBufferSync;
exports.getUBOData = generateUniformBufferSync.getUBOData;
exports.getTestContext = getTestContext.getTestContext;
exports.uniformParsers = uniformParsers.uniformParsers;
exports.unsafeEvalSupported = unsafeEvalSupported.unsafeEvalSupported;
exports.StartupSystem = StartupSystem.StartupSystem;
exports.State = State.State;
exports.StateSystem = StateSystem.StateSystem;
exports.BaseTexture = BaseTexture.BaseTexture;
exports.GLTexture = GLTexture.GLTexture;
exports.Texture = Texture.Texture;
exports.TextureGCSystem = TextureGCSystem.TextureGCSystem;
exports.TextureMatrix = TextureMatrix.TextureMatrix;
exports.TextureSystem = TextureSystem.TextureSystem;
exports.TextureUvs = TextureUvs.TextureUvs;
exports.TransformFeedback = TransformFeedback.TransformFeedback;
exports.TransformFeedbackSystem = TransformFeedbackSystem.TransformFeedbackSystem;
exports.Quad = Quad.Quad;
exports.QuadUv = QuadUv.QuadUv;
exports.ViewSystem = ViewSystem.ViewSystem;
exports.SystemManager = SystemManager.SystemManager;
exports.BaseImageResource = BaseImageResource.BaseImageResource;
exports.Resource = Resource.Resource;
exports.AbstractMultiResource = AbstractMultiResource.AbstractMultiResource;
exports.ArrayResource = ArrayResource.ArrayResource;
exports.INSTALLED = autoDetectResource.INSTALLED;
exports.autoDetectResource = autoDetectResource.autoDetectResource;
exports.BufferResource = BufferResource.BufferResource;
exports.CanvasResource = CanvasResource.CanvasResource;
exports.CubeResource = CubeResource.CubeResource;
exports.ImageBitmapResource = ImageBitmapResource.ImageBitmapResource;
exports.ImageResource = ImageResource.ImageResource;
exports.SVGResource = SVGResource.SVGResource;
exports.VideoResource = VideoResource.VideoResource;
exports.VERSION = VERSION;
Object.keys(color).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return color[k];
    }
  });
});
Object.keys(constants).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return constants[k];
    }
  });
});
Object.keys(extensions).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return extensions[k];
    }
  });
});
Object.keys(math).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return math[k];
    }
  });
});
Object.keys(runner).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return runner[k];
    }
  });
});
Object.keys(settings).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return settings[k];
    }
  });
});
Object.keys(ticker).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return ticker[k];
    }
  });
});
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class AbstractMaskSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.maskStack = [], this.glConst = 0;
  }
  /** Gets count of masks of certain type. */
  getStackLength() {
    return this.maskStack.length;
  }
  /**
   * Changes the mask stack that is used by this System.
   * @param {PIXI.MaskData[]} maskStack - The mask stack
   */
  setMaskStack(maskStack) {
    const { gl } = this.renderer, curStackLen = this.getStackLength();
    this.maskStack = maskStack;
    const newStackLen = this.getStackLength();
    newStackLen !== curStackLen && (newStackLen === 0 ? gl.disable(this.glConst) : (gl.enable(this.glConst), this._useCurrent()));
  }
  /**
   * Setup renderer to use the current mask data.
   * @private
   */
  _useCurrent() {
  }
  /** Destroys the mask stack. */
  destroy() {
    this.renderer = null, this.maskStack = null;
  }
}
exports.AbstractMaskSystem = AbstractMaskSystem;
//# sourceMappingURL=AbstractMaskSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/mask/MaskData.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/core/lib/mask/MaskData.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), Filter = __webpack_require__(/*! ../filters/Filter.js */ "./node_modules/@pixi/core/lib/filters/Filter.js");
class MaskData {
  /**
   * Create MaskData
   * @param {PIXI.DisplayObject} [maskObject=null] - object that describes the mask
   */
  constructor(maskObject = null) {
    this.type = constants.MASK_TYPES.NONE, this.autoDetect = !0, this.maskObject = maskObject || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = Filter.Filter.defaultMultisample, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;
  }
  /**
   * The sprite mask filter.
   * If set to `null`, the default sprite mask filter is used.
   * @default null
   */
  get filter() {
    return this._filters ? this._filters[0] : null;
  }
  set filter(value) {
    value ? this._filters ? this._filters[0] = value : this._filters = [value] : this._filters = null;
  }
  /** Resets the mask data after popMask(). */
  reset() {
    this.pooled && (this.maskObject = null, this.type = constants.MASK_TYPES.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;
  }
  /**
   * Copies counters from maskData above, called from pushMask().
   * @param maskAbove
   */
  copyCountersOrReset(maskAbove) {
    maskAbove ? (this._stencilCounter = maskAbove._stencilCounter, this._scissorCounter = maskAbove._scissorCounter, this._scissorRect = maskAbove._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
  }
}
exports.MaskData = MaskData;
//# sourceMappingURL=MaskData.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/mask/MaskSystem.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/mask/MaskSystem.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), SpriteMaskFilter = __webpack_require__(/*! ../filters/spriteMask/SpriteMaskFilter.js */ "./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.js"), MaskData = __webpack_require__(/*! ./MaskData.js */ "./node_modules/@pixi/core/lib/mask/MaskData.js");
class MaskSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
  }
  /**
   * Changes the mask stack that is used by this System.
   * @param maskStack - The mask stack
   */
  setMaskStack(maskStack) {
    this.maskStack = maskStack, this.renderer.scissor.setMaskStack(maskStack), this.renderer.stencil.setMaskStack(maskStack);
  }
  /**
   * Enables the mask and appends it to the current mask stack.
   *
   * NOTE: The batch renderer should be flushed beforehand to prevent pending renders from being masked.
   * @param {PIXI.DisplayObject} target - Display Object to push the mask to
   * @param {PIXI.MaskData|PIXI.Sprite|PIXI.Graphics|PIXI.DisplayObject} maskDataOrTarget - The masking data.
   */
  push(target, maskDataOrTarget) {
    let maskData = maskDataOrTarget;
    if (!maskData.isMaskData) {
      const d = this.maskDataPool.pop() || new MaskData.MaskData();
      d.pooled = !0, d.maskObject = maskDataOrTarget, maskData = d;
    }
    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    if (maskData.copyCountersOrReset(maskAbove), maskData._colorMask = maskAbove ? maskAbove._colorMask : 15, maskData.autoDetect && this.detect(maskData), maskData._target = target, maskData.type !== constants.MASK_TYPES.SPRITE && this.maskStack.push(maskData), maskData.enabled)
      switch (maskData.type) {
        case constants.MASK_TYPES.SCISSOR:
          this.renderer.scissor.push(maskData);
          break;
        case constants.MASK_TYPES.STENCIL:
          this.renderer.stencil.push(maskData);
          break;
        case constants.MASK_TYPES.SPRITE:
          maskData.copyCountersOrReset(null), this.pushSpriteMask(maskData);
          break;
        case constants.MASK_TYPES.COLOR:
          this.pushColorMask(maskData);
          break;
        default:
          break;
      }
    maskData.type === constants.MASK_TYPES.SPRITE && this.maskStack.push(maskData);
  }
  /**
   * Removes the last mask from the mask stack and doesn't return it.
   *
   * NOTE: The batch renderer should be flushed beforehand to render the masked contents before the mask is removed.
   * @param {PIXI.IMaskTarget} target - Display Object to pop the mask from
   */
  pop(target) {
    const maskData = this.maskStack.pop();
    if (!(!maskData || maskData._target !== target)) {
      if (maskData.enabled)
        switch (maskData.type) {
          case constants.MASK_TYPES.SCISSOR:
            this.renderer.scissor.pop(maskData);
            break;
          case constants.MASK_TYPES.STENCIL:
            this.renderer.stencil.pop(maskData.maskObject);
            break;
          case constants.MASK_TYPES.SPRITE:
            this.popSpriteMask(maskData);
            break;
          case constants.MASK_TYPES.COLOR:
            this.popColorMask(maskData);
            break;
          default:
            break;
        }
      if (maskData.reset(), maskData.pooled && this.maskDataPool.push(maskData), this.maskStack.length !== 0) {
        const maskCurrent = this.maskStack[this.maskStack.length - 1];
        maskCurrent.type === constants.MASK_TYPES.SPRITE && maskCurrent._filters && (maskCurrent._filters[0].maskSprite = maskCurrent.maskObject);
      }
    }
  }
  /**
   * Sets type of MaskData based on its maskObject.
   * @param maskData
   */
  detect(maskData) {
    const maskObject = maskData.maskObject;
    maskObject ? maskObject.isSprite ? maskData.type = constants.MASK_TYPES.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(maskData) ? maskData.type = constants.MASK_TYPES.SCISSOR : maskData.type = constants.MASK_TYPES.STENCIL : maskData.type = constants.MASK_TYPES.COLOR;
  }
  /**
   * Applies the Mask and adds it to the current filter stack.
   * @param maskData - Sprite to be used as the mask.
   */
  pushSpriteMask(maskData) {
    const { maskObject } = maskData, target = maskData._target;
    let alphaMaskFilter = maskData._filters;
    alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex], alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter.SpriteMaskFilter()])), alphaMaskFilter[0].resolution = maskData.resolution, alphaMaskFilter[0].multisample = maskData.multisample, alphaMaskFilter[0].maskSprite = maskObject;
    const stashFilterArea = target.filterArea;
    target.filterArea = maskObject.getBounds(!0), this.renderer.filter.push(target, alphaMaskFilter), target.filterArea = stashFilterArea, maskData._filters || this.alphaMaskIndex++;
  }
  /**
   * Removes the last filter from the filter stack and doesn't return it.
   * @param maskData - Sprite to be used as the mask.
   */
  popSpriteMask(maskData) {
    this.renderer.filter.pop(), maskData._filters ? maskData._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
  }
  /**
   * Pushes the color mask.
   * @param maskData - The mask data
   */
  pushColorMask(maskData) {
    const currColorMask = maskData._colorMask, nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
    nextColorMask !== currColorMask && this.renderer.gl.colorMask(
      (nextColorMask & 1) !== 0,
      (nextColorMask & 2) !== 0,
      (nextColorMask & 4) !== 0,
      (nextColorMask & 8) !== 0
    );
  }
  /**
   * Pops the color mask.
   * @param maskData - The mask data
   */
  popColorMask(maskData) {
    const currColorMask = maskData._colorMask, nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
    nextColorMask !== currColorMask && this.renderer.gl.colorMask(
      (nextColorMask & 1) !== 0,
      (nextColorMask & 2) !== 0,
      (nextColorMask & 4) !== 0,
      (nextColorMask & 8) !== 0
    );
  }
  destroy() {
    this.renderer = null;
  }
}
MaskSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "mask"
};
extensions.extensions.add(MaskSystem);
exports.MaskSystem = MaskSystem;
//# sourceMappingURL=MaskSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/mask/ScissorSystem.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/mask/ScissorSystem.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), math = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.js"), settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js"), AbstractMaskSystem = __webpack_require__(/*! ./AbstractMaskSystem.js */ "./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.js");
const tempMatrix = new math.Matrix(), rectPool = [], _ScissorSystem = class _ScissorSystem2 extends AbstractMaskSystem.AbstractMaskSystem {
  /**
   * @param {PIXI.Renderer} renderer - The renderer this System works for.
   */
  constructor(renderer) {
    super(renderer), this.glConst = settings.settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    return maskData ? maskData._scissorCounter : 0;
  }
  /**
   * evaluates _boundsTransformed, _scissorRect for MaskData
   * @param maskData
   */
  calcScissorRect(maskData) {
    if (maskData._scissorRectLocal)
      return;
    const prevData = maskData._scissorRect, { maskObject } = maskData, { renderer } = this, renderTextureSystem = renderer.renderTexture, rect = maskObject.getBounds(!0, rectPool.pop() ?? new math.Rectangle());
    this.roundFrameToPixels(
      rect,
      renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,
      renderTextureSystem.sourceFrame,
      renderTextureSystem.destinationFrame,
      renderer.projection.transform
    ), prevData && rect.fit(prevData), maskData._scissorRectLocal = rect;
  }
  static isMatrixRotated(matrix) {
    if (!matrix)
      return !1;
    const { a, b, c, d } = matrix;
    return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);
  }
  /**
   * Test, whether the object can be scissor mask with current renderer projection.
   * Calls "calcScissorRect()" if its true.
   * @param maskData - mask data
   * @returns whether Whether the object can be scissor mask
   */
  testScissor(maskData) {
    const { maskObject } = maskData;
    if (!maskObject.isFastRect || !maskObject.isFastRect() || _ScissorSystem2.isMatrixRotated(maskObject.worldTransform) || _ScissorSystem2.isMatrixRotated(this.renderer.projection.transform))
      return !1;
    this.calcScissorRect(maskData);
    const rect = maskData._scissorRectLocal;
    return rect.width > 0 && rect.height > 0;
  }
  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    _ScissorSystem2.isMatrixRotated(transform) || (transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity(), transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(
      bindingDestinationFrame.width / bindingSourceFrame.width,
      bindingDestinationFrame.height / bindingSourceFrame.height
    ).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.renderer.filter.transformAABB(transform, frame), frame.fit(bindingDestinationFrame), frame.x = Math.round(frame.x * resolution), frame.y = Math.round(frame.y * resolution), frame.width = Math.round(frame.width * resolution), frame.height = Math.round(frame.height * resolution));
  }
  /**
   * Applies the Mask and adds it to the current stencil stack.
   * @author alvin
   * @param maskData - The mask data.
   */
  push(maskData) {
    maskData._scissorRectLocal || this.calcScissorRect(maskData);
    const { gl } = this.renderer;
    maskData._scissorRect || gl.enable(gl.SCISSOR_TEST), maskData._scissorCounter++, maskData._scissorRect = maskData._scissorRectLocal, this._useCurrent();
  }
  /**
   * This should be called after a mask is popped off the mask stack. It will rebind the scissor box to be latest with the
   * last mask in the stack.
   *
   * This can also be called when you directly modify the scissor box and want to restore PixiJS state.
   * @param maskData - The mask data.
   */
  pop(maskData) {
    const { gl } = this.renderer;
    maskData && rectPool.push(maskData._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : gl.disable(gl.SCISSOR_TEST);
  }
  /**
   * Setup renderer to use the current scissor data.
   * @private
   */
  _useCurrent() {
    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
    let y;
    this.renderer.renderTexture.current ? y = rect.y : y = this.renderer.height - rect.height - rect.y, this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);
  }
};
_ScissorSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "scissor"
};
let ScissorSystem = _ScissorSystem;
extensions.extensions.add(ScissorSystem);
exports.ScissorSystem = ScissorSystem;
//# sourceMappingURL=ScissorSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/mask/StencilSystem.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/mask/StencilSystem.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js"), AbstractMaskSystem = __webpack_require__(/*! ./AbstractMaskSystem.js */ "./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.js");
class StencilSystem extends AbstractMaskSystem.AbstractMaskSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    super(renderer), this.glConst = settings.settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    return maskData ? maskData._stencilCounter : 0;
  }
  /**
   * Applies the Mask and adds it to the current stencil stack.
   * @param maskData - The mask data
   */
  push(maskData) {
    const maskObject = maskData.maskObject, { gl } = this.renderer, prevMaskCount = maskData._stencilCounter;
    prevMaskCount === 0 && (this.renderer.framebuffer.forceStencil(), gl.clearStencil(0), gl.clear(gl.STENCIL_BUFFER_BIT), gl.enable(gl.STENCIL_TEST)), maskData._stencilCounter++;
    const colorMask = maskData._colorMask;
    colorMask !== 0 && (maskData._colorMask = 0, gl.colorMask(!1, !1, !1, !1)), gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295), gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR), maskObject.renderable = !0, maskObject.render(this.renderer), this.renderer.batch.flush(), maskObject.renderable = !1, colorMask !== 0 && (maskData._colorMask = colorMask, gl.colorMask(
      (colorMask & 1) !== 0,
      (colorMask & 2) !== 0,
      (colorMask & 4) !== 0,
      (colorMask & 8) !== 0
    )), this._useCurrent();
  }
  /**
   * Pops stencil mask. MaskData is already removed from stack
   * @param {PIXI.DisplayObject} maskObject - object of popped mask data
   */
  pop(maskObject) {
    const gl = this.renderer.gl;
    if (this.getStackLength() === 0)
      gl.disable(gl.STENCIL_TEST);
    else {
      const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, colorMask = maskData ? maskData._colorMask : 15;
      colorMask !== 0 && (maskData._colorMask = 0, gl.colorMask(!1, !1, !1, !1)), gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR), maskObject.renderable = !0, maskObject.render(this.renderer), this.renderer.batch.flush(), maskObject.renderable = !1, colorMask !== 0 && (maskData._colorMask = colorMask, gl.colorMask(
        (colorMask & 1) !== 0,
        (colorMask & 2) !== 0,
        (colorMask & 4) !== 0,
        (colorMask & 8) !== 0
      )), this._useCurrent();
    }
  }
  /**
   * Setup renderer to use the current stencil data.
   * @private
   */
  _useCurrent() {
    const gl = this.renderer.gl;
    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295), gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
  }
}
StencilSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "stencil"
};
extensions.extensions.add(StencilSystem);
exports.StencilSystem = StencilSystem;
//# sourceMappingURL=StencilSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/plugin/PluginSystem.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/plugin/PluginSystem.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js");
class PluginSystem {
  constructor(renderer) {
    this.renderer = renderer, this.plugins = {}, Object.defineProperties(this.plugins, {
      extract: {
        enumerable: !1,
        get() {
          return utils.deprecation("7.0.0", "renderer.plugins.extract has moved to renderer.extract"), renderer.extract;
        }
      },
      prepare: {
        enumerable: !1,
        get() {
          return utils.deprecation("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"), renderer.prepare;
        }
      },
      interaction: {
        enumerable: !1,
        get() {
          return utils.deprecation("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"), renderer.events;
        }
      }
    });
  }
  /**
   * Initialize the plugins.
   * @protected
   */
  init() {
    const staticMap = this.rendererPlugins;
    for (const o in staticMap)
      this.plugins[o] = new staticMap[o](this.renderer);
  }
  destroy() {
    for (const o in this.plugins)
      this.plugins[o].destroy(), this.plugins[o] = null;
  }
}
PluginSystem.extension = {
  type: [
    extensions.ExtensionType.RendererSystem,
    extensions.ExtensionType.CanvasRendererSystem
  ],
  name: "_plugin"
};
extensions.extensions.add(PluginSystem);
exports.PluginSystem = PluginSystem;
//# sourceMappingURL=PluginSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/projection/ProjectionSystem.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/projection/ProjectionSystem.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), math = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.js");
class ProjectionSystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.renderer = renderer, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new math.Matrix(), this.transform = null;
  }
  /**
   * Updates the projection-matrix based on the sourceFrame → destinationFrame mapping provided.
   *
   * NOTE: It is expected you call `renderer.framebuffer.setViewport(destinationFrame)` after this. This is because
   * the framebuffer viewport converts shader vertex output in normalized device coordinates to window coordinates.
   *
   * NOTE-2: {@link PIXI.RenderTextureSystem#bind} updates the projection-matrix when you bind a render-texture.
   * It is expected
   * that you dirty the current bindings when calling this manually.
   * @param destinationFrame - The rectangle in the render-target to render the contents into. If rendering to the canvas,
   *  the origin is on the top-left; if rendering to a render-texture, the origin is on the bottom-left.
   * @param sourceFrame - The rectangle in world space that contains the contents being rendered.
   * @param resolution - The resolution of the render-target, which is the ratio of
   *  world-space (or CSS) pixels to physical pixels.
   * @param root - Whether the render-target is the screen. This is required because rendering to textures
   *  is y-flipped (i.e. upside down relative to the screen).
   */
  update(destinationFrame, sourceFrame, resolution, root) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame, this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame, this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root), this.transform && this.projectionMatrix.append(this.transform);
    const renderer = this.renderer;
    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, renderer.globalUniforms.update(), renderer.shader.shader && renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
  }
  /**
   * Calculates the `projectionMatrix` to map points inside `sourceFrame` to inside `destinationFrame`.
   * @param _destinationFrame - The destination frame in the render-target.
   * @param sourceFrame - The source frame in world space.
   * @param _resolution - The render-target's resolution, i.e. ratio of CSS to physical pixels.
   * @param root - Whether rendering into the screen. Otherwise, if rendering to a framebuffer, the projection
   *  is y-flipped.
   */
  calculateProjection(_destinationFrame, sourceFrame, _resolution, root) {
    const pm = this.projectionMatrix, sign = root ? -1 : 1;
    pm.identity(), pm.a = 1 / sourceFrame.width * 2, pm.d = sign * (1 / sourceFrame.height * 2), pm.tx = -1 - sourceFrame.x * pm.a, pm.ty = -sign - sourceFrame.y * pm.d;
  }
  /**
   * Sets the transform of the active render target to the given matrix.
   * @param _matrix - The transformation matrix
   */
  setTransform(_matrix) {
  }
  destroy() {
    this.renderer = null;
  }
}
ProjectionSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "projection"
};
extensions.extensions.add(ProjectionSystem);
exports.ProjectionSystem = ProjectionSystem;
//# sourceMappingURL=ProjectionSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var color = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.js"), constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), Framebuffer = __webpack_require__(/*! ../framebuffer/Framebuffer.js */ "./node_modules/@pixi/core/lib/framebuffer/Framebuffer.js"), BaseTexture = __webpack_require__(/*! ../textures/BaseTexture.js */ "./node_modules/@pixi/core/lib/textures/BaseTexture.js");
class BaseRenderTexture extends BaseTexture.BaseTexture {
  /**
   * @param options
   * @param {number} [options.width=100] - The width of the base render texture.
   * @param {number} [options.height=100] - The height of the base render texture.
   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.BaseTexture.defaultOptions.scaleMode] - See {@link PIXI.SCALE_MODES}
   *   for possible values.
   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio
   *   of the texture being generated.
   * @param {PIXI.MSAA_QUALITY} [options.multisample=PIXI.MSAA_QUALITY.NONE] - The number of samples of the frame buffer.
   */
  constructor(options = {}) {
    if (typeof options == "number") {
      const width = arguments[0], height = arguments[1], scaleMode = arguments[2], resolution = arguments[3];
      options = { width, height, scaleMode, resolution };
    }
    options.width = options.width ?? 100, options.height = options.height ?? 100, options.multisample ?? (options.multisample = constants.MSAA_QUALITY.NONE), super(null, options), this.mipmap = constants.MIPMAP_MODES.OFF, this.valid = !0, this._clear = new color.Color([0, 0, 0, 0]), this.framebuffer = new Framebuffer.Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this), this.framebuffer.multisample = options.multisample, this.maskStack = [], this.filterStack = [{}];
  }
  /** Color when clearning the texture. */
  set clearColor(value) {
    this._clear.setValue(value);
  }
  get clearColor() {
    return this._clear.value;
  }
  /**
   * Color object when clearning the texture.
   * @readonly
   * @since 7.2.0
   */
  get clear() {
    return this._clear;
  }
  /**
   * Shortcut to `this.framebuffer.multisample`.
   * @default PIXI.MSAA_QUALITY.NONE
   */
  get multisample() {
    return this.framebuffer.multisample;
  }
  set multisample(value) {
    this.framebuffer.multisample = value;
  }
  /**
   * Resizes the BaseRenderTexture.
   * @param desiredWidth - The desired width to resize to.
   * @param desiredHeight - The desired height to resize to.
   */
  resize(desiredWidth, desiredHeight) {
    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  }
  /**
   * Frees the texture and framebuffer from WebGL memory without destroying this texture object.
   * This means you can still use the texture later which will upload it to GPU
   * memory again.
   * @fires PIXI.BaseTexture#dispose
   */
  dispose() {
    this.framebuffer.dispose(), super.dispose();
  }
  /** Destroys this texture. */
  destroy() {
    super.destroy(), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
  }
}
exports.BaseRenderTexture = BaseRenderTexture;
//# sourceMappingURL=BaseRenderTexture.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), math = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.js"), RenderTexture = __webpack_require__(/*! ./RenderTexture.js */ "./node_modules/@pixi/core/lib/renderTexture/RenderTexture.js");
const tempTransform = new math.Transform(), tempRect = new math.Rectangle();
class GenerateTextureSystem {
  constructor(renderer) {
    this.renderer = renderer, this._tempMatrix = new math.Matrix();
  }
  /**
   * A Useful function that returns a texture of the display object that can then be used to create sprites
   * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.
   * @param displayObject - The displayObject the object will be generated from.
   * @param {IGenerateTextureOptions} options - Generate texture options.
   * @param {PIXI.Rectangle} options.region - The region of the displayObject, that shall be rendered,
   *        if no region is specified, defaults to the local bounds of the displayObject.
   * @param {number} [options.resolution] - If not given, the renderer's resolution is used.
   * @param {PIXI.MSAA_QUALITY} [options.multisample] - If not given, the renderer's multisample is used.
   * @returns a shiny new texture of the display object passed in
   */
  generateTexture(displayObject, options) {
    const { region: manualRegion, ...textureOptions } = options || {}, region = manualRegion?.copyTo(tempRect) || displayObject.getLocalBounds(tempRect, !0), resolution = textureOptions.resolution || this.renderer.resolution;
    region.width = Math.max(region.width, 1 / resolution), region.height = Math.max(region.height, 1 / resolution), textureOptions.width = region.width, textureOptions.height = region.height, textureOptions.resolution = resolution, textureOptions.multisample ?? (textureOptions.multisample = this.renderer.multisample);
    const renderTexture = RenderTexture.RenderTexture.create(textureOptions);
    this._tempMatrix.tx = -region.x, this._tempMatrix.ty = -region.y;
    const transform = displayObject.transform;
    return displayObject.transform = tempTransform, this.renderer.render(displayObject, {
      renderTexture,
      transform: this._tempMatrix,
      skipUpdateTransform: !!displayObject.parent,
      blit: !0
    }), displayObject.transform = transform, renderTexture;
  }
  destroy() {
  }
}
GenerateTextureSystem.extension = {
  type: [
    extensions.ExtensionType.RendererSystem,
    extensions.ExtensionType.CanvasRendererSystem
  ],
  name: "textureGenerator"
};
extensions.extensions.add(GenerateTextureSystem);
exports.GenerateTextureSystem = GenerateTextureSystem;
//# sourceMappingURL=GenerateTextureSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/renderTexture/RenderTexture.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/renderTexture/RenderTexture.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Texture = __webpack_require__(/*! ../textures/Texture.js */ "./node_modules/@pixi/core/lib/textures/Texture.js"), BaseRenderTexture = __webpack_require__(/*! ./BaseRenderTexture.js */ "./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js");
class RenderTexture extends Texture.Texture {
  /**
   * @param baseRenderTexture - The base texture object that this texture uses.
   * @param frame - The rectangle frame of the texture to show.
   */
  constructor(baseRenderTexture, frame) {
    super(baseRenderTexture, frame), this.valid = !0, this.filterFrame = null, this.filterPoolKey = null, this.updateUvs();
  }
  /**
   * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
   * @readonly
   */
  get framebuffer() {
    return this.baseTexture.framebuffer;
  }
  /**
   * Shortcut to `this.framebuffer.multisample`.
   * @default PIXI.MSAA_QUALITY.NONE
   */
  get multisample() {
    return this.framebuffer.multisample;
  }
  set multisample(value) {
    this.framebuffer.multisample = value;
  }
  /**
   * Resizes the RenderTexture.
   * @param desiredWidth - The desired width to resize to.
   * @param desiredHeight - The desired height to resize to.
   * @param resizeBaseTexture - Should the baseTexture.width and height values be resized as well?
   */
  resize(desiredWidth, desiredHeight, resizeBaseTexture = !0) {
    const resolution = this.baseTexture.resolution, width = Math.round(desiredWidth * resolution) / resolution, height = Math.round(desiredHeight * resolution) / resolution;
    this.valid = width > 0 && height > 0, this._frame.width = this.orig.width = width, this._frame.height = this.orig.height = height, resizeBaseTexture && this.baseTexture.resize(width, height), this.updateUvs();
  }
  /**
   * Changes the resolution of baseTexture, but does not change framebuffer size.
   * @param resolution - The new resolution to apply to RenderTexture
   */
  setResolution(resolution) {
    const { baseTexture } = this;
    baseTexture.resolution !== resolution && (baseTexture.setResolution(resolution), this.resize(baseTexture.width, baseTexture.height, !1));
  }
  /**
   * A short hand way of creating a render texture.
   * @param options - Options
   * @param {number} [options.width=100] - The width of the render texture
   * @param {number} [options.height=100] - The height of the render texture
   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.BaseTexture.defaultOptions.scaleMode] - See {@link PIXI.SCALE_MODES}
   *    for possible values
   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the texture
   *    being generated
   * @param {PIXI.MSAA_QUALITY} [options.multisample=PIXI.MSAA_QUALITY.NONE] - The number of samples of the frame buffer
   * @returns The new render texture
   */
  static create(options) {
    return new RenderTexture(new BaseRenderTexture.BaseRenderTexture(options));
  }
}
exports.RenderTexture = RenderTexture;
//# sourceMappingURL=RenderTexture.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js"), BaseRenderTexture = __webpack_require__(/*! ./BaseRenderTexture.js */ "./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.js"), RenderTexture = __webpack_require__(/*! ./RenderTexture.js */ "./node_modules/@pixi/core/lib/renderTexture/RenderTexture.js");
class RenderTexturePool {
  /**
   * @param textureOptions - options that will be passed to BaseRenderTexture constructor
   * @param {PIXI.SCALE_MODES} [textureOptions.scaleMode] - See {@link PIXI.SCALE_MODES} for possible values.
   */
  constructor(textureOptions) {
    this.texturePool = {}, this.textureOptions = textureOptions || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param realWidth - Width of texture in pixels.
   * @param realHeight - Height of texture in pixels.
   * @param multisample - Number of samples of the framebuffer.
   */
  createTexture(realWidth, realHeight, multisample = constants.MSAA_QUALITY.NONE) {
    const baseRenderTexture = new BaseRenderTexture.BaseRenderTexture(Object.assign({
      width: realWidth,
      height: realHeight,
      resolution: 1,
      multisample
    }, this.textureOptions));
    return new RenderTexture.RenderTexture(baseRenderTexture);
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param minWidth - The minimum width of the render texture.
   * @param minHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @param multisample - Number of samples of the render texture.
   * @returns The new render texture.
   */
  getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = constants.MSAA_QUALITY.NONE) {
    let key;
    minWidth = Math.max(Math.ceil(minWidth * resolution - 1e-6), 1), minHeight = Math.max(Math.ceil(minHeight * resolution - 1e-6), 1), !this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight ? (minWidth = utils.nextPow2(minWidth), minHeight = utils.nextPow2(minHeight), key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0, multisample > 1 && (key += multisample * 4294967296)) : key = multisample > 1 ? -multisample : -1, this.texturePool[key] || (this.texturePool[key] = []);
    let renderTexture = this.texturePool[key].pop();
    return renderTexture || (renderTexture = this.createTexture(minWidth, minHeight, multisample)), renderTexture.filterPoolKey = key, renderTexture.setResolution(resolution), renderTexture;
  }
  /**
   * Gets extra texture of the same size as input renderTexture
   *
   * `getFilterTexture(input, 0.5)` or `getFilterTexture(0.5, input)`
   * @param input - renderTexture from which size and resolution will be copied
   * @param resolution - override resolution of the renderTexture
   *  It overrides, it does not multiply
   * @param multisample - number of samples of the renderTexture
   */
  getFilterTexture(input, resolution, multisample) {
    const filterTexture = this.getOptimalTexture(
      input.width,
      input.height,
      resolution || input.resolution,
      multisample || constants.MSAA_QUALITY.NONE
    );
    return filterTexture.filterFrame = input.filterFrame, filterTexture;
  }
  /**
   * Place a render texture back into the pool.
   * @param renderTexture - The renderTexture to free
   */
  returnTexture(renderTexture) {
    const key = renderTexture.filterPoolKey;
    renderTexture.filterFrame = null, this.texturePool[key].push(renderTexture);
  }
  /**
   * Alias for returnTexture, to be compliant with FilterSystem interface.
   * @param renderTexture - The renderTexture to free
   */
  returnFilterTexture(renderTexture) {
    this.returnTexture(renderTexture);
  }
  /**
   * Clears the pool.
   * @param destroyTextures - Destroy all stored textures.
   */
  clear(destroyTextures) {
    if (destroyTextures = destroyTextures !== !1, destroyTextures)
      for (const i in this.texturePool) {
        const textures = this.texturePool[i];
        if (textures)
          for (let j = 0; j < textures.length; j++)
            textures[j].destroy(!0);
      }
    this.texturePool = {};
  }
  /**
   * If screen size was changed, drops all screen-sized textures,
   * sets new screen size, sets `enableFullScreen` to true
   *
   * Size is measured in pixels, `renderer.view` can be passed here, not `renderer.screen`
   * @param size - Initial size of screen.
   */
  setScreenSize(size) {
    if (!(size.width === this._pixelsWidth && size.height === this._pixelsHeight)) {
      this.enableFullScreen = size.width > 0 && size.height > 0;
      for (const i in this.texturePool) {
        if (!(Number(i) < 0))
          continue;
        const textures = this.texturePool[i];
        if (textures)
          for (let j = 0; j < textures.length; j++)
            textures[j].destroy(!0);
        this.texturePool[i] = [];
      }
      this._pixelsWidth = size.width, this._pixelsHeight = size.height;
    }
  }
}
RenderTexturePool.SCREEN_KEY = -1;
exports.RenderTexturePool = RenderTexturePool;
//# sourceMappingURL=RenderTexturePool.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var color = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.js"), extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), math = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.js");
const tempRect = new math.Rectangle(), tempRect2 = new math.Rectangle();
class RenderTextureSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new math.Rectangle(), this.destinationFrame = new math.Rectangle(), this.viewportFrame = new math.Rectangle();
  }
  contextChange() {
    const attributes = this.renderer?.gl.getContextAttributes();
    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);
  }
  /**
   * Bind the current render texture.
   * @param renderTexture - RenderTexture to bind, by default its `null` - the screen.
   * @param sourceFrame - Part of world that is mapped to the renderTexture.
   * @param destinationFrame - Part of renderTexture, by default it has the same size as sourceFrame.
   */
  bind(renderTexture = null, sourceFrame, destinationFrame) {
    const renderer = this.renderer;
    this.current = renderTexture;
    let baseTexture, framebuffer, resolution;
    renderTexture ? (baseTexture = renderTexture.baseTexture, resolution = baseTexture.resolution, sourceFrame || (tempRect.width = renderTexture.frame.width, tempRect.height = renderTexture.frame.height, sourceFrame = tempRect), destinationFrame || (tempRect2.x = renderTexture.frame.x, tempRect2.y = renderTexture.frame.y, tempRect2.width = sourceFrame.width, tempRect2.height = sourceFrame.height, destinationFrame = tempRect2), framebuffer = baseTexture.framebuffer) : (resolution = renderer.resolution, sourceFrame || (tempRect.width = renderer._view.screen.width, tempRect.height = renderer._view.screen.height, sourceFrame = tempRect), destinationFrame || (destinationFrame = tempRect, destinationFrame.width = sourceFrame.width, destinationFrame.height = sourceFrame.height));
    const viewportFrame = this.viewportFrame;
    viewportFrame.x = destinationFrame.x * resolution, viewportFrame.y = destinationFrame.y * resolution, viewportFrame.width = destinationFrame.width * resolution, viewportFrame.height = destinationFrame.height * resolution, renderTexture || (viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height)), viewportFrame.ceil(), this.renderer.framebuffer.bind(framebuffer, viewportFrame), this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer), renderTexture ? this.renderer.mask.setMaskStack(baseTexture.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(sourceFrame), this.destinationFrame.copyFrom(destinationFrame);
  }
  /**
   * Erases the render texture and fills the drawing area with a colour.
   * @param clearColor - The color as rgba, default to use the renderer backgroundColor
   * @param [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks
   *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.
   */
  clear(clearColor, mask) {
    const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor, color$1 = color.Color.shared.setValue(clearColor || fallbackColor);
    (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) && color$1.premultiply(color$1.alpha);
    const destinationFrame = this.destinationFrame, baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen, clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
    if (clearMask) {
      let { x, y, width, height } = this.viewportFrame;
      x = Math.round(x), y = Math.round(y), width = Math.round(width), height = Math.round(height), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(x, y, width, height);
    }
    this.renderer.framebuffer.clear(color$1.red, color$1.green, color$1.blue, color$1.alpha, mask), clearMask && this.renderer.scissor.pop();
  }
  resize() {
    this.bind(null);
  }
  /** Resets render-texture state. */
  reset() {
    this.bind(null);
  }
  destroy() {
    this.renderer = null;
  }
}
RenderTextureSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "renderTexture"
};
extensions.extensions.add(RenderTextureSystem);
exports.RenderTextureSystem = RenderTextureSystem;
//# sourceMappingURL=RenderTextureSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/render/ObjectRendererSystem.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/render/ObjectRendererSystem.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js");
class ObjectRendererSystem {
  // renderers scene graph!
  constructor(renderer) {
    this.renderer = renderer;
  }
  /**
   * Renders the object to its WebGL view.
   * @param displayObject - The object to be rendered.
   * @param options - the options to be passed to the renderer
   */
  render(displayObject, options) {
    const renderer = this.renderer;
    let renderTexture, clear, transform, skipUpdateTransform;
    if (options && (renderTexture = options.renderTexture, clear = options.clear, transform = options.transform, skipUpdateTransform = options.skipUpdateTransform), this.renderingToScreen = !renderTexture, renderer.runners.prerender.emit(), renderer.emit("prerender"), renderer.projection.transform = transform, !renderer.context.isLost) {
      if (renderTexture || (this.lastObjectRendered = displayObject), !skipUpdateTransform) {
        const cacheParent = displayObject.enableTempParent();
        displayObject.updateTransform(), displayObject.disableTempParent(cacheParent);
      }
      renderer.renderTexture.bind(renderTexture), renderer.batch.currentRenderer.start(), (clear ?? renderer.background.clearBeforeRender) && renderer.renderTexture.clear(), displayObject.render(renderer), renderer.batch.currentRenderer.flush(), renderTexture && (options.blit && renderer.framebuffer.blit(), renderTexture.baseTexture.update()), renderer.runners.postrender.emit(), renderer.projection.transform = null, renderer.emit("postrender");
    }
  }
  destroy() {
    this.renderer = null, this.lastObjectRendered = null;
  }
}
ObjectRendererSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "objectRenderer"
};
extensions.extensions.add(ObjectRendererSystem);
exports.ObjectRendererSystem = ObjectRendererSystem;
//# sourceMappingURL=ObjectRendererSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/settings.js":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/core/lib/settings.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js"), utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js"), BatchRenderer = __webpack_require__(/*! ./batch/BatchRenderer.js */ "./node_modules/@pixi/core/lib/batch/BatchRenderer.js"), Filter = __webpack_require__(/*! ./filters/Filter.js */ "./node_modules/@pixi/core/lib/filters/Filter.js"), Program = __webpack_require__(/*! ./shader/Program.js */ "./node_modules/@pixi/core/lib/shader/Program.js");
__webpack_require__(/*! ./systems.js */ "./node_modules/@pixi/core/lib/systems.js");
var BaseTexture = __webpack_require__(/*! ./textures/BaseTexture.js */ "./node_modules/@pixi/core/lib/textures/BaseTexture.js"), ContextSystem = __webpack_require__(/*! ./context/ContextSystem.js */ "./node_modules/@pixi/core/lib/context/ContextSystem.js"), BackgroundSystem = __webpack_require__(/*! ./background/BackgroundSystem.js */ "./node_modules/@pixi/core/lib/background/BackgroundSystem.js"), ViewSystem = __webpack_require__(/*! ./view/ViewSystem.js */ "./node_modules/@pixi/core/lib/view/ViewSystem.js"), StartupSystem = __webpack_require__(/*! ./startup/StartupSystem.js */ "./node_modules/@pixi/core/lib/startup/StartupSystem.js"), TextureGCSystem = __webpack_require__(/*! ./textures/TextureGCSystem.js */ "./node_modules/@pixi/core/lib/textures/TextureGCSystem.js");
settings.settings.PREFER_ENV = constants.ENV.WEBGL2;
settings.settings.STRICT_TEXTURE_CACHE = !1;
settings.settings.RENDER_OPTIONS = {
  ...ContextSystem.ContextSystem.defaultOptions,
  ...BackgroundSystem.BackgroundSystem.defaultOptions,
  ...ViewSystem.ViewSystem.defaultOptions,
  ...StartupSystem.StartupSystem.defaultOptions
};
Object.defineProperties(settings.settings, {
  /**
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @deprecated since 7.1.0
   * @see PIXI.BaseTexture.defaultOptions.wrapMode
   */
  WRAP_MODE: {
    get() {
      return BaseTexture.BaseTexture.defaultOptions.wrapMode;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"), BaseTexture.BaseTexture.defaultOptions.wrapMode = value;
    }
  },
  /**
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @deprecated since 7.1.0
   * @see PIXI.BaseTexture.defaultOptions.scaleMode
   */
  SCALE_MODE: {
    get() {
      return BaseTexture.BaseTexture.defaultOptions.scaleMode;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"), BaseTexture.BaseTexture.defaultOptions.scaleMode = value;
    }
  },
  /**
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @deprecated since 7.1.0
   * @see PIXI.BaseTexture.defaultOptions.mipmap
   */
  MIPMAP_TEXTURES: {
    get() {
      return BaseTexture.BaseTexture.defaultOptions.mipmap;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"), BaseTexture.BaseTexture.defaultOptions.mipmap = value;
    }
    // MIPMAP_MODES.POW2,
  },
  /**
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @deprecated since 7.1.0
   * @see PIXI.BaseTexture.defaultOptions.anisotropicLevel
   */
  ANISOTROPIC_LEVEL: {
    get() {
      return BaseTexture.BaseTexture.defaultOptions.anisotropicLevel;
    },
    set(value) {
      utils.deprecation(
        "7.1.0",
        "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"
      ), BaseTexture.BaseTexture.defaultOptions.anisotropicLevel = value;
    }
  },
  /**
   * Default filter resolution.
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @deprecated since 7.1.0
   * @type {number|null}
   * @see PIXI.Filter.defaultResolution
   */
  FILTER_RESOLUTION: {
    get() {
      return utils.deprecation("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"), Filter.Filter.defaultResolution;
    },
    set(value) {
      Filter.Filter.defaultResolution = value;
    }
  },
  /**
   * Default filter samples.
   * @static
   * @name FILTER_MULTISAMPLE
   * @memberof PIXI.settings
   * @deprecated since 7.1.0
   * @type {PIXI.MSAA_QUALITY}
   * @see PIXI.Filter.defaultMultisample
   */
  FILTER_MULTISAMPLE: {
    get() {
      return utils.deprecation("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"), Filter.Filter.defaultMultisample;
    },
    set(value) {
      Filter.Filter.defaultMultisample = value;
    }
  },
  /**
   * The maximum textures that this device supports.
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @deprecated since 7.1.0
   * @see PIXI.BatchRenderer.defaultMaxTextures
   * @type {number}
   */
  SPRITE_MAX_TEXTURES: {
    get() {
      return BatchRenderer.BatchRenderer.defaultMaxTextures;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"), BatchRenderer.BatchRenderer.defaultMaxTextures = value;
    }
  },
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @see PIXI.BatchRenderer.defaultBatchSize
   * @deprecated since 7.1.0
   * @type {number}
   */
  SPRITE_BATCH_SIZE: {
    get() {
      return BatchRenderer.BatchRenderer.defaultBatchSize;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"), BatchRenderer.BatchRenderer.defaultBatchSize = value;
    }
  },
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @see PIXI.BatchRenderer.canUploadSameBuffer
   * @deprecated since 7.1.0
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: {
    get() {
      return BatchRenderer.BatchRenderer.canUploadSameBuffer;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"), BatchRenderer.BatchRenderer.canUploadSameBuffer = value;
    }
  },
  /**
   * Default Garbage Collection mode.
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @deprecated since 7.1.0
   * @see PIXI.TextureGCSystem.defaultMode
   */
  GC_MODE: {
    get() {
      return TextureGCSystem.TextureGCSystem.defaultMode;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"), TextureGCSystem.TextureGCSystem.defaultMode = value;
    }
  },
  /**
   * Default Garbage Collection max idle.
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @deprecated since 7.1.0
   * @see PIXI.TextureGCSystem.defaultMaxIdle
   */
  GC_MAX_IDLE: {
    get() {
      return TextureGCSystem.TextureGCSystem.defaultMaxIdle;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"), TextureGCSystem.TextureGCSystem.defaultMaxIdle = value;
    }
  },
  /**
   * Default Garbage Collection maximum check count.
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @deprecated since 7.1.0
   * @see PIXI.TextureGCSystem.defaultCheckCountMax
   */
  GC_MAX_CHECK_COUNT: {
    get() {
      return TextureGCSystem.TextureGCSystem.defaultCheckCountMax;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"), TextureGCSystem.TextureGCSystem.defaultCheckCountMax = value;
    }
  },
  /**
   * Default specify float precision in vertex shader.
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @deprecated since 7.1.0
   * @see PIXI.Program.defaultVertexPrecision
   */
  PRECISION_VERTEX: {
    get() {
      return Program.Program.defaultVertexPrecision;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"), Program.Program.defaultVertexPrecision = value;
    }
  },
  /**
   * Default specify float precision in fragment shader.
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @deprecated since 7.1.0
   * @see PIXI.Program.defaultFragmentPrecision
   */
  PRECISION_FRAGMENT: {
    get() {
      return Program.Program.defaultFragmentPrecision;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"), Program.Program.defaultFragmentPrecision = value;
    }
  }
});
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/GLProgram.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/GLProgram.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class IGLUniformData {
}
class GLProgram {
  /**
   * Makes a new Pixi program.
   * @param program - webgl program
   * @param uniformData - uniforms
   */
  constructor(program, uniformData) {
    this.program = program, this.uniformData = uniformData, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
  }
  /** Destroys this program. */
  destroy() {
    this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
  }
}
exports.GLProgram = GLProgram;
exports.IGLUniformData = IGLUniformData;
//# sourceMappingURL=GLProgram.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/Program.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/Program.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js"), defaultProgram$1 = __webpack_require__(/*! ./defaultProgram.frag.js */ "./node_modules/@pixi/core/lib/shader/defaultProgram.frag.js"), defaultProgram = __webpack_require__(/*! ./defaultProgram.vert.js */ "./node_modules/@pixi/core/lib/shader/defaultProgram.vert.js");
__webpack_require__(/*! ./utils/index.js */ "./node_modules/@pixi/core/lib/shader/utils/index.js");
var setPrecision = __webpack_require__(/*! ./utils/setPrecision.js */ "./node_modules/@pixi/core/lib/shader/utils/setPrecision.js"), getMaxFragmentPrecision = __webpack_require__(/*! ./utils/getMaxFragmentPrecision.js */ "./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.js");
let UID = 0;
const nameCache = {}, _Program = class _Program2 {
  /**
   * @param vertexSrc - The source of the vertex shader.
   * @param fragmentSrc - The source of the fragment shader.
   * @param name - Name for shader
   * @param extra - Extra data for shader
   */
  constructor(vertexSrc, fragmentSrc, name = "pixi-shader", extra = {}) {
    this.extra = {}, this.id = UID++, this.vertexSrc = vertexSrc || _Program2.defaultVertexSrc, this.fragmentSrc = fragmentSrc || _Program2.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.extra = extra, this.vertexSrc.substring(0, 8) !== "#version" && (name = name.replace(/\s+/g, "-"), nameCache[name] ? (nameCache[name]++, name += `-${nameCache[name]}`) : nameCache[name] = 1, this.vertexSrc = `#define SHADER_NAME ${name}
${this.vertexSrc}`, this.fragmentSrc = `#define SHADER_NAME ${name}
${this.fragmentSrc}`, this.vertexSrc = setPrecision.setPrecision(
      this.vertexSrc,
      _Program2.defaultVertexPrecision,
      constants.PRECISION.HIGH
    ), this.fragmentSrc = setPrecision.setPrecision(
      this.fragmentSrc,
      _Program2.defaultFragmentPrecision,
      getMaxFragmentPrecision.getMaxFragmentPrecision()
    )), this.glPrograms = {}, this.syncUniforms = null;
  }
  /**
   * The default vertex shader source.
   * @readonly
   */
  static get defaultVertexSrc() {
    return defaultProgram.default;
  }
  /**
   * The default fragment shader source.
   * @readonly
   */
  static get defaultFragmentSrc() {
    return defaultProgram$1.default;
  }
  /**
   * A short hand function to create a program based of a vertex and fragment shader.
   *
   * This method will also check to see if there is a cached program.
   * @param vertexSrc - The source of the vertex shader.
   * @param fragmentSrc - The source of the fragment shader.
   * @param name - Name for shader
   * @returns A shiny new PixiJS shader program!
   */
  static from(vertexSrc, fragmentSrc, name) {
    const key = vertexSrc + fragmentSrc;
    let program = utils.ProgramCache[key];
    return program || (utils.ProgramCache[key] = program = new _Program2(vertexSrc, fragmentSrc, name)), program;
  }
};
_Program.defaultVertexPrecision = constants.PRECISION.HIGH, /**
* Default specify float precision in fragment shader.
* iOS is best set at highp due to https://github.com/pixijs/pixijs/issues/3742
* @static
* @type {PIXI.PRECISION}
* @default PIXI.PRECISION.MEDIUM
*/
_Program.defaultFragmentPrecision = utils.isMobile.apple.device ? constants.PRECISION.HIGH : constants.PRECISION.MEDIUM;
let Program = _Program;
exports.Program = Program;
//# sourceMappingURL=Program.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/Shader.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/Shader.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.js"), Program = __webpack_require__(/*! ./Program.js */ "./node_modules/@pixi/core/lib/shader/Program.js"), UniformGroup = __webpack_require__(/*! ./UniformGroup.js */ "./node_modules/@pixi/core/lib/shader/UniformGroup.js");
class Shader {
  /**
   * @param program - The program the shader will use.
   * @param uniforms - Custom uniforms to use to augment the built-in ones.
   */
  constructor(program, uniforms) {
    this.uniformBindCount = 0, this.program = program, uniforms ? uniforms instanceof UniformGroup.UniformGroup ? this.uniformGroup = uniforms : this.uniformGroup = new UniformGroup.UniformGroup(uniforms) : this.uniformGroup = new UniformGroup.UniformGroup({}), this.disposeRunner = new runner.Runner("disposeShader");
  }
  // TODO move to shader system..
  checkUniformExists(name, group) {
    if (group.uniforms[name])
      return !0;
    for (const i in group.uniforms) {
      const uniform = group.uniforms[i];
      if (uniform.group === !0 && this.checkUniformExists(name, uniform))
        return !0;
    }
    return !1;
  }
  destroy() {
    this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();
  }
  /**
   * Shader uniform values, shortcut for `uniformGroup.uniforms`.
   * @readonly
   */
  get uniforms() {
    return this.uniformGroup.uniforms;
  }
  /**
   * A short hand function to create a shader based of a vertex and fragment shader.
   * @param vertexSrc - The source of the vertex shader.
   * @param fragmentSrc - The source of the fragment shader.
   * @param uniforms - Custom uniforms to use to augment the built-in ones.
   * @returns A shiny new PixiJS shader!
   */
  static from(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.Program.from(vertexSrc, fragmentSrc);
    return new Shader(program, uniforms);
  }
}
exports.Shader = Shader;
//# sourceMappingURL=Shader.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/ShaderSystem.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/ShaderSystem.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js");
__webpack_require__(/*! ./utils/index.js */ "./node_modules/@pixi/core/lib/shader/utils/index.js");
var generateProgram = __webpack_require__(/*! ./utils/generateProgram.js */ "./node_modules/@pixi/core/lib/shader/utils/generateProgram.js"), generateUniformBufferSync = __webpack_require__(/*! ./utils/generateUniformBufferSync.js */ "./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.js"), unsafeEvalSupported = __webpack_require__(/*! ./utils/unsafeEvalSupported.js */ "./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js"), generateUniformsSync = __webpack_require__(/*! ./utils/generateUniformsSync.js */ "./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.js");
let UID = 0;
const defaultSyncData = { textureCount: 0, uboCount: 0 };
class ShaderSystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.destroyed = !1, this.renderer = renderer, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = UID++;
  }
  /**
   * Overrideable function by `@pixi/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   */
  systemCheck() {
    if (!unsafeEvalSupported.unsafeEvalSupported())
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
  }
  contextChange(gl) {
    this.gl = gl, this.reset();
  }
  /**
   * Changes the current shader to the one given in parameter.
   * @param shader - the new shader
   * @param dontSync - false if the shader should automatically sync its uniforms.
   * @returns the glProgram that belongs to the shader.
   */
  bind(shader, dontSync) {
    shader.disposeRunner.add(this), shader.uniforms.globals = this.renderer.globalUniforms;
    const program = shader.program, glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
    return this.shader = shader, this.program !== program && (this.program = program, this.gl.useProgram(glProgram.program)), dontSync || (defaultSyncData.textureCount = 0, defaultSyncData.uboCount = 0, this.syncUniformGroup(shader.uniformGroup, defaultSyncData)), glProgram;
  }
  /**
   * Uploads the uniforms values to the currently bound shader.
   * @param uniforms - the uniforms values that be applied to the current shader
   */
  setUniforms(uniforms) {
    const shader = this.shader.program, glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
  }
  /* eslint-disable @typescript-eslint/explicit-module-boundary-types */
  /**
   * Syncs uniforms on the group
   * @param group - the uniform group to sync
   * @param syncData - this is data that is passed to the sync function and any nested sync functions
   */
  syncUniformGroup(group, syncData) {
    const glProgram = this.getGlProgram();
    (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) && (glProgram.uniformDirtyGroups[group.id] = group.dirtyId, this.syncUniforms(group, glProgram, syncData));
  }
  /**
   * Overrideable by the @pixi/unsafe-eval package to use static syncUniforms instead.
   * @param group
   * @param glProgram
   * @param syncData
   */
  syncUniforms(group, glProgram, syncData) {
    (group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group))(glProgram.uniformData, group.uniforms, this.renderer, syncData);
  }
  createSyncGroups(group) {
    const id = this.getSignature(group, this.shader.program.uniformData, "u");
    return this.cache[id] || (this.cache[id] = generateUniformsSync.generateUniformsSync(group, this.shader.program.uniformData)), group.syncUniforms[this.shader.program.id] = this.cache[id], group.syncUniforms[this.shader.program.id];
  }
  /**
   * Syncs uniform buffers
   * @param group - the uniform buffer group to sync
   * @param name - the name of the uniform buffer
   */
  syncUniformBufferGroup(group, name) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
      group.dirtyId = 0;
      const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
      group.buffer.update(), syncFunc(
        glProgram.uniformData,
        group.uniforms,
        this.renderer,
        defaultSyncData,
        group.buffer
      );
    }
    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
  }
  /**
   * Will create a function that uploads a uniform buffer using the STD140 standard.
   * The upload function will then be cached for future calls
   * If a group is manually managed, then a simple upload function is generated
   * @param group - the uniform buffer group to sync
   * @param glProgram - the gl program to attach the uniform bindings to
   * @param name - the name of the uniform buffer (must exist on the shader)
   */
  createSyncBufferGroup(group, glProgram, name) {
    const { gl } = this.renderer;
    this.renderer.buffer.bind(group.buffer);
    const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount, gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount), this.shader.uniformBindCount++;
    const id = this.getSignature(group, this.shader.program.uniformData, "ubo");
    let uboData = this._uboCache[id];
    if (uboData || (uboData = this._uboCache[id] = generateUniformBufferSync.generateUniformBufferSync(group, this.shader.program.uniformData)), group.autoManage) {
      const data = new Float32Array(uboData.size / 4);
      group.buffer.update(data);
    }
    return glProgram.uniformGroups[group.id] = uboData.syncFunc, glProgram.uniformGroups[group.id];
  }
  /**
   * Takes a uniform group and data and generates a unique signature for them.
   * @param group - The uniform group to get signature of
   * @param group.uniforms
   * @param uniformData - Uniform information generated by the shader
   * @param preFix
   * @returns Unique signature of the uniform group
   */
  getSignature(group, uniformData, preFix) {
    const uniforms = group.uniforms, strings = [`${preFix}-`];
    for (const i in uniforms)
      strings.push(i), uniformData[i] && strings.push(uniformData[i].type);
    return strings.join("-");
  }
  /**
   * Returns the underlying GLShade rof the currently bound shader.
   *
   * This can be handy for when you to have a little more control over the setting of your uniforms.
   * @returns The glProgram for the currently bound Shader for this context
   */
  getGlProgram() {
    return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
  }
  /**
   * Generates a glProgram version of the Shader provided.
   * @param shader - The shader that the glProgram will be based on.
   * @returns A shiny new glProgram!
   */
  generateProgram(shader) {
    const gl = this.gl, program = shader.program, glProgram = generateProgram.generateProgram(gl, program);
    return program.glPrograms[this.renderer.CONTEXT_UID] = glProgram, glProgram;
  }
  /** Resets ShaderSystem state, does not affect WebGL state. */
  reset() {
    this.program = null, this.shader = null;
  }
  /**
   * Disposes shader.
   * If disposing one equals with current shader, set current as null.
   * @param shader - Shader object
   */
  disposeShader(shader) {
    this.shader === shader && (this.shader = null);
  }
  /** Destroys this System and removes all its textures. */
  destroy() {
    this.renderer = null, this.destroyed = !0;
  }
}
ShaderSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "shader"
};
extensions.extensions.add(ShaderSystem);
exports.ShaderSystem = ShaderSystem;
//# sourceMappingURL=ShaderSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/UniformGroup.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/UniformGroup.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), Buffer = __webpack_require__(/*! ../geometry/Buffer.js */ "./node_modules/@pixi/core/lib/geometry/Buffer.js");
let UID = 0;
class UniformGroup {
  /**
   * @param {object | Buffer} [uniforms] - Custom uniforms to use to augment the built-in ones. Or a pixi buffer.
   * @param isStatic - Uniforms wont be changed after creation.
   * @param isUbo - If true, will treat this uniform group as a uniform buffer object.
   */
  constructor(uniforms, isStatic, isUbo) {
    this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = UID++, this.static = !!isStatic, this.ubo = !!isUbo, uniforms instanceof Buffer.Buffer ? (this.buffer = uniforms, this.buffer.type = constants.BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = uniforms, this.ubo && (this.buffer = new Buffer.Buffer(new Float32Array(1)), this.buffer.type = constants.BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !0));
  }
  update() {
    this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
  }
  add(name, uniforms, _static) {
    if (!this.ubo)
      this.uniforms[name] = new UniformGroup(uniforms, _static);
    else
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
  }
  static from(uniforms, _static, _ubo) {
    return new UniformGroup(uniforms, _static, _ubo);
  }
  /**
   * A short hand function for creating a static UBO UniformGroup.
   * @param uniforms - the ubo item
   * @param _static - should this be updated each time it is used? defaults to true here!
   */
  static uboFrom(uniforms, _static) {
    return new UniformGroup(uniforms, _static ?? !0, !0);
  }
}
exports.UniformGroup = UniformGroup;
//# sourceMappingURL=UniformGroup.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/defaultProgram.frag.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/defaultProgram.frag.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var defaultFragment = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`;
exports["default"] = defaultFragment;
//# sourceMappingURL=defaultProgram.frag.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/defaultProgram.vert.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/defaultProgram.vert.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var defaultVertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`;
exports["default"] = defaultVertex;
//# sourceMappingURL=defaultProgram.vert.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const fragTemplate = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i = 0; i < maxIfs; ++i)
    i > 0 && (src += `
else `), i < maxIfs - 1 && (src += `if(test == ${i}.0){}`);
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  for (; ; ) {
    const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    if (gl.shaderSource(shader, fragmentSrc), gl.compileShader(shader), !gl.getShaderParameter(shader, gl.COMPILE_STATUS))
      maxIfs = maxIfs / 2 | 0;
    else
      break;
  }
  return maxIfs;
}
exports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader;
//# sourceMappingURL=checkMaxIfStatementsInShader.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/compileShader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/compileShader.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function compileShader(gl, type, src) {
  const shader = gl.createShader(type);
  return gl.shaderSource(shader, src), gl.compileShader(shader), shader;
}
exports.compileShader = compileShader;
//# sourceMappingURL=compileShader.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/defaultValue.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/defaultValue.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function booleanArray(size) {
  const array = new Array(size);
  for (let i = 0; i < array.length; i++)
    array[i] = !1;
  return array;
}
function defaultValue(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return !1;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
exports.defaultValue = defaultValue;
//# sourceMappingURL=defaultValue.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/generateProgram.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/generateProgram.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var GLProgram = __webpack_require__(/*! ../GLProgram.js */ "./node_modules/@pixi/core/lib/shader/GLProgram.js"), compileShader = __webpack_require__(/*! ./compileShader.js */ "./node_modules/@pixi/core/lib/shader/utils/compileShader.js"), defaultValue = __webpack_require__(/*! ./defaultValue.js */ "./node_modules/@pixi/core/lib/shader/utils/defaultValue.js"), getAttributeData = __webpack_require__(/*! ./getAttributeData.js */ "./node_modules/@pixi/core/lib/shader/utils/getAttributeData.js"), getUniformData = __webpack_require__(/*! ./getUniformData.js */ "./node_modules/@pixi/core/lib/shader/utils/getUniformData.js"), logProgramError = __webpack_require__(/*! ./logProgramError.js */ "./node_modules/@pixi/core/lib/shader/utils/logProgramError.js");
function generateProgram(gl, program) {
  const glVertShader = compileShader.compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc), glFragShader = compileShader.compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc), webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader), gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;
  if (transformFeedbackVaryings && (typeof gl.transformFeedbackVaryings != "function" ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : gl.transformFeedbackVaryings(
    webGLProgram,
    transformFeedbackVaryings.names,
    transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
  )), gl.linkProgram(webGLProgram), gl.getProgramParameter(webGLProgram, gl.LINK_STATUS) || logProgramError.logProgramError(gl, webGLProgram, glVertShader, glFragShader), program.attributeData = getAttributeData.getAttributeData(webGLProgram, gl), program.uniformData = getUniformData.getUniformData(webGLProgram, gl), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    const keys = Object.keys(program.attributeData);
    keys.sort((a, b) => a > b ? 1 : -1);
    for (let i = 0; i < keys.length; i++)
      program.attributeData[keys[i]].location = i, gl.bindAttribLocation(webGLProgram, i, keys[i]);
    gl.linkProgram(webGLProgram);
  }
  gl.deleteShader(glVertShader), gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i in program.uniformData) {
    const data = program.uniformData[i];
    uniformData[i] = {
      location: gl.getUniformLocation(webGLProgram, i),
      value: defaultValue.defaultValue(data.type, data.size)
    };
  }
  return new GLProgram.GLProgram(webGLProgram, uniformData);
}
exports.generateProgram = generateProgram;
//# sourceMappingURL=generateProgram.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ./index.js */ "./node_modules/@pixi/core/lib/shader/utils/index.js");
var uniformParsers = __webpack_require__(/*! ./uniformParsers.js */ "./node_modules/@pixi/core/lib/shader/utils/uniformParsers.js"), mapSize = __webpack_require__(/*! ./mapSize.js */ "./node_modules/@pixi/core/lib/shader/utils/mapSize.js");
function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
  _renderer.buffer.update(buffer);
}
const UBO_TO_SINGLE_SETTERS = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}, GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    dataLen: 0,
    dirty: 0
  }));
  let size = 0, chunkSize = 0, offset = 0;
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    if (size = GLSL_TO_STD40_SIZE[uboElement.data.type], uboElement.data.size > 1 && (size = Math.max(size, 16) * uboElement.data.size), uboElement.dataLen = size, chunkSize % size !== 0 && chunkSize < 16) {
      const lineUpValue = chunkSize % size % 16;
      chunkSize += lineUpValue, offset += lineUpValue;
    }
    chunkSize + size > 16 ? (offset = Math.ceil(offset / 16) * 16, uboElement.offset = offset, offset += size, chunkSize = size) : (uboElement.offset = offset, chunkSize += size, offset += size);
  }
  return offset = Math.ceil(offset / 16) * 16, { uboElements, size: offset };
}
function getUBOData(uniforms, uniformData) {
  const usedUniformDatas = [];
  for (const i in uniforms)
    uniformData[i] && usedUniformDatas.push(uniformData[i]);
  return usedUniformDatas.sort((a, b) => a.index - b.index), usedUniformDatas;
}
function generateUniformBufferSync(group, uniformData) {
  if (!group.autoManage)
    return { size: 0, syncFunc: uboUpdate };
  const usedUniformDatas = getUBOData(group.uniforms, uniformData), { uboElements, size } = createUBOElements(usedUniformDatas), funcFragments = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i], uniform = group.uniforms[uboElement.data.name], name = uboElement.data.name;
    let parsed = !1;
    for (let j = 0; j < uniformParsers.uniformParsers.length; j++) {
      const uniformParser = uniformParsers.uniformParsers[j];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push(
          `offset = ${uboElement.offset / 4};`,
          uniformParsers.uniformParsers[j].codeUbo(uboElement.data.name, uniform)
        ), parsed = !0;
        break;
      }
    }
    if (!parsed)
      if (uboElement.data.size > 1) {
        const size2 = mapSize.mapSize(uboElement.data.type), rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1), elementSize = size2 / rowSize, remainder = (4 - elementSize % 4) % 4;
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};

                t = 0;

                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                {
                    for(var j = 0; j < ${elementSize}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${remainder};
                }

                `);
      } else {
        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};
                ${template};
                `);
      }
  }
  return funcFragments.push(`
       renderer.buffer.update(buffer);
    `), {
    size,
    // eslint-disable-next-line no-new-func
    syncFunc: new Function(
      "ud",
      "uv",
      "renderer",
      "syncData",
      "buffer",
      funcFragments.join(`
`)
    )
  };
}
exports.createUBOElements = createUBOElements;
exports.generateUniformBufferSync = generateUniformBufferSync;
exports.getUBOData = getUBOData;
//# sourceMappingURL=generateUniformBufferSync.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var uniformParsers = __webpack_require__(/*! ./uniformParsers.js */ "./node_modules/@pixi/core/lib/shader/utils/uniformParsers.js");
const GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
}, GLSL_TO_ARRAY_SETTERS = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (const i in group.uniforms) {
    const data = uniformData[i];
    if (!data) {
      group.uniforms[i]?.group === !0 && (group.uniforms[i].ubo ? funcFragments.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');
                    `) : funcFragments.push(`
                        renderer.shader.syncUniformGroup(uv.${i}, syncData);
                    `));
      continue;
    }
    const uniform = group.uniforms[i];
    let parsed = !1;
    for (let j = 0; j < uniformParsers.uniformParsers.length; j++)
      if (uniformParsers.uniformParsers[j].test(data, uniform)) {
        funcFragments.push(uniformParsers.uniformParsers[j].code(i, uniform)), parsed = !0;
        break;
      }
    if (!parsed) {
      const template = (data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS)[data.type].replace("location", `ud["${i}"].location`);
      funcFragments.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join(`
`));
}
exports.generateUniformsSync = generateUniformsSync;
//# sourceMappingURL=generateUniformsSync.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/getAttributeData.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/getAttributeData.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var mapSize = __webpack_require__(/*! ./mapSize.js */ "./node_modules/@pixi/core/lib/shader/utils/mapSize.js"), mapType = __webpack_require__(/*! ./mapType.js */ "./node_modules/@pixi/core/lib/shader/utils/mapType.js");
function getAttributeData(program, gl) {
  const attributes = {}, totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < totalAttributes; i++) {
    const attribData = gl.getActiveAttrib(program, i);
    if (attribData.name.startsWith("gl_"))
      continue;
    const type = mapType.mapType(gl, attribData.type), data = {
      type,
      name: attribData.name,
      size: mapSize.mapSize(type),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}
exports.getAttributeData = getAttributeData;
//# sourceMappingURL=getAttributeData.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), getTestContext = __webpack_require__(/*! ./getTestContext.js */ "./node_modules/@pixi/core/lib/shader/utils/getTestContext.js");
let maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = constants.PRECISION.MEDIUM;
    const gl = getTestContext.getTestContext();
    if (gl && gl.getShaderPrecisionFormat) {
      const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
      shaderFragment && (maxFragmentPrecision = shaderFragment.precision ? constants.PRECISION.HIGH : constants.PRECISION.MEDIUM);
    }
  }
  return maxFragmentPrecision;
}
exports.getMaxFragmentPrecision = getMaxFragmentPrecision;
//# sourceMappingURL=getMaxFragmentPrecision.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/getTestContext.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/getTestContext.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js");
const unknownContext = {};
let context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context?.isContextLost()) {
    const canvas = settings.settings.ADAPTER.createCanvas();
    let gl;
    settings.settings.PREFER_ENV >= constants.ENV.WEBGL2 && (gl = canvas.getContext("webgl2", {})), gl || (gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {}), gl ? gl.getExtension("WEBGL_draw_buffers") : gl = null), context = gl;
  }
  return context;
}
exports.getTestContext = getTestContext;
//# sourceMappingURL=getTestContext.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/getUniformData.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/getUniformData.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var defaultValue = __webpack_require__(/*! ./defaultValue.js */ "./node_modules/@pixi/core/lib/shader/utils/defaultValue.js"), mapType = __webpack_require__(/*! ./mapType.js */ "./node_modules/@pixi/core/lib/shader/utils/mapType.js");
function getUniformData(program, gl) {
  const uniforms = {}, totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i = 0; i < totalUniforms; i++) {
    const uniformData = gl.getActiveUniform(program, i), name = uniformData.name.replace(/\[.*?\]$/, ""), isArray = !!uniformData.name.match(/\[.*?\]$/), type = mapType.mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i,
      type,
      size: uniformData.size,
      isArray,
      value: defaultValue.defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
}
exports.getUniformData = getUniformData;
//# sourceMappingURL=getUniformData.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var checkMaxIfStatementsInShader = __webpack_require__(/*! ./checkMaxIfStatementsInShader.js */ "./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.js"), compileShader = __webpack_require__(/*! ./compileShader.js */ "./node_modules/@pixi/core/lib/shader/utils/compileShader.js"), defaultValue = __webpack_require__(/*! ./defaultValue.js */ "./node_modules/@pixi/core/lib/shader/utils/defaultValue.js"), generateUniformsSync = __webpack_require__(/*! ./generateUniformsSync.js */ "./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.js"), getMaxFragmentPrecision = __webpack_require__(/*! ./getMaxFragmentPrecision.js */ "./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.js"), getTestContext = __webpack_require__(/*! ./getTestContext.js */ "./node_modules/@pixi/core/lib/shader/utils/getTestContext.js"), logProgramError = __webpack_require__(/*! ./logProgramError.js */ "./node_modules/@pixi/core/lib/shader/utils/logProgramError.js"), mapSize = __webpack_require__(/*! ./mapSize.js */ "./node_modules/@pixi/core/lib/shader/utils/mapSize.js"), mapType = __webpack_require__(/*! ./mapType.js */ "./node_modules/@pixi/core/lib/shader/utils/mapType.js"), setPrecision = __webpack_require__(/*! ./setPrecision.js */ "./node_modules/@pixi/core/lib/shader/utils/setPrecision.js"), uniformParsers = __webpack_require__(/*! ./uniformParsers.js */ "./node_modules/@pixi/core/lib/shader/utils/uniformParsers.js"), unsafeEvalSupported = __webpack_require__(/*! ./unsafeEvalSupported.js */ "./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js");
exports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader;
exports.compileShader = compileShader.compileShader;
exports.defaultValue = defaultValue.defaultValue;
exports.generateUniformsSync = generateUniformsSync.generateUniformsSync;
exports.getMaxFragmentPrecision = getMaxFragmentPrecision.getMaxFragmentPrecision;
exports.getTestContext = getTestContext.getTestContext;
exports.logProgramError = logProgramError.logProgramError;
exports.mapSize = mapSize.mapSize;
exports.mapType = mapType.mapType;
exports.setPrecision = setPrecision.setPrecision;
exports.uniformParsers = uniformParsers.uniformParsers;
exports.unsafeEvalSupported = unsafeEvalSupported.unsafeEvalSupported;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/logProgramError.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/logProgramError.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split(`
`).map((line, index) => `${index}: ${line}`), shaderLog = gl.getShaderInfoLog(shader), splitShader = shaderLog.split(`
`), dedupe = {}, lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n) => n && !dedupe[n] ? (dedupe[n] = !0, !0) : !1), logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`, logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join(`
`);
  logArgs[0] = fragmentSourceToLog, console.error(shaderLog), console.groupCollapsed("click to view full shader code"), console.warn(...logArgs), console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  gl.getProgramParameter(program, gl.LINK_STATUS) || (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) || logPrettyShaderError(gl, vertexShader), gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) || logPrettyShaderError(gl, fragmentShader), console.error("PixiJS Error: Could not initialize shader."), gl.getProgramInfoLog(program) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program)));
}
exports.logProgramError = logProgramError;
//# sourceMappingURL=logProgramError.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/mapSize.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/mapSize.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type) {
  return GLSL_TO_SIZE[type];
}
exports.mapSize = mapSize;
//# sourceMappingURL=mapSize.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/mapType.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/mapType.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

let GL_TABLE = null;
const GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(gl, type) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i = 0; i < typeNames.length; ++i) {
      const tn = typeNames[i];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}
exports.mapType = mapType;
//# sourceMappingURL=mapType.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/setPrecision.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/setPrecision.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js");
function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    let precision = requestedPrecision;
    return requestedPrecision === constants.PRECISION.HIGH && maxSupportedPrecision !== constants.PRECISION.HIGH && (precision = constants.PRECISION.MEDIUM), `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== constants.PRECISION.HIGH && src.substring(0, 15) === "precision highp")
    return src.replace("precision highp", "precision mediump");
  return src;
}
exports.setPrecision = setPrecision;
//# sourceMappingURL=setPrecision.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/uniformParsers.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/uniformParsers.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const uniformParsers = [
  // a float cache layer
  {
    test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
    code: (name) => `
            if(uv["${name}"] !== ud["${name}"].value)
            {
                ud["${name}"].value = uv["${name}"]
                gl.uniform1f(ud["${name}"].location, uv["${name}"])
            }
            `
  },
  // handling samplers
  {
    test: (data, uniform) => (
      // eslint-disable-next-line max-len,no-eq-null,eqeqeq
      (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0)
    ),
    code: (name) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name}"], t);

            if(ud["${name}"].value !== t)
            {
                ud["${name}"].value = t;
                gl.uniform1i(ud["${name}"].location, t);
; // eslint-disable-line max-len
            }`
  },
  // uploading pixi matrix object to mat3
  {
    test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
    code: (name) => (
      // TODO and some smart caching dirty ids here!
      `
            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));
            `
    ),
    codeUbo: (name) => `
                var ${name}_matrix = uv.${name}.toArray(true);

                data[offset] = ${name}_matrix[0];
                data[offset+1] = ${name}_matrix[1];
                data[offset+2] = ${name}_matrix[2];
        
                data[offset + 4] = ${name}_matrix[3];
                data[offset + 5] = ${name}_matrix[4];
                data[offset + 6] = ${name}_matrix[5];
        
                data[offset + 8] = ${name}_matrix[6];
                data[offset + 9] = ${name}_matrix[7];
                data[offset + 10] = ${name}_matrix[8];
            `
  },
  // uploading a pixi point as a vec2 with caching layer
  {
    test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name}"].location, v.x, v.y);
                }`,
    codeUbo: (name) => `
                v = uv.${name};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
  },
  // caching layer for a vec2
  {
    test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);
                }
            `
  },
  // upload a pixi rectangle as a vec4 with caching layer
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
  },
  // upload a pixi color as vec4 with caching layer
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `
  },
  // upload a pixi color as a vec3 with caching layer
  {
    test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `
  },
  // a caching layer for vec4 uploading
  {
    test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
                }`
  }
];
exports.uniformParsers = uniformParsers;
//# sourceMappingURL=uniformParsers.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

let unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval == "boolean")
    return unsafeEval;
  try {
    unsafeEval = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({ a: "b" }, "a", "b") === !0;
  } catch {
    unsafeEval = !1;
  }
  return unsafeEval;
}
exports.unsafeEvalSupported = unsafeEvalSupported;
//# sourceMappingURL=unsafeEvalSupported.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/startup/StartupSystem.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/startup/StartupSystem.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js");
class StartupSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  /**
   * It all starts here! This initiates every system, passing in the options for any system by name.
   * @param options - the config for the renderer and all its systems
   */
  run(options) {
    const { renderer } = this;
    renderer.runners.init.emit(renderer.options), options.hello && console.log(`PixiJS 7.3.2 - ${renderer.rendererLogId} - https://pixijs.com`), renderer.resize(renderer.screen.width, renderer.screen.height);
  }
  destroy() {
  }
}
StartupSystem.defaultOptions = {
  /**
   * {@link PIXI.IRendererOptions.hello}
   * @default false
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  hello: !1
}, /** @ignore */
StartupSystem.extension = {
  type: [
    extensions.ExtensionType.RendererSystem,
    extensions.ExtensionType.CanvasRendererSystem
  ],
  name: "startup"
};
extensions.extensions.add(StartupSystem);
exports.StartupSystem = StartupSystem;
//# sourceMappingURL=StartupSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/state/State.js":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/core/lib/state/State.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js");
const BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5;
class State {
  constructor() {
    this.data = 0, this.blendMode = constants.BLEND_MODES.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;
  }
  /**
   * Activates blending of the computed fragment color values.
   * @default true
   */
  get blend() {
    return !!(this.data & 1 << BLEND);
  }
  set blend(value) {
    !!(this.data & 1 << BLEND) !== value && (this.data ^= 1 << BLEND);
  }
  /**
   * Activates adding an offset to depth values of polygon's fragments
   * @default false
   */
  get offsets() {
    return !!(this.data & 1 << OFFSET);
  }
  set offsets(value) {
    !!(this.data & 1 << OFFSET) !== value && (this.data ^= 1 << OFFSET);
  }
  /**
   * Activates culling of polygons.
   * @default false
   */
  get culling() {
    return !!(this.data & 1 << CULLING);
  }
  set culling(value) {
    !!(this.data & 1 << CULLING) !== value && (this.data ^= 1 << CULLING);
  }
  /**
   * Activates depth comparisons and updates to the depth buffer.
   * @default false
   */
  get depthTest() {
    return !!(this.data & 1 << DEPTH_TEST);
  }
  set depthTest(value) {
    !!(this.data & 1 << DEPTH_TEST) !== value && (this.data ^= 1 << DEPTH_TEST);
  }
  /**
   * Enables or disables writing to the depth buffer.
   * @default true
   */
  get depthMask() {
    return !!(this.data & 1 << DEPTH_MASK);
  }
  set depthMask(value) {
    !!(this.data & 1 << DEPTH_MASK) !== value && (this.data ^= 1 << DEPTH_MASK);
  }
  /**
   * Specifies whether or not front or back-facing polygons can be culled.
   * @default false
   */
  get clockwiseFrontFace() {
    return !!(this.data & 1 << WINDING);
  }
  set clockwiseFrontFace(value) {
    !!(this.data & 1 << WINDING) !== value && (this.data ^= 1 << WINDING);
  }
  /**
   * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
   * @default PIXI.BLEND_MODES.NORMAL
   */
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(value) {
    this.blend = value !== constants.BLEND_MODES.NONE, this._blendMode = value;
  }
  /**
   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
   * @default 0
   */
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(value) {
    this.offsets = !!value, this._polygonOffset = value;
  }
  static for2d() {
    const state = new State();
    return state.depthTest = !1, state.blend = !0, state;
  }
}
State.prototype.toString = function() {
  return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
};
exports.State = State;
//# sourceMappingURL=State.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/state/StateSystem.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/state/StateSystem.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), State = __webpack_require__(/*! ./State.js */ "./node_modules/@pixi/core/lib/state/State.js"), mapWebGLBlendModesToPixi = __webpack_require__(/*! ./utils/mapWebGLBlendModesToPixi.js */ "./node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.js");
const BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5, _StateSystem = class _StateSystem2 {
  constructor() {
    this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = constants.BLEND_MODES.NONE, this._blendEq = !1, this.map = [], this.map[BLEND] = this.setBlend, this.map[OFFSET] = this.setOffset, this.map[CULLING] = this.setCullFace, this.map[DEPTH_TEST] = this.setDepthTest, this.map[WINDING] = this.setFrontFace, this.map[DEPTH_MASK] = this.setDepthMask, this.checks = [], this.defaultState = new State.State(), this.defaultState.blend = !0;
  }
  contextChange(gl) {
    this.gl = gl, this.blendModes = mapWebGLBlendModesToPixi.mapWebGLBlendModesToPixi(gl), this.set(this.defaultState), this.reset();
  }
  /**
   * Sets the current state
   * @param {*} state - The state to set.
   */
  set(state) {
    if (state = state || this.defaultState, this.stateId !== state.data) {
      let diff = this.stateId ^ state.data, i = 0;
      for (; diff; )
        diff & 1 && this.map[i].call(this, !!(state.data & 1 << i)), diff = diff >> 1, i++;
      this.stateId = state.data;
    }
    for (let i = 0; i < this.checks.length; i++)
      this.checks[i](this, state);
  }
  /**
   * Sets the state, when previous state is unknown.
   * @param {*} state - The state to set
   */
  forceState(state) {
    state = state || this.defaultState;
    for (let i = 0; i < this.map.length; i++)
      this.map[i].call(this, !!(state.data & 1 << i));
    for (let i = 0; i < this.checks.length; i++)
      this.checks[i](this, state);
    this.stateId = state.data;
  }
  /**
   * Sets whether to enable or disable blending.
   * @param value - Turn on or off WebGl blending.
   */
  setBlend(value) {
    this.updateCheck(_StateSystem2.checkBlendMode, value), this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  }
  /**
   * Sets whether to enable or disable polygon offset fill.
   * @param value - Turn on or off webgl polygon offset testing.
   */
  setOffset(value) {
    this.updateCheck(_StateSystem2.checkPolygonOffset, value), this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }
  /**
   * Sets whether to enable or disable depth test.
   * @param value - Turn on or off webgl depth testing.
   */
  setDepthTest(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }
  /**
   * Sets whether to enable or disable depth mask.
   * @param value - Turn on or off webgl depth mask.
   */
  setDepthMask(value) {
    this.gl.depthMask(value);
  }
  /**
   * Sets whether to enable or disable cull face.
   * @param {boolean} value - Turn on or off webgl cull face.
   */
  setCullFace(value) {
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
  }
  /**
   * Sets the gl front face.
   * @param {boolean} value - true is clockwise and false is counter-clockwise
   */
  setFrontFace(value) {
    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
  }
  /**
   * Sets the blend mode.
   * @param {number} value - The blend mode to set to.
   */
  setBlendMode(value) {
    if (value === this.blendMode)
      return;
    this.blendMode = value;
    const mode = this.blendModes[value], gl = this.gl;
    mode.length === 2 ? gl.blendFunc(mode[0], mode[1]) : gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]), mode.length === 6 ? (this._blendEq = !0, gl.blendEquationSeparate(mode[4], mode[5])) : this._blendEq && (this._blendEq = !1, gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD));
  }
  /**
   * Sets the polygon offset.
   * @param {number} value - the polygon offset
   * @param {number} scale - the polygon offset scale
   */
  setPolygonOffset(value, scale) {
    this.gl.polygonOffset(value, scale);
  }
  // used
  /** Resets all the logic and disables the VAOs. */
  reset() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);
  }
  /**
   * Checks to see which updates should be checked based on which settings have been activated.
   *
   * For example, if blend is enabled then we should check the blend modes each time the state is changed
   * or if polygon fill is activated then we need to check if the polygon offset changes.
   * The idea is that we only check what we have too.
   * @param func - the checking function to add or remove
   * @param value - should the check function be added or removed.
   */
  updateCheck(func, value) {
    const index = this.checks.indexOf(func);
    value && index === -1 ? this.checks.push(func) : !value && index !== -1 && this.checks.splice(index, 1);
  }
  /**
   * A private little wrapper function that we call to check the blend mode.
   * @param system - the System to perform the state check on
   * @param state - the state that the blendMode will pulled from
   */
  static checkBlendMode(system, state) {
    system.setBlendMode(state.blendMode);
  }
  /**
   * A private little wrapper function that we call to check the polygon offset.
   * @param system - the System to perform the state check on
   * @param state - the state that the blendMode will pulled from
   */
  static checkPolygonOffset(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  }
  /**
   * @ignore
   */
  destroy() {
    this.gl = null;
  }
};
_StateSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "state"
};
let StateSystem = _StateSystem;
extensions.extensions.add(StateSystem);
exports.StateSystem = StateSystem;
//# sourceMappingURL=StateSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js");
function mapWebGLBlendModesToPixi(gl, array = []) {
  return array[constants.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.ADD] = [gl.ONE, gl.ONE], array[constants.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.NONE] = [0, 0], array[constants.BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE], array[constants.BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO], array[constants.BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO], array[constants.BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE], array[constants.BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA], array[constants.BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA], array[constants.BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA], array[constants.BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD], array;
}
exports.mapWebGLBlendModesToPixi = mapWebGLBlendModesToPixi;
//# sourceMappingURL=mapWebGLBlendModesToPixi.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/system/ISystem.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/core/lib/system/ISystem.js ***!
  \*******************************************************/
/***/ (() => {

"use strict";

//# sourceMappingURL=ISystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/system/SystemManager.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/system/SystemManager.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.js"), utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js");
class SystemManager extends utils.EventEmitter {
  constructor() {
    super(...arguments), this.runners = {}, this._systemsHash = {};
  }
  /**
   * Set up a system with a collection of SystemClasses and runners.
   * Systems are attached dynamically to this class when added.
   * @param config - the config for the system manager
   */
  setup(config) {
    this.addRunners(...config.runners);
    const priority = (config.priority ?? []).filter((key) => config.systems[key]), orderByPriority = [
      ...priority,
      ...Object.keys(config.systems).filter((key) => !priority.includes(key))
    ];
    for (const i of orderByPriority)
      this.addSystem(config.systems[i], i);
  }
  /**
   * Create a bunch of runners based of a collection of ids
   * @param runnerIds - the runner ids to add
   */
  addRunners(...runnerIds) {
    runnerIds.forEach((runnerId) => {
      this.runners[runnerId] = new runner.Runner(runnerId);
    });
  }
  /**
   * Add a new system to the renderer.
   * @param ClassRef - Class reference
   * @param name - Property name for system, if not specified
   *        will use a static `name` property on the class itself. This
   *        name will be assigned as s property on the Renderer so make
   *        sure it doesn't collide with properties on Renderer.
   * @returns Return instance of renderer
   */
  addSystem(ClassRef, name) {
    const system = new ClassRef(this);
    if (this[name])
      throw new Error(`Whoops! The name "${name}" is already in use`);
    this[name] = system, this._systemsHash[name] = system;
    for (const i in this.runners)
      this.runners[i].add(system);
    return this;
  }
  /**
   * A function that will run a runner and call the runners function but pass in different options
   * to each system based on there name.
   *
   * E.g. If you have two systems added called `systemA` and `systemB` you could call do the following:
   *
   * ```js
   * system.emitWithCustomOptions(init, {
   *     systemA: {...optionsForA},
   *     systemB: {...optionsForB},
   * });
   * ```
   *
   * `init` would be called on system A passing `optionsForA` and on system B passing `optionsForB`.
   * @param runner - the runner to target
   * @param options - key value options for each system
   */
  emitWithCustomOptions(runner2, options) {
    const systemHashKeys = Object.keys(this._systemsHash);
    runner2.items.forEach((system) => {
      const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);
      system[runner2.name](options[systemName]);
    });
  }
  /** destroy the all runners and systems. Its apps job to */
  destroy() {
    Object.values(this.runners).forEach((runner2) => {
      runner2.destroy();
    }), this._systemsHash = {};
  }
  // TODO implement!
  // removeSystem(ClassRef: ISystemConstructor, name: string): void
  // {
  // }
}
exports.SystemManager = SystemManager;
//# sourceMappingURL=SystemManager.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/systems.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/core/lib/systems.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var BackgroundSystem = __webpack_require__(/*! ./background/BackgroundSystem.js */ "./node_modules/@pixi/core/lib/background/BackgroundSystem.js"), BatchSystem = __webpack_require__(/*! ./batch/BatchSystem.js */ "./node_modules/@pixi/core/lib/batch/BatchSystem.js"), ContextSystem = __webpack_require__(/*! ./context/ContextSystem.js */ "./node_modules/@pixi/core/lib/context/ContextSystem.js"), FilterSystem = __webpack_require__(/*! ./filters/FilterSystem.js */ "./node_modules/@pixi/core/lib/filters/FilterSystem.js"), FramebufferSystem = __webpack_require__(/*! ./framebuffer/FramebufferSystem.js */ "./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.js"), GeometrySystem = __webpack_require__(/*! ./geometry/GeometrySystem.js */ "./node_modules/@pixi/core/lib/geometry/GeometrySystem.js"), MaskSystem = __webpack_require__(/*! ./mask/MaskSystem.js */ "./node_modules/@pixi/core/lib/mask/MaskSystem.js"), ScissorSystem = __webpack_require__(/*! ./mask/ScissorSystem.js */ "./node_modules/@pixi/core/lib/mask/ScissorSystem.js"), StencilSystem = __webpack_require__(/*! ./mask/StencilSystem.js */ "./node_modules/@pixi/core/lib/mask/StencilSystem.js"), PluginSystem = __webpack_require__(/*! ./plugin/PluginSystem.js */ "./node_modules/@pixi/core/lib/plugin/PluginSystem.js"), ProjectionSystem = __webpack_require__(/*! ./projection/ProjectionSystem.js */ "./node_modules/@pixi/core/lib/projection/ProjectionSystem.js"), GenerateTextureSystem = __webpack_require__(/*! ./renderTexture/GenerateTextureSystem.js */ "./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.js"), RenderTextureSystem = __webpack_require__(/*! ./renderTexture/RenderTextureSystem.js */ "./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.js"), ShaderSystem = __webpack_require__(/*! ./shader/ShaderSystem.js */ "./node_modules/@pixi/core/lib/shader/ShaderSystem.js"), StartupSystem = __webpack_require__(/*! ./startup/StartupSystem.js */ "./node_modules/@pixi/core/lib/startup/StartupSystem.js"), StateSystem = __webpack_require__(/*! ./state/StateSystem.js */ "./node_modules/@pixi/core/lib/state/StateSystem.js"), SystemManager = __webpack_require__(/*! ./system/SystemManager.js */ "./node_modules/@pixi/core/lib/system/SystemManager.js"), TextureGCSystem = __webpack_require__(/*! ./textures/TextureGCSystem.js */ "./node_modules/@pixi/core/lib/textures/TextureGCSystem.js"), TextureSystem = __webpack_require__(/*! ./textures/TextureSystem.js */ "./node_modules/@pixi/core/lib/textures/TextureSystem.js"), TransformFeedbackSystem = __webpack_require__(/*! ./transformFeedback/TransformFeedbackSystem.js */ "./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.js"), ViewSystem = __webpack_require__(/*! ./view/ViewSystem.js */ "./node_modules/@pixi/core/lib/view/ViewSystem.js");
exports.BackgroundSystem = BackgroundSystem.BackgroundSystem;
exports.BatchSystem = BatchSystem.BatchSystem;
exports.ContextSystem = ContextSystem.ContextSystem;
exports.FilterSystem = FilterSystem.FilterSystem;
exports.FramebufferSystem = FramebufferSystem.FramebufferSystem;
exports.GeometrySystem = GeometrySystem.GeometrySystem;
exports.MaskSystem = MaskSystem.MaskSystem;
exports.ScissorSystem = ScissorSystem.ScissorSystem;
exports.StencilSystem = StencilSystem.StencilSystem;
exports.PluginSystem = PluginSystem.PluginSystem;
exports.ProjectionSystem = ProjectionSystem.ProjectionSystem;
exports.GenerateTextureSystem = GenerateTextureSystem.GenerateTextureSystem;
exports.RenderTextureSystem = RenderTextureSystem.RenderTextureSystem;
exports.ShaderSystem = ShaderSystem.ShaderSystem;
exports.StartupSystem = StartupSystem.StartupSystem;
exports.StateSystem = StateSystem.StateSystem;
exports.SystemManager = SystemManager.SystemManager;
exports.TextureGCSystem = TextureGCSystem.TextureGCSystem;
exports.TextureSystem = TextureSystem.TextureSystem;
exports.TransformFeedbackSystem = TransformFeedbackSystem.TransformFeedbackSystem;
exports.ViewSystem = ViewSystem.ViewSystem;
//# sourceMappingURL=systems.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/BaseTexture.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/BaseTexture.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js"), utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js"), autoDetectResource = __webpack_require__(/*! ./resources/autoDetectResource.js */ "./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js"), BufferResource = __webpack_require__(/*! ./resources/BufferResource.js */ "./node_modules/@pixi/core/lib/textures/resources/BufferResource.js"), Resource = __webpack_require__(/*! ./resources/Resource.js */ "./node_modules/@pixi/core/lib/textures/resources/Resource.js");
const defaultBufferOptions = {
  scaleMode: constants.SCALE_MODES.NEAREST,
  alphaMode: constants.ALPHA_MODES.NPM
}, _BaseTexture = class _BaseTexture2 extends utils.EventEmitter {
  /**
   * @param {PIXI.Resource|HTMLImageElement|HTMLVideoElement|ImageBitmap|ICanvas|string} [resource=null] -
   *        The current resource to use, for things that aren't Resource objects, will be converted
   *        into a Resource.
   * @param options - Collection of options, default options inherited from {@link PIXI.BaseTexture.defaultOptions}.
   * @param {PIXI.MIPMAP_MODES} [options.mipmap] - If mipmapping is enabled for texture
   * @param {number} [options.anisotropicLevel] - Anisotropic filtering level of texture
   * @param {PIXI.WRAP_MODES} [options.wrapMode] - Wrap mode for textures
   * @param {PIXI.SCALE_MODES} [options.scaleMode] - Default scale mode, linear, nearest
   * @param {PIXI.FORMATS} [options.format] - GL format type
   * @param {PIXI.TYPES} [options.type] - GL data type
   * @param {PIXI.TARGETS} [options.target] - GL texture target
   * @param {PIXI.ALPHA_MODES} [options.alphaMode] - Pre multiply the image alpha
   * @param {number} [options.width=0] - Width of the texture
   * @param {number} [options.height=0] - Height of the texture
   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - Resolution of the base texture
   * @param {object} [options.resourceOptions] - Optional resource options,
   *        see {@link PIXI.autoDetectResource autoDetectResource}
   */
  constructor(resource = null, options = null) {
    super(), options = Object.assign({}, _BaseTexture2.defaultOptions, options);
    const {
      alphaMode,
      mipmap,
      anisotropicLevel,
      scaleMode,
      width,
      height,
      wrapMode,
      format,
      type,
      target,
      resolution,
      resourceOptions
    } = options;
    resource && !(resource instanceof Resource.Resource) && (resource = autoDetectResource.autoDetectResource(resource, resourceOptions), resource.internal = !0), this.resolution = resolution || settings.settings.RESOLUTION, this.width = Math.round((width || 0) * this.resolution) / this.resolution, this.height = Math.round((height || 0) * this.resolution) / this.resolution, this._mipmap = mipmap, this.anisotropicLevel = anisotropicLevel, this._wrapMode = wrapMode, this._scaleMode = scaleMode, this.format = format, this.type = type, this.target = target, this.alphaMode = alphaMode, this.uid = utils.uid(), this.touched = 0, this.isPowerOfTwo = !1, this._refreshPOT(), this._glTextures = {}, this.dirtyId = 0, this.dirtyStyleId = 0, this.cacheId = null, this.valid = width > 0 && height > 0, this.textureCacheIds = [], this.destroyed = !1, this.resource = null, this._batchEnabled = 0, this._batchLocation = 0, this.parentTextureArray = null, this.setResource(resource);
  }
  /**
   * Pixel width of the source of this texture
   * @readonly
   */
  get realWidth() {
    return Math.round(this.width * this.resolution);
  }
  /**
   * Pixel height of the source of this texture
   * @readonly
   */
  get realHeight() {
    return Math.round(this.height * this.resolution);
  }
  /**
   * Mipmap mode of the texture, affects downscaled images
   * @default PIXI.MIPMAP_MODES.POW2
   */
  get mipmap() {
    return this._mipmap;
  }
  set mipmap(value) {
    this._mipmap !== value && (this._mipmap = value, this.dirtyStyleId++);
  }
  /**
   * The scale mode to apply when scaling this texture
   * @default PIXI.SCALE_MODES.LINEAR
   */
  get scaleMode() {
    return this._scaleMode;
  }
  set scaleMode(value) {
    this._scaleMode !== value && (this._scaleMode = value, this.dirtyStyleId++);
  }
  /**
   * How the texture wraps
   * @default PIXI.WRAP_MODES.CLAMP
   */
  get wrapMode() {
    return this._wrapMode;
  }
  set wrapMode(value) {
    this._wrapMode !== value && (this._wrapMode = value, this.dirtyStyleId++);
  }
  /**
   * Changes style options of BaseTexture
   * @param scaleMode - Pixi scalemode
   * @param mipmap - enable mipmaps
   * @returns - this
   */
  setStyle(scaleMode, mipmap) {
    let dirty;
    return scaleMode !== void 0 && scaleMode !== this.scaleMode && (this.scaleMode = scaleMode, dirty = !0), mipmap !== void 0 && mipmap !== this.mipmap && (this.mipmap = mipmap, dirty = !0), dirty && this.dirtyStyleId++, this;
  }
  /**
   * Changes w/h/resolution. Texture becomes valid if width and height are greater than zero.
   * @param desiredWidth - Desired visual width
   * @param desiredHeight - Desired visual height
   * @param resolution - Optionally set resolution
   * @returns - this
   */
  setSize(desiredWidth, desiredHeight, resolution) {
    return resolution = resolution || this.resolution, this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
  }
  /**
   * Sets real size of baseTexture, preserves current resolution.
   * @param realWidth - Full rendered width
   * @param realHeight - Full rendered height
   * @param resolution - Optionally set resolution
   * @returns - this
   */
  setRealSize(realWidth, realHeight, resolution) {
    return this.resolution = resolution || this.resolution, this.width = Math.round(realWidth) / this.resolution, this.height = Math.round(realHeight) / this.resolution, this._refreshPOT(), this.update(), this;
  }
  /**
   * Refresh check for isPowerOfTwo texture based on size
   * @private
   */
  _refreshPOT() {
    this.isPowerOfTwo = utils.isPow2(this.realWidth) && utils.isPow2(this.realHeight);
  }
  /**
   * Changes resolution
   * @param resolution - res
   * @returns - this
   */
  setResolution(resolution) {
    const oldResolution = this.resolution;
    return oldResolution === resolution ? this : (this.resolution = resolution, this.valid && (this.width = Math.round(this.width * oldResolution) / resolution, this.height = Math.round(this.height * oldResolution) / resolution, this.emit("update", this)), this._refreshPOT(), this);
  }
  /**
   * Sets the resource if it wasn't set. Throws error if resource already present
   * @param resource - that is managing this BaseTexture
   * @returns - this
   */
  setResource(resource) {
    if (this.resource === resource)
      return this;
    if (this.resource)
      throw new Error("Resource can be set only once");
    return resource.bind(this), this.resource = resource, this;
  }
  /** Invalidates the object. Texture becomes valid if width and height are greater than zero. */
  update() {
    this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this));
  }
  /**
   * Handle errors with resources.
   * @private
   * @param event - Error event emitted.
   */
  onError(event) {
    this.emit("error", this, event);
  }
  /**
   * Destroys this base texture.
   * The method stops if resource doesn't want this texture to be destroyed.
   * Removes texture from all caches.
   * @fires PIXI.BaseTexture#destroyed
   */
  destroy() {
    this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete utils.BaseTextureCache[this.cacheId], delete utils.TextureCache[this.cacheId], this.cacheId = null), this.valid = !1, this.dispose(), _BaseTexture2.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0, this.emit("destroyed", this), this.removeAllListeners();
  }
  /**
   * Frees the texture from WebGL memory without destroying this texture object.
   * This means you can still use the texture later which will upload it to GPU
   * memory again.
   * @fires PIXI.BaseTexture#dispose
   */
  dispose() {
    this.emit("dispose", this);
  }
  /** Utility function for BaseTexture|Texture cast. */
  castToBaseTexture() {
    return this;
  }
  /**
   * Helper function that creates a base texture based on the source you provide.
   * The source can be - image url, image element, canvas element. If the
   * source is an image url or an image element and not in the base texture
   * cache, it will be created and loaded.
   * @static
   * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas|string|string[]} source - The
   *        source to create base texture from.
   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.
   * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id
   * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.
   * @returns {PIXI.BaseTexture} The new base texture.
   */
  static from(source, options, strict = settings.settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source == "string";
    let cacheId = null;
    if (isFrame)
      cacheId = source;
    else {
      if (!source._pixiId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source._pixiId = `${prefix}_${utils.uid()}`;
      }
      cacheId = source._pixiId;
    }
    let baseTexture = utils.BaseTextureCache[cacheId];
    if (isFrame && strict && !baseTexture)
      throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);
    return baseTexture || (baseTexture = new _BaseTexture2(source, options), baseTexture.cacheId = cacheId, _BaseTexture2.addToCache(baseTexture, cacheId)), baseTexture;
  }
  /**
   * Create a new Texture with a BufferResource from a typed array.
   * @param buffer - The optional array to use. If no data is provided, a new Float32Array is created.
   * @param width - Width of the resource
   * @param height - Height of the resource
   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.
   *        Default properties are different from the constructor's defaults.
   * @param {PIXI.FORMATS} [options.format] - The format is not given, the type is inferred from the
   *        type of the buffer: `RGBA` if Float32Array, Int8Array, Uint8Array, or Uint8ClampedArray,
   *        otherwise `RGBA_INTEGER`.
   * @param {PIXI.TYPES} [options.type] - The type is not given, the type is inferred from the
   *        type of the buffer. Maps Float32Array to `FLOAT`, Int32Array to `INT`, Uint32Array to
   *        `UNSIGNED_INT`, Int16Array to `SHORT`, Uint16Array to `UNSIGNED_SHORT`, Int8Array to `BYTE`,
   *        Uint8Array/Uint8ClampedArray to `UNSIGNED_BYTE`.
   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.NPM]
   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.SCALE_MODES.NEAREST]
   * @returns - The resulting new BaseTexture
   */
  static fromBuffer(buffer, width, height, options) {
    buffer = buffer || new Float32Array(width * height * 4);
    const resource = new BufferResource.BufferResource(buffer, { width, height, ...options?.resourceOptions });
    let format, type;
    return buffer instanceof Float32Array ? (format = constants.FORMATS.RGBA, type = constants.TYPES.FLOAT) : buffer instanceof Int32Array ? (format = constants.FORMATS.RGBA_INTEGER, type = constants.TYPES.INT) : buffer instanceof Uint32Array ? (format = constants.FORMATS.RGBA_INTEGER, type = constants.TYPES.UNSIGNED_INT) : buffer instanceof Int16Array ? (format = constants.FORMATS.RGBA_INTEGER, type = constants.TYPES.SHORT) : buffer instanceof Uint16Array ? (format = constants.FORMATS.RGBA_INTEGER, type = constants.TYPES.UNSIGNED_SHORT) : buffer instanceof Int8Array ? (format = constants.FORMATS.RGBA, type = constants.TYPES.BYTE) : (format = constants.FORMATS.RGBA, type = constants.TYPES.UNSIGNED_BYTE), resource.internal = !0, new _BaseTexture2(resource, Object.assign({}, defaultBufferOptions, { type, format }, options));
  }
  /**
   * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.
   * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.
   * @param {string} id - The id that the BaseTexture will be stored against.
   */
  static addToCache(baseTexture, id) {
    id && (baseTexture.textureCacheIds.includes(id) || baseTexture.textureCacheIds.push(id), utils.BaseTextureCache[id] && utils.BaseTextureCache[id] !== baseTexture && console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`), utils.BaseTextureCache[id] = baseTexture);
  }
  /**
   * Remove a BaseTexture from the global BaseTextureCache.
   * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.
   * @returns {PIXI.BaseTexture|null} The BaseTexture that was removed.
   */
  static removeFromCache(baseTexture) {
    if (typeof baseTexture == "string") {
      const baseTextureFromCache = utils.BaseTextureCache[baseTexture];
      if (baseTextureFromCache) {
        const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
        return index > -1 && baseTextureFromCache.textureCacheIds.splice(index, 1), delete utils.BaseTextureCache[baseTexture], baseTextureFromCache;
      }
    } else if (baseTexture?.textureCacheIds) {
      for (let i = 0; i < baseTexture.textureCacheIds.length; ++i)
        delete utils.BaseTextureCache[baseTexture.textureCacheIds[i]];
      return baseTexture.textureCacheIds.length = 0, baseTexture;
    }
    return null;
  }
};
_BaseTexture.defaultOptions = {
  /**
   * If mipmapping is enabled for texture.
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  mipmap: constants.MIPMAP_MODES.POW2,
  /** Anisotropic filtering level of texture */
  anisotropicLevel: 0,
  /**
   * Default scale mode, linear, nearest.
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  scaleMode: constants.SCALE_MODES.LINEAR,
  /**
   * Wrap mode for textures.
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  wrapMode: constants.WRAP_MODES.CLAMP,
  /**
   * Pre multiply the image alpha
   * @type {PIXI.ALPHA_MODES}
   * @default PIXI.ALPHA_MODES.UNPACK
   */
  alphaMode: constants.ALPHA_MODES.UNPACK,
  /**
   * GL texture target
   * @type {PIXI.TARGETS}
   * @default PIXI.TARGETS.TEXTURE_2D
   */
  target: constants.TARGETS.TEXTURE_2D,
  /**
   * GL format type
   * @type {PIXI.FORMATS}
   * @default PIXI.FORMATS.RGBA
   */
  format: constants.FORMATS.RGBA,
  /**
   * GL data type
   * @type {PIXI.TYPES}
   * @default PIXI.TYPES.UNSIGNED_BYTE
   */
  type: constants.TYPES.UNSIGNED_BYTE
}, /** Global number of the texture batch, used by multi-texture renderers. */
_BaseTexture._globalBatch = 0;
let BaseTexture = _BaseTexture;
exports.BaseTexture = BaseTexture;
//# sourceMappingURL=BaseTexture.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/GLTexture.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/GLTexture.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js");
class GLTexture {
  constructor(texture) {
    this.texture = texture, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = constants.TYPES.UNSIGNED_BYTE, this.internalFormat = constants.FORMATS.RGBA, this.samplerType = 0;
  }
}
exports.GLTexture = GLTexture;
//# sourceMappingURL=GLTexture.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/Texture.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/Texture.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var math = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.js"), settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js"), utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js"), BaseTexture = __webpack_require__(/*! ./BaseTexture.js */ "./node_modules/@pixi/core/lib/textures/BaseTexture.js"), ImageResource = __webpack_require__(/*! ./resources/ImageResource.js */ "./node_modules/@pixi/core/lib/textures/resources/ImageResource.js"), TextureUvs = __webpack_require__(/*! ./TextureUvs.js */ "./node_modules/@pixi/core/lib/textures/TextureUvs.js");
const DEFAULT_UVS = new TextureUvs.TextureUvs();
function removeAllHandlers(tex) {
  tex.destroy = function() {
  }, tex.on = function() {
  }, tex.once = function() {
  }, tex.emit = function() {
  };
}
class Texture extends utils.EventEmitter {
  /**
   * @param baseTexture - The base texture source to create the texture from
   * @param frame - The rectangle frame of the texture to show
   * @param orig - The area of original texture
   * @param trim - Trimmed rectangle of original texture
   * @param rotate - indicates how the texture was rotated by texture packer. See {@link PIXI.groupD8}
   * @param anchor - Default anchor point used for sprite placement / rotation
   * @param borders - Default borders used for 9-slice scaling. See {@link PIXI.NineSlicePlane}
   */
  constructor(baseTexture, frame, orig, trim, rotate, anchor, borders) {
    if (super(), this.noFrame = !1, frame || (this.noFrame = !0, frame = new math.Rectangle(0, 0, 1, 1)), baseTexture instanceof Texture && (baseTexture = baseTexture.baseTexture), this.baseTexture = baseTexture, this._frame = frame, this.trim = trim, this.valid = !1, this.destroyed = !1, this._uvs = DEFAULT_UVS, this.uvMatrix = null, this.orig = orig || frame, this._rotate = Number(rotate || 0), rotate === !0)
      this._rotate = 2;
    else if (this._rotate % 2 !== 0)
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    this.defaultAnchor = anchor ? new math.Point(anchor.x, anchor.y) : new math.Point(0, 0), this.defaultBorders = borders, this._updateID = 0, this.textureCacheIds = [], baseTexture.valid ? this.noFrame ? baseTexture.valid && this.onBaseTextureUpdated(baseTexture) : this.frame = frame : baseTexture.once("loaded", this.onBaseTextureUpdated, this), this.noFrame && baseTexture.on("update", this.onBaseTextureUpdated, this);
  }
  /**
   * Updates this texture on the gpu.
   *
   * Calls the TextureResource update.
   *
   * If you adjusted `frame` manually, please call `updateUvs()` instead.
   */
  update() {
    this.baseTexture.resource && this.baseTexture.resource.update();
  }
  /**
   * Called when the base texture is updated
   * @protected
   * @param baseTexture - The base texture.
   */
  onBaseTextureUpdated(baseTexture) {
    if (this.noFrame) {
      if (!this.baseTexture.valid)
        return;
      this._frame.width = baseTexture.width, this._frame.height = baseTexture.height, this.valid = !0, this.updateUvs();
    } else
      this.frame = this._frame;
    this.emit("update", this);
  }
  /**
   * Destroys this texture
   * @param [destroyBase=false] - Whether to destroy the base texture as well
   * @fires PIXI.Texture#destroyed
   */
  destroy(destroyBase) {
    if (this.baseTexture) {
      if (destroyBase) {
        const { resource } = this.baseTexture;
        resource?.url && utils.TextureCache[resource.url] && Texture.removeFromCache(resource.url), this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
    }
    this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, Texture.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0, this.emit("destroyed", this), this.removeAllListeners();
  }
  /**
   * Creates a new texture object that acts the same as this one.
   * @returns - The new texture
   */
  clone() {
    const clonedFrame = this._frame.clone(), clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone(), clonedTexture = new Texture(
      this.baseTexture,
      !this.noFrame && clonedFrame,
      clonedOrig,
      this.trim?.clone(),
      this.rotate,
      this.defaultAnchor,
      this.defaultBorders
    );
    return this.noFrame && (clonedTexture._frame = clonedFrame), clonedTexture;
  }
  /**
   * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.
   * Call it after changing the frame
   */
  updateUvs() {
    this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs.TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
  }
  /**
   * Helper function that creates a new Texture based on the source you provide.
   * The source can be - frame id, image url, video url, canvas element, video element, base texture
   * @param {string|PIXI.BaseTexture|HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source -
   *        Source or array of sources to create texture from
   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.
   * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id
   * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.
   * @returns {PIXI.Texture} The newly created texture
   */
  static from(source, options = {}, strict = settings.settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source == "string";
    let cacheId = null;
    if (isFrame)
      cacheId = source;
    else if (source instanceof BaseTexture.BaseTexture) {
      if (!source.cacheId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source.cacheId = `${prefix}-${utils.uid()}`, BaseTexture.BaseTexture.addToCache(source, source.cacheId);
      }
      cacheId = source.cacheId;
    } else {
      if (!source._pixiId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source._pixiId = `${prefix}_${utils.uid()}`;
      }
      cacheId = source._pixiId;
    }
    let texture = utils.TextureCache[cacheId];
    if (isFrame && strict && !texture)
      throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);
    return !texture && !(source instanceof BaseTexture.BaseTexture) ? (options.resolution || (options.resolution = utils.getResolutionOfUrl(source)), texture = new Texture(new BaseTexture.BaseTexture(source, options)), texture.baseTexture.cacheId = cacheId, BaseTexture.BaseTexture.addToCache(texture.baseTexture, cacheId), Texture.addToCache(texture, cacheId)) : !texture && source instanceof BaseTexture.BaseTexture && (texture = new Texture(source), Texture.addToCache(texture, cacheId)), texture;
  }
  /**
   * Useful for loading textures via URLs. Use instead of `Texture.from` because
   * it does a better job of handling failed URLs more effectively. This also ignores
   * `PIXI.settings.STRICT_TEXTURE_CACHE`. Works for Videos, SVGs, Images.
   * @param url - The remote URL or array of URLs to load.
   * @param options - Optional options to include
   * @returns - A Promise that resolves to a Texture.
   */
  static fromURL(url, options) {
    const resourceOptions = Object.assign({ autoLoad: !1 }, options?.resourceOptions), texture = Texture.from(url, Object.assign({ resourceOptions }, options), !1), resource = texture.baseTexture.resource;
    return texture.baseTexture.valid ? Promise.resolve(texture) : resource.load().then(() => Promise.resolve(texture));
  }
  /**
   * Create a new Texture with a BufferResource from a typed array.
   * @param buffer - The optional array to use. If no data is provided, a new Float32Array is created.
   * @param width - Width of the resource
   * @param height - Height of the resource
   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.
   *        Default properties are different from the constructor's defaults.
   * @param {PIXI.FORMATS} [options.format] - The format is not given, the type is inferred from the
   *        type of the buffer: `RGBA` if Float32Array, Int8Array, Uint8Array, or Uint8ClampedArray,
   *        otherwise `RGBA_INTEGER`.
   * @param {PIXI.TYPES} [options.type] - The type is not given, the type is inferred from the
   *        type of the buffer. Maps Float32Array to `FLOAT`, Int32Array to `INT`, Uint32Array to
   *        `UNSIGNED_INT`, Int16Array to `SHORT`, Uint16Array to `UNSIGNED_SHORT`, Int8Array to `BYTE`,
   *        Uint8Array/Uint8ClampedArray to `UNSIGNED_BYTE`.
   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.NPM]
   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.SCALE_MODES.NEAREST]
   * @returns - The resulting new BaseTexture
   */
  static fromBuffer(buffer, width, height, options) {
    return new Texture(BaseTexture.BaseTexture.fromBuffer(buffer, width, height, options));
  }
  /**
   * Create a texture from a source and add to the cache.
   * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas|string} source - The input source.
   * @param imageUrl - File name of texture, for cache and resolving resolution.
   * @param name - Human readable name for the texture cache. If no name is
   *        specified, only `imageUrl` will be used as the cache ID.
   * @param options
   * @returns - Output texture
   */
  static fromLoader(source, imageUrl, name, options) {
    const baseTexture = new BaseTexture.BaseTexture(source, Object.assign({
      scaleMode: BaseTexture.BaseTexture.defaultOptions.scaleMode,
      resolution: utils.getResolutionOfUrl(imageUrl)
    }, options)), { resource } = baseTexture;
    resource instanceof ImageResource.ImageResource && (resource.url = imageUrl);
    const texture = new Texture(baseTexture);
    return name || (name = imageUrl), BaseTexture.BaseTexture.addToCache(texture.baseTexture, name), Texture.addToCache(texture, name), name !== imageUrl && (BaseTexture.BaseTexture.addToCache(texture.baseTexture, imageUrl), Texture.addToCache(texture, imageUrl)), texture.baseTexture.valid ? Promise.resolve(texture) : new Promise((resolve) => {
      texture.baseTexture.once("loaded", () => resolve(texture));
    });
  }
  /**
   * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.
   * @param texture - The Texture to add to the cache.
   * @param id - The id that the Texture will be stored against.
   */
  static addToCache(texture, id) {
    id && (texture.textureCacheIds.includes(id) || texture.textureCacheIds.push(id), utils.TextureCache[id] && utils.TextureCache[id] !== texture && console.warn(`Texture added to the cache with an id [${id}] that already had an entry`), utils.TextureCache[id] = texture);
  }
  /**
   * Remove a Texture from the global TextureCache.
   * @param texture - id of a Texture to be removed, or a Texture instance itself
   * @returns - The Texture that was removed
   */
  static removeFromCache(texture) {
    if (typeof texture == "string") {
      const textureFromCache = utils.TextureCache[texture];
      if (textureFromCache) {
        const index = textureFromCache.textureCacheIds.indexOf(texture);
        return index > -1 && textureFromCache.textureCacheIds.splice(index, 1), delete utils.TextureCache[texture], textureFromCache;
      }
    } else if (texture?.textureCacheIds) {
      for (let i = 0; i < texture.textureCacheIds.length; ++i)
        utils.TextureCache[texture.textureCacheIds[i]] === texture && delete utils.TextureCache[texture.textureCacheIds[i]];
      return texture.textureCacheIds.length = 0, texture;
    }
    return null;
  }
  /**
   * Returns resolution of baseTexture
   * @readonly
   */
  get resolution() {
    return this.baseTexture.resolution;
  }
  /**
   * The frame specifies the region of the base texture that this texture uses.
   * Please call `updateUvs()` after you change coordinates of `frame` manually.
   */
  get frame() {
    return this._frame;
  }
  set frame(frame) {
    this._frame = frame, this.noFrame = !1;
    const { x, y, width, height } = frame, xNotFit = x + width > this.baseTexture.width, yNotFit = y + height > this.baseTexture.height;
    if (xNotFit || yNotFit) {
      const relationship = xNotFit && yNotFit ? "and" : "or", errorX = `X: ${x} + ${width} = ${x + width} > ${this.baseTexture.width}`, errorY = `Y: ${y} + ${height} = ${y + height} > ${this.baseTexture.height}`;
      throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);
    }
    this.valid = width && height && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = frame), this.valid && this.updateUvs();
  }
  /**
   * Indicates whether the texture is rotated inside the atlas
   * set to 2 to compensate for texture packer rotation
   * set to 6 to compensate for spine packer rotation
   * can be used to rotate or mirror sprites
   * See {@link PIXI.groupD8} for explanation
   */
  get rotate() {
    return this._rotate;
  }
  set rotate(rotate) {
    this._rotate = rotate, this.valid && this.updateUvs();
  }
  /** The width of the Texture in pixels. */
  get width() {
    return this.orig.width;
  }
  /** The height of the Texture in pixels. */
  get height() {
    return this.orig.height;
  }
  /** Utility function for BaseTexture|Texture cast. */
  castToBaseTexture() {
    return this.baseTexture;
  }
  /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */
  static get EMPTY() {
    return Texture._EMPTY || (Texture._EMPTY = new Texture(new BaseTexture.BaseTexture()), removeAllHandlers(Texture._EMPTY), removeAllHandlers(Texture._EMPTY.baseTexture)), Texture._EMPTY;
  }
  /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */
  static get WHITE() {
    if (!Texture._WHITE) {
      const canvas = settings.settings.ADAPTER.createCanvas(16, 16), context = canvas.getContext("2d");
      canvas.width = 16, canvas.height = 16, context.fillStyle = "white", context.fillRect(0, 0, 16, 16), Texture._WHITE = new Texture(BaseTexture.BaseTexture.from(canvas)), removeAllHandlers(Texture._WHITE), removeAllHandlers(Texture._WHITE.baseTexture);
    }
    return Texture._WHITE;
  }
}
exports.Texture = Texture;
//# sourceMappingURL=Texture.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/TextureGCSystem.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/TextureGCSystem.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js");
const _TextureGCSystem = class _TextureGCSystem2 {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.renderer = renderer, this.count = 0, this.checkCount = 0, this.maxIdle = _TextureGCSystem2.defaultMaxIdle, this.checkCountMax = _TextureGCSystem2.defaultCheckCountMax, this.mode = _TextureGCSystem2.defaultMode;
  }
  /**
   * Checks to see when the last time a texture was used.
   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
   */
  postrender() {
    this.renderer.objectRenderer.renderingToScreen && (this.count++, this.mode !== constants.GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
  }
  /**
   * Checks to see when the last time a texture was used.
   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
   */
  run() {
    const tm = this.renderer.texture, managedTextures = tm.managedTextures;
    let wasRemoved = !1;
    for (let i = 0; i < managedTextures.length; i++) {
      const texture = managedTextures[i];
      texture.resource && this.count - texture.touched > this.maxIdle && (tm.destroyTexture(texture, !0), managedTextures[i] = null, wasRemoved = !0);
    }
    if (wasRemoved) {
      let j = 0;
      for (let i = 0; i < managedTextures.length; i++)
        managedTextures[i] !== null && (managedTextures[j++] = managedTextures[i]);
      managedTextures.length = j;
    }
  }
  /**
   * Removes all the textures within the specified displayObject and its children from the GPU.
   * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.
   */
  unload(displayObject) {
    const tm = this.renderer.texture, texture = displayObject._texture;
    texture && !texture.framebuffer && tm.destroyTexture(texture);
    for (let i = displayObject.children.length - 1; i >= 0; i--)
      this.unload(displayObject.children[i]);
  }
  destroy() {
    this.renderer = null;
  }
};
_TextureGCSystem.defaultMode = constants.GC_MODES.AUTO, /**
* Default maximum idle frames before a texture is destroyed by garbage collection.
* @static
* @default 3600
* @see PIXI.TextureGCSystem#maxIdle
*/
_TextureGCSystem.defaultMaxIdle = 60 * 60, /**
* Default frames between two garbage collections.
* @static
* @default 600
* @see PIXI.TextureGCSystem#checkCountMax
*/
_TextureGCSystem.defaultCheckCountMax = 60 * 10, /** @ignore */
_TextureGCSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "textureGC"
};
let TextureGCSystem = _TextureGCSystem;
extensions.extensions.add(TextureGCSystem);
exports.TextureGCSystem = TextureGCSystem;
//# sourceMappingURL=TextureGCSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/TextureMatrix.js":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/TextureMatrix.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var math = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.js");
const tempMat = new math.Matrix();
class TextureMatrix {
  /**
   * @param texture - observed texture
   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
   */
  constructor(texture, clampMargin) {
    this._texture = texture, this.mapCoord = new math.Matrix(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof clampMargin > "u" ? 0.5 : clampMargin, this.isSimple = !1;
  }
  /** Texture property. */
  get texture() {
    return this._texture;
  }
  set texture(value) {
    this._texture = value, this._textureID = -1;
  }
  /**
   * Multiplies uvs array to transform
   * @param uvs - mesh uvs
   * @param [out=uvs] - output
   * @returns - output
   */
  multiplyUvs(uvs, out) {
    out === void 0 && (out = uvs);
    const mat = this.mapCoord;
    for (let i = 0; i < uvs.length; i += 2) {
      const x = uvs[i], y = uvs[i + 1];
      out[i] = x * mat.a + y * mat.c + mat.tx, out[i + 1] = x * mat.b + y * mat.d + mat.ty;
    }
    return out;
  }
  /**
   * Updates matrices if texture was changed.
   * @param [forceUpdate=false] - if true, matrices will be updated any case
   * @returns - Whether or not it was updated
   */
  update(forceUpdate) {
    const tex = this._texture;
    if (!tex || !tex.valid || !forceUpdate && this._textureID === tex._updateID)
      return !1;
    this._textureID = tex._updateID, this._updateID++;
    const uvs = tex._uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    const orig = tex.orig, trim = tex.trim;
    trim && (tempMat.set(
      orig.width / trim.width,
      0,
      0,
      orig.height / trim.height,
      -trim.x / trim.width,
      -trim.y / trim.height
    ), this.mapCoord.append(tempMat));
    const texBase = tex.baseTexture, frame = this.uClampFrame, margin = this.clampMargin / texBase.resolution, offset = this.clampOffset;
    return frame[0] = (tex._frame.x + margin + offset) / texBase.width, frame[1] = (tex._frame.y + margin + offset) / texBase.height, frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width, frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height, this.uClampOffset[0] = offset / texBase.realWidth, this.uClampOffset[1] = offset / texBase.realHeight, this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0, !0;
  }
}
exports.TextureMatrix = TextureMatrix;
//# sourceMappingURL=TextureMatrix.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/TextureSystem.js":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/TextureSystem.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js"), BaseTexture = __webpack_require__(/*! ./BaseTexture.js */ "./node_modules/@pixi/core/lib/textures/BaseTexture.js"), GLTexture = __webpack_require__(/*! ./GLTexture.js */ "./node_modules/@pixi/core/lib/textures/GLTexture.js"), mapInternalFormatToSamplerType = __webpack_require__(/*! ./utils/mapInternalFormatToSamplerType.js */ "./node_modules/@pixi/core/lib/textures/utils/mapInternalFormatToSamplerType.js"), mapTypeAndFormatToInternalFormat = __webpack_require__(/*! ./utils/mapTypeAndFormatToInternalFormat.js */ "./node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.js");
class TextureSystem {
  /**
   * @param renderer - The renderer this system works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new BaseTexture.BaseTexture(), this.hasIntegerTextures = !1;
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat.mapTypeAndFormatToInternalFormat(gl), this.samplerTypes = mapInternalFormatToSamplerType.mapInternalFormatToSamplerType(gl);
    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = maxTextures;
    for (let i = 0; i < maxTextures; i++)
      this.boundTextures[i] = null;
    this.emptyTextures = {};
    const emptyTexture2D = new GLTexture.GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D, this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture.GLTexture(gl.createTexture()), gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
    for (let i = 0; i < 6; i++)
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    for (let i = 0; i < this.boundTextures.length; i++)
      this.bind(null, i);
  }
  /**
   * Bind a texture to a specific location
   *
   * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`
   * @param texture - Texture to bind
   * @param [location=0] - Location to bind at
   */
  bind(texture, location = 0) {
    const { gl } = this;
    if (texture = texture?.castToBaseTexture(), texture?.valid && !texture.parentTextureArray) {
      texture.touched = this.renderer.textureGC.count;
      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
      this.boundTextures[location] !== texture && (this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), gl.bindTexture(texture.target, glTexture.texture)), glTexture.dirtyId !== texture.dirtyId ? (this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), this.updateTexture(texture)) : glTexture.dirtyStyleId !== texture.dirtyStyleId && this.updateTextureStyle(texture), this.boundTextures[location] = texture;
    } else
      this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture), this.boundTextures[location] = null;
  }
  /** Resets texture location and bound textures Actual `bind(null, i)` calls will be performed at next `unbind()` call */
  reset() {
    this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;
    for (let i = 0; i < this.boundTextures.length; i++)
      this.boundTextures[i] = this.unknownTexture;
  }
  /**
   * Unbind a texture.
   * @param texture - Texture to bind
   */
  unbind(texture) {
    const { gl, boundTextures } = this;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = !1;
      for (let i = 0; i < boundTextures.length; i++)
        boundTextures[i] === this.unknownTexture && this.bind(null, i);
    }
    for (let i = 0; i < boundTextures.length; i++)
      boundTextures[i] === texture && (this.currentLocation !== i && (gl.activeTexture(gl.TEXTURE0 + i), this.currentLocation = i), gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture), boundTextures[i] = null);
  }
  /**
   * Ensures that current boundTextures all have FLOAT sampler type,
   * see {@link PIXI.SAMPLER_TYPES} for explanation.
   * @param maxTextures - number of locations to check
   */
  ensureSamplerType(maxTextures) {
    const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;
    if (hasIntegerTextures)
      for (let i = maxTextures - 1; i >= 0; --i) {
        const tex = boundTextures[i];
        tex && tex._glTextures[CONTEXT_UID].samplerType !== constants.SAMPLER_TYPES.FLOAT && this.renderer.texture.unbind(tex);
      }
  }
  /**
   * Initialize a texture
   * @private
   * @param texture - Texture to initialize
   */
  initTexture(texture) {
    const glTexture = new GLTexture.GLTexture(this.gl.createTexture());
    return glTexture.dirtyId = -1, texture._glTextures[this.CONTEXT_UID] = glTexture, this.managedTextures.push(texture), texture.on("dispose", this.destroyTexture, this), glTexture;
  }
  initTextureType(texture, glTexture) {
    glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format, glTexture.samplerType = this.samplerTypes[glTexture.internalFormat] ?? constants.SAMPLER_TYPES.FLOAT, this.webGLVersion === 2 && texture.type === constants.TYPES.HALF_FLOAT ? glTexture.type = this.gl.HALF_FLOAT : glTexture.type = texture.type;
  }
  /**
   * Update a texture
   * @private
   * @param {PIXI.BaseTexture} texture - Texture to initialize
   */
  updateTexture(texture) {
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture)
      return;
    const renderer = this.renderer;
    if (this.initTextureType(texture, glTexture), texture.resource?.upload(renderer, texture, glTexture))
      glTexture.samplerType !== constants.SAMPLER_TYPES.FLOAT && (this.hasIntegerTextures = !0);
    else {
      const width = texture.realWidth, height = texture.realHeight, gl = renderer.gl;
      (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) && (glTexture.width = width, glTexture.height = height, gl.texImage2D(
        texture.target,
        0,
        glTexture.internalFormat,
        width,
        height,
        0,
        texture.format,
        glTexture.type,
        null
      ));
    }
    texture.dirtyStyleId !== glTexture.dirtyStyleId && this.updateTextureStyle(texture), glTexture.dirtyId = texture.dirtyId;
  }
  /**
   * Deletes the texture from WebGL
   * @private
   * @param texture - the texture to destroy
   * @param [skipRemove=false] - Whether to skip removing the texture from the TextureManager.
   */
  destroyTexture(texture, skipRemove) {
    const { gl } = this;
    if (texture = texture.castToBaseTexture(), texture._glTextures[this.CONTEXT_UID] && (this.unbind(texture), gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture), texture.off("dispose", this.destroyTexture, this), delete texture._glTextures[this.CONTEXT_UID], !skipRemove)) {
      const i = this.managedTextures.indexOf(texture);
      i !== -1 && utils.removeItems(this.managedTextures, i, 1);
    }
  }
  /**
   * Update texture style such as mipmap flag
   * @private
   * @param {PIXI.BaseTexture} texture - Texture to update
   */
  updateTextureStyle(texture) {
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    glTexture && ((texture.mipmap === constants.MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo ? glTexture.mipmap = !1 : glTexture.mipmap = texture.mipmap >= 1, this.webGLVersion !== 2 && !texture.isPowerOfTwo ? glTexture.wrapMode = constants.WRAP_MODES.CLAMP : glTexture.wrapMode = texture.wrapMode, texture.resource?.style(this.renderer, texture, glTexture) || this.setStyle(texture, glTexture), glTexture.dirtyStyleId = texture.dirtyStyleId);
  }
  /**
   * Set style for texture
   * @private
   * @param texture - Texture to update
   * @param glTexture
   */
  setStyle(texture, glTexture) {
    const gl = this.gl;
    if (glTexture.mipmap && texture.mipmap !== constants.MIPMAP_MODES.ON_MANUAL && gl.generateMipmap(texture.target), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode), glTexture.mipmap) {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === constants.SCALE_MODES.LINEAR) {
        const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
      }
    } else
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
  }
  destroy() {
    this.renderer = null;
  }
}
TextureSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "texture"
};
extensions.extensions.add(TextureSystem);
exports.TextureSystem = TextureSystem;
//# sourceMappingURL=TextureSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/TextureUvs.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/TextureUvs.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var math = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.js");
class TextureUvs {
  constructor() {
    this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
  }
  /**
   * Sets the texture Uvs based on the given frame information.
   * @protected
   * @param frame - The frame of the texture
   * @param baseFrame - The base frame of the texture
   * @param rotate - Rotation of frame, see {@link PIXI.groupD8}
   */
  set(frame, baseFrame, rotate) {
    const tw = baseFrame.width, th = baseFrame.height;
    if (rotate) {
      const w2 = frame.width / 2 / tw, h2 = frame.height / 2 / th, cX = frame.x / tw + w2, cY = frame.y / th + h2;
      rotate = math.groupD8.add(rotate, math.groupD8.NW), this.x0 = cX + w2 * math.groupD8.uX(rotate), this.y0 = cY + h2 * math.groupD8.uY(rotate), rotate = math.groupD8.add(rotate, 2), this.x1 = cX + w2 * math.groupD8.uX(rotate), this.y1 = cY + h2 * math.groupD8.uY(rotate), rotate = math.groupD8.add(rotate, 2), this.x2 = cX + w2 * math.groupD8.uX(rotate), this.y2 = cY + h2 * math.groupD8.uY(rotate), rotate = math.groupD8.add(rotate, 2), this.x3 = cX + w2 * math.groupD8.uX(rotate), this.y3 = cY + h2 * math.groupD8.uY(rotate);
    } else
      this.x0 = frame.x / tw, this.y0 = frame.y / th, this.x1 = (frame.x + frame.width) / tw, this.y1 = frame.y / th, this.x2 = (frame.x + frame.width) / tw, this.y2 = (frame.y + frame.height) / th, this.x3 = frame.x / tw, this.y3 = (frame.y + frame.height) / th;
    this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
  }
}
TextureUvs.prototype.toString = function() {
  return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
};
exports.TextureUvs = TextureUvs;
//# sourceMappingURL=TextureUvs.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var BaseTexture = __webpack_require__(/*! ../BaseTexture.js */ "./node_modules/@pixi/core/lib/textures/BaseTexture.js"), autoDetectResource = __webpack_require__(/*! ./autoDetectResource.js */ "./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js"), Resource = __webpack_require__(/*! ./Resource.js */ "./node_modules/@pixi/core/lib/textures/resources/Resource.js");
class AbstractMultiResource extends Resource.Resource {
  /**
   * @param length
   * @param options - Options to for Resource constructor
   * @param {number} [options.width] - Width of the resource
   * @param {number} [options.height] - Height of the resource
   */
  constructor(length, options) {
    const { width, height } = options || {};
    super(width, height), this.items = [], this.itemDirtyIds = [];
    for (let i = 0; i < length; i++) {
      const partTexture = new BaseTexture.BaseTexture();
      this.items.push(partTexture), this.itemDirtyIds.push(-2);
    }
    this.length = length, this._load = null, this.baseTexture = null;
  }
  /**
   * Used from ArrayResource and CubeResource constructors.
   * @param resources - Can be resources, image elements, canvas, etc. ,
   *  length should be same as constructor length
   * @param options - Detect options for resources
   */
  initFromArray(resources, options) {
    for (let i = 0; i < this.length; i++)
      resources[i] && (resources[i].castToBaseTexture ? this.addBaseTextureAt(resources[i].castToBaseTexture(), i) : resources[i] instanceof Resource.Resource ? this.addResourceAt(resources[i], i) : this.addResourceAt(autoDetectResource.autoDetectResource(resources[i], options), i));
  }
  /** Destroy this BaseImageResource. */
  dispose() {
    for (let i = 0, len = this.length; i < len; i++)
      this.items[i].destroy();
    this.items = null, this.itemDirtyIds = null, this._load = null;
  }
  /**
   * Set a resource by ID
   * @param resource
   * @param index - Zero-based index of resource to set
   * @returns - Instance for chaining
   */
  addResourceAt(resource, index) {
    if (!this.items[index])
      throw new Error(`Index ${index} is out of bounds`);
    return resource.valid && !this.valid && this.resize(resource.width, resource.height), this.items[index].setResource(resource), this;
  }
  /**
   * Set the parent base texture.
   * @param baseTexture
   */
  bind(baseTexture) {
    if (this.baseTexture !== null)
      throw new Error("Only one base texture per TextureArray is allowed");
    super.bind(baseTexture);
    for (let i = 0; i < this.length; i++)
      this.items[i].parentTextureArray = baseTexture, this.items[i].on("update", baseTexture.update, baseTexture);
  }
  /**
   * Unset the parent base texture.
   * @param baseTexture
   */
  unbind(baseTexture) {
    super.unbind(baseTexture);
    for (let i = 0; i < this.length; i++)
      this.items[i].parentTextureArray = null, this.items[i].off("update", baseTexture.update, baseTexture);
  }
  /**
   * Load all the resources simultaneously
   * @returns - When load is resolved
   */
  load() {
    if (this._load)
      return this._load;
    const promises = this.items.map((item) => item.resource).filter((item) => item).map((item) => item.load());
    return this._load = Promise.all(promises).then(
      () => {
        const { realWidth, realHeight } = this.items[0];
        return this.resize(realWidth, realHeight), this.update(), Promise.resolve(this);
      }
    ), this._load;
  }
}
exports.AbstractMultiResource = AbstractMultiResource;
//# sourceMappingURL=AbstractMultiResource.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/ArrayResource.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/ArrayResource.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), AbstractMultiResource = __webpack_require__(/*! ./AbstractMultiResource.js */ "./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js");
class ArrayResource extends AbstractMultiResource.AbstractMultiResource {
  /**
   * @param source - Number of items in array or the collection
   *        of image URLs to use. Can also be resources, image elements, canvas, etc.
   * @param options - Options to apply to {@link PIXI.autoDetectResource}
   * @param {number} [options.width] - Width of the resource
   * @param {number} [options.height] - Height of the resource
   */
  constructor(source, options) {
    const { width, height } = options || {};
    let urls, length;
    Array.isArray(source) ? (urls = source, length = source.length) : length = source, super(length, { width, height }), urls && this.initFromArray(urls, options);
  }
  /**
   * Set a baseTexture by ID,
   * ArrayResource just takes resource from it, nothing more
   * @param baseTexture
   * @param index - Zero-based index of resource to set
   * @returns - Instance for chaining
   */
  addBaseTextureAt(baseTexture, index) {
    if (baseTexture.resource)
      this.addResourceAt(baseTexture.resource, index);
    else
      throw new Error("ArrayResource does not support RenderTexture");
    return this;
  }
  /**
   * Add binding
   * @param baseTexture
   */
  bind(baseTexture) {
    super.bind(baseTexture), baseTexture.target = constants.TARGETS.TEXTURE_2D_ARRAY;
  }
  /**
   * Upload the resources to the GPU.
   * @param renderer
   * @param texture
   * @param glTexture
   * @returns - whether texture was uploaded
   */
  upload(renderer, texture, glTexture) {
    const { length, itemDirtyIds, items } = this, { gl } = renderer;
    glTexture.dirtyId < 0 && gl.texImage3D(
      gl.TEXTURE_2D_ARRAY,
      0,
      glTexture.internalFormat,
      this._width,
      this._height,
      length,
      0,
      texture.format,
      glTexture.type,
      null
    );
    for (let i = 0; i < length; i++) {
      const item = items[i];
      itemDirtyIds[i] < item.dirtyId && (itemDirtyIds[i] = item.dirtyId, item.valid && gl.texSubImage3D(
        gl.TEXTURE_2D_ARRAY,
        0,
        0,
        // xoffset
        0,
        // yoffset
        i,
        // zoffset
        item.resource.width,
        item.resource.height,
        1,
        texture.format,
        glTexture.type,
        item.resource.source
      ));
    }
    return !0;
  }
}
exports.ArrayResource = ArrayResource;
//# sourceMappingURL=ArrayResource.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js"), Resource = __webpack_require__(/*! ./Resource.js */ "./node_modules/@pixi/core/lib/textures/resources/Resource.js");
class BaseImageResource extends Resource.Resource {
  /**
   * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source
   */
  constructor(source) {
    const sourceAny = source, width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width, height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
    super(width, height), this.source = source, this.noSubImage = !1;
  }
  /**
   * Set cross origin based detecting the url and the crossorigin
   * @param element - Element to apply crossOrigin
   * @param url - URL to check
   * @param crossorigin - Cross origin value to use
   */
  static crossOrigin(element, url, crossorigin) {
    crossorigin === void 0 && !url.startsWith("data:") ? element.crossOrigin = utils.determineCrossOrigin(url) : crossorigin !== !1 && (element.crossOrigin = typeof crossorigin == "string" ? crossorigin : "anonymous");
  }
  /**
   * Upload the texture to the GPU.
   * @param renderer - Upload to the renderer
   * @param baseTexture - Reference to parent texture
   * @param glTexture
   * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} [source] - (optional)
   * @returns - true is success
   */
  upload(renderer, baseTexture, glTexture, source) {
    const gl = renderer.gl, width = baseTexture.realWidth, height = baseTexture.realHeight;
    if (source = source || this.source, typeof HTMLImageElement < "u" && source instanceof HTMLImageElement) {
      if (!source.complete || source.naturalWidth === 0)
        return !1;
    } else if (typeof HTMLVideoElement < "u" && source instanceof HTMLVideoElement && source.readyState <= 1)
      return !1;
    return gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === constants.ALPHA_MODES.UNPACK), !this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height ? gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source) : (glTexture.width = width, glTexture.height = height, gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source)), !0;
  }
  /**
   * Checks if source width/height was changed, resize can cause extra baseTexture update.
   * Triggers one update in any case.
   */
  update() {
    if (this.destroyed)
      return;
    const source = this.source, width = source.naturalWidth || source.videoWidth || source.width, height = source.naturalHeight || source.videoHeight || source.height;
    this.resize(width, height), super.update();
  }
  /** Destroy this {@link PIXI.BaseImageResource} */
  dispose() {
    this.source = null;
  }
}
exports.BaseImageResource = BaseImageResource;
//# sourceMappingURL=BaseImageResource.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/BufferResource.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/BufferResource.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), Resource = __webpack_require__(/*! ./Resource.js */ "./node_modules/@pixi/core/lib/textures/resources/Resource.js");
class BufferResource extends Resource.Resource {
  /**
   * @param source - Source buffer
   * @param options - Options
   * @param {number} options.width - Width of the texture
   * @param {number} options.height - Height of the texture
   * @param {1|2|4|8} [options.unpackAlignment=4] - The alignment of the pixel rows.
   */
  constructor(source, options) {
    const { width, height } = options || {};
    if (!width || !height)
      throw new Error("BufferResource width or height invalid");
    super(width, height), this.data = source, this.unpackAlignment = options.unpackAlignment ?? 4;
  }
  /**
   * Upload the texture to the GPU.
   * @param renderer - Upload to the renderer
   * @param baseTexture - Reference to parent texture
   * @param glTexture - glTexture
   * @returns - true is success
   */
  upload(renderer, baseTexture, glTexture) {
    const gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, this.unpackAlignment), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === constants.ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth, height = baseTexture.realHeight;
    return glTexture.width === width && glTexture.height === height ? gl.texSubImage2D(
      baseTexture.target,
      0,
      0,
      0,
      width,
      height,
      baseTexture.format,
      glTexture.type,
      this.data
    ) : (glTexture.width = width, glTexture.height = height, gl.texImage2D(
      baseTexture.target,
      0,
      glTexture.internalFormat,
      width,
      height,
      0,
      baseTexture.format,
      glTexture.type,
      this.data
    )), !0;
  }
  /** Destroy and don't use after this. */
  dispose() {
    this.data = null;
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if buffer source
   */
  static test(source) {
    return source === null || source instanceof Int8Array || source instanceof Uint8Array || source instanceof Uint8ClampedArray || source instanceof Int16Array || source instanceof Uint16Array || source instanceof Int32Array || source instanceof Uint32Array || source instanceof Float32Array;
  }
}
exports.BufferResource = BufferResource;
//# sourceMappingURL=BufferResource.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/CanvasResource.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/CanvasResource.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js");
class CanvasResource extends BaseImageResource.BaseImageResource {
  /**
   * @param source - Canvas element to use
   */
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor(source) {
    super(source);
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if source is HTMLCanvasElement or OffscreenCanvas
   */
  static test(source) {
    const { OffscreenCanvas } = globalThis;
    return OffscreenCanvas && source instanceof OffscreenCanvas ? !0 : globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
  }
}
exports.CanvasResource = CanvasResource;
//# sourceMappingURL=CanvasResource.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/CubeResource.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/CubeResource.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), AbstractMultiResource = __webpack_require__(/*! ./AbstractMultiResource.js */ "./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js");
const _CubeResource = class _CubeResource2 extends AbstractMultiResource.AbstractMultiResource {
  /**
   * @param {Array<string|PIXI.Resource>} [source] - Collection of URLs or resources
   *        to use as the sides of the cube.
   * @param options - ImageResource options
   * @param {number} [options.width] - Width of resource
   * @param {number} [options.height] - Height of resource
   * @param {number} [options.autoLoad=true] - Whether to auto-load resources
   * @param {number} [options.linkBaseTexture=true] - In case BaseTextures are supplied,
   *   whether to copy them or use
   */
  constructor(source, options) {
    const { width, height, autoLoad, linkBaseTexture } = options || {};
    if (source && source.length !== _CubeResource2.SIDES)
      throw new Error(`Invalid length. Got ${source.length}, expected 6`);
    super(6, { width, height });
    for (let i = 0; i < _CubeResource2.SIDES; i++)
      this.items[i].target = constants.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
    this.linkBaseTexture = linkBaseTexture !== !1, source && this.initFromArray(source, options), autoLoad !== !1 && this.load();
  }
  /**
   * Add binding.
   * @param baseTexture - parent base texture
   */
  bind(baseTexture) {
    super.bind(baseTexture), baseTexture.target = constants.TARGETS.TEXTURE_CUBE_MAP;
  }
  addBaseTextureAt(baseTexture, index, linkBaseTexture) {
    if (linkBaseTexture === void 0 && (linkBaseTexture = this.linkBaseTexture), !this.items[index])
      throw new Error(`Index ${index} is out of bounds`);
    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0)
      if (baseTexture.resource)
        this.addResourceAt(baseTexture.resource, index);
      else
        throw new Error("CubeResource does not support copying of renderTexture.");
    else
      baseTexture.target = constants.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index, baseTexture.parentTextureArray = this.baseTexture, this.items[index] = baseTexture;
    return baseTexture.valid && !this.valid && this.resize(baseTexture.realWidth, baseTexture.realHeight), this.items[index] = baseTexture, this;
  }
  /**
   * Upload the resource
   * @param renderer
   * @param _baseTexture
   * @param glTexture
   * @returns {boolean} true is success
   */
  upload(renderer, _baseTexture, glTexture) {
    const dirty = this.itemDirtyIds;
    for (let i = 0; i < _CubeResource2.SIDES; i++) {
      const side = this.items[i];
      (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) && (side.valid && side.resource ? (side.resource.upload(renderer, side, glTexture), dirty[i] = side.dirtyId) : dirty[i] < -1 && (renderer.gl.texImage2D(
        side.target,
        0,
        glTexture.internalFormat,
        _baseTexture.realWidth,
        _baseTexture.realHeight,
        0,
        _baseTexture.format,
        glTexture.type,
        null
      ), dirty[i] = -1));
    }
    return !0;
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if source is an array of 6 elements
   */
  static test(source) {
    return Array.isArray(source) && source.length === _CubeResource2.SIDES;
  }
};
_CubeResource.SIDES = 6;
let CubeResource = _CubeResource;
exports.CubeResource = CubeResource;
//# sourceMappingURL=CubeResource.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js"), BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js");
class ImageBitmapResource extends BaseImageResource.BaseImageResource {
  /**
   * @param source - ImageBitmap or URL to use.
   * @param options - Options to use.
   */
  constructor(source, options) {
    options = options || {};
    let baseSource, url, ownsImageBitmap;
    typeof source == "string" ? (baseSource = ImageBitmapResource.EMPTY, url = source, ownsImageBitmap = !0) : (baseSource = source, url = null, ownsImageBitmap = !1), super(baseSource), this.url = url, this.crossOrigin = options.crossOrigin ?? !0, this.alphaMode = typeof options.alphaMode == "number" ? options.alphaMode : null, this.ownsImageBitmap = options.ownsImageBitmap ?? ownsImageBitmap, this._load = null, options.autoLoad !== !1 && this.load();
  }
  load() {
    return this._load ? this._load : (this._load = new Promise(async (resolve, reject) => {
      if (this.url === null) {
        resolve(this);
        return;
      }
      try {
        const response = await settings.settings.ADAPTER.fetch(this.url, {
          mode: this.crossOrigin ? "cors" : "no-cors"
        });
        if (this.destroyed)
          return;
        const imageBlob = await response.blob();
        if (this.destroyed)
          return;
        const imageBitmap = await createImageBitmap(imageBlob, {
          premultiplyAlpha: this.alphaMode === null || this.alphaMode === constants.ALPHA_MODES.UNPACK ? "premultiply" : "none"
        });
        if (this.destroyed) {
          imageBitmap.close();
          return;
        }
        this.source = imageBitmap, this.update(), resolve(this);
      } catch (e) {
        if (this.destroyed)
          return;
        reject(e), this.onError.emit(e);
      }
    }), this._load);
  }
  /**
   * Upload the image bitmap resource to GPU.
   * @param renderer - Renderer to upload to
   * @param baseTexture - BaseTexture for this resource
   * @param glTexture - GLTexture to use
   * @returns {boolean} true is success
   */
  upload(renderer, baseTexture, glTexture) {
    return this.source instanceof ImageBitmap ? (typeof this.alphaMode == "number" && (baseTexture.alphaMode = this.alphaMode), super.upload(renderer, baseTexture, glTexture)) : (this.load(), !1);
  }
  /** Destroys this resource. */
  dispose() {
    this.ownsImageBitmap && this.source instanceof ImageBitmap && this.source.close(), super.dispose(), this._load = null;
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if current environment support ImageBitmap, and source is string or ImageBitmap
   */
  static test(source) {
    return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && (typeof source == "string" || source instanceof ImageBitmap);
  }
  /**
   * ImageBitmap cannot be created synchronously, so a empty placeholder canvas is needed when loading from URLs.
   * Only for internal usage.
   * @returns The cached placeholder canvas.
   */
  static get EMPTY() {
    return ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.settings.ADAPTER.createCanvas(0, 0), ImageBitmapResource._EMPTY;
  }
}
exports.ImageBitmapResource = ImageBitmapResource;
//# sourceMappingURL=ImageBitmapResource.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/ImageResource.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/ImageResource.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js"), BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js");
class ImageResource extends BaseImageResource.BaseImageResource {
  /**
   * @param source - image source or URL
   * @param options
   * @param {boolean} [options.autoLoad=true] - start loading process
   * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - whether its required to create
   *        a bitmap before upload
   * @param {boolean} [options.crossorigin=true] - Load image using cross origin
   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Premultiply image alpha in bitmap
   */
  constructor(source, options) {
    if (options = options || {}, typeof source == "string") {
      const imageElement = new Image();
      BaseImageResource.BaseImageResource.crossOrigin(imageElement, source, options.crossorigin), imageElement.src = source, source = imageElement;
    }
    super(source), !source.complete && this._width && this._height && (this._width = 0, this._height = 0), this.url = source.src, this._process = null, this.preserveBitmap = !1, this.createBitmap = (options.createBitmap ?? settings.settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, this.alphaMode = typeof options.alphaMode == "number" ? options.alphaMode : null, this.bitmap = null, this._load = null, options.autoLoad !== !1 && this.load();
  }
  /**
   * Returns a promise when image will be loaded and processed.
   * @param createBitmap - whether process image into bitmap
   */
  load(createBitmap) {
    return this._load ? this._load : (createBitmap !== void 0 && (this.createBitmap = createBitmap), this._load = new Promise((resolve, reject) => {
      const source = this.source;
      this.url = source.src;
      const completed = () => {
        this.destroyed || (source.onload = null, source.onerror = null, this.update(), this._load = null, this.createBitmap ? resolve(this.process()) : resolve(this));
      };
      source.complete && source.src ? completed() : (source.onload = completed, source.onerror = (event) => {
        reject(event), this.onError.emit(event);
      });
    }), this._load);
  }
  /**
   * Called when we need to convert image into BitmapImage.
   * Can be called multiple times, real promise is cached inside.
   * @returns - Cached promise to fill that bitmap
   */
  process() {
    const source = this.source;
    if (this._process !== null)
      return this._process;
    if (this.bitmap !== null || !globalThis.createImageBitmap)
      return Promise.resolve(this);
    const createImageBitmap = globalThis.createImageBitmap, cors = !source.crossOrigin || source.crossOrigin === "anonymous";
    return this._process = fetch(
      source.src,
      {
        mode: cors ? "cors" : "no-cors"
      }
    ).then((r) => r.blob()).then((blob) => createImageBitmap(
      blob,
      0,
      0,
      source.width,
      source.height,
      {
        premultiplyAlpha: this.alphaMode === null || this.alphaMode === constants.ALPHA_MODES.UNPACK ? "premultiply" : "none"
      }
    )).then((bitmap) => this.destroyed ? Promise.reject() : (this.bitmap = bitmap, this.update(), this._process = null, Promise.resolve(this))), this._process;
  }
  /**
   * Upload the image resource to GPU.
   * @param renderer - Renderer to upload to
   * @param baseTexture - BaseTexture for this resource
   * @param glTexture - GLTexture to use
   * @returns {boolean} true is success
   */
  upload(renderer, baseTexture, glTexture) {
    if (typeof this.alphaMode == "number" && (baseTexture.alphaMode = this.alphaMode), !this.createBitmap)
      return super.upload(renderer, baseTexture, glTexture);
    if (!this.bitmap && (this.process(), !this.bitmap))
      return !1;
    if (super.upload(renderer, baseTexture, glTexture, this.bitmap), !this.preserveBitmap) {
      let flag = !0;
      const glTextures = baseTexture._glTextures;
      for (const key in glTextures) {
        const otherTex = glTextures[key];
        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
          flag = !1;
          break;
        }
      }
      flag && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
    }
    return !0;
  }
  /** Destroys this resource. */
  dispose() {
    this.source.onload = null, this.source.onerror = null, super.dispose(), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if current environment support HTMLImageElement, and source is string or HTMLImageElement
   */
  static test(source) {
    return typeof HTMLImageElement < "u" && (typeof source == "string" || source instanceof HTMLImageElement);
  }
}
exports.ImageResource = ImageResource;
//# sourceMappingURL=ImageResource.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/Resource.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/Resource.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.js");
class Resource {
  /**
   * @param width - Width of the resource
   * @param height - Height of the resource
   */
  constructor(width = 0, height = 0) {
    this._width = width, this._height = height, this.destroyed = !1, this.internal = !1, this.onResize = new runner.Runner("setRealSize"), this.onUpdate = new runner.Runner("update"), this.onError = new runner.Runner("onError");
  }
  /**
   * Bind to a parent BaseTexture
   * @param baseTexture - Parent texture
   */
  bind(baseTexture) {
    this.onResize.add(baseTexture), this.onUpdate.add(baseTexture), this.onError.add(baseTexture), (this._width || this._height) && this.onResize.emit(this._width, this._height);
  }
  /**
   * Unbind to a parent BaseTexture
   * @param baseTexture - Parent texture
   */
  unbind(baseTexture) {
    this.onResize.remove(baseTexture), this.onUpdate.remove(baseTexture), this.onError.remove(baseTexture);
  }
  /**
   * Trigger a resize event
   * @param width - X dimension
   * @param height - Y dimension
   */
  resize(width, height) {
    (width !== this._width || height !== this._height) && (this._width = width, this._height = height, this.onResize.emit(width, height));
  }
  /**
   * Has been validated
   * @readonly
   */
  get valid() {
    return !!this._width && !!this._height;
  }
  /** Has been updated trigger event. */
  update() {
    this.destroyed || this.onUpdate.emit();
  }
  /**
   * This can be overridden to start preloading a resource
   * or do any other prepare step.
   * @protected
   * @returns Handle the validate event
   */
  load() {
    return Promise.resolve(this);
  }
  /**
   * The width of the resource.
   * @readonly
   */
  get width() {
    return this._width;
  }
  /**
   * The height of the resource.
   * @readonly
   */
  get height() {
    return this._height;
  }
  /**
   * Set the style, optional to override
   * @param _renderer - yeah, renderer!
   * @param _baseTexture - the texture
   * @param _glTexture - texture instance for this webgl context
   * @returns - `true` is success
   */
  style(_renderer, _baseTexture, _glTexture) {
    return !1;
  }
  /** Clean up anything, this happens when destroying is ready. */
  dispose() {
  }
  /**
   * Call when destroying resource, unbind any BaseTexture object
   * before calling this method, as reference counts are maintained
   * internally.
   */
  destroy() {
    this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
  }
  /**
   * Abstract, used to auto-detect resource type.
   * @param {*} _source - The source object
   * @param {string} _extension - The extension of source, if set
   */
  static test(_source, _extension) {
    return !1;
  }
}
exports.Resource = Resource;
//# sourceMappingURL=Resource.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/SVGResource.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/SVGResource.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js"), utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js"), BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js");
const _SVGResource = class _SVGResource2 extends BaseImageResource.BaseImageResource {
  /**
   * @param sourceBase64 - Base64 encoded SVG element or URL for SVG file.
   * @param {object} [options] - Options to use
   * @param {number} [options.scale=1] - Scale to apply to SVG. Overridden by...
   * @param {number} [options.width] - Rasterize SVG this wide. Aspect ratio preserved if height not specified.
   * @param {number} [options.height] - Rasterize SVG this high. Aspect ratio preserved if width not specified.
   * @param {boolean} [options.autoLoad=true] - Start loading right away.
   */
  constructor(sourceBase64, options) {
    options = options || {}, super(settings.settings.ADAPTER.createCanvas()), this._width = 0, this._height = 0, this.svg = sourceBase64, this.scale = options.scale || 1, this._overrideWidth = options.width, this._overrideHeight = options.height, this._resolve = null, this._crossorigin = options.crossorigin, this._load = null, options.autoLoad !== !1 && this.load();
  }
  load() {
    return this._load ? this._load : (this._load = new Promise((resolve) => {
      if (this._resolve = () => {
        this.update(), resolve(this);
      }, _SVGResource2.SVG_XML.test(this.svg.trim())) {
        if (!btoa)
          throw new Error("Your browser doesn't support base64 conversions.");
        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
      }
      this._loadSvg();
    }), this._load);
  }
  /** Loads an SVG image from `imageUrl` or `data URL`. */
  _loadSvg() {
    const tempImage = new Image();
    BaseImageResource.BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin), tempImage.src = this.svg, tempImage.onerror = (event) => {
      this._resolve && (tempImage.onerror = null, this.onError.emit(event));
    }, tempImage.onload = () => {
      if (!this._resolve)
        return;
      const svgWidth = tempImage.width, svgHeight = tempImage.height;
      if (!svgWidth || !svgHeight)
        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
      let width = svgWidth * this.scale, height = svgHeight * this.scale;
      (this._overrideWidth || this._overrideHeight) && (width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth, height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight), width = Math.round(width), height = Math.round(height);
      const canvas = this.source;
      canvas.width = width, canvas.height = height, canvas._pixiId = `canvas_${utils.uid()}`, canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height), this._resolve(), this._resolve = null;
    };
  }
  /**
   * Get size from an svg string using a regular expression.
   * @param svgString - a serialized svg element
   * @returns - image extension
   */
  static getSize(svgString) {
    const sizeMatch = _SVGResource2.SVG_SIZE.exec(svgString), size = {};
    return sizeMatch && (size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3])), size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]))), size;
  }
  /** Destroys this texture. */
  dispose() {
    super.dispose(), this._resolve = null, this._crossorigin = null;
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @param {string} extension - The extension of source, if set
   * @returns {boolean} - If the source is a SVG source or data file
   */
  static test(source, extension) {
    return extension === "svg" || typeof source == "string" && source.startsWith("data:image/svg+xml") || typeof source == "string" && _SVGResource2.SVG_XML.test(source);
  }
  // eslint-disable-line max-len
};
_SVGResource.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, /**
* Regular expression for SVG size.
* @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;
* @readonly
*/
_SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
let SVGResource = _SVGResource;
exports.SVGResource = SVGResource;
//# sourceMappingURL=SVGResource.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/VideoResource.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/VideoResource.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var ticker = __webpack_require__(/*! @pixi/ticker */ "./node_modules/@pixi/ticker/lib/index.js"), BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js");
const _VideoResource = class _VideoResource2 extends BaseImageResource.BaseImageResource {
  /**
   * @param {HTMLVideoElement|object|string|Array<string|object>} source - Video element to use.
   * @param {object} [options] - Options to use
   * @param {boolean} [options.autoLoad=true] - Start loading the video immediately
   * @param {boolean} [options.autoPlay=true] - Start playing video immediately
   * @param {number} [options.updateFPS=0] - How many times a second to update the texture from the video.
   * Leave at 0 to update at every render.
   * @param {boolean} [options.crossorigin=true] - Load image using cross origin
   * @param {boolean} [options.loop=false] - Loops the video
   * @param {boolean} [options.muted=false] - Mutes the video audio, useful for autoplay
   * @param {boolean} [options.playsinline=true] - Prevents opening the video on mobile devices
   */
  constructor(source, options) {
    if (options = options || {}, !(source instanceof HTMLVideoElement)) {
      const videoElement = document.createElement("video");
      options.autoLoad !== !1 && videoElement.setAttribute("preload", "auto"), options.playsinline !== !1 && (videoElement.setAttribute("webkit-playsinline", ""), videoElement.setAttribute("playsinline", "")), options.muted === !0 && (videoElement.setAttribute("muted", ""), videoElement.muted = !0), options.loop === !0 && videoElement.setAttribute("loop", ""), options.autoPlay !== !1 && videoElement.setAttribute("autoplay", ""), typeof source == "string" && (source = [source]);
      const firstSrc = source[0].src || source[0];
      BaseImageResource.BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
      for (let i = 0; i < source.length; ++i) {
        const sourceElement = document.createElement("source");
        let { src, mime } = source[i];
        if (src = src || source[i], src.startsWith("data:"))
          mime = src.slice(5, src.indexOf(";"));
        else if (!src.startsWith("blob:")) {
          const baseSrc = src.split("?").shift().toLowerCase(), ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
          mime = mime || _VideoResource2.MIME_TYPES[ext] || `video/${ext}`;
        }
        sourceElement.src = src, mime && (sourceElement.type = mime), videoElement.appendChild(sourceElement);
      }
      source = videoElement;
    }
    super(source), this.noSubImage = !0, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = options.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = options.autoPlay !== !1, this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), options.autoLoad !== !1 && this.load();
  }
  /**
   * Trigger updating of the texture.
   * @param _deltaTime - time delta since last tick
   */
  update(_deltaTime = 0) {
    if (!this.destroyed) {
      if (this._updateFPS) {
        const elapsedMS = ticker.Ticker.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      }
      (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(
        /* deltaTime*/
      ), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
    }
  }
  _videoFrameRequestCallback() {
    this.update(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    );
  }
  /**
   * Start preloading the video resource.
   * @returns {Promise<void>} Handle the validate event
   */
  load() {
    if (this._load)
      return this._load;
    const source = this.source;
    return (source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height && (source.complete = !0), source.addEventListener("play", this._onPlayStart), source.addEventListener("pause", this._onPlayStop), source.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._onCanPlay() : (source.addEventListener("canplay", this._onCanPlay), source.addEventListener("canplaythrough", this._onCanPlay), source.addEventListener("error", this._onError, !0)), this._load = new Promise((resolve, reject) => {
      this.valid ? resolve(this) : (this._resolve = resolve, this._reject = reject, source.load());
    }), this._load;
  }
  /**
   * Handle video error events.
   * @param event
   */
  _onError(event) {
    this.source.removeEventListener("error", this._onError, !0), this.onError.emit(event), this._reject && (this._reject(event), this._reject = null, this._resolve = null);
  }
  /**
   * Returns true if the underlying source is playing.
   * @returns - True if playing.
   */
  _isSourcePlaying() {
    const source = this.source;
    return !source.paused && !source.ended;
  }
  /**
   * Returns true if the underlying source is ready for playing.
   * @returns - True if ready.
   */
  _isSourceReady() {
    return this.source.readyState > 2;
  }
  /** Runs the update loop when the video is ready to play. */
  _onPlayStart() {
    this.valid || this._onCanPlay(), this._configureAutoUpdate();
  }
  /** Fired when a pause event is triggered, stops the update loop. */
  _onPlayStop() {
    this._configureAutoUpdate();
  }
  /** Fired when the video is completed seeking to the current playback position. */
  _onSeeked() {
    this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.update(), this._msToNextUpdate = 0);
  }
  /** Fired when the video is loaded and ready to play. */
  _onCanPlay() {
    const source = this.source;
    source.removeEventListener("canplay", this._onCanPlay), source.removeEventListener("canplaythrough", this._onCanPlay);
    const valid = this.valid;
    this._msToNextUpdate = 0, this.update(), this._msToNextUpdate = 0, !valid && this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && source.play();
  }
  /** Destroys this texture. */
  dispose() {
    this._configureAutoUpdate();
    const source = this.source;
    source && (source.removeEventListener("play", this._onPlayStart), source.removeEventListener("pause", this._onPlayStop), source.removeEventListener("seeked", this._onSeeked), source.removeEventListener("canplay", this._onCanPlay), source.removeEventListener("canplaythrough", this._onCanPlay), source.removeEventListener("error", this._onError, !0), source.pause(), source.src = "", source.load()), super.dispose();
  }
  /** Should the base texture automatically update itself, set to true by default. */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    value !== this._autoUpdate && (this._autoUpdate = value, this._configureAutoUpdate());
  }
  /**
   * How many times a second to update the texture from the video. Leave at 0 to update at every render.
   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
   */
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(value) {
    value !== this._updateFPS && (this._updateFPS = value, this._configureAutoUpdate());
  }
  _configureAutoUpdate() {
    this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.source.requestVideoFrameCallback ? (this._isConnectedToTicker && (ticker.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    ))) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (ticker.Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (ticker.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0));
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @param {string} extension - The extension of source, if set
   * @returns {boolean} `true` if video source
   */
  static test(source, extension) {
    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource2.TYPES.includes(extension);
  }
};
_VideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], /**
* Map of video MIME types that can't be directly derived from file extensions.
* @readonly
*/
_VideoResource.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};
let VideoResource = _VideoResource;
exports.VideoResource = VideoResource;
//# sourceMappingURL=VideoResource.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const INSTALLED = [];
function autoDetectResource(source, options) {
  if (!source)
    return null;
  let extension = "";
  if (typeof source == "string") {
    const result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    result && (extension = result[1].toLowerCase());
  }
  for (let i = INSTALLED.length - 1; i >= 0; --i) {
    const ResourcePlugin = INSTALLED[i];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension))
      return new ResourcePlugin(source, options);
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
exports.INSTALLED = INSTALLED;
exports.autoDetectResource = autoDetectResource;
//# sourceMappingURL=autoDetectResource.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var ArrayResource = __webpack_require__(/*! ./ArrayResource.js */ "./node_modules/@pixi/core/lib/textures/resources/ArrayResource.js"), autoDetectResource = __webpack_require__(/*! ./autoDetectResource.js */ "./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.js"), BufferResource = __webpack_require__(/*! ./BufferResource.js */ "./node_modules/@pixi/core/lib/textures/resources/BufferResource.js"), CanvasResource = __webpack_require__(/*! ./CanvasResource.js */ "./node_modules/@pixi/core/lib/textures/resources/CanvasResource.js"), CubeResource = __webpack_require__(/*! ./CubeResource.js */ "./node_modules/@pixi/core/lib/textures/resources/CubeResource.js"), ImageBitmapResource = __webpack_require__(/*! ./ImageBitmapResource.js */ "./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.js"), ImageResource = __webpack_require__(/*! ./ImageResource.js */ "./node_modules/@pixi/core/lib/textures/resources/ImageResource.js"), SVGResource = __webpack_require__(/*! ./SVGResource.js */ "./node_modules/@pixi/core/lib/textures/resources/SVGResource.js"), VideoResource = __webpack_require__(/*! ./VideoResource.js */ "./node_modules/@pixi/core/lib/textures/resources/VideoResource.js"), BaseImageResource = __webpack_require__(/*! ./BaseImageResource.js */ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.js"), Resource = __webpack_require__(/*! ./Resource.js */ "./node_modules/@pixi/core/lib/textures/resources/Resource.js"), AbstractMultiResource = __webpack_require__(/*! ./AbstractMultiResource.js */ "./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.js");
autoDetectResource.INSTALLED.push(
  ImageBitmapResource.ImageBitmapResource,
  ImageResource.ImageResource,
  CanvasResource.CanvasResource,
  VideoResource.VideoResource,
  SVGResource.SVGResource,
  BufferResource.BufferResource,
  CubeResource.CubeResource,
  ArrayResource.ArrayResource
);
exports.ArrayResource = ArrayResource.ArrayResource;
exports.INSTALLED = autoDetectResource.INSTALLED;
exports.autoDetectResource = autoDetectResource.autoDetectResource;
exports.BufferResource = BufferResource.BufferResource;
exports.CanvasResource = CanvasResource.CanvasResource;
exports.CubeResource = CubeResource.CubeResource;
exports.ImageBitmapResource = ImageBitmapResource.ImageBitmapResource;
exports.ImageResource = ImageResource.ImageResource;
exports.SVGResource = SVGResource.SVGResource;
exports.VideoResource = VideoResource.VideoResource;
exports.BaseImageResource = BaseImageResource.BaseImageResource;
exports.Resource = Resource.Resource;
exports.AbstractMultiResource = AbstractMultiResource.AbstractMultiResource;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/utils/mapInternalFormatToSamplerType.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/utils/mapInternalFormatToSamplerType.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js");
function mapInternalFormatToSamplerType(gl) {
  let table;
  return "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext ? table = {
    [gl.RGB]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGBA]: constants.SAMPLER_TYPES.FLOAT,
    [gl.ALPHA]: constants.SAMPLER_TYPES.FLOAT,
    [gl.LUMINANCE]: constants.SAMPLER_TYPES.FLOAT,
    [gl.LUMINANCE_ALPHA]: constants.SAMPLER_TYPES.FLOAT,
    [gl.R8]: constants.SAMPLER_TYPES.FLOAT,
    [gl.R8_SNORM]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RG8]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RG8_SNORM]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGB8]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGB8_SNORM]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGB565]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGBA4]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGB5_A1]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGBA8]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGBA8_SNORM]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGB10_A2]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGB10_A2UI]: constants.SAMPLER_TYPES.FLOAT,
    [gl.SRGB8]: constants.SAMPLER_TYPES.FLOAT,
    [gl.SRGB8_ALPHA8]: constants.SAMPLER_TYPES.FLOAT,
    [gl.R16F]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RG16F]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGB16F]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGBA16F]: constants.SAMPLER_TYPES.FLOAT,
    [gl.R32F]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RG32F]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGB32F]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGBA32F]: constants.SAMPLER_TYPES.FLOAT,
    [gl.R11F_G11F_B10F]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGB9_E5]: constants.SAMPLER_TYPES.FLOAT,
    [gl.R8I]: constants.SAMPLER_TYPES.INT,
    [gl.R8UI]: constants.SAMPLER_TYPES.UINT,
    [gl.R16I]: constants.SAMPLER_TYPES.INT,
    [gl.R16UI]: constants.SAMPLER_TYPES.UINT,
    [gl.R32I]: constants.SAMPLER_TYPES.INT,
    [gl.R32UI]: constants.SAMPLER_TYPES.UINT,
    [gl.RG8I]: constants.SAMPLER_TYPES.INT,
    [gl.RG8UI]: constants.SAMPLER_TYPES.UINT,
    [gl.RG16I]: constants.SAMPLER_TYPES.INT,
    [gl.RG16UI]: constants.SAMPLER_TYPES.UINT,
    [gl.RG32I]: constants.SAMPLER_TYPES.INT,
    [gl.RG32UI]: constants.SAMPLER_TYPES.UINT,
    [gl.RGB8I]: constants.SAMPLER_TYPES.INT,
    [gl.RGB8UI]: constants.SAMPLER_TYPES.UINT,
    [gl.RGB16I]: constants.SAMPLER_TYPES.INT,
    [gl.RGB16UI]: constants.SAMPLER_TYPES.UINT,
    [gl.RGB32I]: constants.SAMPLER_TYPES.INT,
    [gl.RGB32UI]: constants.SAMPLER_TYPES.UINT,
    [gl.RGBA8I]: constants.SAMPLER_TYPES.INT,
    [gl.RGBA8UI]: constants.SAMPLER_TYPES.UINT,
    [gl.RGBA16I]: constants.SAMPLER_TYPES.INT,
    [gl.RGBA16UI]: constants.SAMPLER_TYPES.UINT,
    [gl.RGBA32I]: constants.SAMPLER_TYPES.INT,
    [gl.RGBA32UI]: constants.SAMPLER_TYPES.UINT,
    [gl.DEPTH_COMPONENT16]: constants.SAMPLER_TYPES.FLOAT,
    [gl.DEPTH_COMPONENT24]: constants.SAMPLER_TYPES.FLOAT,
    [gl.DEPTH_COMPONENT32F]: constants.SAMPLER_TYPES.FLOAT,
    [gl.DEPTH_STENCIL]: constants.SAMPLER_TYPES.FLOAT,
    [gl.DEPTH24_STENCIL8]: constants.SAMPLER_TYPES.FLOAT,
    [gl.DEPTH32F_STENCIL8]: constants.SAMPLER_TYPES.FLOAT
  } : table = {
    [gl.RGB]: constants.SAMPLER_TYPES.FLOAT,
    [gl.RGBA]: constants.SAMPLER_TYPES.FLOAT,
    [gl.ALPHA]: constants.SAMPLER_TYPES.FLOAT,
    [gl.LUMINANCE]: constants.SAMPLER_TYPES.FLOAT,
    [gl.LUMINANCE_ALPHA]: constants.SAMPLER_TYPES.FLOAT,
    [gl.DEPTH_STENCIL]: constants.SAMPLER_TYPES.FLOAT
  }, table;
}
exports.mapInternalFormatToSamplerType = mapInternalFormatToSamplerType;
//# sourceMappingURL=mapInternalFormatToSamplerType.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js");
function mapTypeAndFormatToInternalFormat(gl) {
  let table;
  return "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext ? table = {
    [constants.TYPES.UNSIGNED_BYTE]: {
      [constants.FORMATS.RGBA]: gl.RGBA8,
      [constants.FORMATS.RGB]: gl.RGB8,
      [constants.FORMATS.RG]: gl.RG8,
      [constants.FORMATS.RED]: gl.R8,
      [constants.FORMATS.RGBA_INTEGER]: gl.RGBA8UI,
      [constants.FORMATS.RGB_INTEGER]: gl.RGB8UI,
      [constants.FORMATS.RG_INTEGER]: gl.RG8UI,
      [constants.FORMATS.RED_INTEGER]: gl.R8UI,
      [constants.FORMATS.ALPHA]: gl.ALPHA,
      [constants.FORMATS.LUMINANCE]: gl.LUMINANCE,
      [constants.FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
    },
    [constants.TYPES.BYTE]: {
      [constants.FORMATS.RGBA]: gl.RGBA8_SNORM,
      [constants.FORMATS.RGB]: gl.RGB8_SNORM,
      [constants.FORMATS.RG]: gl.RG8_SNORM,
      [constants.FORMATS.RED]: gl.R8_SNORM,
      [constants.FORMATS.RGBA_INTEGER]: gl.RGBA8I,
      [constants.FORMATS.RGB_INTEGER]: gl.RGB8I,
      [constants.FORMATS.RG_INTEGER]: gl.RG8I,
      [constants.FORMATS.RED_INTEGER]: gl.R8I
    },
    [constants.TYPES.UNSIGNED_SHORT]: {
      [constants.FORMATS.RGBA_INTEGER]: gl.RGBA16UI,
      [constants.FORMATS.RGB_INTEGER]: gl.RGB16UI,
      [constants.FORMATS.RG_INTEGER]: gl.RG16UI,
      [constants.FORMATS.RED_INTEGER]: gl.R16UI,
      [constants.FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16
    },
    [constants.TYPES.SHORT]: {
      [constants.FORMATS.RGBA_INTEGER]: gl.RGBA16I,
      [constants.FORMATS.RGB_INTEGER]: gl.RGB16I,
      [constants.FORMATS.RG_INTEGER]: gl.RG16I,
      [constants.FORMATS.RED_INTEGER]: gl.R16I
    },
    [constants.TYPES.UNSIGNED_INT]: {
      [constants.FORMATS.RGBA_INTEGER]: gl.RGBA32UI,
      [constants.FORMATS.RGB_INTEGER]: gl.RGB32UI,
      [constants.FORMATS.RG_INTEGER]: gl.RG32UI,
      [constants.FORMATS.RED_INTEGER]: gl.R32UI,
      [constants.FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24
    },
    [constants.TYPES.INT]: {
      [constants.FORMATS.RGBA_INTEGER]: gl.RGBA32I,
      [constants.FORMATS.RGB_INTEGER]: gl.RGB32I,
      [constants.FORMATS.RG_INTEGER]: gl.RG32I,
      [constants.FORMATS.RED_INTEGER]: gl.R32I
    },
    [constants.TYPES.FLOAT]: {
      [constants.FORMATS.RGBA]: gl.RGBA32F,
      [constants.FORMATS.RGB]: gl.RGB32F,
      [constants.FORMATS.RG]: gl.RG32F,
      [constants.FORMATS.RED]: gl.R32F,
      [constants.FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F
    },
    [constants.TYPES.HALF_FLOAT]: {
      [constants.FORMATS.RGBA]: gl.RGBA16F,
      [constants.FORMATS.RGB]: gl.RGB16F,
      [constants.FORMATS.RG]: gl.RG16F,
      [constants.FORMATS.RED]: gl.R16F
    },
    [constants.TYPES.UNSIGNED_SHORT_5_6_5]: {
      [constants.FORMATS.RGB]: gl.RGB565
    },
    [constants.TYPES.UNSIGNED_SHORT_4_4_4_4]: {
      [constants.FORMATS.RGBA]: gl.RGBA4
    },
    [constants.TYPES.UNSIGNED_SHORT_5_5_5_1]: {
      [constants.FORMATS.RGBA]: gl.RGB5_A1
    },
    [constants.TYPES.UNSIGNED_INT_2_10_10_10_REV]: {
      [constants.FORMATS.RGBA]: gl.RGB10_A2,
      [constants.FORMATS.RGBA_INTEGER]: gl.RGB10_A2UI
    },
    [constants.TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {
      [constants.FORMATS.RGB]: gl.R11F_G11F_B10F
    },
    [constants.TYPES.UNSIGNED_INT_5_9_9_9_REV]: {
      [constants.FORMATS.RGB]: gl.RGB9_E5
    },
    [constants.TYPES.UNSIGNED_INT_24_8]: {
      [constants.FORMATS.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8
    },
    [constants.TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
      [constants.FORMATS.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8
    }
  } : table = {
    [constants.TYPES.UNSIGNED_BYTE]: {
      [constants.FORMATS.RGBA]: gl.RGBA,
      [constants.FORMATS.RGB]: gl.RGB,
      [constants.FORMATS.ALPHA]: gl.ALPHA,
      [constants.FORMATS.LUMINANCE]: gl.LUMINANCE,
      [constants.FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
    },
    [constants.TYPES.UNSIGNED_SHORT_5_6_5]: {
      [constants.FORMATS.RGB]: gl.RGB
    },
    [constants.TYPES.UNSIGNED_SHORT_4_4_4_4]: {
      [constants.FORMATS.RGBA]: gl.RGBA
    },
    [constants.TYPES.UNSIGNED_SHORT_5_5_5_1]: {
      [constants.FORMATS.RGBA]: gl.RGBA
    }
  }, table;
}
exports.mapTypeAndFormatToInternalFormat = mapTypeAndFormatToInternalFormat;
//# sourceMappingURL=mapTypeAndFormatToInternalFormat.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var runner = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.js");
class TransformFeedback {
  constructor() {
    this._glTransformFeedbacks = {}, this.buffers = [], this.disposeRunner = new runner.Runner("disposeTransformFeedback");
  }
  /**
   * Bind buffer to TransformFeedback
   * @param index - index to bind
   * @param buffer - buffer to bind
   */
  bindBuffer(index, buffer) {
    this.buffers[index] = buffer;
  }
  /** Destroy WebGL resources that are connected to this TransformFeedback. */
  destroy() {
    this.disposeRunner.emit(this, !1);
  }
}
exports.TransformFeedback = TransformFeedback;
//# sourceMappingURL=TransformFeedback.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js");
class TransformFeedbackSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer;
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  /**
   * Bind TransformFeedback and buffers
   * @param transformFeedback - TransformFeedback to bind
   */
  bind(transformFeedback) {
    const { gl, CONTEXT_UID } = this, glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
  }
  /** Unbind TransformFeedback */
  unbind() {
    const { gl } = this;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
  }
  /**
   * Begin TransformFeedback
   * @param drawMode - DrawMode for TransformFeedback
   * @param shader - A Shader used by TransformFeedback. Current bound shader will be used if not provided.
   */
  beginTransformFeedback(drawMode, shader) {
    const { gl, renderer } = this;
    shader && renderer.shader.bind(shader), gl.beginTransformFeedback(drawMode);
  }
  /** End TransformFeedback */
  endTransformFeedback() {
    const { gl } = this;
    gl.endTransformFeedback();
  }
  /**
   * Create TransformFeedback and bind buffers
   * @param tf - TransformFeedback
   * @returns WebGLTransformFeedback
   */
  createGLTransformFeedback(tf) {
    const { gl, renderer, CONTEXT_UID } = this, glTransformFeedback = gl.createTransformFeedback();
    tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback, gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
    for (let i = 0; i < tf.buffers.length; i++) {
      const buffer = tf.buffers[i];
      buffer && (renderer.buffer.update(buffer), buffer._glBuffers[CONTEXT_UID].refCount++, gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, buffer._glBuffers[CONTEXT_UID].buffer || null));
    }
    return gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null), tf.disposeRunner.add(this), glTransformFeedback;
  }
  /**
   * Disposes TransfromFeedback
   * @param {PIXI.TransformFeedback} tf - TransformFeedback
   * @param {boolean} [contextLost=false] - If context was lost, we suppress delete TransformFeedback
   */
  disposeTransformFeedback(tf, contextLost) {
    const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID], gl = this.gl;
    tf.disposeRunner.remove(this);
    const bufferSystem = this.renderer.buffer;
    if (bufferSystem)
      for (let i = 0; i < tf.buffers.length; i++) {
        const buffer = tf.buffers[i];
        if (!buffer)
          continue;
        const buf = buffer._glBuffers[this.CONTEXT_UID];
        buf && (buf.refCount--, buf.refCount === 0 && !contextLost && bufferSystem.dispose(buffer, contextLost));
      }
    glTF && (contextLost || gl.deleteTransformFeedback(glTF), delete tf._glTransformFeedbacks[this.CONTEXT_UID]);
  }
  destroy() {
    this.renderer = null;
  }
}
TransformFeedbackSystem.extension = {
  type: extensions.ExtensionType.RendererSystem,
  name: "transformFeedback"
};
extensions.extensions.add(TransformFeedbackSystem);
exports.TransformFeedbackSystem = TransformFeedbackSystem;
//# sourceMappingURL=TransformFeedbackSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/utils/Quad.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/core/lib/utils/Quad.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Geometry = __webpack_require__(/*! ../geometry/Geometry.js */ "./node_modules/@pixi/core/lib/geometry/Geometry.js");
class Quad extends Geometry.Geometry {
  constructor() {
    super(), this.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]);
  }
}
exports.Quad = Quad;
//# sourceMappingURL=Quad.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/utils/QuadUv.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/core/lib/utils/QuadUv.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Buffer = __webpack_require__(/*! ../geometry/Buffer.js */ "./node_modules/@pixi/core/lib/geometry/Buffer.js"), Geometry = __webpack_require__(/*! ../geometry/Geometry.js */ "./node_modules/@pixi/core/lib/geometry/Geometry.js");
class QuadUv extends Geometry.Geometry {
  constructor() {
    super(), this.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]), this.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]), this.vertexBuffer = new Buffer.Buffer(this.vertices), this.uvBuffer = new Buffer.Buffer(this.uvs), this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
  }
  /**
   * Maps two Rectangle to the quad.
   * @param targetTextureFrame - The first rectangle
   * @param destinationFrame - The second rectangle
   * @returns - Returns itself.
   */
  map(targetTextureFrame, destinationFrame) {
    let x = 0, y = 0;
    return this.uvs[0] = x, this.uvs[1] = y, this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width, this.uvs[3] = y, this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width, this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height, this.uvs[6] = x, this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height, x = destinationFrame.x, y = destinationFrame.y, this.vertices[0] = x, this.vertices[1] = y, this.vertices[2] = x + destinationFrame.width, this.vertices[3] = y, this.vertices[4] = x + destinationFrame.width, this.vertices[5] = y + destinationFrame.height, this.vertices[6] = x, this.vertices[7] = y + destinationFrame.height, this.invalidate(), this;
  }
  /**
   * Legacy upload method, just marks buffers dirty.
   * @returns - Returns itself.
   */
  invalidate() {
    return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
  }
}
exports.QuadUv = QuadUv;
//# sourceMappingURL=QuadUv.js.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/view/ViewSystem.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/view/ViewSystem.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), math = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.js"), settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js");
class ViewSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  /**
   * initiates the view system
   * @param {PIXI.ViewOptions} options - the options for the view
   */
  init(options) {
    this.screen = new math.Rectangle(0, 0, options.width, options.height), this.element = options.view || settings.settings.ADAPTER.createCanvas(), this.resolution = options.resolution || settings.settings.RESOLUTION, this.autoDensity = !!options.autoDensity;
  }
  /**
   * Resizes the screen and canvas to the specified dimensions.
   * @param desiredScreenWidth - The new width of the screen.
   * @param desiredScreenHeight - The new height of the screen.
   */
  resizeView(desiredScreenWidth, desiredScreenHeight) {
    this.element.width = Math.round(desiredScreenWidth * this.resolution), this.element.height = Math.round(desiredScreenHeight * this.resolution);
    const screenWidth = this.element.width / this.resolution, screenHeight = this.element.height / this.resolution;
    this.screen.width = screenWidth, this.screen.height = screenHeight, this.autoDensity && (this.element.style.width = `${screenWidth}px`, this.element.style.height = `${screenHeight}px`), this.renderer.emit("resize", screenWidth, screenHeight), this.renderer.runners.resize.emit(this.screen.width, this.screen.height);
  }
  /**
   * Destroys this System and optionally removes the canvas from the dom.
   * @param {boolean} [removeView=false] - Whether to remove the canvas from the DOM.
   */
  destroy(removeView) {
    removeView && this.element.parentNode?.removeChild(this.element), this.renderer = null, this.element = null, this.screen = null;
  }
}
ViewSystem.defaultOptions = {
  /**
   * {@link PIXI.IRendererOptions.width}
   * @default 800
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  width: 800,
  /**
   * {@link PIXI.IRendererOptions.height}
   * @default 600
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  height: 600,
  /**
   * {@link PIXI.IRendererOptions.resolution}
   * @type {number}
   * @default PIXI.settings.RESOLUTION
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  resolution: void 0,
  /**
   * {@link PIXI.IRendererOptions.autoDensity}
   * @default false
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  autoDensity: !1
}, /** @ignore */
ViewSystem.extension = {
  type: [
    extensions.ExtensionType.RendererSystem,
    extensions.ExtensionType.CanvasRendererSystem
  ],
  name: "_view"
};
extensions.extensions.add(ViewSystem);
exports.ViewSystem = ViewSystem;
//# sourceMappingURL=ViewSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/display/lib/Bounds.js":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/display/lib/Bounds.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
class Bounds {
  constructor() {
    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
  }
  /**
   * Checks if bounds are empty.
   * @returns - True if empty.
   */
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  /** Clears the bounds and resets. */
  clear() {
    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
  }
  /**
   * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle
   * It is not guaranteed that it will return tempRect
   * @param rect - Temporary object will be used if AABB is not empty
   * @returns - A rectangle of the bounds
   */
  getRectangle(rect) {
    return this.minX > this.maxX || this.minY > this.maxY ? core.Rectangle.EMPTY : (rect = rect || new core.Rectangle(0, 0, 1, 1), rect.x = this.minX, rect.y = this.minY, rect.width = this.maxX - this.minX, rect.height = this.maxY - this.minY, rect);
  }
  /**
   * This function should be inlined when its possible.
   * @param point - The point to add.
   */
  addPoint(point) {
    this.minX = Math.min(this.minX, point.x), this.maxX = Math.max(this.maxX, point.x), this.minY = Math.min(this.minY, point.y), this.maxY = Math.max(this.maxY, point.y);
  }
  /**
   * Adds a point, after transformed. This should be inlined when its possible.
   * @param matrix
   * @param point
   */
  addPointMatrix(matrix, point) {
    const { a, b, c, d, tx, ty } = matrix, x = a * point.x + c * point.y + tx, y = b * point.x + d * point.y + ty;
    this.minX = Math.min(this.minX, x), this.maxX = Math.max(this.maxX, x), this.minY = Math.min(this.minY, y), this.maxY = Math.max(this.maxY, y);
  }
  /**
   * Adds a quad, not transformed
   * @param vertices - The verts to add.
   */
  addQuad(vertices) {
    let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY, x = vertices[0], y = vertices[1];
    minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, x = vertices[2], y = vertices[3], minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, x = vertices[4], y = vertices[5], minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, x = vertices[6], y = vertices[7], minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;
  }
  /**
   * Adds sprite frame, transformed.
   * @param transform - transform to apply
   * @param x0 - left X of frame
   * @param y0 - top Y of frame
   * @param x1 - right X of frame
   * @param y1 - bottom Y of frame
   */
  addFrame(transform, x0, y0, x1, y1) {
    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
  }
  /**
   * Adds sprite frame, multiplied by matrix
   * @param matrix - matrix to apply
   * @param x0 - left X of frame
   * @param y0 - top Y of frame
   * @param x1 - right X of frame
   * @param y1 - bottom Y of frame
   */
  addFrameMatrix(matrix, x0, y0, x1, y1) {
    const a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d, tx = matrix.tx, ty = matrix.ty;
    let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY, x = a * x0 + c * y0 + tx, y = b * x0 + d * y0 + ty;
    minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, x = a * x1 + c * y0 + tx, y = b * x1 + d * y0 + ty, minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, x = a * x0 + c * y1 + tx, y = b * x0 + d * y1 + ty, minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, x = a * x1 + c * y1 + tx, y = b * x1 + d * y1 + ty, minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY, this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;
  }
  /**
   * Adds screen vertices from array
   * @param vertexData - calculated vertices
   * @param beginOffset - begin offset
   * @param endOffset - end offset, excluded
   */
  addVertexData(vertexData, beginOffset, endOffset) {
    let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
    for (let i = beginOffset; i < endOffset; i += 2) {
      const x = vertexData[i], y = vertexData[i + 1];
      minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = x > maxX ? x : maxX, maxY = y > maxY ? y : maxY;
    }
    this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;
  }
  /**
   * Add an array of mesh vertices
   * @param transform - mesh transform
   * @param vertices - mesh coordinates in array
   * @param beginOffset - begin offset
   * @param endOffset - end offset, excluded
   */
  addVertices(transform, vertices, beginOffset, endOffset) {
    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
  }
  /**
   * Add an array of mesh vertices.
   * @param matrix - mesh matrix
   * @param vertices - mesh coordinates in array
   * @param beginOffset - begin offset
   * @param endOffset - end offset, excluded
   * @param padX - x padding
   * @param padY - y padding
   */
  addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {
    const a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d, tx = matrix.tx, ty = matrix.ty;
    let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
    for (let i = beginOffset; i < endOffset; i += 2) {
      const rawX = vertices[i], rawY = vertices[i + 1], x = a * rawX + c * rawY + tx, y = d * rawY + b * rawX + ty;
      minX = Math.min(minX, x - padX), maxX = Math.max(maxX, x + padX), minY = Math.min(minY, y - padY), maxY = Math.max(maxY, y + padY);
    }
    this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;
  }
  /**
   * Adds other {@link PIXI.Bounds}.
   * @param bounds - The Bounds to be added
   */
  addBounds(bounds) {
    const minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
    this.minX = bounds.minX < minX ? bounds.minX : minX, this.minY = bounds.minY < minY ? bounds.minY : minY, this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX, this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
  }
  /**
   * Adds other Bounds, masked with Bounds.
   * @param bounds - The Bounds to be added.
   * @param mask - TODO
   */
  addBoundsMask(bounds, mask) {
    const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX, _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY, _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX, _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX, this.minY = _minY < minY ? _minY : minY, this.maxX = _maxX > maxX ? _maxX : maxX, this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  /**
   * Adds other Bounds, multiplied by matrix. Bounds shouldn't be empty.
   * @param bounds - other bounds
   * @param matrix - multiplicator
   */
  addBoundsMatrix(bounds, matrix) {
    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
  }
  /**
   * Adds other Bounds, masked with Rectangle.
   * @param bounds - TODO
   * @param area - TODO
   */
  addBoundsArea(bounds, area) {
    const _minX = bounds.minX > area.x ? bounds.minX : area.x, _minY = bounds.minY > area.y ? bounds.minY : area.y, _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width, _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX, this.minY = _minY < minY ? _minY : minY, this.maxX = _maxX > maxX ? _maxX : maxX, this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  /**
   * Pads bounds object, making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   */
  pad(paddingX = 0, paddingY = paddingX) {
    this.isEmpty() || (this.minX -= paddingX, this.maxX += paddingX, this.minY -= paddingY, this.maxY += paddingY);
  }
  /**
   * Adds padded frame. (x0, y0) should be strictly less than (x1, y1)
   * @param x0 - left X of frame
   * @param y0 - top Y of frame
   * @param x1 - right X of frame
   * @param y1 - bottom Y of frame
   * @param padX - padding X
   * @param padY - padding Y
   */
  addFramePad(x0, y0, x1, y1, padX, padY) {
    x0 -= padX, y0 -= padY, x1 += padX, y1 += padY, this.minX = this.minX < x0 ? this.minX : x0, this.maxX = this.maxX > x1 ? this.maxX : x1, this.minY = this.minY < y0 ? this.minY : y0, this.maxY = this.maxY > y1 ? this.maxY : y1;
  }
}
exports.Bounds = Bounds;
//# sourceMappingURL=Bounds.js.map


/***/ }),

/***/ "./node_modules/@pixi/display/lib/Container.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/display/lib/Container.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), DisplayObject = __webpack_require__(/*! ./DisplayObject.js */ "./node_modules/@pixi/display/lib/DisplayObject.js");
const tempMatrix = new core.Matrix();
function sortChildren(a, b) {
  return a.zIndex === b.zIndex ? a._lastSortedIndex - b._lastSortedIndex : a.zIndex - b.zIndex;
}
const _Container = class _Container2 extends DisplayObject.DisplayObject {
  constructor() {
    super(), this.children = [], this.sortableChildren = _Container2.defaultSortableChildren, this.sortDirty = !1;
  }
  /**
   * Overridable method that can be used by Container subclasses whenever the children array is modified.
   * @param _length
   */
  onChildrenChange(_length) {
  }
  /**
   * Adds one or more children to the container.
   *
   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
   * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to add to the container
   * @returns {PIXI.DisplayObject} - The first child that was added.
   */
  addChild(...children) {
    if (children.length > 1)
      for (let i = 0; i < children.length; i++)
        this.addChild(children[i]);
    else {
      const child = children[0];
      child.parent && child.parent.removeChild(child), child.parent = this, this.sortDirty = !0, child.transform._parentID = -1, this.children.push(child), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", child, this, this.children.length - 1), child.emit("added", this);
    }
    return children[0];
  }
  /**
   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.
   * If the child is already in this container, it will be moved to the specified index.
   * @param {PIXI.DisplayObject} child - The child to add.
   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.
   * @returns {PIXI.DisplayObject} The child that was added.
   */
  addChildAt(child, index) {
    if (index < 0 || index > this.children.length)
      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);
    return child.parent && child.parent.removeChild(child), child.parent = this, this.sortDirty = !0, child.transform._parentID = -1, this.children.splice(index, 0, child), this._boundsID++, this.onChildrenChange(index), child.emit("added", this), this.emit("childAdded", child, this, index), child;
  }
  /**
   * Swaps the position of 2 Display Objects within this container.
   * @param child - First display object to swap
   * @param child2 - Second display object to swap
   */
  swapChildren(child, child2) {
    if (child === child2)
      return;
    const index1 = this.getChildIndex(child), index2 = this.getChildIndex(child2);
    this.children[index1] = child2, this.children[index2] = child, this.onChildrenChange(index1 < index2 ? index1 : index2);
  }
  /**
   * Returns the index position of a child DisplayObject instance
   * @param child - The DisplayObject instance to identify
   * @returns - The index position of the child display object to identify
   */
  getChildIndex(child) {
    const index = this.children.indexOf(child);
    if (index === -1)
      throw new Error("The supplied DisplayObject must be a child of the caller");
    return index;
  }
  /**
   * Changes the position of an existing child in the display object container
   * @param child - The child DisplayObject instance for which you want to change the index number
   * @param index - The resulting index number for the child display object
   */
  setChildIndex(child, index) {
    if (index < 0 || index >= this.children.length)
      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
    const currentIndex = this.getChildIndex(child);
    core.utils.removeItems(this.children, currentIndex, 1), this.children.splice(index, 0, child), this.onChildrenChange(index);
  }
  /**
   * Returns the child at the specified index
   * @param index - The index to get the child at
   * @returns - The child at the given index, if any.
   */
  getChildAt(index) {
    if (index < 0 || index >= this.children.length)
      throw new Error(`getChildAt: Index (${index}) does not exist.`);
    return this.children[index];
  }
  /**
   * Removes one or more children from the container.
   * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to remove
   * @returns {PIXI.DisplayObject} The first child that was removed.
   */
  removeChild(...children) {
    if (children.length > 1)
      for (let i = 0; i < children.length; i++)
        this.removeChild(children[i]);
    else {
      const child = children[0], index = this.children.indexOf(child);
      if (index === -1)
        return null;
      child.parent = null, child.transform._parentID = -1, core.utils.removeItems(this.children, index, 1), this._boundsID++, this.onChildrenChange(index), child.emit("removed", this), this.emit("childRemoved", child, this, index);
    }
    return children[0];
  }
  /**
   * Removes a child from the specified index position.
   * @param index - The index to get the child from
   * @returns The child that was removed.
   */
  removeChildAt(index) {
    const child = this.getChildAt(index);
    return child.parent = null, child.transform._parentID = -1, core.utils.removeItems(this.children, index, 1), this._boundsID++, this.onChildrenChange(index), child.emit("removed", this), this.emit("childRemoved", child, this, index), child;
  }
  /**
   * Removes all children from this container that are within the begin and end indexes.
   * @param beginIndex - The beginning position.
   * @param endIndex - The ending position. Default value is size of the container.
   * @returns - List of removed children
   */
  removeChildren(beginIndex = 0, endIndex = this.children.length) {
    const begin = beginIndex, end = endIndex, range = end - begin;
    let removed;
    if (range > 0 && range <= end) {
      removed = this.children.splice(begin, range);
      for (let i = 0; i < removed.length; ++i)
        removed[i].parent = null, removed[i].transform && (removed[i].transform._parentID = -1);
      this._boundsID++, this.onChildrenChange(beginIndex);
      for (let i = 0; i < removed.length; ++i)
        removed[i].emit("removed", this), this.emit("childRemoved", removed[i], this, i);
      return removed;
    } else if (range === 0 && this.children.length === 0)
      return [];
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  }
  /** Sorts children by zIndex. Previous order is maintained for 2 children with the same zIndex. */
  sortChildren() {
    let sortRequired = !1;
    for (let i = 0, j = this.children.length; i < j; ++i) {
      const child = this.children[i];
      child._lastSortedIndex = i, !sortRequired && child.zIndex !== 0 && (sortRequired = !0);
    }
    sortRequired && this.children.length > 1 && this.children.sort(sortChildren), this.sortDirty = !1;
  }
  /** Updates the transform on all children of this container for rendering. */
  updateTransform() {
    this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
    for (let i = 0, j = this.children.length; i < j; ++i) {
      const child = this.children[i];
      child.visible && child.updateTransform();
    }
  }
  /**
   * Recalculates the bounds of the container.
   *
   * This implementation will automatically fit the children's bounds into the calculation. Each child's bounds
   * is limited to its mask's bounds or filterArea, if any is applied.
   */
  calculateBounds() {
    this._bounds.clear(), this._calculateBounds();
    for (let i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      if (!(!child.visible || !child.renderable))
        if (child.calculateBounds(), child._mask) {
          const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;
          maskObject ? (maskObject.calculateBounds(), this._bounds.addBoundsMask(child._bounds, maskObject._bounds)) : this._bounds.addBounds(child._bounds);
        } else
          child.filterArea ? this._bounds.addBoundsArea(child._bounds, child.filterArea) : this._bounds.addBounds(child._bounds);
    }
    this._bounds.updateID = this._boundsID;
  }
  /**
   * Retrieves the local bounds of the displayObject as a rectangle object.
   *
   * Calling `getLocalBounds` may invalidate the `_bounds` of the whole subtree below. If using it inside a render()
   * call, it is advised to call `getBounds()` immediately after to recalculate the world bounds of the subtree.
   * @param rect - Optional rectangle to store the result of the bounds calculation.
   * @param skipChildrenUpdate - Setting to `true` will stop re-calculation of children transforms,
   *  it was default behaviour of pixi 4.0-5.2 and caused many problems to users.
   * @returns - The rectangular bounding area.
   */
  getLocalBounds(rect, skipChildrenUpdate = !1) {
    const result = super.getLocalBounds(rect);
    if (!skipChildrenUpdate)
      for (let i = 0, j = this.children.length; i < j; ++i) {
        const child = this.children[i];
        child.visible && child.updateTransform();
      }
    return result;
  }
  /**
   * Recalculates the content bounds of this object. This should be overriden to
   * calculate the bounds of this specific object (not including children).
   * @protected
   */
  _calculateBounds() {
  }
  /**
   * Renders this object and its children with culling.
   * @protected
   * @param {PIXI.Renderer} renderer - The renderer
   */
  _renderWithCulling(renderer) {
    const sourceFrame = renderer.renderTexture.sourceFrame;
    if (!(sourceFrame.width > 0 && sourceFrame.height > 0))
      return;
    let bounds, transform;
    this.cullArea ? (bounds = this.cullArea, transform = this.worldTransform) : this._render !== _Container2.prototype._render && (bounds = this.getBounds(!0));
    const projectionTransform = renderer.projection.transform;
    if (projectionTransform && (transform ? (transform = tempMatrix.copyFrom(transform), transform.prepend(projectionTransform)) : transform = projectionTransform), bounds && sourceFrame.intersects(bounds, transform))
      this._render(renderer);
    else if (this.cullArea)
      return;
    for (let i = 0, j = this.children.length; i < j; ++i) {
      const child = this.children[i], childCullable = child.cullable;
      child.cullable = childCullable || !this.cullArea, child.render(renderer), child.cullable = childCullable;
    }
  }
  /**
   * Renders the object using the WebGL renderer.
   *
   * The [_render]{@link PIXI.Container#_render} method is be overriden for rendering the contents of the
   * container itself. This `render` method will invoke it, and also invoke the `render` methods of all
   * children afterward.
   *
   * If `renderable` or `visible` is false or if `worldAlpha` is not positive or if `cullable` is true and
   * the bounds of this object are out of frame, this implementation will entirely skip rendering.
   * See {@link PIXI.DisplayObject} for choosing between `renderable` or `visible`. Generally,
   * setting alpha to zero is not recommended for purely skipping rendering.
   *
   * When your scene becomes large (especially when it is larger than can be viewed in a single screen), it is
   * advised to employ **culling** to automatically skip rendering objects outside of the current screen.
   * See [cullable]{@link PIXI.DisplayObject#cullable} and [cullArea]{@link PIXI.DisplayObject#cullArea}.
   * Other culling methods might be better suited for a large number static objects; see
   * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} and
   * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull}.
   *
   * The [renderAdvanced]{@link PIXI.Container#renderAdvanced} method is internally used when when masking or
   * filtering is applied on a container. This does, however, break batching and can affect performance when
   * masking and filtering is applied extensively throughout the scene graph.
   * @param renderer - The renderer
   */
  render(renderer) {
    if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
      if (this._mask || this.filters?.length)
        this.renderAdvanced(renderer);
      else if (this.cullable)
        this._renderWithCulling(renderer);
      else {
        this._render(renderer);
        for (let i = 0, j = this.children.length; i < j; ++i)
          this.children[i].render(renderer);
      }
  }
  /**
   * Render the object using the WebGL renderer and advanced features.
   * @param renderer - The renderer
   */
  renderAdvanced(renderer) {
    const filters = this.filters, mask = this._mask;
    if (filters) {
      this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
      for (let i = 0; i < filters.length; i++)
        filters[i].enabled && this._enabledFilters.push(filters[i]);
    }
    const flush = filters && this._enabledFilters?.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== core.MASK_TYPES.NONE));
    if (flush && renderer.batch.flush(), filters && this._enabledFilters?.length && renderer.filter.push(this, this._enabledFilters), mask && renderer.mask.push(this, this._mask), this.cullable)
      this._renderWithCulling(renderer);
    else {
      this._render(renderer);
      for (let i = 0, j = this.children.length; i < j; ++i)
        this.children[i].render(renderer);
    }
    flush && renderer.batch.flush(), mask && renderer.mask.pop(this), filters && this._enabledFilters?.length && renderer.filter.pop();
  }
  /**
   * To be overridden by the subclasses.
   * @param _renderer - The renderer
   */
  _render(_renderer) {
  }
  /**
   * Removes all internal references and listeners as well as removes children from the display list.
   * Do not use a Container after calling `destroy`.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
   *  method called as well. 'options' will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
   *  Should it destroy the texture of the child sprite
   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
   *  Should it destroy the base texture of the child sprite
   */
  destroy(options) {
    super.destroy(), this.sortDirty = !1;
    const destroyChildren = typeof options == "boolean" ? options : options?.children, oldChildren = this.removeChildren(0, this.children.length);
    if (destroyChildren)
      for (let i = 0; i < oldChildren.length; ++i)
        oldChildren[i].destroy(options);
  }
  /** The width of the Container, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return this.scale.x * this.getLocalBounds().width;
  }
  set width(value) {
    const width = this.getLocalBounds().width;
    width !== 0 ? this.scale.x = value / width : this.scale.x = 1, this._width = value;
  }
  /** The height of the Container, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return this.scale.y * this.getLocalBounds().height;
  }
  set height(value) {
    const height = this.getLocalBounds().height;
    height !== 0 ? this.scale.y = value / height : this.scale.y = 1, this._height = value;
  }
};
_Container.defaultSortableChildren = !1;
let Container = _Container;
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
exports.Container = Container;
//# sourceMappingURL=Container.js.map


/***/ }),

/***/ "./node_modules/@pixi/display/lib/DisplayObject.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/display/lib/DisplayObject.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), Bounds = __webpack_require__(/*! ./Bounds.js */ "./node_modules/@pixi/display/lib/Bounds.js");
class DisplayObject extends core.utils.EventEmitter {
  constructor() {
    super(), this.tempDisplayObjectParent = null, this.transform = new core.Transform(), this.alpha = 1, this.visible = !0, this.renderable = !0, this.cullable = !1, this.cullArea = null, this.parent = null, this.worldAlpha = 1, this._lastSortedIndex = 0, this._zIndex = 0, this.filterArea = null, this.filters = null, this._enabledFilters = null, this._bounds = new Bounds.Bounds(), this._localBounds = null, this._boundsID = 0, this._boundsRect = null, this._localBoundsRect = null, this._mask = null, this._maskRefCount = 0, this._destroyed = !1, this.isSprite = !1, this.isMask = !1;
  }
  /**
   * Mixes all enumerable properties and methods from a source object to DisplayObject.
   * @param source - The source of properties and methods to mix in.
   */
  static mixin(source) {
    const keys = Object.keys(source);
    for (let i = 0; i < keys.length; ++i) {
      const propertyName = keys[i];
      Object.defineProperty(
        DisplayObject.prototype,
        propertyName,
        Object.getOwnPropertyDescriptor(source, propertyName)
      );
    }
  }
  /**
   * Fired when this DisplayObject is added to a Container.
   * @instance
   * @event added
   * @param {PIXI.Container} container - The container added to.
   */
  /**
   * Fired when this DisplayObject is removed from a Container.
   * @instance
   * @event removed
   * @param {PIXI.Container} container - The container removed from.
   */
  /**
   * Fired when this DisplayObject is destroyed. This event is emitted once
   * destroy is finished.
   * @instance
   * @event destroyed
   */
  /** Readonly flag for destroyed display objects. */
  get destroyed() {
    return this._destroyed;
  }
  /** Recursively updates transform of all objects from the root to this one internal function for toLocal() */
  _recursivePostUpdateTransform() {
    this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
  }
  /** Updates the object transform for rendering. TODO - Optimization pass! */
  updateTransform() {
    this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
  }
  /**
   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link PIXI.Rectangle}.
   *
   * This method is expensive on containers with a large subtree (like the stage). This is because the bounds
   * of a container depend on its children's bounds, which recursively causes all bounds in the subtree to
   * be recalculated. The upside, however, is that calling `getBounds` once on a container will indeed update
   * the bounds of all children (the whole subtree, in fact). This side effect should be exploited by using
   * `displayObject._bounds.getRectangle()` when traversing through all the bounds in a scene graph. Otherwise,
   * calling `getBounds` on each object in a subtree will cause the total cost to increase quadratically as
   * its height increases.
   *
   * The transforms of all objects in a container's **subtree** and of all **ancestors** are updated.
   * The world bounds of all display objects in a container's **subtree** will also be recalculated.
   *
   * The `_bounds` object stores the last calculation of the bounds. You can use to entirely skip bounds
   * calculation if needed.
   *
   * ```js
   * const lastCalculatedBounds = displayObject._bounds.getRectangle(optionalRect);
   * ```
   *
   * Do know that usage of `getLocalBounds` can corrupt the `_bounds` of children (the whole subtree, actually). This
   * is a known issue that has not been solved. See [getLocalBounds]{@link PIXI.DisplayObject#getLocalBounds} for more
   * details.
   *
   * `getBounds` should be called with `skipUpdate` equal to `true` in a render() call. This is because the transforms
   * are guaranteed to be update-to-date. In fact, recalculating inside a render() call may cause corruption in certain
   * cases.
   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
   *  being updated. This means the calculation returned MAY be out of date BUT will give you a
   *  nice performance boost.
   * @param rect - Optional rectangle to store the result of the bounds calculation.
   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
   */
  getBounds(skipUpdate, rect) {
    return skipUpdate || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), rect || (this._boundsRect || (this._boundsRect = new core.Rectangle()), rect = this._boundsRect), this._bounds.getRectangle(rect);
  }
  /**
   * Retrieves the local bounds of the displayObject as a rectangle object.
   * @param rect - Optional rectangle to store the result of the bounds calculation.
   * @returns - The rectangular bounding area.
   */
  getLocalBounds(rect) {
    rect || (this._localBoundsRect || (this._localBoundsRect = new core.Rectangle()), rect = this._localBoundsRect), this._localBounds || (this._localBounds = new Bounds.Bounds());
    const transformRef = this.transform, parentRef = this.parent;
    this.parent = null, this._tempDisplayObjectParent.worldAlpha = parentRef?.worldAlpha ?? 1, this.transform = this._tempDisplayObjectParent.transform;
    const worldBounds = this._bounds, worldBoundsID = this._boundsID;
    this._bounds = this._localBounds;
    const bounds = this.getBounds(!1, rect);
    return this.parent = parentRef, this.transform = transformRef, this._bounds = worldBounds, this._bounds.updateID += this._boundsID - worldBoundsID, bounds;
  }
  /**
   * Calculates the global position of the display object.
   * @param position - The world origin to calculate from.
   * @param point - A Point object in which to store the value, optional
   *  (otherwise will create a new Point).
   * @param skipUpdate - Should we skip the update transform.
   * @returns - A point object representing the position of this object.
   */
  toGlobal(position, point, skipUpdate = !1) {
    return skipUpdate || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(position, point);
  }
  /**
   * Calculates the local position of the display object relative to another point.
   * @param position - The world origin to calculate from.
   * @param from - The DisplayObject to calculate the global position from.
   * @param point - A Point object in which to store the value, optional
   *  (otherwise will create a new Point).
   * @param skipUpdate - Should we skip the update transform
   * @returns - A point object representing the position of this object
   */
  toLocal(position, from, point, skipUpdate) {
    return from && (position = from.toGlobal(position, point, skipUpdate)), skipUpdate || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(position, point);
  }
  /**
   * Set the parent Container of this DisplayObject.
   * @param container - The Container to add this DisplayObject to.
   * @returns - The Container that this DisplayObject was added to.
   */
  setParent(container) {
    if (!container || !container.addChild)
      throw new Error("setParent: Argument must be a Container");
    return container.addChild(this), container;
  }
  /** Remove the DisplayObject from its parent Container. If the DisplayObject has no parent, do nothing. */
  removeFromParent() {
    this.parent?.removeChild(this);
  }
  /**
   * Convenience function to set the position, scale, skew and pivot at once.
   * @param x - The X position
   * @param y - The Y position
   * @param scaleX - The X scale value
   * @param scaleY - The Y scale value
   * @param rotation - The rotation
   * @param skewX - The X skew value
   * @param skewY - The Y skew value
   * @param pivotX - The X pivot value
   * @param pivotY - The Y pivot value
   * @returns - The DisplayObject instance
   */
  setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {
    return this.position.x = x, this.position.y = y, this.scale.x = scaleX || 1, this.scale.y = scaleY || 1, this.rotation = rotation, this.skew.x = skewX, this.skew.y = skewY, this.pivot.x = pivotX, this.pivot.y = pivotY, this;
  }
  /**
   * Base destroy method for generic display objects. This will automatically
   * remove the display object from its parent Container as well as remove
   * all current event listeners and internal references. Do not use a DisplayObject
   * after calling `destroy()`.
   * @param _options
   */
  destroy(_options) {
    this.removeFromParent(), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.eventMode = "auto", this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners();
  }
  /**
   * @protected
   * @member {PIXI.Container}
   */
  get _tempDisplayObjectParent() {
    return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new TemporaryDisplayObject()), this.tempDisplayObjectParent;
  }
  /**
   * Used in Renderer, cacheAsBitmap and other places where you call an `updateTransform` on root.
   *
   * ```js
   * const cacheParent = elem.enableTempParent();
   * elem.updateTransform();
   * elem.disableTempParent(cacheParent);
   * ```
   * @returns - Current parent
   */
  enableTempParent() {
    const myParent = this.parent;
    return this.parent = this._tempDisplayObjectParent, myParent;
  }
  /**
   * Pair method for `enableTempParent`
   * @param cacheParent - Actual parent of element
   */
  disableTempParent(cacheParent) {
    this.parent = cacheParent;
  }
  /**
   * The position of the displayObject on the x axis relative to the local coordinates of the parent.
   * An alias to position.x
   */
  get x() {
    return this.position.x;
  }
  set x(value) {
    this.transform.position.x = value;
  }
  /**
   * The position of the displayObject on the y axis relative to the local coordinates of the parent.
   * An alias to position.y
   */
  get y() {
    return this.position.y;
  }
  set y(value) {
    this.transform.position.y = value;
  }
  /**
   * Current transform of the object based on world (parent) factors.
   * @readonly
   */
  get worldTransform() {
    return this.transform.worldTransform;
  }
  /**
   * Current transform of the object based on local factors: position, scale, other stuff.
   * @readonly
   */
  get localTransform() {
    return this.transform.localTransform;
  }
  /**
   * The coordinate of the object relative to the local coordinates of the parent.
   * @since 4.0.0
   */
  get position() {
    return this.transform.position;
  }
  set position(value) {
    this.transform.position.copyFrom(value);
  }
  /**
   * The scale factors of this object along the local coordinate axes.
   *
   * The default scale is (1, 1).
   * @since 4.0.0
   */
  get scale() {
    return this.transform.scale;
  }
  set scale(value) {
    this.transform.scale.copyFrom(value);
  }
  /**
   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
   * is the projection of `pivot` in the parent's local space.
   *
   * By default, the pivot is the origin (0, 0).
   * @since 4.0.0
   */
  get pivot() {
    return this.transform.pivot;
  }
  set pivot(value) {
    this.transform.pivot.copyFrom(value);
  }
  /**
   * The skew factor for the object in radians.
   * @since 4.0.0
   */
  get skew() {
    return this.transform.skew;
  }
  set skew(value) {
    this.transform.skew.copyFrom(value);
  }
  /**
   * The rotation of the object in radians.
   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
   */
  get rotation() {
    return this.transform.rotation;
  }
  set rotation(value) {
    this.transform.rotation = value;
  }
  /**
   * The angle of the object in degrees.
   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
   */
  get angle() {
    return this.transform.rotation * core.RAD_TO_DEG;
  }
  set angle(value) {
    this.transform.rotation = value * core.DEG_TO_RAD;
  }
  /**
   * The zIndex of the displayObject.
   *
   * If a container has the sortableChildren property set to true, children will be automatically
   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
   * and thus rendered on top of other display objects within the same container.
   * @see PIXI.Container#sortableChildren
   */
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value, this.parent && (this.parent.sortDirty = !0);
  }
  /**
   * Indicates if the object is globally visible.
   * @readonly
   */
  get worldVisible() {
    let item = this;
    do {
      if (!item.visible)
        return !1;
      item = item.parent;
    } while (item);
    return !0;
  }
  /**
   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
   * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
   * To remove a mask, set this property to `null`.
   *
   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
   * @example
   * import { Graphics, Sprite } from 'pixi.js';
   *
   * const graphics = new Graphics();
   * graphics.beginFill(0xFF3300);
   * graphics.drawRect(50, 250, 100, 100);
   * graphics.endFill();
   *
   * const sprite = new Sprite(texture);
   * sprite.mask = graphics;
   * @todo At the moment, CanvasRenderer doesn't support Sprite as mask.
   */
  get mask() {
    return this._mask;
  }
  set mask(value) {
    if (this._mask !== value) {
      if (this._mask) {
        const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
        maskObject && (maskObject._maskRefCount--, maskObject._maskRefCount === 0 && (maskObject.renderable = !0, maskObject.isMask = !1));
      }
      if (this._mask = value, this._mask) {
        const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
        maskObject && (maskObject._maskRefCount === 0 && (maskObject.renderable = !1, maskObject.isMask = !0), maskObject._maskRefCount++);
      }
    }
  }
}
class TemporaryDisplayObject extends DisplayObject {
  constructor() {
    super(...arguments), this.sortDirty = null;
  }
}
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
exports.DisplayObject = DisplayObject;
exports.TemporaryDisplayObject = TemporaryDisplayObject;
//# sourceMappingURL=DisplayObject.js.map


/***/ }),

/***/ "./node_modules/@pixi/display/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/display/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ./settings.js */ "./node_modules/@pixi/display/lib/settings.js");
var Bounds = __webpack_require__(/*! ./Bounds.js */ "./node_modules/@pixi/display/lib/Bounds.js"), Container = __webpack_require__(/*! ./Container.js */ "./node_modules/@pixi/display/lib/Container.js"), DisplayObject = __webpack_require__(/*! ./DisplayObject.js */ "./node_modules/@pixi/display/lib/DisplayObject.js");
exports.Bounds = Bounds.Bounds;
exports.Container = Container.Container;
exports.DisplayObject = DisplayObject.DisplayObject;
exports.TemporaryDisplayObject = DisplayObject.TemporaryDisplayObject;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/display/lib/settings.js":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/display/lib/settings.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), Container = __webpack_require__(/*! ./Container.js */ "./node_modules/@pixi/display/lib/Container.js");
Object.defineProperties(core.settings, {
  /**
   * Sets the default value for the container property 'sortableChildren'.
   * @static
   * @name SORTABLE_CHILDREN
   * @memberof PIXI.settings
   * @deprecated since 7.1.0
   * @type {boolean}
   * @see PIXI.Container.defaultSortableChildren
   */
  SORTABLE_CHILDREN: {
    get() {
      return Container.Container.defaultSortableChildren;
    },
    set(value) {
      core.utils.deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"), Container.Container.defaultSortableChildren = value;
    }
  }
});
Object.defineProperty(exports, "settings", ({
  enumerable: !0,
  get: function() {
    return core.settings;
  }
}));
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/EventBoundary.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/events/lib/EventBoundary.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), EventTicker = __webpack_require__(/*! ./EventTicker.js */ "./node_modules/@pixi/events/lib/EventTicker.js"), FederatedMouseEvent = __webpack_require__(/*! ./FederatedMouseEvent.js */ "./node_modules/@pixi/events/lib/FederatedMouseEvent.js"), FederatedPointerEvent = __webpack_require__(/*! ./FederatedPointerEvent.js */ "./node_modules/@pixi/events/lib/FederatedPointerEvent.js"), FederatedWheelEvent = __webpack_require__(/*! ./FederatedWheelEvent.js */ "./node_modules/@pixi/events/lib/FederatedWheelEvent.js");
const PROPAGATION_LIMIT = 2048, tempHitLocation = new core.Point(), tempLocalMapping = new core.Point();
class EventBoundary {
  /**
   * @param rootTarget - The holder of the event boundary.
   */
  constructor(rootTarget) {
    this.dispatch = new core.utils.EventEmitter(), this.moveOnAll = !1, this.enableGlobalMoveEvents = !0, this.mappingState = {
      trackingData: {}
    }, this.eventPool = /* @__PURE__ */ new Map(), this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = !1, this.rootTarget = rootTarget, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel);
  }
  /**
   * Adds an event mapping for the event `type` handled by `fn`.
   *
   * Event mappings can be used to implement additional or custom events. They take an event
   * coming from the upstream scene (or directly from the {@link PIXI.EventSystem}) and dispatch new downstream events
   * generally trickling down and bubbling up to {@link PIXI.EventBoundary.rootTarget this.rootTarget}.
   *
   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
   * instead.
   * @param type - The type of upstream event to map.
   * @param fn - The mapping method. The context of this function must be bound manually, if desired.
   */
  addEventMapping(type, fn) {
    this.mappingTable[type] || (this.mappingTable[type] = []), this.mappingTable[type].push({
      fn,
      priority: 0
    }), this.mappingTable[type].sort((a, b) => a.priority - b.priority);
  }
  /**
   * Dispatches the given event
   * @param e
   * @param type
   */
  dispatchEvent(e, type) {
    e.propagationStopped = !1, e.propagationImmediatelyStopped = !1, this.propagate(e, type), this.dispatch.emit(type || e.type, e);
  }
  /**
   * Maps the given upstream event through the event boundary and propagates it downstream.
   * @param e
   */
  mapEvent(e) {
    if (!this.rootTarget)
      return;
    const mappers = this.mappingTable[e.type];
    if (mappers)
      for (let i = 0, j = mappers.length; i < j; i++)
        mappers[i].fn(e);
    else
      console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);
  }
  /**
   * Finds the DisplayObject that is the target of a event at the given coordinates.
   *
   * The passed (x,y) coordinates are in the world space above this event boundary.
   * @param x
   * @param y
   */
  hitTest(x, y) {
    EventTicker.EventsTicker.pauseUpdate = !0;
    const fn = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive", invertedPath = this[fn](
      this.rootTarget,
      this.rootTarget.eventMode,
      tempHitLocation.set(x, y),
      this.hitTestFn,
      this.hitPruneFn
    );
    return invertedPath && invertedPath[0];
  }
  /**
   * Propagate the passed event from from {@link PIXI.EventBoundary.rootTarget this.rootTarget} to its
   * target {@code e.target}.
   * @param e - The event to propagate.
   * @param type
   */
  propagate(e, type) {
    if (!e.target)
      return;
    const composedPath = e.composedPath();
    e.eventPhase = e.CAPTURING_PHASE;
    for (let i = 0, j = composedPath.length - 1; i < j; i++)
      if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped)
        return;
    if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, type), !(e.propagationStopped || e.propagationImmediatelyStopped)) {
      e.eventPhase = e.BUBBLING_PHASE;
      for (let i = composedPath.length - 2; i >= 0; i--)
        if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped)
          return;
    }
  }
  /**
   * Emits the event {@code e} to all interactive display objects. The event is propagated in the bubbling phase always.
   *
   * This is used in the `globalpointermove` event.
   * @param e - The emitted event.
   * @param type - The listeners to notify.
   * @param targets - The targets to notify.
   */
  all(e, type, targets = this._allInteractiveElements) {
    if (targets.length === 0)
      return;
    e.eventPhase = e.BUBBLING_PHASE;
    const events = Array.isArray(type) ? type : [type];
    for (let i = targets.length - 1; i >= 0; i--)
      events.forEach((event) => {
        e.currentTarget = targets[i], this.notifyTarget(e, event);
      });
  }
  /**
   * Finds the propagation path from {@link PIXI.EventBoundary.rootTarget rootTarget} to the passed
   * {@code target}. The last element in the path is {@code target}.
   * @param target
   */
  propagationPath(target) {
    const propagationPath = [target];
    for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
      if (!target.parent)
        throw new Error("Cannot find propagation path to disconnected target");
      propagationPath.push(target.parent), target = target.parent;
    }
    return propagationPath.reverse(), propagationPath;
  }
  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = !1) {
    let shouldReturn = !1;
    if (this._interactivePrune(currentTarget))
      return null;
    if ((currentTarget.eventMode === "dynamic" || eventMode === "dynamic") && (EventTicker.EventsTicker.pauseUpdate = !1), currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i], nestedHit = this.hitTestMoveRecursive(
          child,
          this._isInteractive(eventMode) ? eventMode : child.eventMode,
          location,
          testFn,
          pruneFn,
          ignore || pruneFn(currentTarget, location)
        );
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)
            continue;
          const isInteractive = currentTarget.isInteractive();
          (nestedHit.length > 0 || isInteractive) && (isInteractive && this._allInteractiveElements.push(currentTarget), nestedHit.push(currentTarget)), this._hitElements.length === 0 && (this._hitElements = nestedHit), shouldReturn = !0;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode), isInteractiveTarget = currentTarget.isInteractive();
    return isInteractiveMode && isInteractiveTarget && this._allInteractiveElements.push(currentTarget), ignore || this._hitElements.length > 0 ? null : shouldReturn ? this._hitElements : isInteractiveMode && !pruneFn(currentTarget, location) && testFn(currentTarget, location) ? isInteractiveTarget ? [currentTarget] : [] : null;
  }
  /**
   * Recursive implementation for {@link PIXI.EventBoundary.hitTest hitTest}.
   * @param currentTarget - The DisplayObject that is to be hit tested.
   * @param eventMode - The event mode for the `currentTarget` or one of its parents.
   * @param location - The location that is being tested for overlap.
   * @param testFn - Callback that determines whether the target passes hit testing. This callback
   *  can assume that `pruneFn` failed to prune the display object.
   * @param pruneFn - Callback that determiness whether the target and all of its children
   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
   *  of the scene graph.
   * @returns An array holding the hit testing target and all its ancestors in order. The first element
   *  is the target itself and the last is {@link PIXI.EventBoundary.rootTarget rootTarget}. This is the opposite
   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
   */
  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location))
      return null;
    if ((currentTarget.eventMode === "dynamic" || eventMode === "dynamic") && (EventTicker.EventsTicker.pauseUpdate = !1), currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i], nestedHit = this.hitTestRecursive(
          child,
          this._isInteractive(eventMode) ? eventMode : child.eventMode,
          location,
          testFn,
          pruneFn
        );
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)
            continue;
          const isInteractive = currentTarget.isInteractive();
          return (nestedHit.length > 0 || isInteractive) && nestedHit.push(currentTarget), nestedHit;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode), isInteractiveTarget = currentTarget.isInteractive();
    return isInteractiveMode && testFn(currentTarget, location) ? isInteractiveTarget ? [currentTarget] : [] : null;
  }
  _isInteractive(int) {
    return int === "static" || int === "dynamic";
  }
  _interactivePrune(displayObject) {
    return !!(!displayObject || displayObject.isMask || !displayObject.visible || !displayObject.renderable || displayObject.eventMode === "none" || displayObject.eventMode === "passive" && !displayObject.interactiveChildren || displayObject.isMask);
  }
  /**
   * Checks whether the display object or any of its children cannot pass the hit test at all.
   *
   * {@link PIXI.EventBoundary}'s implementation uses the {@link PIXI.DisplayObject.hitArea hitArea}
   * and {@link PIXI.DisplayObject._mask} for pruning.
   * @param displayObject
   * @param location
   */
  hitPruneFn(displayObject, location) {
    if (displayObject.hitArea && (displayObject.worldTransform.applyInverse(location, tempLocalMapping), !displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)))
      return !0;
    if (displayObject._mask) {
      const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;
      if (maskObject && !maskObject.containsPoint?.(location))
        return !0;
    }
    return !1;
  }
  /**
   * Checks whether the display object passes hit testing for the given location.
   * @param displayObject
   * @param location
   * @returns - Whether `displayObject` passes hit testing for `location`.
   */
  hitTestFn(displayObject, location) {
    return displayObject.eventMode === "passive" ? !1 : displayObject.hitArea ? !0 : displayObject.containsPoint ? displayObject.containsPoint(location) : !1;
  }
  /**
   * Notify all the listeners to the event's `currentTarget`.
   *
   * If the `currentTarget` contains the property `on<type>`, then it is called here,
   * simulating the behavior from version 6.x and prior.
   * @param e - The event passed to the target.
   * @param type
   */
  notifyTarget(e, type) {
    type = type ?? e.type;
    const handlerKey = `on${type}`;
    e.currentTarget[handlerKey]?.(e);
    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
    this.notifyListeners(e, key), e.eventPhase === e.AT_TARGET && this.notifyListeners(e, type);
  }
  /**
   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
   *
   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
   * @param from
   */
  mapPointerDown(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e = this.createPointerEvent(from);
    if (this.dispatchEvent(e, "pointerdown"), e.pointerType === "touch")
      this.dispatchEvent(e, "touchstart");
    else if (e.pointerType === "mouse" || e.pointerType === "pen") {
      const isRightButton = e.button === 2;
      this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
    }
    const trackingData = this.trackingData(from.pointerId);
    trackingData.pressTargetsByButton[from.button] = e.composedPath(), this.freeEvent(e);
  }
  /**
   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
   *
   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
   * @param from - The upstream `pointermove` event.
   */
  mapPointerMove(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = !0;
    const e = this.createPointerEvent(from);
    this._isPointerMoveEvent = !1;
    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen", trackingData = this.trackingData(from.pointerId), outTarget = this.findMountedTarget(trackingData.overTargets);
    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {
      const outType = from.type === "mousemove" ? "mouseout" : "pointerout", outEvent = this.createPointerEvent(from, outType, outTarget);
      if (this.dispatchEvent(outEvent, "pointerout"), isMouse && this.dispatchEvent(outEvent, "mouseout"), !e.composedPath().includes(outTarget)) {
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
        for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e.composedPath().includes(leaveEvent.target); )
          leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
        this.freeEvent(leaveEvent);
      }
      this.freeEvent(outEvent);
    }
    if (outTarget !== e.target) {
      const overType = from.type === "mousemove" ? "mouseover" : "pointerover", overEvent = this.clonePointerEvent(e, overType);
      this.dispatchEvent(overEvent, "pointerover"), isMouse && this.dispatchEvent(overEvent, "mouseover");
      let overTargetAncestor = outTarget?.parent;
      for (; overTargetAncestor && overTargetAncestor !== this.rootTarget.parent && overTargetAncestor !== e.target; )
        overTargetAncestor = overTargetAncestor.parent;
      if (!overTargetAncestor || overTargetAncestor === this.rootTarget.parent) {
        const enterEvent = this.clonePointerEvent(e, "pointerenter");
        for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent; )
          enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
        this.freeEvent(enterEvent);
      }
      this.freeEvent(overEvent);
    }
    const allMethods = [], allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? !0;
    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e, "pointermove"), allowGlobalPointerEvents && allMethods.push("globalpointermove"), e.pointerType === "touch" && (this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove"), allowGlobalPointerEvents && allMethods.push("globaltouchmove")), isMouse && (this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove"), allowGlobalPointerEvents && allMethods.push("globalmousemove"), this.cursor = e.target?.cursor), allMethods.length > 0 && this.all(e, allMethods), this._allInteractiveElements.length = 0, this._hitElements.length = 0, trackingData.overTargets = e.composedPath(), this.freeEvent(e);
  }
  /**
   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
   *
   * The tracking data for the specific pointer gets a new `overTarget`.
   * @param from - The upstream `pointerover` event.
   */
  mapPointerOver(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId), e = this.createPointerEvent(from), isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
    this.dispatchEvent(e, "pointerover"), isMouse && this.dispatchEvent(e, "mouseover"), e.pointerType === "mouse" && (this.cursor = e.target?.cursor);
    const enterEvent = this.clonePointerEvent(e, "pointerenter");
    for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== this.rootTarget.parent; )
      enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
    trackingData.overTargets = e.composedPath(), this.freeEvent(e), this.freeEvent(enterEvent);
  }
  /**
   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
   *
   * The tracking data for the specific pointer is cleared of a `overTarget`.
   * @param from - The upstream `pointerout` event.
   */
  mapPointerOut(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    if (trackingData.overTargets) {
      const isMouse = from.pointerType === "mouse" || from.pointerType === "pen", outTarget = this.findMountedTarget(trackingData.overTargets), outEvent = this.createPointerEvent(from, "pointerout", outTarget);
      this.dispatchEvent(outEvent), isMouse && this.dispatchEvent(outEvent, "mouseout");
      const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
      for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && leaveEvent.target !== this.rootTarget.parent; )
        leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
      trackingData.overTargets = null, this.freeEvent(outEvent), this.freeEvent(leaveEvent);
    }
    this.cursor = null;
  }
  /**
   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
   * and `click`/`rightclick`/`pointertap` events, in that order.
   *
   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
   * specific pointer types.
   * @param from - The upstream `pointerup` event.
   */
  mapPointerUp(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const now = performance.now(), e = this.createPointerEvent(from);
    if (this.dispatchEvent(e, "pointerup"), e.pointerType === "touch")
      this.dispatchEvent(e, "touchend");
    else if (e.pointerType === "mouse" || e.pointerType === "pen") {
      const isRightButton = e.button === 2;
      this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
    }
    const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    let clickTarget = pressTarget;
    if (pressTarget && !e.composedPath().includes(pressTarget)) {
      let currentTarget = pressTarget;
      for (; currentTarget && !e.composedPath().includes(currentTarget); ) {
        if (e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), e.pointerType === "touch")
          this.notifyTarget(e, "touchendoutside");
        else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          const isRightButton = e.button === 2;
          this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button], clickTarget = currentTarget;
    }
    if (clickTarget) {
      const clickEvent = this.clonePointerEvent(e, "click");
      clickEvent.target = clickTarget, clickEvent.path = null, trackingData.clicksByButton[from.button] || (trackingData.clicksByButton[from.button] = {
        clickCount: 0,
        target: clickEvent.target,
        timeStamp: now
      });
      const clickHistory = trackingData.clicksByButton[from.button];
      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200 ? ++clickHistory.clickCount : clickHistory.clickCount = 1, clickHistory.target = clickEvent.target, clickHistory.timeStamp = now, clickEvent.detail = clickHistory.clickCount, clickEvent.pointerType === "mouse") {
        const isRightButton = clickEvent.button === 2;
        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
      } else
        clickEvent.pointerType === "touch" && this.dispatchEvent(clickEvent, "tap");
      this.dispatchEvent(clickEvent, "pointertap"), this.freeEvent(clickEvent);
    }
    this.freeEvent(e);
  }
  /**
   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
   * `pointerdown` target to `rootTarget`.
   *
   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
   * `{@link PIXI.EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
   *
   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
   * @param from - The upstream `pointerupoutside` event.
   */
  mapPointerUpOutside(from) {
    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]), e = this.createPointerEvent(from);
    if (pressTarget) {
      let currentTarget = pressTarget;
      for (; currentTarget; )
        e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), e.pointerType === "touch" ? this.notifyTarget(e, "touchendoutside") : (e.pointerType === "mouse" || e.pointerType === "pen") && this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside"), currentTarget = currentTarget.parent;
      delete trackingData.pressTargetsByButton[from.button];
    }
    this.freeEvent(e);
  }
  /**
   * Maps the upstream `wheel` event to a downstream `wheel` event.
   * @param from - The upstream `wheel` event.
   */
  mapWheel(from) {
    if (!(from instanceof FederatedWheelEvent.FederatedWheelEvent)) {
      console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
      return;
    }
    const wheelEvent = this.createWheelEvent(from);
    this.dispatchEvent(wheelEvent), this.freeEvent(wheelEvent);
  }
  /**
   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
   *
   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
   * or `pointerover` target was unmounted from the scene graph.
   * @param propagationPath - The propagation path was valid in the past.
   * @returns - The most specific event-target still mounted at the same location in the scene graph.
   */
  findMountedTarget(propagationPath) {
    if (!propagationPath)
      return null;
    let currentTarget = propagationPath[0];
    for (let i = 1; i < propagationPath.length && propagationPath[i].parent === currentTarget; i++)
      currentTarget = propagationPath[i];
    return currentTarget;
  }
  /**
   * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.
   *
   * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The {@code originalEvent} for the returned event.
   * @param [type=from.type] - The type of the returned event.
   * @param target - The target of the returned event.
   */
  createPointerEvent(from, type, target) {
    const event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);
    return this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0], typeof type == "string" && (event.type = type), event;
  }
  /**
   * Creates a wheel event whose {@code originalEvent} is {@code from}.
   *
   * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The upstream wheel event.
   */
  createWheelEvent(from) {
    const event = this.allocateEvent(FederatedWheelEvent.FederatedWheelEvent);
    return this.copyWheelData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = this.hitTest(event.global.x, event.global.y), event;
  }
  /**
   * Clones the event {@code from}, with an optional {@code type} override.
   *
   * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The event to clone.
   * @param [type=from.type] - The type of the returned event.
   */
  clonePointerEvent(from, type) {
    const event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);
    return event.nativeEvent = from.nativeEvent, event.originalEvent = from.originalEvent, this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.target = from.target, event.path = from.composedPath().slice(), event.type = type ?? event.type, event;
  }
  /**
   * Copies wheel {@link PIXI.FederatedWheelEvent} data from {@code from} into {@code to}.
   *
   * The following properties are copied:
   * + deltaMode
   * + deltaX
   * + deltaY
   * + deltaZ
   * @param from
   * @param to
   */
  copyWheelData(from, to) {
    to.deltaMode = from.deltaMode, to.deltaX = from.deltaX, to.deltaY = from.deltaY, to.deltaZ = from.deltaZ;
  }
  /**
   * Copies pointer {@link PIXI.FederatedPointerEvent} data from {@code from} into {@code to}.
   *
   * The following properties are copied:
   * + pointerId
   * + width
   * + height
   * + isPrimary
   * + pointerType
   * + pressure
   * + tangentialPressure
   * + tiltX
   * + tiltY
   * @param from
   * @param to
   */
  copyPointerData(from, to) {
    from instanceof FederatedPointerEvent.FederatedPointerEvent && to instanceof FederatedPointerEvent.FederatedPointerEvent && (to.pointerId = from.pointerId, to.width = from.width, to.height = from.height, to.isPrimary = from.isPrimary, to.pointerType = from.pointerType, to.pressure = from.pressure, to.tangentialPressure = from.tangentialPressure, to.tiltX = from.tiltX, to.tiltY = from.tiltY, to.twist = from.twist);
  }
  /**
   * Copies mouse {@link PIXI.FederatedMouseEvent} data from {@code from} to {@code to}.
   *
   * The following properties are copied:
   * + altKey
   * + button
   * + buttons
   * + clientX
   * + clientY
   * + metaKey
   * + movementX
   * + movementY
   * + pageX
   * + pageY
   * + x
   * + y
   * + screen
   * + shiftKey
   * + global
   * @param from
   * @param to
   */
  copyMouseData(from, to) {
    from instanceof FederatedMouseEvent.FederatedMouseEvent && to instanceof FederatedMouseEvent.FederatedMouseEvent && (to.altKey = from.altKey, to.button = from.button, to.buttons = from.buttons, to.client.copyFrom(from.client), to.ctrlKey = from.ctrlKey, to.metaKey = from.metaKey, to.movement.copyFrom(from.movement), to.screen.copyFrom(from.screen), to.shiftKey = from.shiftKey, to.global.copyFrom(from.global));
  }
  /**
   * Copies base {@link PIXI.FederatedEvent} data from {@code from} into {@code to}.
   *
   * The following properties are copied:
   * + isTrusted
   * + srcElement
   * + timeStamp
   * + type
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */
  copyData(from, to) {
    to.isTrusted = from.isTrusted, to.srcElement = from.srcElement, to.timeStamp = performance.now(), to.type = from.type, to.detail = from.detail, to.view = from.view, to.which = from.which, to.layer.copyFrom(from.layer), to.page.copyFrom(from.page);
  }
  /**
   * @param id - The pointer ID.
   * @returns The tracking data stored for the given pointer. If no data exists, a blank
   *  state will be created.
   */
  trackingData(id) {
    return this.mappingState.trackingData[id] || (this.mappingState.trackingData[id] = {
      pressTargetsByButton: {},
      clicksByButton: {},
      overTarget: null
    }), this.mappingState.trackingData[id];
  }
  /**
   * Allocate a specific type of event from {@link PIXI.EventBoundary#eventPool this.eventPool}.
   *
   * This allocation is constructor-agnostic, as long as it only takes one argument - this event
   * boundary.
   * @param constructor - The event's constructor.
   */
  allocateEvent(constructor) {
    this.eventPool.has(constructor) || this.eventPool.set(constructor, []);
    const event = this.eventPool.get(constructor).pop() || new constructor(this);
    return event.eventPhase = event.NONE, event.currentTarget = null, event.path = null, event.target = null, event;
  }
  /**
   * Frees the event and puts it back into the event pool.
   *
   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
   *
   * It is also advised that events not allocated from {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}
   * not be freed. This is because of the possibility that the same event is freed twice, which can cause
   * it to be allocated twice & result in overwriting.
   * @param event - The event to be freed.
   * @throws Error if the event is managed by another event boundary.
   */
  freeEvent(event) {
    if (event.manager !== this)
      throw new Error("It is illegal to free an event not managed by this EventBoundary!");
    const constructor = event.constructor;
    this.eventPool.has(constructor) || this.eventPool.set(constructor, []), this.eventPool.get(constructor).push(event);
  }
  /**
   * Similar to {@link PIXI.EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
   * is set on the event.
   * @param e - The event to call each listener with.
   * @param type - The event key.
   */
  notifyListeners(e, type) {
    const listeners = e.currentTarget._events[type];
    if (listeners && e.currentTarget.isInteractive())
      if ("fn" in listeners)
        listeners.once && e.currentTarget.removeListener(type, listeners.fn, void 0, !0), listeners.fn.call(listeners.context, e);
      else
        for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++)
          listeners[i].once && e.currentTarget.removeListener(type, listeners[i].fn, void 0, !0), listeners[i].fn.call(listeners[i].context, e);
  }
}
exports.EventBoundary = EventBoundary;
//# sourceMappingURL=EventBoundary.js.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/EventSystem.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/events/lib/EventSystem.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), EventBoundary = __webpack_require__(/*! ./EventBoundary.js */ "./node_modules/@pixi/events/lib/EventBoundary.js"), EventTicker = __webpack_require__(/*! ./EventTicker.js */ "./node_modules/@pixi/events/lib/EventTicker.js"), FederatedPointerEvent = __webpack_require__(/*! ./FederatedPointerEvent.js */ "./node_modules/@pixi/events/lib/FederatedPointerEvent.js"), FederatedWheelEvent = __webpack_require__(/*! ./FederatedWheelEvent.js */ "./node_modules/@pixi/events/lib/FederatedWheelEvent.js");
const MOUSE_POINTER_ID = 1, TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
}, _EventSystem = class _EventSystem2 {
  /**
   * @param {PIXI.Renderer} renderer
   */
  constructor(renderer) {
    this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = renderer, this.rootBoundary = new EventBoundary.EventBoundary(null), EventTicker.EventsTicker.init(this), this.autoPreventDefault = !0, this.eventsAdded = !1, this.rootPointerEvent = new FederatedPointerEvent.FederatedPointerEvent(null), this.rootWheelEvent = new FederatedWheelEvent.FederatedWheelEvent(null), this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    }, this.features = new Proxy({ ..._EventSystem2.defaultEventFeatures }, {
      set: (target, key, value) => (key === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = value), target[key] = value, !0)
    }), this.onPointerDown = this.onPointerDown.bind(this), this.onPointerMove = this.onPointerMove.bind(this), this.onPointerUp = this.onPointerUp.bind(this), this.onPointerOverOut = this.onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this);
  }
  /**
   * The default interaction mode for all display objects.
   * @see PIXI.DisplayObject.eventMode
   * @type {PIXI.EventMode}
   * @readonly
   * @since 7.2.0
   */
  static get defaultEventMode() {
    return this._defaultEventMode;
  }
  /**
   * Runner init called, view is available at this point.
   * @ignore
   */
  init(options) {
    const { view, resolution } = this.renderer;
    this.setTargetElement(view), this.resolution = resolution, _EventSystem2._defaultEventMode = options.eventMode ?? "auto", Object.assign(this.features, options.eventFeatures ?? {}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
  }
  /**
   * Handle changing resolution.
   * @ignore
   */
  resolutionChange(resolution) {
    this.resolution = resolution;
  }
  /** Destroys all event listeners and detaches the renderer. */
  destroy() {
    this.setTargetElement(null), this.renderer = null;
  }
  /**
   * Sets the current cursor mode, handling any callbacks or CSS style changes.
   * @param mode - cursor mode, a key from the cursorStyles dictionary
   */
  setCursor(mode) {
    mode = mode || "default";
    let applyStyles = !0;
    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (applyStyles = !1), this.currentCursor === mode)
      return;
    this.currentCursor = mode;
    const style = this.cursorStyles[mode];
    if (style)
      switch (typeof style) {
        case "string":
          applyStyles && (this.domElement.style.cursor = style);
          break;
        case "function":
          style(mode);
          break;
        case "object":
          applyStyles && Object.assign(this.domElement.style, style);
          break;
      }
    else
      applyStyles && typeof mode == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode) && (this.domElement.style.cursor = mode);
  }
  /**
   * The global pointer event.
   * Useful for getting the pointer position without listening to events.
   * @since 7.2.0
   */
  get pointer() {
    return this.rootPointerEvent;
  }
  /**
   * Event handler for pointer down events on {@link PIXI.EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */
  onPointerDown(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    const events = this.normalizeToPointerData(nativeEvent);
    this.autoPreventDefault && events[0].isNormalized && (nativeEvent.cancelable || !("cancelable" in nativeEvent)) && nativeEvent.preventDefault();
    for (let i = 0, j = events.length; i < j; i++) {
      const nativeEvent2 = events[i], federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
      this.rootBoundary.mapEvent(federatedEvent);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Event handler for pointer move events on on {@link PIXI.EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch events.
   */
  onPointerMove(nativeEvent) {
    if (!this.features.move)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, EventTicker.EventsTicker.pointerMoved();
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Event handler for pointer up events on {@link PIXI.EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */
  onPointerUp(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    let target = nativeEvent.target;
    nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (target = nativeEvent.composedPath()[0]);
    const outside = target !== this.domElement ? "outside" : "", normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
      event.type += outside, this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Event handler for pointer over & out events on {@link PIXI.EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */
  onPointerOverOut(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Passive handler for `wheel` events on {@link PIXI.EventSystem.domElement this.domElement}.
   * @param nativeEvent - The native wheel event.
   */
  onWheel(nativeEvent) {
    if (!this.features.wheel)
      return;
    const wheelEvent = this.normalizeWheelEvent(nativeEvent);
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(wheelEvent);
  }
  /**
   * Sets the {@link PIXI.EventSystem#domElement domElement} and binds event listeners.
   *
   * To deregister the current DOM element without setting a new one, pass {@code null}.
   * @param element - The new DOM element.
   */
  setTargetElement(element) {
    this.removeEvents(), this.domElement = element, EventTicker.EventsTicker.domElement = element, this.addEvents();
  }
  /** Register event listeners on {@link PIXI.Renderer#domElement this.domElement}. */
  addEvents() {
    if (this.eventsAdded || !this.domElement)
      return;
    EventTicker.EventsTicker.addTickerListener();
    const style = this.domElement.style;
    style && (globalThis.navigator.msPointerEnabled ? (style.msContentZooming = "none", style.msTouchAction = "none") : this.supportsPointerEvents && (style.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, !0), this.domElement.addEventListener("pointerdown", this.onPointerDown, !0), this.domElement.addEventListener("pointerleave", this.onPointerOverOut, !0), this.domElement.addEventListener("pointerover", this.onPointerOverOut, !0), globalThis.addEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, !0), this.domElement.addEventListener("mousedown", this.onPointerDown, !0), this.domElement.addEventListener("mouseout", this.onPointerOverOut, !0), this.domElement.addEventListener("mouseover", this.onPointerOverOut, !0), globalThis.addEventListener("mouseup", this.onPointerUp, !0), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, !0), this.domElement.addEventListener("touchend", this.onPointerUp, !0), this.domElement.addEventListener("touchmove", this.onPointerMove, !0))), this.domElement.addEventListener("wheel", this.onWheel, {
      passive: !0,
      capture: !0
    }), this.eventsAdded = !0;
  }
  /** Unregister event listeners on {@link PIXI.EventSystem#domElement this.domElement}. */
  removeEvents() {
    if (!this.eventsAdded || !this.domElement)
      return;
    EventTicker.EventsTicker.removeTickerListener();
    const style = this.domElement.style;
    globalThis.navigator.msPointerEnabled ? (style.msContentZooming = "", style.msTouchAction = "") : this.supportsPointerEvents && (style.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, !0), this.domElement.removeEventListener("pointerdown", this.onPointerDown, !0), this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0), this.domElement.removeEventListener("pointerover", this.onPointerOverOut, !0), globalThis.removeEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, !0), this.domElement.removeEventListener("mousedown", this.onPointerDown, !0), this.domElement.removeEventListener("mouseout", this.onPointerOverOut, !0), this.domElement.removeEventListener("mouseover", this.onPointerOverOut, !0), globalThis.removeEventListener("mouseup", this.onPointerUp, !0), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, !0), this.domElement.removeEventListener("touchend", this.onPointerUp, !0), this.domElement.removeEventListener("touchmove", this.onPointerMove, !0))), this.domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this.eventsAdded = !1;
  }
  /**
   * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
   * resulting value is stored in the point. This takes into account the fact that the DOM
   * element could be scaled and positioned anywhere on the screen.
   * @param  {PIXI.IPointData} point - the point that the result will be stored in
   * @param  {number} x - the x coord of the position to map
   * @param  {number} y - the y coord of the position to map
   */
  mapPositionToPoint(point, x, y) {
    const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
      x: 0,
      y: 0,
      width: this.domElement.width,
      height: this.domElement.height,
      left: 0,
      top: 0
    }, resolutionMultiplier = 1 / this.resolution;
    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier, point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
  }
  /**
   * Ensures that the original event object contains all data that a regular pointer event would have
   * @param event - The original event data from a touch or mouse event
   * @returns An array containing a single normalized pointer event, in the case of a pointer
   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
   */
  normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent)
      for (let i = 0, li = event.changedTouches.length; i < li; i++) {
        const touch = event.changedTouches[i];
        typeof touch.button > "u" && (touch.button = 0), typeof touch.buttons > "u" && (touch.buttons = 1), typeof touch.isPrimary > "u" && (touch.isPrimary = event.touches.length === 1 && event.type === "touchstart"), typeof touch.width > "u" && (touch.width = touch.radiusX || 1), typeof touch.height > "u" && (touch.height = touch.radiusY || 1), typeof touch.tiltX > "u" && (touch.tiltX = 0), typeof touch.tiltY > "u" && (touch.tiltY = 0), typeof touch.pointerType > "u" && (touch.pointerType = "touch"), typeof touch.pointerId > "u" && (touch.pointerId = touch.identifier || 0), typeof touch.pressure > "u" && (touch.pressure = touch.force || 0.5), typeof touch.twist > "u" && (touch.twist = 0), typeof touch.tangentialPressure > "u" && (touch.tangentialPressure = 0), typeof touch.layerX > "u" && (touch.layerX = touch.offsetX = touch.clientX), typeof touch.layerY > "u" && (touch.layerY = touch.offsetY = touch.clientY), touch.isNormalized = !0, touch.type = event.type, normalizedEvents.push(touch);
      }
    else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
      const tempEvent = event;
      typeof tempEvent.isPrimary > "u" && (tempEvent.isPrimary = !0), typeof tempEvent.width > "u" && (tempEvent.width = 1), typeof tempEvent.height > "u" && (tempEvent.height = 1), typeof tempEvent.tiltX > "u" && (tempEvent.tiltX = 0), typeof tempEvent.tiltY > "u" && (tempEvent.tiltY = 0), typeof tempEvent.pointerType > "u" && (tempEvent.pointerType = "mouse"), typeof tempEvent.pointerId > "u" && (tempEvent.pointerId = MOUSE_POINTER_ID), typeof tempEvent.pressure > "u" && (tempEvent.pressure = 0.5), typeof tempEvent.twist > "u" && (tempEvent.twist = 0), typeof tempEvent.tangentialPressure > "u" && (tempEvent.tangentialPressure = 0), tempEvent.isNormalized = !0, normalizedEvents.push(tempEvent);
    } else
      normalizedEvents.push(event);
    return normalizedEvents;
  }
  /**
   * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
   *
   * The returned {@link PIXI.FederatedWheelEvent} is a shared instance. It will not persist across
   * multiple native wheel events.
   * @param nativeEvent - The native wheel event that occurred on the canvas.
   * @returns A federated wheel event.
   */
  normalizeWheelEvent(nativeEvent) {
    const event = this.rootWheelEvent;
    return this.transferMouseData(event, nativeEvent), event.deltaX = nativeEvent.deltaX, event.deltaY = nativeEvent.deltaY, event.deltaZ = nativeEvent.deltaZ, event.deltaMode = nativeEvent.deltaMode, this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY), event.global.copyFrom(event.screen), event.offset.copyFrom(event.screen), event.nativeEvent = nativeEvent, event.type = nativeEvent.type, event;
  }
  /**
   * Normalizes the `nativeEvent` into a federateed {@link PIXI.FederatedPointerEvent}.
   * @param event
   * @param nativeEvent
   */
  bootstrapEvent(event, nativeEvent) {
    return event.originalEvent = null, event.nativeEvent = nativeEvent, event.pointerId = nativeEvent.pointerId, event.width = nativeEvent.width, event.height = nativeEvent.height, event.isPrimary = nativeEvent.isPrimary, event.pointerType = nativeEvent.pointerType, event.pressure = nativeEvent.pressure, event.tangentialPressure = nativeEvent.tangentialPressure, event.tiltX = nativeEvent.tiltX, event.tiltY = nativeEvent.tiltY, event.twist = nativeEvent.twist, this.transferMouseData(event, nativeEvent), this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY), event.global.copyFrom(event.screen), event.offset.copyFrom(event.screen), event.isTrusted = nativeEvent.isTrusted, event.type === "pointerleave" && (event.type = "pointerout"), event.type.startsWith("mouse") && (event.type = event.type.replace("mouse", "pointer")), event.type.startsWith("touch") && (event.type = TOUCH_TO_POINTER[event.type] || event.type), event;
  }
  /**
   * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.
   * @param event
   * @param nativeEvent
   */
  transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted, event.srcElement = nativeEvent.srcElement, event.timeStamp = performance.now(), event.type = nativeEvent.type, event.altKey = nativeEvent.altKey, event.button = nativeEvent.button, event.buttons = nativeEvent.buttons, event.client.x = nativeEvent.clientX, event.client.y = nativeEvent.clientY, event.ctrlKey = nativeEvent.ctrlKey, event.metaKey = nativeEvent.metaKey, event.movement.x = nativeEvent.movementX, event.movement.y = nativeEvent.movementY, event.page.x = nativeEvent.pageX, event.page.y = nativeEvent.pageY, event.relatedTarget = null, event.shiftKey = nativeEvent.shiftKey;
  }
};
_EventSystem.extension = {
  name: "events",
  type: [
    core.ExtensionType.RendererSystem,
    core.ExtensionType.CanvasRendererSystem
  ]
}, /**
* The event features that are enabled by the EventSystem
* This option only is available when using **@pixi/events** package
* (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.
* @since 7.2.0
*/
_EventSystem.defaultEventFeatures = {
  move: !0,
  globalMove: !0,
  click: !0,
  wheel: !0
};
let EventSystem = _EventSystem;
core.extensions.add(EventSystem);
exports.EventSystem = EventSystem;
//# sourceMappingURL=EventSystem.js.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/EventTicker.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/events/lib/EventTicker.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
class EventsTickerClass {
  constructor() {
    this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this.tickerAdded = !1, this._pauseUpdate = !0;
  }
  /**
   * Initializes the event ticker.
   * @param events - The event system.
   */
  init(events) {
    this.removeTickerListener(), this.events = events, this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this.tickerAdded = !1, this._pauseUpdate = !0;
  }
  /** Whether to pause the update checks or not. */
  get pauseUpdate() {
    return this._pauseUpdate;
  }
  set pauseUpdate(paused) {
    this._pauseUpdate = paused;
  }
  /** Adds the ticker listener. */
  addTickerListener() {
    this.tickerAdded || !this.domElement || (core.Ticker.system.add(this.tickerUpdate, this, core.UPDATE_PRIORITY.INTERACTION), this.tickerAdded = !0);
  }
  /** Removes the ticker listener. */
  removeTickerListener() {
    this.tickerAdded && (core.Ticker.system.remove(this.tickerUpdate, this), this.tickerAdded = !1);
  }
  /** Sets flag to not fire extra events when the user has already moved there mouse */
  pointerMoved() {
    this._didMove = !0;
  }
  /** Updates the state of interactive objects. */
  update() {
    if (!this.domElement || this._pauseUpdate)
      return;
    if (this._didMove) {
      this._didMove = !1;
      return;
    }
    const rootPointerEvent = this.events.rootPointerEvent;
    this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch" || globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
      clientX: rootPointerEvent.clientX,
      clientY: rootPointerEvent.clientY
    }));
  }
  /**
   * Updates the state of interactive objects if at least {@link interactionFrequency}
   * milliseconds have passed since the last invocation.
   *
   * Invoked by a throttled ticker update from {@link PIXI.Ticker.system}.
   * @param deltaTime - time delta since the last call
   */
  tickerUpdate(deltaTime) {
    this._deltaTime += deltaTime, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());
  }
}
const EventsTicker = new EventsTickerClass();
exports.EventsTicker = EventsTicker;
//# sourceMappingURL=EventTicker.js.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/FederatedEvent.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/events/lib/FederatedEvent.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
class FederatedEvent {
  /**
   * @param manager - The event boundary which manages this event. Propagation can only occur
   *  within the boundary's jurisdiction.
   */
  constructor(manager) {
    this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = FederatedEvent.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = new core.Point(), this.page = new core.Point(), this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = manager;
  }
  /** @readonly */
  get layerX() {
    return this.layer.x;
  }
  /** @readonly */
  get layerY() {
    return this.layer.y;
  }
  /** @readonly */
  get pageX() {
    return this.page.x;
  }
  /** @readonly */
  get pageY() {
    return this.page.y;
  }
  /**
   * Fallback for the deprecated @code{PIXI.InteractionEvent.data}.
   * @deprecated since 7.0.0
   */
  get data() {
    return this;
  }
  /** The propagation path for this event. Alias for {@link PIXI.EventBoundary.propagationPath}. */
  composedPath() {
    return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path;
  }
  /**
   * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.
   * @deprecated
   * @param _type
   * @param _bubbles
   * @param _cancelable
   */
  initEvent(_type, _bubbles, _cancelable) {
    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  /**
   * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.
   * @deprecated
   * @param _typeArg
   * @param _bubblesArg
   * @param _cancelableArg
   * @param _viewArg
   * @param _detailArg
   */
  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  /** Prevent default behavior of PixiJS and the user agent. */
  preventDefault() {
    this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = !0;
  }
  /**
   * Stop this event from propagating to any addition listeners, including on the
   * {@link PIXI.FederatedEventTarget.currentTarget currentTarget} and also the following
   * event targets on the propagation path.
   */
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = !0;
  }
  /**
   * Stop this event from propagating to the next {@link PIXI.FederatedEventTarget}. The rest of the listeners
   * on the {@link PIXI.FederatedEventTarget.currentTarget currentTarget} will still be notified.
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
exports.FederatedEvent = FederatedEvent;
//# sourceMappingURL=FederatedEvent.js.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/FederatedEventMap.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/events/lib/FederatedEventMap.js ***!
  \************************************************************/
/***/ (() => {

"use strict";

//# sourceMappingURL=FederatedEventMap.js.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/FederatedEventTarget.js":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/events/lib/FederatedEventTarget.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), display = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.js"), EventSystem = __webpack_require__(/*! ./EventSystem.js */ "./node_modules/@pixi/events/lib/EventSystem.js"), FederatedEvent = __webpack_require__(/*! ./FederatedEvent.js */ "./node_modules/@pixi/events/lib/FederatedEvent.js");
function convertEventModeToInteractiveMode(mode) {
  return mode === "dynamic" || mode === "static";
}
const FederatedDisplayObject = {
  /**
   * Property-based event handler for the `click` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onclick = (event) => {
   *  //some function here that happens on click
   * }
   */
  onclick: null,
  /**
   * Property-based event handler for the `mousedown` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmousedown = (event) => {
   *  //some function here that happens on mousedown
   * }
   */
  onmousedown: null,
  /**
   * Property-based event handler for the `mouseenter` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmouseenter = (event) => {
   *  //some function here that happens on mouseenter
   * }
   */
  onmouseenter: null,
  /**
   * Property-based event handler for the `mouseleave` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmouseleave = (event) => {
   *  //some function here that happens on mouseleave
   * }
   */
  onmouseleave: null,
  /**
   * Property-based event handler for the `mousemove` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmousemove = (event) => {
   *  //some function here that happens on mousemove
   * }
   */
  onmousemove: null,
  /**
   * Property-based event handler for the `globalmousemove` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onglobalmousemove = (event) => {
   *  //some function here that happens on globalmousemove
   * }
   */
  onglobalmousemove: null,
  /**
   * Property-based event handler for the `mouseout` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmouseout = (event) => {
   *  //some function here that happens on mouseout
   * }
   */
  onmouseout: null,
  /**
   * Property-based event handler for the `mouseover` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmouseover = (event) => {
   *  //some function here that happens on mouseover
   * }
   */
  onmouseover: null,
  /**
   * Property-based event handler for the `mouseup` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmouseup = (event) => {
   *  //some function here that happens on mouseup
   * }
   */
  onmouseup: null,
  /**
   * Property-based event handler for the `mouseupoutside` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onmouseupoutside = (event) => {
   *  //some function here that happens on mouseupoutside
   * }
   */
  onmouseupoutside: null,
  /**
   * Property-based event handler for the `pointercancel` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointercancel = (event) => {
   *  //some function here that happens on pointercancel
   * }
   */
  onpointercancel: null,
  /**
   * Property-based event handler for the `pointerdown` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointerdown = (event) => {
   *  //some function here that happens on pointerdown
   * }
   */
  onpointerdown: null,
  /**
   * Property-based event handler for the `pointerenter` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointerenter = (event) => {
   *  //some function here that happens on pointerenter
   * }
   */
  onpointerenter: null,
  /**
   * Property-based event handler for the `pointerleave` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointerleave = (event) => {
   *  //some function here that happens on pointerleave
   * }
   */
  onpointerleave: null,
  /**
   * Property-based event handler for the `pointermove` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointermove = (event) => {
   *  //some function here that happens on pointermove
   * }
   */
  onpointermove: null,
  /**
   * Property-based event handler for the `globalpointermove` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onglobalpointermove = (event) => {
   *  //some function here that happens on globalpointermove
   * }
   */
  onglobalpointermove: null,
  /**
   * Property-based event handler for the `pointerout` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointerout = (event) => {
   *  //some function here that happens on pointerout
   * }
   */
  onpointerout: null,
  /**
   * Property-based event handler for the `pointerover` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointerover = (event) => {
   *  //some function here that happens on pointerover
   * }
   */
  onpointerover: null,
  /**
   * Property-based event handler for the `pointertap` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointertap = (event) => {
   *  //some function here that happens on pointertap
   * }
   */
  onpointertap: null,
  /**
   * Property-based event handler for the `pointerup` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointerup = (event) => {
   *  //some function here that happens on pointerup
   * }
   */
  onpointerup: null,
  /**
   * Property-based event handler for the `pointerupoutside` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onpointerupoutside = (event) => {
   *  //some function here that happens on pointerupoutside
   * }
   */
  onpointerupoutside: null,
  /**
   * Property-based event handler for the `rightclick` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onrightclick = (event) => {
   *  //some function here that happens on rightclick
   * }
   */
  onrightclick: null,
  /**
   * Property-based event handler for the `rightdown` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onrightdown = (event) => {
   *  //some function here that happens on rightdown
   * }
   */
  onrightdown: null,
  /**
   * Property-based event handler for the `rightup` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onrightup = (event) => {
   *  //some function here that happens on rightup
   * }
   */
  onrightup: null,
  /**
   * Property-based event handler for the `rightupoutside` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onrightupoutside = (event) => {
   *  //some function here that happens on rightupoutside
   * }
   */
  onrightupoutside: null,
  /**
   * Property-based event handler for the `tap` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.ontap = (event) => {
   *  //some function here that happens on tap
   * }
   */
  ontap: null,
  /**
   * Property-based event handler for the `touchcancel` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.ontouchcancel = (event) => {
   *  //some function here that happens on touchcancel
   * }
   */
  ontouchcancel: null,
  /**
   * Property-based event handler for the `touchend` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.ontouchend = (event) => {
   *  //some function here that happens on touchend
   * }
   */
  ontouchend: null,
  /**
   * Property-based event handler for the `touchendoutside` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.ontouchendoutside = (event) => {
   *  //some function here that happens on touchendoutside
   * }
   */
  ontouchendoutside: null,
  /**
   * Property-based event handler for the `touchmove` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.ontouchmove = (event) => {
   *  //some function here that happens on touchmove
   * }
   */
  ontouchmove: null,
  /**
   * Property-based event handler for the `globaltouchmove` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onglobaltouchmove = (event) => {
   *  //some function here that happens on globaltouchmove
   * }
   */
  onglobaltouchmove: null,
  /**
   * Property-based event handler for the `touchstart` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.ontouchstart = (event) => {
   *  //some function here that happens on touchstart
   * }
   */
  ontouchstart: null,
  /**
   * Property-based event handler for the `wheel` event.
   * @memberof PIXI.DisplayObject#
   * @default null
   * @example
   * this.onwheel = (event) => {
   *  //some function here that happens on wheel
   * }
   */
  onwheel: null,
  /**
   * @ignore
   */
  _internalInteractive: void 0,
  /**
   * Enable interaction events for the DisplayObject. Touch, pointer and mouse
   * @memberof PIXI.DisplayObject#
   */
  get interactive() {
    return this._internalInteractive ?? convertEventModeToInteractiveMode(EventSystem.EventSystem.defaultEventMode);
  },
  set interactive(value) {
    core.utils.deprecation(
      "7.2.0",
      // eslint-disable-next-line max-len
      "Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead."
    ), this._internalInteractive = value, this.eventMode = value ? "static" : "auto";
  },
  /**
   * @ignore
   */
  _internalEventMode: void 0,
  /**
   * Enable interaction events for the DisplayObject. Touch, pointer and mouse.
   * This now replaces the `interactive` property.
   * There are 5 types of interaction settings:
   * - `'none'`: Ignores all interaction events, even on its children.
   * - `'passive'`: Does not emit events and ignores all hit testing on itself and non-interactive children.
   * Interactive children will still emit events.
   * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7
   * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7
   * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to
   * allow for interaction when the mouse isn't moving
   * @example
   * import { Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite(texture);
   * sprite.eventMode = 'static';
   * sprite.on('tap', (event) => {
   *     // Handle event
   * });
   * @memberof PIXI.DisplayObject#
   * @since 7.2.0
   */
  get eventMode() {
    return this._internalEventMode ?? EventSystem.EventSystem.defaultEventMode;
  },
  set eventMode(value) {
    this._internalInteractive = convertEventModeToInteractiveMode(value), this._internalEventMode = value;
  },
  /**
   * Determines if the displayObject is interactive or not
   * @returns {boolean} Whether the displayObject is interactive or not
   * @memberof PIXI.DisplayObject#
   * @since 7.2.0
   * @example
   * import { Sprite } from 'pixi.js';
   * const sprite = new Sprite(texture);
   * sprite.eventMode = 'static';
   * sprite.isInteractive(); // true
   *
   * sprite.eventMode = 'dynamic';
   * sprite.isInteractive(); // true
   *
   * sprite.eventMode = 'none';
   * sprite.isInteractive(); // false
   *
   * sprite.eventMode = 'passive';
   * sprite.isInteractive(); // false
   *
   * sprite.eventMode = 'auto';
   * sprite.isInteractive(); // false
   */
  isInteractive() {
    return this.eventMode === "static" || this.eventMode === "dynamic";
  },
  /**
   * Determines if the children to the displayObject can be clicked/touched
   * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
   * @memberof PIXI.Container#
   */
  interactiveChildren: !0,
  /**
   * Interaction shape. Children will be hit first, then this shape will be checked.
   * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.
   * @example
   * import { Rectangle, Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite(texture);
   * sprite.interactive = true;
   * sprite.hitArea = new Rectangle(0, 0, 100, 100);
   * @member {PIXI.IHitArea}
   * @memberof PIXI.DisplayObject#
   */
  hitArea: null,
  /**
   * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`
   * seeks to be compatible with the DOM's `addEventListener` with support for options.
   * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
   * @memberof PIXI.DisplayObject
   * @param type - The type of event to listen to.
   * @param listener - The listener callback or object.
   * @param options - Listener options, used for capture phase.
   * @example
   * // Tell the user whether they did a single, double, triple, or nth click.
   * button.addEventListener('click', {
   *     handleEvent(e): {
   *         let prefix;
   *
   *         switch (e.detail) {
   *             case 1: prefix = 'single'; break;
   *             case 2: prefix = 'double'; break;
   *             case 3: prefix = 'triple'; break;
   *             default: prefix = e.detail + 'th'; break;
   *         }
   *
   *         console.log('That was a ' + prefix + 'click');
   *     }
   * });
   *
   * // But skip the first click!
   * button.parent.addEventListener('click', function blockClickOnce(e) {
   *     e.stopImmediatePropagation();
   *     button.parent.removeEventListener('click', blockClickOnce, true);
   * }, {
   *     capture: true,
   * });
   */
  addEventListener(type, listener, options) {
    const capture = typeof options == "boolean" && options || typeof options == "object" && options.capture, context = typeof listener == "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type, listener = typeof listener == "function" ? listener : listener.handleEvent, this.on(type, listener, context);
  },
  /**
   * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`
   * seeks to be compatible with the DOM's `removeEventListener` with support for options.
   * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
   * @memberof PIXI.DisplayObject
   * @param type - The type of event the listener is bound to.
   * @param listener - The listener callback or object.
   * @param options - The original listener options. This is required to deregister a capture phase listener.
   */
  removeEventListener(type, listener, options) {
    const capture = typeof options == "boolean" && options || typeof options == "object" && options.capture, context = typeof listener == "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type, listener = typeof listener == "function" ? listener : listener.handleEvent, this.off(type, listener, context);
  },
  /**
   * Dispatch the event on this {@link PIXI.DisplayObject} using the event's {@link PIXI.EventBoundary}.
   *
   * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.
   *
   * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
   * @memberof PIXI.DisplayObject
   * @param e - The event to dispatch.
   * @returns Whether the {@link PIXI.FederatedEvent.preventDefault preventDefault}() method was not invoked.
   * @example
   * // Reuse a click event!
   * button.dispatchEvent(clickEvent);
   */
  dispatchEvent(e) {
    if (!(e instanceof FederatedEvent.FederatedEvent))
      throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    return e.defaultPrevented = !1, e.path = null, e.target = this, e.manager.dispatchEvent(e), !e.defaultPrevented;
  }
};
display.DisplayObject.mixin(FederatedDisplayObject);
exports.FederatedDisplayObject = FederatedDisplayObject;
//# sourceMappingURL=FederatedEventTarget.js.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/FederatedMouseEvent.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/events/lib/FederatedMouseEvent.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), FederatedEvent = __webpack_require__(/*! ./FederatedEvent.js */ "./node_modules/@pixi/events/lib/FederatedEvent.js");
class FederatedMouseEvent extends FederatedEvent.FederatedEvent {
  constructor() {
    super(...arguments), this.client = new core.Point(), this.movement = new core.Point(), this.offset = new core.Point(), this.global = new core.Point(), this.screen = new core.Point();
  }
  /** @readonly */
  get clientX() {
    return this.client.x;
  }
  /** @readonly */
  get clientY() {
    return this.client.y;
  }
  /**
   * Alias for {@link PIXI.FederatedMouseEvent.clientX this.clientX}.
   * @readonly
   */
  get x() {
    return this.clientX;
  }
  /**
   * Alias for {@link PIXI.FederatedMouseEvent.clientY this.clientY}.
   * @readonly
   */
  get y() {
    return this.clientY;
  }
  /** @readonly */
  get movementX() {
    return this.movement.x;
  }
  /** @readonly */
  get movementY() {
    return this.movement.y;
  }
  /** @readonly */
  get offsetX() {
    return this.offset.x;
  }
  /** @readonly */
  get offsetY() {
    return this.offset.y;
  }
  /** @readonly */
  get globalX() {
    return this.global.x;
  }
  /** @readonly */
  get globalY() {
    return this.global.y;
  }
  /**
   * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.
   * @readonly
   */
  get screenX() {
    return this.screen.x;
  }
  /**
   * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.
   * @readonly
   */
  get screenY() {
    return this.screen.y;
  }
  /**
   * This will return the local coordinates of the specified displayObject for this InteractionData
   * @param {PIXI.DisplayObject} displayObject - The DisplayObject that you would like the local
   *  coords off
   * @param {PIXI.IPointData} point - A Point object in which to store the value, optional (otherwise
   *  will create a new point)
   * @param {PIXI.IPointData} globalPos - A Point object containing your custom global coords, optional
   *  (otherwise will use the current global coords)
   * @returns - A point containing the coordinates of the InteractionData position relative
   *  to the DisplayObject
   */
  getLocalPosition(displayObject, point, globalPos) {
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
  }
  /**
   * Whether the modifier key was pressed when this event natively occurred.
   * @param key - The modifier key.
   */
  getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  }
  /**
   * Not supported.
   * @param _typeArg
   * @param _canBubbleArg
   * @param _cancelableArg
   * @param _viewArg
   * @param _detailArg
   * @param _screenXArg
   * @param _screenYArg
   * @param _clientXArg
   * @param _clientYArg
   * @param _ctrlKeyArg
   * @param _altKeyArg
   * @param _shiftKeyArg
   * @param _metaKeyArg
   * @param _buttonArg
   * @param _relatedTargetArg
   * @deprecated since 7.0.0
   */
  // eslint-disable-next-line max-params
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
}
exports.FederatedMouseEvent = FederatedMouseEvent;
//# sourceMappingURL=FederatedMouseEvent.js.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/FederatedPointerEvent.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/events/lib/FederatedPointerEvent.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var FederatedMouseEvent = __webpack_require__(/*! ./FederatedMouseEvent.js */ "./node_modules/@pixi/events/lib/FederatedMouseEvent.js");
class FederatedPointerEvent extends FederatedMouseEvent.FederatedMouseEvent {
  constructor() {
    super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1;
  }
  // Only included for completeness for now
  getCoalescedEvents() {
    return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : [];
  }
  // Only included for completeness for now
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
}
exports.FederatedPointerEvent = FederatedPointerEvent;
//# sourceMappingURL=FederatedPointerEvent.js.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/FederatedWheelEvent.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/events/lib/FederatedWheelEvent.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var FederatedMouseEvent = __webpack_require__(/*! ./FederatedMouseEvent.js */ "./node_modules/@pixi/events/lib/FederatedMouseEvent.js");
class FederatedWheelEvent extends FederatedMouseEvent.FederatedMouseEvent {
  constructor() {
    super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;
  }
}
FederatedWheelEvent.DOM_DELTA_PIXEL = 0, /** Units specified in lines. */
FederatedWheelEvent.DOM_DELTA_LINE = 1, /** Units specified in pages. */
FederatedWheelEvent.DOM_DELTA_PAGE = 2;
exports.FederatedWheelEvent = FederatedWheelEvent;
//# sourceMappingURL=FederatedWheelEvent.js.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/events/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var EventBoundary = __webpack_require__(/*! ./EventBoundary.js */ "./node_modules/@pixi/events/lib/EventBoundary.js"), EventSystem = __webpack_require__(/*! ./EventSystem.js */ "./node_modules/@pixi/events/lib/EventSystem.js"), FederatedEvent = __webpack_require__(/*! ./FederatedEvent.js */ "./node_modules/@pixi/events/lib/FederatedEvent.js");
__webpack_require__(/*! ./FederatedEventMap.js */ "./node_modules/@pixi/events/lib/FederatedEventMap.js");
var FederatedEventTarget = __webpack_require__(/*! ./FederatedEventTarget.js */ "./node_modules/@pixi/events/lib/FederatedEventTarget.js"), FederatedMouseEvent = __webpack_require__(/*! ./FederatedMouseEvent.js */ "./node_modules/@pixi/events/lib/FederatedMouseEvent.js"), FederatedPointerEvent = __webpack_require__(/*! ./FederatedPointerEvent.js */ "./node_modules/@pixi/events/lib/FederatedPointerEvent.js"), FederatedWheelEvent = __webpack_require__(/*! ./FederatedWheelEvent.js */ "./node_modules/@pixi/events/lib/FederatedWheelEvent.js");
exports.EventBoundary = EventBoundary.EventBoundary;
exports.EventSystem = EventSystem.EventSystem;
exports.FederatedEvent = FederatedEvent.FederatedEvent;
exports.FederatedDisplayObject = FederatedEventTarget.FederatedDisplayObject;
exports.FederatedMouseEvent = FederatedMouseEvent.FederatedMouseEvent;
exports.FederatedPointerEvent = FederatedPointerEvent.FederatedPointerEvent;
exports.FederatedWheelEvent = FederatedWheelEvent.FederatedWheelEvent;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/extensions/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/extensions/lib/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => (ExtensionType2.Renderer = "renderer", ExtensionType2.Application = "application", ExtensionType2.RendererSystem = "renderer-webgl-system", ExtensionType2.RendererPlugin = "renderer-webgl-plugin", ExtensionType2.CanvasRendererSystem = "renderer-canvas-system", ExtensionType2.CanvasRendererPlugin = "renderer-canvas-plugin", ExtensionType2.Asset = "asset", ExtensionType2.LoadParser = "load-parser", ExtensionType2.ResolveParser = "resolve-parser", ExtensionType2.CacheParser = "cache-parser", ExtensionType2.DetectionParser = "detection-parser", ExtensionType2))(ExtensionType || {});
const normalizeExtension = (ext) => {
  if (typeof ext == "function" || typeof ext == "object" && ext.extension) {
    if (!ext.extension)
      throw new Error("Extension class must have an extension object");
    ext = { ...typeof ext.extension != "object" ? { type: ext.extension } : ext.extension, ref: ext };
  }
  if (typeof ext == "object")
    ext = { ...ext };
  else
    throw new Error("Invalid extension type");
  return typeof ext.type == "string" && (ext.type = [ext.type]), ext;
}, normalizePriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority, extensions = {
  /** @ignore */
  _addHandlers: {},
  /** @ignore */
  _removeHandlers: {},
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {PIXI.extensions} For chaining.
   */
  remove(...extensions2) {
    return extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
    }), this;
  },
  /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {PIXI.extensions} For chaining.
   */
  add(...extensions2) {
    return extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => {
        const handlers = this._addHandlers, queue = this._queue;
        handlers[type] ? handlers[type](ext) : (queue[type] = queue[type] || [], queue[type].push(ext));
      });
    }), this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.
   * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.
   * @returns {PIXI.extensions} For chaining.
   */
  handle(type, onAdd, onRemove) {
    const addHandlers = this._addHandlers, removeHandlers = this._removeHandlers;
    if (addHandlers[type] || removeHandlers[type])
      throw new Error(`Extension type ${type} already has a handler`);
    addHandlers[type] = onAdd, removeHandlers[type] = onRemove;
    const queue = this._queue;
    return queue[type] && (queue[type].forEach((ext) => onAdd(ext)), delete queue[type]), this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByMap(type, map) {
    return this.handle(
      type,
      (extension) => {
        map[extension.name] = extension.ref;
      },
      (extension) => {
        delete map[extension.name];
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @param defaultPriority - The default priority to use if none is specified.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByList(type, list, defaultPriority = -1) {
    return this.handle(
      type,
      (extension) => {
        list.includes(extension.ref) || (list.push(extension.ref), list.sort((a, b) => normalizePriority(b, defaultPriority) - normalizePriority(a, defaultPriority)));
      },
      (extension) => {
        const index = list.indexOf(extension.ref);
        index !== -1 && list.splice(index, 1);
      }
    );
  }
};
exports.ExtensionType = ExtensionType;
exports.extensions = extensions;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/extract/lib/Extract.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/extract/lib/Extract.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
const TEMP_RECT = new core.Rectangle(), BYTES_PER_PIXEL = 4, _Extract = class _Extract2 {
  /**
   * @param renderer - A reference to the current renderer
   */
  constructor(renderer) {
    this.renderer = renderer, this._rendererPremultipliedAlpha = !1;
  }
  contextChange() {
    const attributes = this.renderer?.gl.getContextAttributes();
    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);
  }
  /**
   * Will return a HTML Image of the target
   * @param target - A displayObject or renderTexture
   *  to convert. If left empty will use the main renderer
   * @param format - Image format, e.g. "image/jpeg" or "image/webp".
   * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.
   * @param frame - The frame the extraction is restricted to.
   * @returns - HTML Image of the target
   */
  async image(target, format, quality, frame) {
    const image = new Image();
    return image.src = await this.base64(target, format, quality, frame), image;
  }
  /**
   * Will return a base64 encoded string of this target. It works by calling
   *  `Extract.canvas` and then running toDataURL on that.
   * @param target - A displayObject or renderTexture
   *  to convert. If left empty will use the main renderer
   * @param format - Image format, e.g. "image/jpeg" or "image/webp".
   * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.
   * @param frame - The frame the extraction is restricted to.
   * @returns - A base64 encoded string of the texture.
   */
  async base64(target, format, quality, frame) {
    const canvas = this.canvas(target, frame);
    if (canvas.toBlob !== void 0)
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result), reader.onerror = reject, reader.readAsDataURL(blob);
        }, format, quality);
      });
    if (canvas.toDataURL !== void 0)
      return canvas.toDataURL(format, quality);
    if (canvas.convertToBlob !== void 0) {
      const blob = await canvas.convertToBlob({ type: format, quality });
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result), reader.onerror = reject, reader.readAsDataURL(blob);
      });
    }
    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
  }
  /**
   * Creates a Canvas element, renders this target to it and then returns it.
   * @param target - A displayObject or renderTexture
   *  to convert. If left empty will use the main renderer
   * @param frame - The frame the extraction is restricted to.
   * @returns - A Canvas element with the texture rendered on.
   */
  canvas(target, frame) {
    const { pixels, width, height, flipY, premultipliedAlpha } = this._rawPixels(target, frame);
    flipY && _Extract2._flipY(pixels, width, height), premultipliedAlpha && _Extract2._unpremultiplyAlpha(pixels);
    const canvasBuffer = new core.utils.CanvasRenderTarget(width, height, 1), imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);
    return canvasBuffer.context.putImageData(imageData, 0, 0), canvasBuffer.canvas;
  }
  /**
   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
   * order, with integer values between 0 and 255 (included).
   * @param target - A displayObject or renderTexture
   *  to convert. If left empty will use the main renderer
   * @param frame - The frame the extraction is restricted to.
   * @returns - One-dimensional array containing the pixel data of the entire texture
   */
  pixels(target, frame) {
    const { pixels, width, height, flipY, premultipliedAlpha } = this._rawPixels(target, frame);
    return flipY && _Extract2._flipY(pixels, width, height), premultipliedAlpha && _Extract2._unpremultiplyAlpha(pixels), pixels;
  }
  _rawPixels(target, frame) {
    const renderer = this.renderer;
    if (!renderer)
      throw new Error("The Extract has already been destroyed");
    let resolution, flipY = !1, premultipliedAlpha = !1, renderTexture, generated = !1;
    target && (target instanceof core.RenderTexture ? renderTexture = target : (renderTexture = renderer.generateTexture(target, {
      region: frame,
      resolution: renderer.resolution,
      multisample: renderer.multisample
    }), generated = !0, frame && (TEMP_RECT.width = frame.width, TEMP_RECT.height = frame.height, frame = TEMP_RECT)));
    const gl = renderer.gl;
    if (renderTexture) {
      if (resolution = renderTexture.baseTexture.resolution, frame = frame ?? renderTexture.frame, flipY = !1, premultipliedAlpha = renderTexture.baseTexture.alphaMode > 0 && renderTexture.baseTexture.format === core.FORMATS.RGBA, !generated) {
        renderer.renderTexture.bind(renderTexture);
        const fbo = renderTexture.framebuffer.glFramebuffers[renderer.CONTEXT_UID];
        fbo.blitFramebuffer && renderer.framebuffer.bind(fbo.blitFramebuffer);
      }
    } else
      resolution = renderer.resolution, frame || (frame = TEMP_RECT, frame.width = renderer.width / resolution, frame.height = renderer.height / resolution), flipY = !0, premultipliedAlpha = this._rendererPremultipliedAlpha, renderer.renderTexture.bind();
    const width = Math.max(Math.round(frame.width * resolution), 1), height = Math.max(Math.round(frame.height * resolution), 1), pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    return gl.readPixels(
      Math.round(frame.x * resolution),
      Math.round(frame.y * resolution),
      width,
      height,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      pixels
    ), generated && renderTexture?.destroy(!0), { pixels, width, height, flipY, premultipliedAlpha };
  }
  /** Destroys the extract. */
  destroy() {
    this.renderer = null;
  }
  static _flipY(pixels, width, height) {
    const w = width << 2, h = height >> 1, temp = new Uint8Array(w);
    for (let y = 0; y < h; y++) {
      const t = y * w, b = (height - y - 1) * w;
      temp.set(pixels.subarray(t, t + w)), pixels.copyWithin(t, b, b + w), pixels.set(temp, b);
    }
  }
  static _unpremultiplyAlpha(pixels) {
    pixels instanceof Uint8ClampedArray && (pixels = new Uint8Array(pixels.buffer));
    const n = pixels.length;
    for (let i = 0; i < n; i += 4) {
      const alpha = pixels[i + 3];
      if (alpha !== 0) {
        const a = 255.001 / alpha;
        pixels[i] = pixels[i] * a + 0.5, pixels[i + 1] = pixels[i + 1] * a + 0.5, pixels[i + 2] = pixels[i + 2] * a + 0.5;
      }
    }
  }
};
_Extract.extension = {
  name: "extract",
  type: core.ExtensionType.RendererSystem
};
let Extract = _Extract;
core.extensions.add(Extract);
exports.Extract = Extract;
//# sourceMappingURL=Extract.js.map


/***/ }),

/***/ "./node_modules/@pixi/extract/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/extract/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Extract = __webpack_require__(/*! ./Extract.js */ "./node_modules/@pixi/extract/lib/Extract.js");
exports.Extract = Extract.Extract;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-alpha/lib/AlphaFilter.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/filter-alpha/lib/AlphaFilter.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), alpha = __webpack_require__(/*! ./alpha.frag.js */ "./node_modules/@pixi/filter-alpha/lib/alpha.frag.js");
class AlphaFilter extends core.Filter {
  /**
   * @param alpha - Amount of alpha from 0 to 1, where 0 is transparent
   */
  constructor(alpha$1 = 1) {
    super(core.defaultVertex, alpha.default, { uAlpha: 1 }), this.alpha = alpha$1;
  }
  /**
   * Coefficient for alpha multiplication
   * @default 1
   */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}
exports.AlphaFilter = AlphaFilter;
//# sourceMappingURL=AlphaFilter.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-alpha/lib/alpha.frag.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/filter-alpha/lib/alpha.frag.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var fragment = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
exports["default"] = fragment;
//# sourceMappingURL=alpha.frag.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-alpha/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/filter-alpha/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var AlphaFilter = __webpack_require__(/*! ./AlphaFilter.js */ "./node_modules/@pixi/filter-alpha/lib/AlphaFilter.js");
exports.AlphaFilter = AlphaFilter.AlphaFilter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-blur/lib/BlurFilter.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/filter-blur/lib/BlurFilter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), BlurFilterPass = __webpack_require__(/*! ./BlurFilterPass.js */ "./node_modules/@pixi/filter-blur/lib/BlurFilterPass.js");
class BlurFilter extends core.Filter {
  /**
   * @param strength - The strength of the blur filter.
   * @param quality - The quality of the blur filter.
   * @param {number|null} [resolution=PIXI.Filter.defaultResolution] - The resolution of the blur filter.
   * @param kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
   */
  constructor(strength = 8, quality = 4, resolution = core.Filter.defaultResolution, kernelSize = 5) {
    super(), this._repeatEdgePixels = !1, this.blurXFilter = new BlurFilterPass.BlurFilterPass(!0, strength, quality, resolution, kernelSize), this.blurYFilter = new BlurFilterPass.BlurFilterPass(!1, strength, quality, resolution, kernelSize), this.resolution = resolution, this.quality = quality, this.blur = strength, this.repeatEdgePixels = !1;
  }
  /**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - How to clear
   */
  apply(filterManager, input, output, clearMode) {
    const xStrength = Math.abs(this.blurXFilter.strength), yStrength = Math.abs(this.blurYFilter.strength);
    if (xStrength && yStrength) {
      const renderTarget = filterManager.getFilterTexture();
      this.blurXFilter.apply(filterManager, input, renderTarget, core.CLEAR_MODES.CLEAR), this.blurYFilter.apply(filterManager, renderTarget, output, clearMode), filterManager.returnFilterTexture(renderTarget);
    } else
      yStrength ? this.blurYFilter.apply(filterManager, input, output, clearMode) : this.blurXFilter.apply(filterManager, input, output, clearMode);
  }
  updatePadding() {
    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
  }
  /**
   * Sets the strength of both the blurX and blurY properties simultaneously
   * @default 2
   */
  get blur() {
    return this.blurXFilter.blur;
  }
  set blur(value) {
    this.blurXFilter.blur = this.blurYFilter.blur = value, this.updatePadding();
  }
  /**
   * Sets the number of passes for blur. More passes means higher quality bluring.
   * @default 1
   */
  get quality() {
    return this.blurXFilter.quality;
  }
  set quality(value) {
    this.blurXFilter.quality = this.blurYFilter.quality = value;
  }
  /**
   * Sets the strength of the blurX property
   * @default 2
   */
  get blurX() {
    return this.blurXFilter.blur;
  }
  set blurX(value) {
    this.blurXFilter.blur = value, this.updatePadding();
  }
  /**
   * Sets the strength of the blurY property
   * @default 2
   */
  get blurY() {
    return this.blurYFilter.blur;
  }
  set blurY(value) {
    this.blurYFilter.blur = value, this.updatePadding();
  }
  /**
   * Sets the blendmode of the filter
   * @default PIXI.BLEND_MODES.NORMAL
   */
  get blendMode() {
    return this.blurYFilter.blendMode;
  }
  set blendMode(value) {
    this.blurYFilter.blendMode = value;
  }
  /**
   * If set to true the edge of the target will be clamped
   * @default false
   */
  get repeatEdgePixels() {
    return this._repeatEdgePixels;
  }
  set repeatEdgePixels(value) {
    this._repeatEdgePixels = value, this.updatePadding();
  }
}
exports.BlurFilter = BlurFilter;
//# sourceMappingURL=BlurFilter.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-blur/lib/BlurFilterPass.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/filter-blur/lib/BlurFilterPass.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), generateBlurFragSource = __webpack_require__(/*! ./generateBlurFragSource.js */ "./node_modules/@pixi/filter-blur/lib/generateBlurFragSource.js"), generateBlurVertSource = __webpack_require__(/*! ./generateBlurVertSource.js */ "./node_modules/@pixi/filter-blur/lib/generateBlurVertSource.js");
class BlurFilterPass extends core.Filter {
  /**
   * @param horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).
   * @param strength - The strength of the blur filter.
   * @param quality - The quality of the blur filter.
   * @param {number|null} [resolution=PIXI.Filter.defaultResolution] - The resolution of the blur filter.
   * @param kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
   */
  constructor(horizontal, strength = 8, quality = 4, resolution = core.Filter.defaultResolution, kernelSize = 5) {
    const vertSrc = generateBlurVertSource.generateBlurVertSource(kernelSize, horizontal), fragSrc = generateBlurFragSource.generateBlurFragSource(kernelSize);
    super(
      // vertex shader
      vertSrc,
      // fragment shader
      fragSrc
    ), this.horizontal = horizontal, this.resolution = resolution, this._quality = 0, this.quality = quality, this.blur = strength;
  }
  /**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - How to clear
   */
  apply(filterManager, input, output, clearMode) {
    if (output ? this.horizontal ? this.uniforms.strength = 1 / output.width * (output.width / input.width) : this.uniforms.strength = 1 / output.height * (output.height / input.height) : this.horizontal ? this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width) : this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)
      filterManager.applyFilter(this, input, output, clearMode);
    else {
      const renderTarget = filterManager.getFilterTexture(), renderer = filterManager.renderer;
      let flip = input, flop = renderTarget;
      this.state.blend = !1, filterManager.applyFilter(this, flip, flop, core.CLEAR_MODES.CLEAR);
      for (let i = 1; i < this.passes - 1; i++) {
        filterManager.bindAndClear(flip, core.CLEAR_MODES.BLIT), this.uniforms.uSampler = flop;
        const temp = flop;
        flop = flip, flip = temp, renderer.shader.bind(this), renderer.geometry.draw(5);
      }
      this.state.blend = !0, filterManager.applyFilter(this, flop, output, clearMode), filterManager.returnFilterTexture(renderTarget);
    }
  }
  /**
   * Sets the strength of both the blur.
   * @default 16
   */
  get blur() {
    return this.strength;
  }
  set blur(value) {
    this.padding = 1 + Math.abs(value) * 2, this.strength = value;
  }
  /**
   * Sets the quality of the blur by modifying the number of passes. More passes means higher
   * quality bluring but the lower the performance.
   * @default 4
   */
  get quality() {
    return this._quality;
  }
  set quality(value) {
    this._quality = value, this.passes = value;
  }
}
exports.BlurFilterPass = BlurFilterPass;
//# sourceMappingURL=BlurFilterPass.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-blur/lib/generateBlurFragSource.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/filter-blur/lib/generateBlurFragSource.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
}, fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join(`
`);
function generateBlurFragSource(kernelSize) {
  const kernel = GAUSSIAN_VALUES[kernelSize], halfLength = kernel.length;
  let fragSource = fragTemplate, blurLoop = "";
  const template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
  let value;
  for (let i = 0; i < kernelSize; i++) {
    let blur = template.replace("%index%", i.toString());
    value = i, i >= halfLength && (value = kernelSize - i - 1), blur = blur.replace("%value%", kernel[value].toString()), blurLoop += blur, blurLoop += `
`;
  }
  return fragSource = fragSource.replace("%blur%", blurLoop), fragSource = fragSource.replace("%size%", kernelSize.toString()), fragSource;
}
exports.generateBlurFragSource = generateBlurFragSource;
//# sourceMappingURL=generateBlurFragSource.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-blur/lib/generateBlurVertSource.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/filter-blur/lib/generateBlurVertSource.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function generateBlurVertSource(kernelSize, x) {
  const halfLength = Math.ceil(kernelSize / 2);
  let vertSource = vertTemplate, blurLoop = "", template;
  x ? template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  for (let i = 0; i < kernelSize; i++) {
    let blur = template.replace("%index%", i.toString());
    blur = blur.replace("%sampleIndex%", `${i - (halfLength - 1)}.0`), blurLoop += blur, blurLoop += `
`;
  }
  return vertSource = vertSource.replace("%blur%", blurLoop), vertSource = vertSource.replace("%size%", kernelSize.toString()), vertSource;
}
exports.generateBlurVertSource = generateBlurVertSource;
//# sourceMappingURL=generateBlurVertSource.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-blur/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/filter-blur/lib/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var BlurFilter = __webpack_require__(/*! ./BlurFilter.js */ "./node_modules/@pixi/filter-blur/lib/BlurFilter.js"), BlurFilterPass = __webpack_require__(/*! ./BlurFilterPass.js */ "./node_modules/@pixi/filter-blur/lib/BlurFilterPass.js");
exports.BlurFilter = BlurFilter.BlurFilter;
exports.BlurFilterPass = BlurFilterPass.BlurFilterPass;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-color-matrix/lib/ColorMatrixFilter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/filter-color-matrix/lib/ColorMatrixFilter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), colorMatrix = __webpack_require__(/*! ./colorMatrix.frag.js */ "./node_modules/@pixi/filter-color-matrix/lib/colorMatrix.frag.js");
class ColorMatrixFilter extends core.Filter {
  constructor() {
    const uniforms = {
      m: new Float32Array([
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]),
      uAlpha: 1
    };
    super(core.defaultFilterVertex, colorMatrix.default, uniforms), this.alpha = 1;
  }
  /**
   * Transforms current matrix and set the new one
   * @param {number[]} matrix - 5x4 matrix
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  _loadMatrix(matrix, multiply = !1) {
    let newMatrix = matrix;
    multiply && (this._multiply(newMatrix, this.uniforms.m, matrix), newMatrix = this._colorMatrix(newMatrix)), this.uniforms.m = newMatrix;
  }
  /**
   * Multiplies two mat5's
   * @private
   * @param out - 5x4 matrix the receiving matrix
   * @param a - 5x4 matrix the first operand
   * @param b - 5x4 matrix the second operand
   * @returns {number[]} 5x4 matrix
   */
  _multiply(out, a, b) {
    return out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15], out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16], out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17], out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18], out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4], out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15], out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16], out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17], out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18], out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9], out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15], out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16], out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17], out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18], out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14], out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15], out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16], out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17], out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18], out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19], out;
  }
  /**
   * Create a Float32 Array and normalize the offset component to 0-1
   * @param {number[]} matrix - 5x4 matrix
   * @returns {number[]} 5x4 matrix with all values between 0-1
   */
  _colorMatrix(matrix) {
    const m = new Float32Array(matrix);
    return m[4] /= 255, m[9] /= 255, m[14] /= 255, m[19] /= 255, m;
  }
  /**
   * Adjusts brightness
   * @param b - value of the brigthness (0-1, where 0 is black)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  brightness(b, multiply) {
    const matrix = [
      b,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Sets each channel on the diagonal of the color matrix.
   * This can be used to achieve a tinting effect on Containers similar to the tint field of some
   * display objects like Sprite, Text, Graphics, and Mesh.
   * @param color - Color of the tint. This is a hex value.
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  tint(color, multiply) {
    const [r, g, b] = core.Color.shared.setValue(color).toArray(), matrix = [
      r,
      0,
      0,
      0,
      0,
      0,
      g,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Set the matrices in grey scales
   * @param scale - value of the grey (0-1, where 0 is black)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  greyscale(scale, multiply) {
    const matrix = [
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Set the black and white matrice.
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  blackAndWhite(multiply) {
    const matrix = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Set the hue property of the color
   * @param rotation - in degrees
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  hue(rotation, multiply) {
    rotation = (rotation || 0) / 180 * Math.PI;
    const cosR = Math.cos(rotation), sinR = Math.sin(rotation), sqrt = Math.sqrt, w = 1 / 3, sqrW = sqrt(w), a00 = cosR + (1 - cosR) * w, a01 = w * (1 - cosR) - sqrW * sinR, a02 = w * (1 - cosR) + sqrW * sinR, a10 = w * (1 - cosR) + sqrW * sinR, a11 = cosR + w * (1 - cosR), a12 = w * (1 - cosR) - sqrW * sinR, a20 = w * (1 - cosR) - sqrW * sinR, a21 = w * (1 - cosR) + sqrW * sinR, a22 = cosR + w * (1 - cosR), matrix = [
      a00,
      a01,
      a02,
      0,
      0,
      a10,
      a11,
      a12,
      0,
      0,
      a20,
      a21,
      a22,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Set the contrast matrix, increase the separation between dark and bright
   * Increase contrast : shadows darker and highlights brighter
   * Decrease contrast : bring the shadows up and the highlights down
   * @param amount - value of the contrast (0-1)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  contrast(amount, multiply) {
    const v = (amount || 0) + 1, o = -0.5 * (v - 1), matrix = [
      v,
      0,
      0,
      0,
      o,
      0,
      v,
      0,
      0,
      o,
      0,
      0,
      v,
      0,
      o,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Set the saturation matrix, increase the separation between colors
   * Increase saturation : increase contrast, brightness, and sharpness
   * @param amount - The saturation amount (0-1)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  saturate(amount = 0, multiply) {
    const x = amount * 2 / 3 + 1, y = (x - 1) * -0.5, matrix = [
      x,
      y,
      y,
      0,
      0,
      y,
      x,
      y,
      0,
      0,
      y,
      y,
      x,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /** Desaturate image (remove color) Call the saturate function */
  desaturate() {
    this.saturate(-1);
  }
  /**
   * Negative image (inverse of classic rgb matrix)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  negative(multiply) {
    const matrix = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Sepia image
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  sepia(multiply) {
    const matrix = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  technicolor(multiply) {
    const matrix = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Polaroid filter
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  polaroid(multiply) {
    const matrix = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Filter who transforms : Red -> Blue and Blue -> Red
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  toBGR(multiply) {
    const matrix = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  kodachrome(multiply) {
    const matrix = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Brown delicious browni filter (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  browni(multiply) {
    const matrix = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Vintage filter (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  vintage(multiply) {
    const matrix = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * We don't know exactly what it does, kind of gradient map, but funny to play with!
   * @param desaturation - Tone values.
   * @param toned - Tone values.
   * @param lightColor - Tone values, example: `0xFFE580`
   * @param darkColor - Tone values, example: `0xFFE580`
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  colorTone(desaturation, toned, lightColor, darkColor, multiply) {
    desaturation = desaturation || 0.2, toned = toned || 0.15, lightColor = lightColor || 16770432, darkColor = darkColor || 3375104;
    const temp = core.Color.shared, [lR, lG, lB] = temp.setValue(lightColor).toArray(), [dR, dG, dB] = temp.setValue(darkColor).toArray(), matrix = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      lR,
      lG,
      lB,
      desaturation,
      0,
      dR,
      dG,
      dB,
      toned,
      0,
      lR - dR,
      lG - dG,
      lB - dB,
      0,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Night effect
   * @param intensity - The intensity of the night effect.
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  night(intensity, multiply) {
    intensity = intensity || 0.1;
    const matrix = [
      intensity * -2,
      -intensity,
      0,
      0,
      0,
      -intensity,
      0,
      intensity,
      0,
      0,
      0,
      intensity,
      intensity * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Predator effect
   *
   * Erase the current matrix by setting a new indepent one
   * @param amount - how much the predator feels his future victim
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  predator(amount, multiply) {
    const matrix = [
      // row 1
      11.224130630493164 * amount,
      -4.794486999511719 * amount,
      -2.8746118545532227 * amount,
      0 * amount,
      0.40342438220977783 * amount,
      // row 2
      -3.6330697536468506 * amount,
      9.193157196044922 * amount,
      -2.951810836791992 * amount,
      0 * amount,
      -1.316135048866272 * amount,
      // row 3
      -3.2184197902679443 * amount,
      -4.2375030517578125 * amount,
      7.476448059082031 * amount,
      0 * amount,
      0.8044459223747253 * amount,
      // row 4
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * LSD effect
   *
   * Multiply the current matrix
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  lsd(multiply) {
    const matrix = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /** Erase the current matrix by setting the default one. */
  reset() {
    const matrix = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, !1);
  }
  /**
   * The matrix of the color matrix filter
   * @member {number[]}
   * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
   */
  get matrix() {
    return this.uniforms.m;
  }
  set matrix(value) {
    this.uniforms.m = value;
  }
  /**
   * The opacity value to use when mixing the original and resultant colors.
   *
   * When the value is 0, the original color is used without modification.
   * When the value is 1, the result color is used.
   * When in the range (0, 1) the color is interpolated between the original and result by this amount.
   * @default 1
   */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
exports.ColorMatrixFilter = ColorMatrixFilter;
//# sourceMappingURL=ColorMatrixFilter.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-color-matrix/lib/colorMatrix.frag.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/filter-color-matrix/lib/colorMatrix.frag.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var fragment = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`;
exports["default"] = fragment;
//# sourceMappingURL=colorMatrix.frag.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-color-matrix/lib/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/filter-color-matrix/lib/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var ColorMatrixFilter = __webpack_require__(/*! ./ColorMatrixFilter.js */ "./node_modules/@pixi/filter-color-matrix/lib/ColorMatrixFilter.js");
exports.ColorMatrixFilter = ColorMatrixFilter.ColorMatrixFilter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-displacement/lib/DisplacementFilter.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/filter-displacement/lib/DisplacementFilter.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), displacement$1 = __webpack_require__(/*! ./displacement.frag.js */ "./node_modules/@pixi/filter-displacement/lib/displacement.frag.js"), displacement = __webpack_require__(/*! ./displacement.vert.js */ "./node_modules/@pixi/filter-displacement/lib/displacement.vert.js");
class DisplacementFilter extends core.Filter {
  /**
   * @param {PIXI.Sprite} sprite - The sprite used for the displacement map. (make sure its added to the scene!)
   * @param scale - The scale of the displacement
   */
  constructor(sprite, scale) {
    const maskMatrix = new core.Matrix();
    sprite.renderable = !1, super(displacement.default, displacement$1.default, {
      mapSampler: sprite._texture,
      filterMatrix: maskMatrix,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    }), this.maskSprite = sprite, this.maskMatrix = maskMatrix, scale == null && (scale = 20), this.scale = new core.Point(scale, scale);
  }
  /**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - clearMode.
   */
  apply(filterManager, input, output, clearMode) {
    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
    const wt = this.maskSprite.worldTransform, lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b), lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
    lenX !== 0 && lenY !== 0 && (this.uniforms.rotation[0] = wt.a / lenX, this.uniforms.rotation[1] = wt.b / lenX, this.uniforms.rotation[2] = wt.c / lenY, this.uniforms.rotation[3] = wt.d / lenY), filterManager.applyFilter(this, input, output, clearMode);
  }
  /** The texture used for the displacement map. Must be power of 2 sized texture. */
  get map() {
    return this.uniforms.mapSampler;
  }
  set map(value) {
    this.uniforms.mapSampler = value;
  }
}
exports.DisplacementFilter = DisplacementFilter;
//# sourceMappingURL=DisplacementFilter.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-displacement/lib/displacement.frag.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/filter-displacement/lib/displacement.frag.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var fragment = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`;
exports["default"] = fragment;
//# sourceMappingURL=displacement.frag.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-displacement/lib/displacement.vert.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/filter-displacement/lib/displacement.vert.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var vertex = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
exports["default"] = vertex;
//# sourceMappingURL=displacement.vert.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-displacement/lib/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/filter-displacement/lib/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DisplacementFilter = __webpack_require__(/*! ./DisplacementFilter.js */ "./node_modules/@pixi/filter-displacement/lib/DisplacementFilter.js");
exports.DisplacementFilter = DisplacementFilter.DisplacementFilter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-fxaa/lib/FXAAFilter.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/filter-fxaa/lib/FXAAFilter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), fxaa$1 = __webpack_require__(/*! ./fxaa.frag.js */ "./node_modules/@pixi/filter-fxaa/lib/fxaa.frag.js"), fxaa = __webpack_require__(/*! ./fxaa.vert.js */ "./node_modules/@pixi/filter-fxaa/lib/fxaa.vert.js");
class FXAAFilter extends core.Filter {
  constructor() {
    super(fxaa.default, fxaa$1.default);
  }
}
exports.FXAAFilter = FXAAFilter;
//# sourceMappingURL=FXAAFilter.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-fxaa/lib/fxaa.frag.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/filter-fxaa/lib/fxaa.frag.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var fragment = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
exports["default"] = fragment;
//# sourceMappingURL=fxaa.frag.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-fxaa/lib/fxaa.vert.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/filter-fxaa/lib/fxaa.vert.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var vertex = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`;
exports["default"] = vertex;
//# sourceMappingURL=fxaa.vert.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-fxaa/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/filter-fxaa/lib/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var FXAAFilter = __webpack_require__(/*! ./FXAAFilter.js */ "./node_modules/@pixi/filter-fxaa/lib/FXAAFilter.js");
exports.FXAAFilter = FXAAFilter.FXAAFilter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-noise/lib/NoiseFilter.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/filter-noise/lib/NoiseFilter.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), noise = __webpack_require__(/*! ./noise.frag.js */ "./node_modules/@pixi/filter-noise/lib/noise.frag.js");
class NoiseFilter extends core.Filter {
  /**
   * @param {number} [noise=0.5] - The noise intensity, should be a normalized value in the range [0, 1].
   * @param {number} [seed] - A random seed for the noise generation. Default is `Math.random()`.
   */
  constructor(noise$1 = 0.5, seed = Math.random()) {
    super(core.defaultFilterVertex, noise.default, {
      uNoise: 0,
      uSeed: 0
    }), this.noise = noise$1, this.seed = seed;
  }
  /**
   * The amount of noise to apply, this value should be in the range (0, 1].
   * @default 0.5
   */
  get noise() {
    return this.uniforms.uNoise;
  }
  set noise(value) {
    this.uniforms.uNoise = value;
  }
  /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */
  get seed() {
    return this.uniforms.uSeed;
  }
  set seed(value) {
    this.uniforms.uSeed = value;
  }
}
exports.NoiseFilter = NoiseFilter;
//# sourceMappingURL=NoiseFilter.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-noise/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/filter-noise/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var NoiseFilter = __webpack_require__(/*! ./NoiseFilter.js */ "./node_modules/@pixi/filter-noise/lib/NoiseFilter.js");
exports.NoiseFilter = NoiseFilter.NoiseFilter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/filter-noise/lib/noise.frag.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/filter-noise/lib/noise.frag.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var fragment = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
exports["default"] = fragment;
//# sourceMappingURL=noise.frag.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/Graphics.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/Graphics.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), display = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.js"), _const = __webpack_require__(/*! ./const.js */ "./node_modules/@pixi/graphics/lib/const.js"), GraphicsGeometry = __webpack_require__(/*! ./GraphicsGeometry.js */ "./node_modules/@pixi/graphics/lib/GraphicsGeometry.js"), FillStyle = __webpack_require__(/*! ./styles/FillStyle.js */ "./node_modules/@pixi/graphics/lib/styles/FillStyle.js"), LineStyle = __webpack_require__(/*! ./styles/LineStyle.js */ "./node_modules/@pixi/graphics/lib/styles/LineStyle.js");
__webpack_require__(/*! ./utils/index.js */ "./node_modules/@pixi/graphics/lib/utils/index.js");
var QuadraticUtils = __webpack_require__(/*! ./utils/QuadraticUtils.js */ "./node_modules/@pixi/graphics/lib/utils/QuadraticUtils.js"), BezierUtils = __webpack_require__(/*! ./utils/BezierUtils.js */ "./node_modules/@pixi/graphics/lib/utils/BezierUtils.js"), ArcUtils = __webpack_require__(/*! ./utils/ArcUtils.js */ "./node_modules/@pixi/graphics/lib/utils/ArcUtils.js");
const DEFAULT_SHADERS = {}, _Graphics = class _Graphics2 extends display.Container {
  /**
   * @param geometry - Geometry to use, if omitted will create a new GraphicsGeometry instance.
   */
  constructor(geometry = null) {
    super(), this.shader = null, this.pluginName = "batch", this.currentPath = null, this.batches = [], this.batchTint = -1, this.batchDirty = -1, this.vertexData = null, this._fillStyle = new FillStyle.FillStyle(), this._lineStyle = new LineStyle.LineStyle(), this._matrix = null, this._holeMode = !1, this.state = core.State.for2d(), this._geometry = geometry || new GraphicsGeometry.GraphicsGeometry(), this._geometry.refCount++, this._transformID = -1, this._tintColor = new core.Color(16777215), this.blendMode = core.BLEND_MODES.NORMAL;
  }
  /**
   * Includes vertex positions, face indices, normals, colors, UVs, and
   * custom attributes within buffers, reducing the cost of passing all
   * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
   * @readonly
   */
  get geometry() {
    return this._geometry;
  }
  /**
   * Creates a new Graphics object with the same values as this one.
   * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)
   * @returns - A clone of the graphics object
   */
  clone() {
    return this.finishPoly(), new _Graphics2(this._geometry);
  }
  /**
   * The blend mode to be applied to the graphic shape. Apply a value of
   * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each
   * primitive in the GraphicsGeometry list is rendered sequentially, modes
   * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will
   * be applied per-primitive.
   * @default PIXI.BLEND_MODES.NORMAL
   */
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  /**
   * The tint applied to each graphic shape. This is a hex value. A value of
   * 0xFFFFFF will remove any tint effect.
   * @default 0xFFFFFF
   */
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
  }
  /**
   * The current fill style.
   * @readonly
   */
  get fill() {
    return this._fillStyle;
  }
  /**
   * The current line style.
   * @readonly
   */
  get line() {
    return this._lineStyle;
  }
  lineStyle(options = null, color = 0, alpha, alignment = 0.5, native = !1) {
    return typeof options == "number" && (options = { width: options, color, alpha, alignment, native }), this.lineTextureStyle(options);
  }
  /**
   * Like line style but support texture for line fill.
   * @param [options] - Collection of options for setting line style.
   * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style
   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use
   * @param {PIXI.ColorSource} [options.color=0x0] - color of the line to draw, will update the objects stored style.
   *  Default 0xFFFFFF if texture present.
   * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style
   * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture
   * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).
   *        WebGL only.
   * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
   * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style
   * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style
   * @param {number}[options.miterLimit=10] - miter limit ratio
   * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls
   */
  lineTextureStyle(options) {
    const defaultLineStyleOptions = {
      width: 0,
      texture: core.Texture.WHITE,
      color: options?.texture ? 16777215 : 0,
      matrix: null,
      alignment: 0.5,
      native: !1,
      cap: _const.LINE_CAP.BUTT,
      join: _const.LINE_JOIN.MITER,
      miterLimit: 10
    };
    options = Object.assign(defaultLineStyleOptions, options), this.normalizeColor(options), this.currentPath && this.startPoly();
    const visible = options.width > 0 && options.alpha > 0;
    return visible ? (options.matrix && (options.matrix = options.matrix.clone(), options.matrix.invert()), Object.assign(this._lineStyle, { visible }, options)) : this._lineStyle.reset(), this;
  }
  /**
   * Start a polygon object internally.
   * @protected
   */
  startPoly() {
    if (this.currentPath) {
      const points = this.currentPath.points, len = this.currentPath.points.length;
      len > 2 && (this.drawShape(this.currentPath), this.currentPath = new core.Polygon(), this.currentPath.closeStroke = !1, this.currentPath.points.push(points[len - 2], points[len - 1]));
    } else
      this.currentPath = new core.Polygon(), this.currentPath.closeStroke = !1;
  }
  /**
   * Finish the polygon object.
   * @protected
   */
  finishPoly() {
    this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);
  }
  /**
   * Moves the current drawing position to x, y.
   * @param x - the X coordinate to move to
   * @param y - the Y coordinate to move to
   * @returns - This Graphics object. Good for chaining method calls
   */
  moveTo(x, y) {
    return this.startPoly(), this.currentPath.points[0] = x, this.currentPath.points[1] = y, this;
  }
  /**
   * Draws a line using the current line style from the current drawing position to (x, y);
   * The current drawing position is then set to (x, y).
   * @param x - the X coordinate to draw to
   * @param y - the Y coordinate to draw to
   * @returns - This Graphics object. Good for chaining method calls
   */
  lineTo(x, y) {
    this.currentPath || this.moveTo(0, 0);
    const points = this.currentPath.points, fromX = points[points.length - 2], fromY = points[points.length - 1];
    return (fromX !== x || fromY !== y) && points.push(x, y), this;
  }
  /**
   * Initialize the curve
   * @param x
   * @param y
   */
  _initCurve(x = 0, y = 0) {
    this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [x, y]) : this.moveTo(x, y);
  }
  /**
   * Calculate the points for a quadratic bezier curve and then draws it.
   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
   * @param cpX - Control point x
   * @param cpY - Control point y
   * @param toX - Destination point x
   * @param toY - Destination point y
   * @returns - This Graphics object. Good for chaining method calls
   */
  quadraticCurveTo(cpX, cpY, toX, toY) {
    this._initCurve();
    const points = this.currentPath.points;
    return points.length === 0 && this.moveTo(0, 0), QuadraticUtils.QuadraticUtils.curveTo(cpX, cpY, toX, toY, points), this;
  }
  /**
   * Calculate the points for a bezier curve and then draws it.
   * @param cpX - Control point x
   * @param cpY - Control point y
   * @param cpX2 - Second Control point x
   * @param cpY2 - Second Control point y
   * @param toX - Destination point x
   * @param toY - Destination point y
   * @returns This Graphics object. Good for chaining method calls
   */
  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
    return this._initCurve(), BezierUtils.BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points), this;
  }
  /**
   * The `arcTo` method creates an arc/curve between two tangents on the canvas.
   * The first tangent is from the start point to the first control point,
   * and the second tangent is from the first control point to the second control point.
   * Note that the second control point is not necessarily the end point of the arc.
   *
   * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
   * @param x1 - The x-coordinate of the first control point of the arc
   * @param y1 - The y-coordinate of the first control point of the arc
   * @param x2 - The x-coordinate of the second control point of the arc
   * @param y2 - The y-coordinate of the second control point of the arc
   * @param radius - The radius of the arc
   * @returns - This Graphics object. Good for chaining method calls
   */
  arcTo(x1, y1, x2, y2, radius) {
    this._initCurve(x1, y1);
    const points = this.currentPath.points, result = ArcUtils.ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
    if (result) {
      const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;
      this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);
    }
    return this;
  }
  /**
   * The arc method creates an arc/curve (used to create circles, or parts of circles).
   * @param cx - The x-coordinate of the center of the circle
   * @param cy - The y-coordinate of the center of the circle
   * @param radius - The radius of the circle
   * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position
   *  of the arc's circle)
   * @param endAngle - The ending angle, in radians
   * @param anticlockwise - Specifies whether the drawing should be
   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
   *  indicates counter-clockwise.
   * @returns - This Graphics object. Good for chaining method calls
   */
  arc(cx, cy, radius, startAngle, endAngle, anticlockwise = !1) {
    if (startAngle === endAngle)
      return this;
    if (!anticlockwise && endAngle <= startAngle ? endAngle += core.PI_2 : anticlockwise && startAngle <= endAngle && (startAngle += core.PI_2), endAngle - startAngle === 0)
      return this;
    const startX = cx + Math.cos(startAngle) * radius, startY = cy + Math.sin(startAngle) * radius, eps = this._geometry.closePointEps;
    let points = this.currentPath ? this.currentPath.points : null;
    if (points) {
      const xDiff = Math.abs(points[points.length - 2] - startX), yDiff = Math.abs(points[points.length - 1] - startY);
      xDiff < eps && yDiff < eps || points.push(startX, startY);
    } else
      this.moveTo(startX, startY), points = this.currentPath.points;
    return ArcUtils.ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points), this;
  }
  /**
   * Specifies a simple one-color fill that subsequent calls to other Graphics methods
   * (such as lineTo() or drawCircle()) use when drawing.
   * @param {PIXI.ColorSource} color - the color of the fill
   * @param alpha - the alpha of the fill, will override the color's alpha
   * @returns - This Graphics object. Suitable for chaining method calls
   */
  beginFill(color = 0, alpha) {
    return this.beginTextureFill({ texture: core.Texture.WHITE, color, alpha });
  }
  /**
   * Normalize the color input from options for line style or fill
   * @param {PIXI.IFillStyleOptions} options - Fill style object.
   */
  normalizeColor(options) {
    const temp = core.Color.shared.setValue(options.color ?? 0);
    options.color = temp.toNumber(), options.alpha ?? (options.alpha = temp.alpha);
  }
  /**
   * Begin the texture fill.
   * Note: The wrap mode of the texture is forced to REPEAT on render.
   * @param options - Fill style object.
   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill
   * @param {PIXI.ColorSource} [options.color=0xffffff] - Background to fill behind texture
   * @param {number} [options.alpha] - Alpha of fill, overrides the color's alpha
   * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix
   * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls
   */
  beginTextureFill(options) {
    const defaultOptions = {
      texture: core.Texture.WHITE,
      color: 16777215,
      matrix: null
    };
    options = Object.assign(defaultOptions, options), this.normalizeColor(options), this.currentPath && this.startPoly();
    const visible = options.alpha > 0;
    return visible ? (options.matrix && (options.matrix = options.matrix.clone(), options.matrix.invert()), Object.assign(this._fillStyle, { visible }, options)) : this._fillStyle.reset(), this;
  }
  /**
   * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
   * @returns - This Graphics object. Good for chaining method calls
   */
  endFill() {
    return this.finishPoly(), this._fillStyle.reset(), this;
  }
  /**
   * Draws a rectangle shape.
   * @param x - The X coord of the top-left of the rectangle
   * @param y - The Y coord of the top-left of the rectangle
   * @param width - The width of the rectangle
   * @param height - The height of the rectangle
   * @returns - This Graphics object. Good for chaining method calls
   */
  drawRect(x, y, width, height) {
    return this.drawShape(new core.Rectangle(x, y, width, height));
  }
  /**
   * Draw a rectangle shape with rounded/beveled corners.
   * @param x - The X coord of the top-left of the rectangle
   * @param y - The Y coord of the top-left of the rectangle
   * @param width - The width of the rectangle
   * @param height - The height of the rectangle
   * @param radius - Radius of the rectangle corners
   * @returns - This Graphics object. Good for chaining method calls
   */
  drawRoundedRect(x, y, width, height, radius) {
    return this.drawShape(new core.RoundedRectangle(x, y, width, height, radius));
  }
  /**
   * Draws a circle.
   * @param x - The X coordinate of the center of the circle
   * @param y - The Y coordinate of the center of the circle
   * @param radius - The radius of the circle
   * @returns - This Graphics object. Good for chaining method calls
   */
  drawCircle(x, y, radius) {
    return this.drawShape(new core.Circle(x, y, radius));
  }
  /**
   * Draws an ellipse.
   * @param x - The X coordinate of the center of the ellipse
   * @param y - The Y coordinate of the center of the ellipse
   * @param width - The half width of the ellipse
   * @param height - The half height of the ellipse
   * @returns - This Graphics object. Good for chaining method calls
   */
  drawEllipse(x, y, width, height) {
    return this.drawShape(new core.Ellipse(x, y, width, height));
  }
  /**
   * Draws a polygon using the given path.
   * @param {number[]|PIXI.IPointData[]|PIXI.Polygon} path - The path data used to construct the polygon.
   * @returns - This Graphics object. Good for chaining method calls
   */
  drawPolygon(...path) {
    let points, closeStroke = !0;
    const poly = path[0];
    poly.points ? (closeStroke = poly.closeStroke, points = poly.points) : Array.isArray(path[0]) ? points = path[0] : points = path;
    const shape = new core.Polygon(points);
    return shape.closeStroke = closeStroke, this.drawShape(shape), this;
  }
  /**
   * Draw any shape.
   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw
   * @returns - This Graphics object. Good for chaining method calls
   */
  drawShape(shape) {
    return this._holeMode ? this._geometry.drawHole(shape, this._matrix) : this._geometry.drawShape(
      shape,
      this._fillStyle.clone(),
      this._lineStyle.clone(),
      this._matrix
    ), this;
  }
  /**
   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
   * @returns - This Graphics object. Good for chaining method calls
   */
  clear() {
    return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;
  }
  /**
   * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and
   * masked with gl.scissor.
   * @returns - True if only 1 rect.
   */
  isFastRect() {
    const data = this._geometry.graphicsData;
    return data.length === 1 && data[0].shape.type === core.SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
  }
  /**
   * Renders the object using the WebGL renderer
   * @param renderer - The renderer
   */
  _render(renderer) {
    this.finishPoly();
    const geometry = this._geometry;
    geometry.updateBatches(), geometry.batchable ? (this.batchDirty !== geometry.batchDirty && this._populateBatches(), this._renderBatched(renderer)) : (renderer.batch.flush(), this._renderDirect(renderer));
  }
  /** Populating batches for rendering. */
  _populateBatches() {
    const geometry = this._geometry, blendMode = this.blendMode, len = geometry.batches.length;
    this.batchTint = -1, this._transformID = -1, this.batchDirty = geometry.batchDirty, this.batches.length = len, this.vertexData = new Float32Array(geometry.points);
    for (let i = 0; i < len; i++) {
      const gI = geometry.batches[i], color = gI.style.color, vertexData = new Float32Array(
        this.vertexData.buffer,
        gI.attribStart * 4 * 2,
        gI.attribSize * 2
      ), uvs = new Float32Array(
        geometry.uvsFloat32.buffer,
        gI.attribStart * 4 * 2,
        gI.attribSize * 2
      ), indices = new Uint16Array(
        geometry.indicesUint16.buffer,
        gI.start * 2,
        gI.size
      ), batch = {
        vertexData,
        blendMode,
        indices,
        uvs,
        _batchRGB: core.Color.shared.setValue(color).toRgbArray(),
        _tintRGB: color,
        _texture: gI.style.texture,
        alpha: gI.style.alpha,
        worldAlpha: 1
      };
      this.batches[i] = batch;
    }
  }
  /**
   * Renders the batches using the BathedRenderer plugin
   * @param renderer - The renderer
   */
  _renderBatched(renderer) {
    if (this.batches.length) {
      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
      for (let i = 0, l = this.batches.length; i < l; i++) {
        const batch = this.batches[i];
        batch.worldAlpha = this.worldAlpha * batch.alpha, renderer.plugins[this.pluginName].render(batch);
      }
    }
  }
  /**
   * Renders the graphics direct
   * @param renderer - The renderer
   */
  _renderDirect(renderer) {
    const shader = this._resolveDirectShader(renderer), geometry = this._geometry, worldAlpha = this.worldAlpha, uniforms = shader.uniforms, drawCalls = geometry.drawCalls;
    uniforms.translationMatrix = this.transform.worldTransform, core.Color.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint), renderer.shader.bind(shader), renderer.geometry.bind(geometry, shader), renderer.state.set(this.state);
    for (let i = 0, l = drawCalls.length; i < l; i++)
      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);
  }
  /**
   * Renders specific DrawCall
   * @param renderer
   * @param drawCall
   */
  _renderDrawCallDirect(renderer, drawCall) {
    const { texArray, type, size, start } = drawCall, groupTextureCount = texArray.count;
    for (let j = 0; j < groupTextureCount; j++)
      renderer.texture.bind(texArray.elements[j], j);
    renderer.geometry.draw(type, size, start);
  }
  /**
   * Resolves shader for direct rendering
   * @param renderer - The renderer
   */
  _resolveDirectShader(renderer) {
    let shader = this.shader;
    const pluginName = this.pluginName;
    if (!shader) {
      if (!DEFAULT_SHADERS[pluginName]) {
        const { maxTextures } = renderer.plugins[pluginName], sampleValues = new Int32Array(maxTextures);
        for (let i = 0; i < maxTextures; i++)
          sampleValues[i] = i;
        const uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new core.Matrix(),
          default: core.UniformGroup.from({ uSamplers: sampleValues }, !0)
        }, program = renderer.plugins[pluginName]._shader.program;
        DEFAULT_SHADERS[pluginName] = new core.Shader(program, uniforms);
      }
      shader = DEFAULT_SHADERS[pluginName];
    }
    return shader;
  }
  /**
   * Retrieves the bounds of the graphic shape as a rectangle object.
   * @see PIXI.GraphicsGeometry#bounds
   */
  _calculateBounds() {
    this.finishPoly();
    const geometry = this._geometry;
    if (!geometry.graphicsData.length)
      return;
    const { minX, minY, maxX, maxY } = geometry.bounds;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  /**
   * Tests if a point is inside this graphics object
   * @param point - the point to test
   * @returns - the result of the test
   */
  containsPoint(point) {
    return this.worldTransform.applyInverse(point, _Graphics2._TEMP_POINT), this._geometry.containsPoint(_Graphics2._TEMP_POINT);
  }
  /** Recalculate the tint by applying tint to batches using Graphics tint. */
  calculateTints() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this._tintColor.toNumber();
      for (let i = 0; i < this.batches.length; i++) {
        const batch = this.batches[i];
        batch._tintRGB = core.Color.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();
      }
    }
  }
  /** If there's a transform update or a change to the shape of the geometry, recalculate the vertices. */
  calculateVertices() {
    const wtID = this.transform._worldID;
    if (this._transformID === wtID)
      return;
    this._transformID = wtID;
    const wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty, data = this._geometry.points, vertexData = this.vertexData;
    let count = 0;
    for (let i = 0; i < data.length; i += 2) {
      const x = data[i], y = data[i + 1];
      vertexData[count++] = a * x + c * y + tx, vertexData[count++] = d * y + b * x + ty;
    }
  }
  /**
   * Closes the current path.
   * @returns - Returns itself.
   */
  closePath() {
    const currentPath = this.currentPath;
    return currentPath && (currentPath.closeStroke = !0, this.finishPoly()), this;
  }
  /**
   * Apply a matrix to the positional data.
   * @param matrix - Matrix to use for transform current shape.
   * @returns - Returns itself.
   */
  setMatrix(matrix) {
    return this._matrix = matrix, this;
  }
  /**
   * Begin adding holes to the last draw shape
   * IMPORTANT: holes must be fully inside a shape to work
   * Also weirdness ensues if holes overlap!
   * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,
   * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.
   * @returns - Returns itself.
   */
  beginHole() {
    return this.finishPoly(), this._holeMode = !0, this;
  }
  /**
   * End adding holes to the last draw shape.
   * @returns - Returns itself.
   */
  endHole() {
    return this.finishPoly(), this._holeMode = !1, this;
  }
  /**
   * Destroys the Graphics object.
   * @param options - Options parameter. A boolean will act as if all
   *  options have been set to that value
   * @param {boolean} [options.children=false] - if set to true, all the children will have
   *  their destroy method called as well. 'options' will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
   *  Should it destroy the texture of the child sprite
   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
   *  Should it destroy the base texture of the child sprite
   */
  destroy(options) {
    this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, super.destroy(options);
  }
};
_Graphics.curves = _const.curves, /**
* Temporary point to use for containsPoint.
* @private
*/
_Graphics._TEMP_POINT = new core.Point();
let Graphics = _Graphics;
exports.Graphics = Graphics;
//# sourceMappingURL=Graphics.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/GraphicsData.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/GraphicsData.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class GraphicsData {
  /**
   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
   * @param fillStyle - the width of the line to draw
   * @param lineStyle - the color of the line to draw
   * @param matrix - Transform matrix
   */
  constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
    this.points = [], this.holes = [], this.shape = shape, this.lineStyle = lineStyle, this.fillStyle = fillStyle, this.matrix = matrix, this.type = shape.type;
  }
  /**
   * Creates a new GraphicsData object with the same values as this one.
   * @returns - Cloned GraphicsData object
   */
  clone() {
    return new GraphicsData(
      this.shape,
      this.fillStyle,
      this.lineStyle,
      this.matrix
    );
  }
  /** Destroys the Graphics data. */
  destroy() {
    this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;
  }
}
exports.GraphicsData = GraphicsData;
//# sourceMappingURL=GraphicsData.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/GraphicsGeometry.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/GraphicsGeometry.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), display = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.js"), GraphicsData = __webpack_require__(/*! ./GraphicsData.js */ "./node_modules/@pixi/graphics/lib/GraphicsData.js"), index = __webpack_require__(/*! ./utils/index.js */ "./node_modules/@pixi/graphics/lib/utils/index.js"), BatchPart = __webpack_require__(/*! ./utils/BatchPart.js */ "./node_modules/@pixi/graphics/lib/utils/BatchPart.js"), buildPoly = __webpack_require__(/*! ./utils/buildPoly.js */ "./node_modules/@pixi/graphics/lib/utils/buildPoly.js"), buildLine = __webpack_require__(/*! ./utils/buildLine.js */ "./node_modules/@pixi/graphics/lib/utils/buildLine.js");
const tmpPoint = new core.Point(), _GraphicsGeometry = class _GraphicsGeometry2 extends core.BatchGeometry {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor() {
    super(), this.closePointEps = 1e-4, this.boundsPadding = 0, this.uvsFloat32 = null, this.indicesUint16 = null, this.batchable = !1, this.points = [], this.colors = [], this.uvs = [], this.indices = [], this.textureIds = [], this.graphicsData = [], this.drawCalls = [], this.batchDirty = -1, this.batches = [], this.dirty = 0, this.cacheDirty = -1, this.clearDirty = 0, this.shapeIndex = 0, this._bounds = new display.Bounds(), this.boundsDirty = -1;
  }
  /**
   * Get the current bounds of the graphic geometry.
   *
   * Since 6.5.0, bounds of the graphics geometry are calculated based on the vertices of generated geometry.
   * Since shapes or strokes with full transparency (`alpha: 0`) will not generate geometry, they are not considered
   * when calculating bounds for the graphics geometry. See PR [#8343]{@link https://github.com/pixijs/pixijs/pull/8343}
   * and issue [#8623]{@link https://github.com/pixijs/pixijs/pull/8623}.
   * @readonly
   */
  get bounds() {
    return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;
  }
  /** Call if you changed graphicsData manually. Empties all batch buffers. */
  invalidate() {
    this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
    for (let i = 0; i < this.drawCalls.length; i++)
      this.drawCalls[i].texArray.clear(), index.DRAW_CALL_POOL.push(this.drawCalls[i]);
    this.drawCalls.length = 0;
    for (let i = 0; i < this.batches.length; i++) {
      const batchPart = this.batches[i];
      batchPart.reset(), index.BATCH_POOL.push(batchPart);
    }
    this.batches.length = 0;
  }
  /**
   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
   * @returns - This GraphicsGeometry object. Good for chaining method calls
   */
  clear() {
    return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;
  }
  /**
   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
   * @param fillStyle - Defines style of the fill.
   * @param lineStyle - Defines style of the lines.
   * @param matrix - Transform applied to the points of the shape.
   * @returns - Returns geometry for chaining.
   */
  drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
    const data = new GraphicsData.GraphicsData(shape, fillStyle, lineStyle, matrix);
    return this.graphicsData.push(data), this.dirty++, this;
  }
  /**
   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
   * @param matrix - Transform applied to the points of the shape.
   * @returns - Returns geometry for chaining.
   */
  drawHole(shape, matrix = null) {
    if (!this.graphicsData.length)
      return null;
    const data = new GraphicsData.GraphicsData(shape, null, null, matrix), lastShape = this.graphicsData[this.graphicsData.length - 1];
    return data.lineStyle = lastShape.lineStyle, lastShape.holes.push(data), this.dirty++, this;
  }
  /** Destroys the GraphicsGeometry object. */
  destroy() {
    super.destroy();
    for (let i = 0; i < this.graphicsData.length; ++i)
      this.graphicsData[i].destroy();
    this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;
  }
  /**
   * Check to see if a point is contained within this geometry.
   * @param point - Point to check if it's contained.
   * @returns {boolean} `true` if the point is contained within geometry.
   */
  containsPoint(point) {
    const graphicsData = this.graphicsData;
    for (let i = 0; i < graphicsData.length; ++i) {
      const data = graphicsData[i];
      if (data.fillStyle.visible && data.shape && (data.matrix ? data.matrix.applyInverse(point, tmpPoint) : tmpPoint.copyFrom(point), data.shape.contains(tmpPoint.x, tmpPoint.y))) {
        let hitHole = !1;
        if (data.holes) {
          for (let i2 = 0; i2 < data.holes.length; i2++)
            if (data.holes[i2].shape.contains(tmpPoint.x, tmpPoint.y)) {
              hitHole = !0;
              break;
            }
        }
        if (!hitHole)
          return !0;
      }
    }
    return !1;
  }
  /**
   * Generates intermediate batch data. Either gets converted to drawCalls
   * or used to convert to batch objects directly by the Graphics object.
   */
  updateBatches() {
    if (!this.graphicsData.length) {
      this.batchable = !0;
      return;
    }
    if (!this.validateBatching())
      return;
    this.cacheDirty = this.dirty;
    const uvs = this.uvs, graphicsData = this.graphicsData;
    let batchPart = null, currentStyle = null;
    this.batches.length > 0 && (batchPart = this.batches[this.batches.length - 1], currentStyle = batchPart.style);
    for (let i = this.shapeIndex; i < graphicsData.length; i++) {
      this.shapeIndex++;
      const data = graphicsData[i], fillStyle = data.fillStyle, lineStyle = data.lineStyle;
      index.FILL_COMMANDS[data.type].build(data), data.matrix && this.transformPoints(data.points, data.matrix), (fillStyle.visible || lineStyle.visible) && this.processHoles(data.holes);
      for (let j = 0; j < 2; j++) {
        const style = j === 0 ? fillStyle : lineStyle;
        if (!style.visible)
          continue;
        const nextTexture = style.texture.baseTexture, index2 = this.indices.length, attribIndex = this.points.length / 2;
        nextTexture.wrapMode = core.WRAP_MODES.REPEAT, j === 0 ? this.processFill(data) : this.processLine(data);
        const size = this.points.length / 2 - attribIndex;
        size !== 0 && (batchPart && !this._compareStyles(currentStyle, style) && (batchPart.end(index2, attribIndex), batchPart = null), batchPart || (batchPart = index.BATCH_POOL.pop() || new BatchPart.BatchPart(), batchPart.begin(style, index2, attribIndex), this.batches.push(batchPart), currentStyle = style), this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix));
      }
    }
    const index$1 = this.indices.length, attrib = this.points.length / 2;
    if (batchPart && batchPart.end(index$1, attrib), this.batches.length === 0) {
      this.batchable = !0;
      return;
    }
    const need32 = attrib > 65535;
    this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();
  }
  /**
   * Affinity check
   * @param styleA
   * @param styleB
   */
  _compareStyles(styleA, styleB) {
    return !(!styleA || !styleB || styleA.texture.baseTexture !== styleB.texture.baseTexture || styleA.color + styleA.alpha !== styleB.color + styleB.alpha || !!styleA.native != !!styleB.native);
  }
  /** Test geometry for batching process. */
  validateBatching() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length)
      return !1;
    for (let i = 0, l = this.graphicsData.length; i < l; i++) {
      const data = this.graphicsData[i], fill = data.fillStyle, line = data.lineStyle;
      if (fill && !fill.texture.baseTexture.valid || line && !line.texture.baseTexture.valid)
        return !1;
    }
    return !0;
  }
  /** Offset the indices so that it works with the batcher. */
  packBatches() {
    this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
    const batches = this.batches;
    for (let i = 0, l = batches.length; i < l; i++) {
      const batch = batches[i];
      for (let j = 0; j < batch.size; j++) {
        const index2 = batch.start + j;
        this.indicesUint16[index2] = this.indicesUint16[index2] - batch.attribStart;
      }
    }
  }
  /**
   * Checks to see if this graphics geometry can be batched.
   * Currently it needs to be small enough and not contain any native lines.
   */
  isBatchable() {
    if (this.points.length > 65535 * 2)
      return !1;
    const batches = this.batches;
    for (let i = 0; i < batches.length; i++)
      if (batches[i].style.native)
        return !1;
    return this.points.length < _GraphicsGeometry2.BATCHABLE_SIZE * 2;
  }
  /** Converts intermediate batches data to drawCalls. */
  buildDrawCalls() {
    let TICK = ++core.BaseTexture._globalBatch;
    for (let i = 0; i < this.drawCalls.length; i++)
      this.drawCalls[i].texArray.clear(), index.DRAW_CALL_POOL.push(this.drawCalls[i]);
    this.drawCalls.length = 0;
    const colors = this.colors, textureIds = this.textureIds;
    let currentGroup = index.DRAW_CALL_POOL.pop();
    currentGroup || (currentGroup = new core.BatchDrawCall(), currentGroup.texArray = new core.BatchTextureArray()), currentGroup.texArray.count = 0, currentGroup.start = 0, currentGroup.size = 0, currentGroup.type = core.DRAW_MODES.TRIANGLES;
    let textureCount = 0, currentTexture = null, textureId = 0, native = !1, drawMode = core.DRAW_MODES.TRIANGLES, index$1 = 0;
    this.drawCalls.push(currentGroup);
    for (let i = 0; i < this.batches.length; i++) {
      const data = this.batches[i], maxTextures = 8, style = data.style, nextTexture = style.texture.baseTexture;
      native !== !!style.native && (native = !!style.native, drawMode = native ? core.DRAW_MODES.LINES : core.DRAW_MODES.TRIANGLES, currentTexture = null, textureCount = maxTextures, TICK++), currentTexture !== nextTexture && (currentTexture = nextTexture, nextTexture._batchEnabled !== TICK && (textureCount === maxTextures && (TICK++, textureCount = 0, currentGroup.size > 0 && (currentGroup = index.DRAW_CALL_POOL.pop(), currentGroup || (currentGroup = new core.BatchDrawCall(), currentGroup.texArray = new core.BatchTextureArray()), this.drawCalls.push(currentGroup)), currentGroup.start = index$1, currentGroup.size = 0, currentGroup.texArray.count = 0, currentGroup.type = drawMode), nextTexture.touched = 1, nextTexture._batchEnabled = TICK, nextTexture._batchLocation = textureCount, nextTexture.wrapMode = core.WRAP_MODES.REPEAT, currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture, textureCount++)), currentGroup.size += data.size, index$1 += data.size, textureId = nextTexture._batchLocation, this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart), this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
    }
    core.BaseTexture._globalBatch = TICK, this.packAttributes();
  }
  /** Packs attributes to single buffer. */
  packAttributes() {
    const verts = this.points, uvs = this.uvs, colors = this.colors, textureIds = this.textureIds, glPoints = new ArrayBuffer(verts.length * 3 * 4), f32 = new Float32Array(glPoints), u32 = new Uint32Array(glPoints);
    let p = 0;
    for (let i = 0; i < verts.length / 2; i++)
      f32[p++] = verts[i * 2], f32[p++] = verts[i * 2 + 1], f32[p++] = uvs[i * 2], f32[p++] = uvs[i * 2 + 1], u32[p++] = colors[i], f32[p++] = textureIds[i];
    this._buffer.update(glPoints), this._indexBuffer.update(this.indicesUint16);
  }
  /**
   * Process fill part of Graphics.
   * @param data
   */
  processFill(data) {
    data.holes.length ? buildPoly.buildPoly.triangulate(data, this) : index.FILL_COMMANDS[data.type].triangulate(data, this);
  }
  /**
   * Process line part of Graphics.
   * @param data
   */
  processLine(data) {
    buildLine.buildLine(data, this);
    for (let i = 0; i < data.holes.length; i++)
      buildLine.buildLine(data.holes[i], this);
  }
  /**
   * Process the holes data.
   * @param holes
   */
  processHoles(holes) {
    for (let i = 0; i < holes.length; i++) {
      const hole = holes[i];
      index.FILL_COMMANDS[hole.type].build(hole), hole.matrix && this.transformPoints(hole.points, hole.matrix);
    }
  }
  /** Update the local bounds of the object. Expensive to use performance-wise. */
  calculateBounds() {
    const bounds = this._bounds;
    bounds.clear(), bounds.addVertexData(this.points, 0, this.points.length), bounds.pad(this.boundsPadding, this.boundsPadding);
  }
  /**
   * Transform points using matrix.
   * @param points - Points to transform
   * @param matrix - Transform matrix
   */
  transformPoints(points, matrix) {
    for (let i = 0; i < points.length / 2; i++) {
      const x = points[i * 2], y = points[i * 2 + 1];
      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx, points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;
    }
  }
  /**
   * Add colors.
   * @param colors - List of colors to add to
   * @param color - Color to add
   * @param alpha - Alpha to use
   * @param size - Number of colors to add
   * @param offset
   */
  addColors(colors, color, alpha, size, offset = 0) {
    const bgr = core.Color.shared.setValue(color).toLittleEndianNumber(), result = core.Color.shared.setValue(bgr).toPremultiplied(alpha);
    colors.length = Math.max(colors.length, offset + size);
    for (let i = 0; i < size; i++)
      colors[offset + i] = result;
  }
  /**
   * Add texture id that the shader/fragment wants to use.
   * @param textureIds
   * @param id
   * @param size
   * @param offset
   */
  addTextureIds(textureIds, id, size, offset = 0) {
    textureIds.length = Math.max(textureIds.length, offset + size);
    for (let i = 0; i < size; i++)
      textureIds[offset + i] = id;
  }
  /**
   * Generates the UVs for a shape.
   * @param verts - Vertices
   * @param uvs - UVs
   * @param texture - Reference to Texture
   * @param start - Index buffer start index.
   * @param size - The size/length for index buffer.
   * @param matrix - Optional transform for all points.
   */
  addUvs(verts, uvs, texture, start, size, matrix = null) {
    let index2 = 0;
    const uvsStart = uvs.length, frame = texture.frame;
    for (; index2 < size; ) {
      let x = verts[(start + index2) * 2], y = verts[(start + index2) * 2 + 1];
      if (matrix) {
        const nx = matrix.a * x + matrix.c * y + matrix.tx;
        y = matrix.b * x + matrix.d * y + matrix.ty, x = nx;
      }
      index2++, uvs.push(x / frame.width, y / frame.height);
    }
    const baseTexture = texture.baseTexture;
    (frame.width < baseTexture.width || frame.height < baseTexture.height) && this.adjustUvs(uvs, texture, uvsStart, size);
  }
  /**
   * Modify uvs array according to position of texture region
   * Does not work with rotated or trimmed textures
   * @param uvs - array
   * @param texture - region
   * @param start - starting index for uvs
   * @param size - how many points to adjust
   */
  adjustUvs(uvs, texture, start, size) {
    const baseTexture = texture.baseTexture, eps = 1e-6, finish = start + size * 2, frame = texture.frame, scaleX = frame.width / baseTexture.width, scaleY = frame.height / baseTexture.height;
    let offsetX = frame.x / frame.width, offsetY = frame.y / frame.height, minX = Math.floor(uvs[start] + eps), minY = Math.floor(uvs[start + 1] + eps);
    for (let i = start + 2; i < finish; i += 2)
      minX = Math.min(minX, Math.floor(uvs[i] + eps)), minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
    offsetX -= minX, offsetY -= minY;
    for (let i = start; i < finish; i += 2)
      uvs[i] = (uvs[i] + offsetX) * scaleX, uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;
  }
};
_GraphicsGeometry.BATCHABLE_SIZE = 100;
let GraphicsGeometry = _GraphicsGeometry;
exports.GraphicsGeometry = GraphicsGeometry;
//# sourceMappingURL=GraphicsGeometry.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/const.js":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/const.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var LINE_JOIN = /* @__PURE__ */ ((LINE_JOIN2) => (LINE_JOIN2.MITER = "miter", LINE_JOIN2.BEVEL = "bevel", LINE_JOIN2.ROUND = "round", LINE_JOIN2))(LINE_JOIN || {}), LINE_CAP = /* @__PURE__ */ ((LINE_CAP2) => (LINE_CAP2.BUTT = "butt", LINE_CAP2.ROUND = "round", LINE_CAP2.SQUARE = "square", LINE_CAP2))(LINE_CAP || {});
const curves = {
  adaptive: !0,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount(length, defaultSegments = 20) {
    if (!this.adaptive || !length || isNaN(length))
      return defaultSegments;
    let result = Math.ceil(length / this.maxLength);
    return result < this.minSegments ? result = this.minSegments : result > this.maxSegments && (result = this.maxSegments), result;
  }
}, GRAPHICS_CURVES = curves;
exports.GRAPHICS_CURVES = GRAPHICS_CURVES;
exports.LINE_CAP = LINE_CAP;
exports.LINE_JOIN = LINE_JOIN;
exports.curves = curves;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var index = __webpack_require__(/*! ./utils/index.js */ "./node_modules/@pixi/graphics/lib/utils/index.js"), _const = __webpack_require__(/*! ./const.js */ "./node_modules/@pixi/graphics/lib/const.js"), Graphics = __webpack_require__(/*! ./Graphics.js */ "./node_modules/@pixi/graphics/lib/Graphics.js"), GraphicsData = __webpack_require__(/*! ./GraphicsData.js */ "./node_modules/@pixi/graphics/lib/GraphicsData.js"), GraphicsGeometry = __webpack_require__(/*! ./GraphicsGeometry.js */ "./node_modules/@pixi/graphics/lib/GraphicsGeometry.js"), FillStyle = __webpack_require__(/*! ./styles/FillStyle.js */ "./node_modules/@pixi/graphics/lib/styles/FillStyle.js"), LineStyle = __webpack_require__(/*! ./styles/LineStyle.js */ "./node_modules/@pixi/graphics/lib/styles/LineStyle.js"), buildPoly = __webpack_require__(/*! ./utils/buildPoly.js */ "./node_modules/@pixi/graphics/lib/utils/buildPoly.js"), buildCircle = __webpack_require__(/*! ./utils/buildCircle.js */ "./node_modules/@pixi/graphics/lib/utils/buildCircle.js"), buildRectangle = __webpack_require__(/*! ./utils/buildRectangle.js */ "./node_modules/@pixi/graphics/lib/utils/buildRectangle.js"), buildRoundedRectangle = __webpack_require__(/*! ./utils/buildRoundedRectangle.js */ "./node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.js"), buildLine = __webpack_require__(/*! ./utils/buildLine.js */ "./node_modules/@pixi/graphics/lib/utils/buildLine.js"), ArcUtils = __webpack_require__(/*! ./utils/ArcUtils.js */ "./node_modules/@pixi/graphics/lib/utils/ArcUtils.js"), BezierUtils = __webpack_require__(/*! ./utils/BezierUtils.js */ "./node_modules/@pixi/graphics/lib/utils/BezierUtils.js"), QuadraticUtils = __webpack_require__(/*! ./utils/QuadraticUtils.js */ "./node_modules/@pixi/graphics/lib/utils/QuadraticUtils.js"), BatchPart = __webpack_require__(/*! ./utils/BatchPart.js */ "./node_modules/@pixi/graphics/lib/utils/BatchPart.js");
const graphicsUtils = {
  buildPoly: buildPoly.buildPoly,
  buildCircle: buildCircle.buildCircle,
  buildRectangle: buildRectangle.buildRectangle,
  buildRoundedRectangle: buildRoundedRectangle.buildRoundedRectangle,
  buildLine: buildLine.buildLine,
  ArcUtils: ArcUtils.ArcUtils,
  BezierUtils: BezierUtils.BezierUtils,
  QuadraticUtils: QuadraticUtils.QuadraticUtils,
  BatchPart: BatchPart.BatchPart,
  FILL_COMMANDS: index.FILL_COMMANDS,
  BATCH_POOL: index.BATCH_POOL,
  DRAW_CALL_POOL: index.DRAW_CALL_POOL
};
exports.GRAPHICS_CURVES = _const.GRAPHICS_CURVES;
exports.LINE_CAP = _const.LINE_CAP;
exports.LINE_JOIN = _const.LINE_JOIN;
exports.curves = _const.curves;
exports.Graphics = Graphics.Graphics;
exports.GraphicsData = GraphicsData.GraphicsData;
exports.GraphicsGeometry = GraphicsGeometry.GraphicsGeometry;
exports.FillStyle = FillStyle.FillStyle;
exports.LineStyle = LineStyle.LineStyle;
exports.graphicsUtils = graphicsUtils;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/styles/FillStyle.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/styles/FillStyle.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
class FillStyle {
  constructor() {
    this.color = 16777215, this.alpha = 1, this.texture = core.Texture.WHITE, this.matrix = null, this.visible = !1, this.reset();
  }
  /** Clones the object */
  clone() {
    const obj = new FillStyle();
    return obj.color = this.color, obj.alpha = this.alpha, obj.texture = this.texture, obj.matrix = this.matrix, obj.visible = this.visible, obj;
  }
  /** Reset */
  reset() {
    this.color = 16777215, this.alpha = 1, this.texture = core.Texture.WHITE, this.matrix = null, this.visible = !1;
  }
  /** Destroy and don't use after this. */
  destroy() {
    this.texture = null, this.matrix = null;
  }
}
exports.FillStyle = FillStyle;
//# sourceMappingURL=FillStyle.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/styles/LineStyle.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/styles/LineStyle.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/@pixi/graphics/lib/const.js"), FillStyle = __webpack_require__(/*! ./FillStyle.js */ "./node_modules/@pixi/graphics/lib/styles/FillStyle.js");
class LineStyle extends FillStyle.FillStyle {
  constructor() {
    super(...arguments), this.width = 0, this.alignment = 0.5, this.native = !1, this.cap = _const.LINE_CAP.BUTT, this.join = _const.LINE_JOIN.MITER, this.miterLimit = 10;
  }
  /** Clones the object. */
  clone() {
    const obj = new LineStyle();
    return obj.color = this.color, obj.alpha = this.alpha, obj.texture = this.texture, obj.matrix = this.matrix, obj.visible = this.visible, obj.width = this.width, obj.alignment = this.alignment, obj.native = this.native, obj.cap = this.cap, obj.join = this.join, obj.miterLimit = this.miterLimit, obj;
  }
  /** Reset the line style to default. */
  reset() {
    super.reset(), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1, this.cap = _const.LINE_CAP.BUTT, this.join = _const.LINE_JOIN.MITER, this.miterLimit = 10;
  }
}
exports.LineStyle = LineStyle;
//# sourceMappingURL=LineStyle.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/ArcUtils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/ArcUtils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), _const = __webpack_require__(/*! ../const.js */ "./node_modules/@pixi/graphics/lib/const.js");
class ArcUtils {
  /**
   * Calculate information of the arc for {@link PIXI.Graphics.arcTo}.
   * @private
   * @param x1 - The x-coordinate of the first control point of the arc
   * @param y1 - The y-coordinate of the first control point of the arc
   * @param x2 - The x-coordinate of the second control point of the arc
   * @param y2 - The y-coordinate of the second control point of the arc
   * @param radius - The radius of the arc
   * @param points - Collection of points to add to
   * @returns - If the arc length is valid, return center of circle, radius and other info otherwise `null`.
   */
  static curveTo(x1, y1, x2, y2, radius, points) {
    const fromX = points[points.length - 2], a1 = points[points.length - 1] - y1, b1 = fromX - x1, a2 = y2 - y1, b2 = x2 - x1, mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0)
      return (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) && points.push(x1, y1), null;
    const dd = a1 * a1 + b1 * b1, cc = a2 * a2 + b2 * b2, tt = a1 * a2 + b1 * b2, k1 = radius * Math.sqrt(dd) / mm, k2 = radius * Math.sqrt(cc) / mm, j1 = k1 * tt / dd, j2 = k2 * tt / cc, cx = k1 * b2 + k2 * b1, cy = k1 * a2 + k2 * a1, px = b1 * (k2 + j1), py = a1 * (k2 + j1), qx = b2 * (k1 + j2), qy = a2 * (k1 + j2), startAngle = Math.atan2(py - cy, px - cx), endAngle = Math.atan2(qy - cy, qx - cx);
    return {
      cx: cx + x1,
      cy: cy + y1,
      radius,
      startAngle,
      endAngle,
      anticlockwise: b1 * a2 > b2 * a1
    };
  }
  /**
   * The arc method creates an arc/curve (used to create circles, or parts of circles).
   * @private
   * @param _startX - Start x location of arc
   * @param _startY - Start y location of arc
   * @param cx - The x-coordinate of the center of the circle
   * @param cy - The y-coordinate of the center of the circle
   * @param radius - The radius of the circle
   * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position
   *  of the arc's circle)
   * @param endAngle - The ending angle, in radians
   * @param _anticlockwise - Specifies whether the drawing should be
   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
   *  indicates counter-clockwise.
   * @param points - Collection of points to add to
   */
  static arc(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
    const sweep = endAngle - startAngle, n = _const.curves._segmentsCount(
      Math.abs(sweep) * radius,
      Math.ceil(Math.abs(sweep) / core.PI_2) * 40
    ), theta = sweep / (n * 2), theta2 = theta * 2, cTheta = Math.cos(theta), sTheta = Math.sin(theta), segMinus = n - 1, remainder = segMinus % 1 / segMinus;
    for (let i = 0; i <= segMinus; ++i) {
      const real = i + remainder * i, angle = theta + startAngle + theta2 * real, c = Math.cos(angle), s = -Math.sin(angle);
      points.push(
        (cTheta * c + sTheta * s) * radius + cx,
        (cTheta * -s + sTheta * c) * radius + cy
      );
    }
  }
}
exports.ArcUtils = ArcUtils;
//# sourceMappingURL=ArcUtils.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/BatchPart.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/BatchPart.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class BatchPart {
  constructor() {
    this.reset();
  }
  /**
   * Begin batch part.
   * @param style
   * @param startIndex
   * @param attribStart
   */
  begin(style, startIndex, attribStart) {
    this.reset(), this.style = style, this.start = startIndex, this.attribStart = attribStart;
  }
  /**
   * End batch part.
   * @param endIndex
   * @param endAttrib
   */
  end(endIndex, endAttrib) {
    this.attribSize = endAttrib - this.attribStart, this.size = endIndex - this.start;
  }
  reset() {
    this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;
  }
}
exports.BatchPart = BatchPart;
//# sourceMappingURL=BatchPart.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/BezierUtils.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/BezierUtils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/@pixi/graphics/lib/const.js");
class BezierUtils {
  /**
   * Calculate length of bezier curve.
   * Analytical solution is impossible, since it involves an integral that does not integrate in general.
   * Therefore numerical solution is used.
   * @private
   * @param fromX - Starting point x
   * @param fromY - Starting point y
   * @param cpX - Control point x
   * @param cpY - Control point y
   * @param cpX2 - Second Control point x
   * @param cpY2 - Second Control point y
   * @param toX - Destination point x
   * @param toY - Destination point y
   * @returns - Length of bezier curve
   */
  static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    let result = 0, t = 0, t2 = 0, t3 = 0, nt = 0, nt2 = 0, nt3 = 0, x = 0, y = 0, dx = 0, dy = 0, prevX = fromX, prevY = fromY;
    for (let i = 1; i <= 10; ++i)
      t = i / 10, t2 = t * t, t3 = t2 * t, nt = 1 - t, nt2 = nt * nt, nt3 = nt2 * nt, x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX, y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY, dx = prevX - x, dy = prevY - y, prevX = x, prevY = y, result += Math.sqrt(dx * dx + dy * dy);
    return result;
  }
  /**
   * Calculate the points for a bezier curve and then draws it.
   *
   * Ignored from docs since it is not directly exposed.
   * @ignore
   * @param cpX - Control point x
   * @param cpY - Control point y
   * @param cpX2 - Second Control point x
   * @param cpY2 - Second Control point y
   * @param toX - Destination point x
   * @param toY - Destination point y
   * @param points - Path array to push points into
   */
  static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
    const fromX = points[points.length - 2], fromY = points[points.length - 1];
    points.length -= 2;
    const n = _const.curves._segmentsCount(
      BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)
    );
    let dt = 0, dt2 = 0, dt3 = 0, t2 = 0, t3 = 0;
    points.push(fromX, fromY);
    for (let i = 1, j = 0; i <= n; ++i)
      j = i / n, dt = 1 - j, dt2 = dt * dt, dt3 = dt2 * dt, t2 = j * j, t3 = t2 * j, points.push(
        dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX,
        dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY
      );
  }
}
exports.BezierUtils = BezierUtils;
//# sourceMappingURL=BezierUtils.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/QuadraticUtils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/QuadraticUtils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/@pixi/graphics/lib/const.js");
class QuadraticUtils {
  /**
   * Calculate length of quadratic curve
   * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}
   * for the detailed explanation of math behind this.
   * @private
   * @param fromX - x-coordinate of curve start point
   * @param fromY - y-coordinate of curve start point
   * @param cpX - x-coordinate of curve control point
   * @param cpY - y-coordinate of curve control point
   * @param toX - x-coordinate of curve end point
   * @param toY - y-coordinate of curve end point
   * @returns - Length of quadratic curve
   */
  static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
    const ax = fromX - 2 * cpX + toX, ay = fromY - 2 * cpY + toY, bx = 2 * cpX - 2 * fromX, by = 2 * cpY - 2 * fromY, a = 4 * (ax * ax + ay * ay), b = 4 * (ax * bx + ay * by), c = bx * bx + by * by, s = 2 * Math.sqrt(a + b + c), a2 = Math.sqrt(a), a32 = 2 * a * a2, c2 = 2 * Math.sqrt(c), ba = b / a2;
    return (a32 * s + a2 * b * (s - c2) + (4 * c * a - b * b) * Math.log((2 * a2 + ba + s) / (ba + c2))) / (4 * a32);
  }
  /**
   * Calculate the points for a quadratic bezier curve and then draws it.
   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
   * @private
   * @param cpX - Control point x
   * @param cpY - Control point y
   * @param toX - Destination point x
   * @param toY - Destination point y
   * @param points - Points to add segments to.
   */
  static curveTo(cpX, cpY, toX, toY, points) {
    const fromX = points[points.length - 2], fromY = points[points.length - 1], n = _const.curves._segmentsCount(
      QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY)
    );
    let xa = 0, ya = 0;
    for (let i = 1; i <= n; ++i) {
      const j = i / n;
      xa = fromX + (cpX - fromX) * j, ya = fromY + (cpY - fromY) * j, points.push(
        xa + (cpX + (toX - cpX) * j - xa) * j,
        ya + (cpY + (toY - cpY) * j - ya) * j
      );
    }
  }
}
exports.QuadraticUtils = QuadraticUtils;
//# sourceMappingURL=QuadraticUtils.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/buildCircle.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/buildCircle.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
const buildCircle = {
  build(graphicsData) {
    const points = graphicsData.points;
    let x, y, dx, dy, rx, ry;
    if (graphicsData.type === core.SHAPES.CIRC) {
      const circle = graphicsData.shape;
      x = circle.x, y = circle.y, rx = ry = circle.radius, dx = dy = 0;
    } else if (graphicsData.type === core.SHAPES.ELIP) {
      const ellipse = graphicsData.shape;
      x = ellipse.x, y = ellipse.y, rx = ellipse.width, ry = ellipse.height, dx = dy = 0;
    } else {
      const roundedRect = graphicsData.shape, halfWidth = roundedRect.width / 2, halfHeight = roundedRect.height / 2;
      x = roundedRect.x + halfWidth, y = roundedRect.y + halfHeight, rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight))), dx = halfWidth - rx, dy = halfHeight - ry;
    }
    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
      points.length = 0;
      return;
    }
    const n = Math.ceil(2.3 * Math.sqrt(rx + ry)), m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    if (points.length = m, m === 0)
      return;
    if (n === 0) {
      points.length = 8, points[0] = points[6] = x + dx, points[1] = points[3] = y + dy, points[2] = points[4] = x - dx, points[5] = points[7] = y - dy;
      return;
    }
    let j1 = 0, j2 = n * 4 + (dx ? 2 : 0) + 2, j3 = j2, j4 = m;
    {
      const x0 = dx + rx, y0 = dy, x1 = x + x0, x2 = x - x0, y1 = y + y0;
      if (points[j1++] = x1, points[j1++] = y1, points[--j2] = y1, points[--j2] = x2, dy) {
        const y2 = y - y0;
        points[j3++] = x2, points[j3++] = y2, points[--j4] = y2, points[--j4] = x1;
      }
    }
    for (let i = 1; i < n; i++) {
      const a = Math.PI / 2 * (i / n), x0 = dx + Math.cos(a) * rx, y0 = dy + Math.sin(a) * ry, x1 = x + x0, x2 = x - x0, y1 = y + y0, y2 = y - y0;
      points[j1++] = x1, points[j1++] = y1, points[--j2] = y1, points[--j2] = x2, points[j3++] = x2, points[j3++] = y2, points[--j4] = y2, points[--j4] = x1;
    }
    {
      const x0 = dx, y0 = dy + ry, x1 = x + x0, x2 = x - x0, y1 = y + y0, y2 = y - y0;
      points[j1++] = x1, points[j1++] = y1, points[--j4] = y2, points[--j4] = x1, dx && (points[j1++] = x2, points[j1++] = y1, points[--j4] = y2, points[--j4] = x2);
    }
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points, verts = graphicsGeometry.points, indices = graphicsGeometry.indices;
    if (points.length === 0)
      return;
    let vertPos = verts.length / 2;
    const center = vertPos;
    let x, y;
    if (graphicsData.type !== core.SHAPES.RREC) {
      const circle = graphicsData.shape;
      x = circle.x, y = circle.y;
    } else {
      const roundedRect = graphicsData.shape;
      x = roundedRect.x + roundedRect.width / 2, y = roundedRect.y + roundedRect.height / 2;
    }
    const matrix = graphicsData.matrix;
    verts.push(
      graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x,
      graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y
    ), vertPos++, verts.push(points[0], points[1]);
    for (let i = 2; i < points.length; i += 2)
      verts.push(points[i], points[i + 1]), indices.push(vertPos++, center, vertPos);
    indices.push(center + 1, center, vertPos);
  }
};
exports.buildCircle = buildCircle;
//# sourceMappingURL=buildCircle.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/buildLine.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/buildLine.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), _const = __webpack_require__(/*! ../const.js */ "./node_modules/@pixi/graphics/lib/const.js");
function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x - nx * innerWeight, iy = y - ny * innerWeight, ox = x + nx * outerWeight, oy = y + ny * outerWeight;
  let exx, eyy;
  clockwise ? (exx = ny, eyy = -nx) : (exx = -ny, eyy = nx);
  const eix = ix + exx, eiy = iy + eyy, eox = ox + exx, eoy = oy + eyy;
  return verts.push(
    eix,
    eiy,
    eox,
    eoy
  ), 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx, cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y), angle1 = Math.atan2(ex - cx, ey - cy);
  clockwise && angle0 < angle1 ? angle0 += Math.PI * 2 : !clockwise && angle0 > angle1 && (angle1 += Math.PI * 2);
  let startAngle = angle0;
  const angleDiff = angle1 - angle0, absAngleDiff = Math.abs(angleDiff), radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y), segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1, angleInc = angleDiff / segCount;
  if (startAngle += angleInc, clockwise) {
    verts.push(
      cx,
      cy,
      sx,
      sy
    );
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)
      verts.push(
        cx,
        cy,
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
    verts.push(
      cx,
      cy,
      ex,
      ey
    );
  } else {
    verts.push(
      sx,
      sy,
      cx,
      cy
    );
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius,
        cx,
        cy
      );
    verts.push(
      ex,
      ey,
      cx,
      cy
    );
  }
  return segCount * 2;
}
function buildNonNativeLine(graphicsData, graphicsGeometry) {
  const shape = graphicsData.shape;
  let points = graphicsData.points || shape.points.slice();
  const eps = graphicsGeometry.closePointEps;
  if (points.length === 0)
    return;
  const style = graphicsData.lineStyle, firstPoint = new core.Point(points[0], points[1]), lastPoint = new core.Point(points[points.length - 2], points[points.length - 1]), closedShape = shape.type !== core.SHAPES.POLY || shape.closeStroke, closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice(), closedPath && (points.pop(), points.pop(), lastPoint.set(points[points.length - 2], points[points.length - 1]));
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5, midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY), points.push(midPointX, midPointY);
  }
  const verts = graphicsGeometry.points, length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2, width = style.width / 2, widthSquared = width * width, miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0], y0 = points[1], x1 = points[2], y1 = points[3], x2 = 0, y2 = 0, perpx = -(y0 - y1), perpy = x0 - x1, perp1x = 0, perp1y = 0, dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist, perpy /= dist, perpx *= width, perpy *= width;
  const ratio = style.alignment, innerWeight = (1 - ratio) * 2, outerWeight = ratio * 2;
  closedShape || (style.cap === _const.LINE_CAP.ROUND ? indexCount += round(
    x0 - perpx * (innerWeight - outerWeight) * 0.5,
    y0 - perpy * (innerWeight - outerWeight) * 0.5,
    x0 - perpx * innerWeight,
    y0 - perpy * innerWeight,
    x0 + perpx * outerWeight,
    y0 + perpy * outerWeight,
    verts,
    !0
  ) + 2 : style.cap === _const.LINE_CAP.SQUARE && (indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, !0, verts))), verts.push(
    x0 - perpx * innerWeight,
    y0 - perpy * innerWeight,
    x0 + perpx * outerWeight,
    y0 + perpy * outerWeight
  );
  for (let i = 1; i < length - 1; ++i) {
    x0 = points[(i - 1) * 2], y0 = points[(i - 1) * 2 + 1], x1 = points[i * 2], y1 = points[i * 2 + 1], x2 = points[(i + 1) * 2], y2 = points[(i + 1) * 2 + 1], perpx = -(y0 - y1), perpy = x0 - x1, dist = Math.sqrt(perpx * perpx + perpy * perpy), perpx /= dist, perpy /= dist, perpx *= width, perpy *= width, perp1x = -(y1 - y2), perp1y = x1 - x2, dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y), perp1x /= dist, perp1y /= dist, perp1x *= width, perp1y *= width;
    const dx0 = x1 - x0, dy0 = y0 - y1, dx1 = x1 - x2, dy1 = y2 - y1, dot = dx0 * dx1 + dy0 * dy1, cross = dy0 * dx1 - dy1 * dx0, clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(
        x1 - perpx * innerWeight,
        y1 - perpy * innerWeight,
        x1 + perpx * outerWeight,
        y1 + perpy * outerWeight
      ), dot >= 0 && (style.join === _const.LINE_JOIN.ROUND ? indexCount += round(
        x1,
        y1,
        x1 - perpx * innerWeight,
        y1 - perpy * innerWeight,
        x1 - perp1x * innerWeight,
        y1 - perp1y * innerWeight,
        verts,
        !1
      ) + 4 : indexCount += 2, verts.push(
        x1 - perp1x * outerWeight,
        y1 - perp1y * outerWeight,
        x1 + perp1x * innerWeight,
        y1 + perp1y * innerWeight
      ));
      continue;
    }
    const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0), c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2), px = (dx0 * c2 - dx1 * c1) / cross, py = (dy1 * c1 - dy0 * c2) / cross, pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1), imx = x1 + (px - x1) * innerWeight, imy = y1 + (py - y1) * innerWeight, omx = x1 - (px - x1) * outerWeight, omy = y1 - (py - y1) * outerWeight, smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1), insideWeight = clockwise ? innerWeight : outerWeight, smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared, insideMiterOk = pdist <= smallerInsideDiagonalSq;
    let join = style.join;
    if (join === _const.LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared && (join = _const.LINE_JOIN.BEVEL), insideMiterOk)
      switch (join) {
        case _const.LINE_JOIN.MITER: {
          verts.push(
            imx,
            imy,
            omx,
            omy
          );
          break;
        }
        case _const.LINE_JOIN.BEVEL: {
          clockwise ? verts.push(
            imx,
            imy,
            // inner miter point
            x1 + perpx * outerWeight,
            y1 + perpy * outerWeight,
            // first segment's outer vertex
            imx,
            imy,
            // inner miter point
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight
          ) : verts.push(
            x1 - perpx * innerWeight,
            y1 - perpy * innerWeight,
            // first segment's inner vertex
            omx,
            omy,
            // outer miter point
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            // second segment's outer vertex
            omx,
            omy
          ), indexCount += 2;
          break;
        }
        case _const.LINE_JOIN.ROUND: {
          clockwise ? (verts.push(
            imx,
            imy,
            x1 + perpx * outerWeight,
            y1 + perpy * outerWeight
          ), indexCount += round(
            x1,
            y1,
            x1 + perpx * outerWeight,
            y1 + perpy * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            !0
          ) + 4, verts.push(
            imx,
            imy,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight
          )) : (verts.push(
            x1 - perpx * innerWeight,
            y1 - perpy * innerWeight,
            omx,
            omy
          ), indexCount += round(
            x1,
            y1,
            x1 - perpx * innerWeight,
            y1 - perpy * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            !1
          ) + 4, verts.push(
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            omx,
            omy
          ));
          break;
        }
      }
    else {
      switch (verts.push(
        x1 - perpx * innerWeight,
        y1 - perpy * innerWeight,
        // first segment's inner vertex
        x1 + perpx * outerWeight,
        y1 + perpy * outerWeight
      ), join) {
        case _const.LINE_JOIN.MITER: {
          clockwise ? verts.push(
            omx,
            omy,
            // inner miter point
            omx,
            omy
          ) : verts.push(
            imx,
            imy,
            // outer miter point
            imx,
            imy
          ), indexCount += 2;
          break;
        }
        case _const.LINE_JOIN.ROUND: {
          clockwise ? indexCount += round(
            x1,
            y1,
            x1 + perpx * outerWeight,
            y1 + perpy * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            !0
          ) + 2 : indexCount += round(
            x1,
            y1,
            x1 - perpx * innerWeight,
            y1 - perpy * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            !1
          ) + 2;
          break;
        }
      }
      verts.push(
        x1 - perp1x * innerWeight,
        y1 - perp1y * innerWeight,
        // second segment's inner vertex
        x1 + perp1x * outerWeight,
        y1 + perp1y * outerWeight
      ), indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2], y0 = points[(length - 2) * 2 + 1], x1 = points[(length - 1) * 2], y1 = points[(length - 1) * 2 + 1], perpx = -(y0 - y1), perpy = x0 - x1, dist = Math.sqrt(perpx * perpx + perpy * perpy), perpx /= dist, perpy /= dist, perpx *= width, perpy *= width, verts.push(
    x1 - perpx * innerWeight,
    y1 - perpy * innerWeight,
    x1 + perpx * outerWeight,
    y1 + perpy * outerWeight
  ), closedShape || (style.cap === _const.LINE_CAP.ROUND ? indexCount += round(
    x1 - perpx * (innerWeight - outerWeight) * 0.5,
    y1 - perpy * (innerWeight - outerWeight) * 0.5,
    x1 - perpx * innerWeight,
    y1 - perpy * innerWeight,
    x1 + perpx * outerWeight,
    y1 + perpy * outerWeight,
    verts,
    !1
  ) + 2 : style.cap === _const.LINE_CAP.SQUARE && (indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, !1, verts)));
  const indices = graphicsGeometry.indices, eps2 = _const.curves.epsilon * _const.curves.epsilon;
  for (let i = indexStart; i < indexCount + indexStart - 2; ++i)
    x0 = verts[i * 2], y0 = verts[i * 2 + 1], x1 = verts[(i + 1) * 2], y1 = verts[(i + 1) * 2 + 1], x2 = verts[(i + 2) * 2], y2 = verts[(i + 2) * 2 + 1], !(Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) && indices.push(i, i + 1, i + 2);
}
function buildNativeLine(graphicsData, graphicsGeometry) {
  let i = 0;
  const shape = graphicsData.shape, points = graphicsData.points || shape.points, closedShape = shape.type !== core.SHAPES.POLY || shape.closeStroke;
  if (points.length === 0)
    return;
  const verts = graphicsGeometry.points, indices = graphicsGeometry.indices, length = points.length / 2, startIndex = verts.length / 2;
  let currentIndex = startIndex;
  for (verts.push(points[0], points[1]), i = 1; i < length; i++)
    verts.push(points[i * 2], points[i * 2 + 1]), indices.push(currentIndex, currentIndex + 1), currentIndex++;
  closedShape && indices.push(currentIndex, startIndex);
}
function buildLine(graphicsData, graphicsGeometry) {
  graphicsData.lineStyle.native ? buildNativeLine(graphicsData, graphicsGeometry) : buildNonNativeLine(graphicsData, graphicsGeometry);
}
exports.buildLine = buildLine;
//# sourceMappingURL=buildLine.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/buildPoly.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/buildPoly.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
function fixOrientation(points, hole = !1) {
  const m = points.length;
  if (m < 6)
    return;
  let area = 0;
  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {
    const x2 = points[i], y2 = points[i + 1];
    area += (x2 - x1) * (y2 + y1), x1 = x2, y1 = y2;
  }
  if (!hole && area > 0 || hole && area <= 0) {
    const n = m / 2;
    for (let i = n + n % 2; i < m; i += 2) {
      const i1 = m - i - 2, i2 = m - i - 1, i3 = i, i4 = i + 1;
      [points[i1], points[i3]] = [points[i3], points[i1]], [points[i2], points[i4]] = [points[i4], points[i2]];
    }
  }
}
const buildPoly = {
  build(graphicsData) {
    graphicsData.points = graphicsData.shape.points.slice();
  },
  triangulate(graphicsData, graphicsGeometry) {
    let points = graphicsData.points;
    const holes = graphicsData.holes, verts = graphicsGeometry.points, indices = graphicsGeometry.indices;
    if (points.length >= 6) {
      fixOrientation(points, !1);
      const holeArray = [];
      for (let i = 0; i < holes.length; i++) {
        const hole = holes[i];
        fixOrientation(hole.points, !0), holeArray.push(points.length / 2), points = points.concat(hole.points);
      }
      const triangles = core.utils.earcut(points, holeArray, 2);
      if (!triangles)
        return;
      const vertPos = verts.length / 2;
      for (let i = 0; i < triangles.length; i += 3)
        indices.push(triangles[i] + vertPos), indices.push(triangles[i + 1] + vertPos), indices.push(triangles[i + 2] + vertPos);
      for (let i = 0; i < points.length; i++)
        verts.push(points[i]);
    }
  }
};
exports.buildPoly = buildPoly;
//# sourceMappingURL=buildPoly.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/buildRectangle.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/buildRectangle.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const buildRectangle = {
  build(graphicsData) {
    const rectData = graphicsData.shape, x = rectData.x, y = rectData.y, width = rectData.width, height = rectData.height, points = graphicsData.points;
    points.length = 0, width >= 0 && height >= 0 && points.push(
      x,
      y,
      x + width,
      y,
      x + width,
      y + height,
      x,
      y + height
    );
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points, verts = graphicsGeometry.points;
    if (points.length === 0)
      return;
    const vertPos = verts.length / 2;
    verts.push(
      points[0],
      points[1],
      points[2],
      points[3],
      points[6],
      points[7],
      points[4],
      points[5]
    ), graphicsGeometry.indices.push(
      vertPos,
      vertPos + 1,
      vertPos + 2,
      vertPos + 1,
      vertPos + 2,
      vertPos + 3
    );
  }
};
exports.buildRectangle = buildRectangle;
//# sourceMappingURL=buildRectangle.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var buildCircle = __webpack_require__(/*! ./buildCircle.js */ "./node_modules/@pixi/graphics/lib/utils/buildCircle.js");
const buildRoundedRectangle = {
  build(graphicsData) {
    buildCircle.buildCircle.build(graphicsData);
  },
  triangulate(graphicsData, graphicsGeometry) {
    buildCircle.buildCircle.triangulate(graphicsData, graphicsGeometry);
  }
};
exports.buildRoundedRectangle = buildRoundedRectangle;
//# sourceMappingURL=buildRoundedRectangle.js.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), buildCircle = __webpack_require__(/*! ./buildCircle.js */ "./node_modules/@pixi/graphics/lib/utils/buildCircle.js"), buildPoly = __webpack_require__(/*! ./buildPoly.js */ "./node_modules/@pixi/graphics/lib/utils/buildPoly.js"), buildRectangle = __webpack_require__(/*! ./buildRectangle.js */ "./node_modules/@pixi/graphics/lib/utils/buildRectangle.js"), buildRoundedRectangle = __webpack_require__(/*! ./buildRoundedRectangle.js */ "./node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.js"), ArcUtils = __webpack_require__(/*! ./ArcUtils.js */ "./node_modules/@pixi/graphics/lib/utils/ArcUtils.js"), BatchPart = __webpack_require__(/*! ./BatchPart.js */ "./node_modules/@pixi/graphics/lib/utils/BatchPart.js"), BezierUtils = __webpack_require__(/*! ./BezierUtils.js */ "./node_modules/@pixi/graphics/lib/utils/BezierUtils.js"), buildLine = __webpack_require__(/*! ./buildLine.js */ "./node_modules/@pixi/graphics/lib/utils/buildLine.js"), QuadraticUtils = __webpack_require__(/*! ./QuadraticUtils.js */ "./node_modules/@pixi/graphics/lib/utils/QuadraticUtils.js");
const FILL_COMMANDS = {
  [core.SHAPES.POLY]: buildPoly.buildPoly,
  [core.SHAPES.CIRC]: buildCircle.buildCircle,
  [core.SHAPES.ELIP]: buildCircle.buildCircle,
  [core.SHAPES.RECT]: buildRectangle.buildRectangle,
  [core.SHAPES.RREC]: buildRoundedRectangle.buildRoundedRectangle
}, BATCH_POOL = [], DRAW_CALL_POOL = [];
exports.buildCircle = buildCircle.buildCircle;
exports.buildPoly = buildPoly.buildPoly;
exports.buildRectangle = buildRectangle.buildRectangle;
exports.buildRoundedRectangle = buildRoundedRectangle.buildRoundedRectangle;
exports.ArcUtils = ArcUtils.ArcUtils;
exports.BatchPart = BatchPart.BatchPart;
exports.BezierUtils = BezierUtils.BezierUtils;
exports.buildLine = buildLine.buildLine;
exports.QuadraticUtils = QuadraticUtils.QuadraticUtils;
exports.BATCH_POOL = BATCH_POOL;
exports.DRAW_CALL_POOL = DRAW_CALL_POOL;
exports.FILL_COMMANDS = FILL_COMMANDS;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/IPoint.js":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/math/lib/IPoint.js ***!
  \***********************************************/
/***/ (() => {

"use strict";

//# sourceMappingURL=IPoint.js.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/IPointData.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/math/lib/IPointData.js ***!
  \***************************************************/
/***/ (() => {

"use strict";

//# sourceMappingURL=IPointData.js.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/Matrix.js":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/math/lib/Matrix.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ./const.js */ "./node_modules/@pixi/math/lib/const.js"), Point = __webpack_require__(/*! ./Point.js */ "./node_modules/@pixi/math/lib/Point.js");
class Matrix {
  /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */
  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
    this.array = null, this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty;
  }
  /**
   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
   *
   * a = array[0]
   * b = array[1]
   * c = array[3]
   * d = array[4]
   * tx = array[2]
   * ty = array[5]
   * @param array - The array that the matrix will be populated from.
   */
  fromArray(array) {
    this.a = array[0], this.b = array[1], this.c = array[3], this.d = array[4], this.tx = array[2], this.ty = array[5];
  }
  /**
   * Sets the matrix properties.
   * @param a - Matrix component
   * @param b - Matrix component
   * @param c - Matrix component
   * @param d - Matrix component
   * @param tx - Matrix component
   * @param ty - Matrix component
   * @returns This matrix. Good for chaining method calls.
   */
  set(a, b, c, d, tx, ty) {
    return this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty, this;
  }
  /**
   * Creates an array from the current Matrix object.
   * @param transpose - Whether we need to transpose the matrix or not
   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
   * @returns The newly created array which contains the matrix
   */
  toArray(transpose, out) {
    this.array || (this.array = new Float32Array(9));
    const array = out || this.array;
    return transpose ? (array[0] = this.a, array[1] = this.b, array[2] = 0, array[3] = this.c, array[4] = this.d, array[5] = 0, array[6] = this.tx, array[7] = this.ty, array[8] = 1) : (array[0] = this.a, array[1] = this.c, array[2] = this.tx, array[3] = this.b, array[4] = this.d, array[5] = this.ty, array[6] = 0, array[7] = 0, array[8] = 1), array;
  }
  /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @param pos - The origin
   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {PIXI.Point} The new point, transformed through this matrix
   */
  apply(pos, newPos) {
    newPos = newPos || new Point.Point();
    const x = pos.x, y = pos.y;
    return newPos.x = this.a * x + this.c * y + this.tx, newPos.y = this.b * x + this.d * y + this.ty, newPos;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @param pos - The origin
   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {PIXI.Point} The new point, inverse-transformed through this matrix
   */
  applyInverse(pos, newPos) {
    newPos = newPos || new Point.Point();
    const id = 1 / (this.a * this.d + this.c * -this.b), x = pos.x, y = pos.y;
    return newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id, newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id, newPos;
  }
  /**
   * Translates the matrix on the x and y.
   * @param x - How much to translate x by
   * @param y - How much to translate y by
   * @returns This matrix. Good for chaining method calls.
   */
  translate(x, y) {
    return this.tx += x, this.ty += y, this;
  }
  /**
   * Applies a scale transformation to the matrix.
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   */
  scale(x, y) {
    return this.a *= x, this.d *= y, this.c *= x, this.b *= y, this.tx *= x, this.ty *= y, this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   * @param angle - The angle in radians.
   * @returns This matrix. Good for chaining method calls.
   */
  rotate(angle) {
    const cos = Math.cos(angle), sin = Math.sin(angle), a1 = this.a, c1 = this.c, tx1 = this.tx;
    return this.a = a1 * cos - this.b * sin, this.b = a1 * sin + this.b * cos, this.c = c1 * cos - this.d * sin, this.d = c1 * sin + this.d * cos, this.tx = tx1 * cos - this.ty * sin, this.ty = tx1 * sin + this.ty * cos, this;
  }
  /**
   * Appends the given Matrix to this Matrix.
   * @param matrix - The matrix to append.
   * @returns This matrix. Good for chaining method calls.
   */
  append(matrix) {
    const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d;
    return this.a = matrix.a * a1 + matrix.b * c1, this.b = matrix.a * b1 + matrix.b * d1, this.c = matrix.c * a1 + matrix.d * c1, this.d = matrix.c * b1 + matrix.d * d1, this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx, this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty, this;
  }
  /**
   * Sets the matrix based on all the available properties
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   */
  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    return this.a = Math.cos(rotation + skewY) * scaleX, this.b = Math.sin(rotation + skewY) * scaleX, this.c = -Math.sin(rotation - skewX) * scaleY, this.d = Math.cos(rotation - skewX) * scaleY, this.tx = x - (pivotX * this.a + pivotY * this.c), this.ty = y - (pivotX * this.b + pivotY * this.d), this;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   */
  prepend(matrix) {
    const tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      const a1 = this.a, c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c, this.b = a1 * matrix.b + this.b * matrix.d, this.c = c1 * matrix.a + this.d * matrix.c, this.d = c1 * matrix.b + this.d * matrix.d;
    }
    return this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx, this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty, this;
  }
  /**
   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
   * @param transform - The transform to apply the properties to.
   * @returns The transform with the newly applied properties
   */
  decompose(transform) {
    const a = this.a, b = this.b, c = this.c, d = this.d, pivot = transform.pivot, skewX = -Math.atan2(-c, d), skewY = Math.atan2(b, a), delta = Math.abs(skewX + skewY);
    return delta < 1e-5 || Math.abs(_const.PI_2 - delta) < 1e-5 ? (transform.rotation = skewY, transform.skew.x = transform.skew.y = 0) : (transform.rotation = 0, transform.skew.x = skewX, transform.skew.y = skewY), transform.scale.x = Math.sqrt(a * a + b * b), transform.scale.y = Math.sqrt(c * c + d * d), transform.position.x = this.tx + (pivot.x * a + pivot.y * c), transform.position.y = this.ty + (pivot.x * b + pivot.y * d), transform;
  }
  /**
   * Inverts this matrix
   * @returns This matrix. Good for chaining method calls.
   */
  invert() {
    const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d, tx1 = this.tx, n = a1 * d1 - b1 * c1;
    return this.a = d1 / n, this.b = -b1 / n, this.c = -c1 / n, this.d = a1 / n, this.tx = (c1 * this.ty - d1 * tx1) / n, this.ty = -(a1 * this.ty - b1 * tx1) / n, this;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   * @returns This matrix. Good for chaining method calls.
   */
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */
  clone() {
    const matrix = new Matrix();
    return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix;
  }
  /**
   * Changes the values of the given matrix to be the same as the ones in this matrix
   * @param matrix - The matrix to copy to.
   * @returns The matrix given in parameter with its values updated.
   */
  copyTo(matrix) {
    return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix
   * @param {PIXI.Matrix} matrix - The matrix to copy from.
   * @returns {PIXI.Matrix} this
   */
  copyFrom(matrix) {
    return this.a = matrix.a, this.b = matrix.b, this.c = matrix.c, this.d = matrix.d, this.tx = matrix.tx, this.ty = matrix.ty, this;
  }
  /**
   * A default (identity) matrix
   * @readonly
   */
  static get IDENTITY() {
    return new Matrix();
  }
  /**
   * A temp matrix
   * @readonly
   */
  static get TEMP_MATRIX() {
    return new Matrix();
  }
}
Matrix.prototype.toString = function() {
  return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
};
exports.Matrix = Matrix;
//# sourceMappingURL=Matrix.js.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/ObservablePoint.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/math/lib/ObservablePoint.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class ObservablePoint {
  /**
   * Creates a new `ObservablePoint`
   * @param cb - callback function triggered when `x` and/or `y` are changed
   * @param scope - owner of callback
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(cb, scope, x = 0, y = 0) {
    this._x = x, this._y = y, this.cb = cb, this.scope = scope;
  }
  /**
   * Creates a clone of this point.
   * The callback and scope params can be overridden otherwise they will default
   * to the clone object's values.
   * @override
   * @param cb - The callback function triggered when `x` and/or `y` are changed
   * @param scope - The owner of the callback
   * @returns a copy of this observable point
   */
  clone(cb = this.cb, scope = this.scope) {
    return new ObservablePoint(cb, scope, this._x, this._y);
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=x] - position of the point on the y axis
   * @returns The observable point instance itself
   */
  set(x = 0, y = x) {
    return (this._x !== x || this._y !== y) && (this._x = x, this._y = y, this.cb.call(this.scope)), this;
  }
  /**
   * Copies x and y from the given point (`p`)
   * @param p - The point to copy from. Can be any of type that is or extends `IPointData`
   * @returns The observable point instance itself
   */
  copyFrom(p) {
    return (this._x !== p.x || this._y !== p.y) && (this._x = p.x, this._y = p.y, this.cb.call(this.scope)), this;
  }
  /**
   * Copies this point's x and y into that of the given point (`p`)
   * @param p - The point to copy to. Can be any of type that is or extends `IPointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(p) {
    return p.set(this._x, this._y), p;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(p) {
    return p.x === this._x && p.y === this._y;
  }
  /** Position of the observable point on the x axis. */
  get x() {
    return this._x;
  }
  set x(value) {
    this._x !== value && (this._x = value, this.cb.call(this.scope));
  }
  /** Position of the observable point on the y axis. */
  get y() {
    return this._y;
  }
  set y(value) {
    this._y !== value && (this._y = value, this.cb.call(this.scope));
  }
}
ObservablePoint.prototype.toString = function() {
  return `[@pixi/math:ObservablePoint x=${this.x} y=${this.y} scope=${this.scope}]`;
};
exports.ObservablePoint = ObservablePoint;
//# sourceMappingURL=ObservablePoint.js.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/Point.js":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/math/lib/Point.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class Point {
  /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(x = 0, y = 0) {
    this.x = 0, this.y = 0, this.x = x, this.y = y;
  }
  /**
   * Creates a clone of this point
   * @returns A clone of this point
   */
  clone() {
    return new Point(this.x, this.y);
  }
  /**
   * Copies `x` and `y` from the given point into this point
   * @param p - The point to copy from
   * @returns The point instance itself
   */
  copyFrom(p) {
    return this.set(p.x, p.y), this;
  }
  /**
   * Copies this point's x and y into the given point (`p`).
   * @param p - The point to copy to. Can be any of type that is or extends `IPointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(p) {
    return p.set(this.x, this.y), p;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(p) {
    return p.x === this.x && p.y === this.y;
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the `x` axis
   * @param {number} [y=x] - position of the point on the `y` axis
   * @returns The point instance itself
   */
  set(x = 0, y = x) {
    return this.x = x, this.y = y, this;
  }
}
Point.prototype.toString = function() {
  return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
};
exports.Point = Point;
//# sourceMappingURL=Point.js.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/Transform.js":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/math/lib/Transform.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Matrix = __webpack_require__(/*! ./Matrix.js */ "./node_modules/@pixi/math/lib/Matrix.js"), ObservablePoint = __webpack_require__(/*! ./ObservablePoint.js */ "./node_modules/@pixi/math/lib/ObservablePoint.js");
const _Transform = class {
  constructor() {
    this.worldTransform = new Matrix.Matrix(), this.localTransform = new Matrix.Matrix(), this.position = new ObservablePoint.ObservablePoint(this.onChange, this, 0, 0), this.scale = new ObservablePoint.ObservablePoint(this.onChange, this, 1, 1), this.pivot = new ObservablePoint.ObservablePoint(this.onChange, this, 0, 0), this.skew = new ObservablePoint.ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
  }
  /** Called when a value changes. */
  onChange() {
    this._localID++;
  }
  /** Called when the skew or the rotation changes. */
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
  }
  /** Updates the local transformation matrix. */
  updateLocalTransform() {
    const lt = this.localTransform;
    this._localID !== this._currentLocalID && (lt.a = this._cx * this.scale.x, lt.b = this._sx * this.scale.x, lt.c = this._cy * this.scale.y, lt.d = this._sy * this.scale.y, lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c), lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d), this._currentLocalID = this._localID, this._parentID = -1);
  }
  /**
   * Updates the local and the world transformation matrices.
   * @param parentTransform - The parent transform
   */
  updateTransform(parentTransform) {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID && (lt.a = this._cx * this.scale.x, lt.b = this._sx * this.scale.x, lt.c = this._cy * this.scale.y, lt.d = this._sy * this.scale.y, lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c), lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== parentTransform._worldID) {
      const pt = parentTransform.worldTransform, wt = this.worldTransform;
      wt.a = lt.a * pt.a + lt.b * pt.c, wt.b = lt.a * pt.b + lt.b * pt.d, wt.c = lt.c * pt.a + lt.d * pt.c, wt.d = lt.c * pt.b + lt.d * pt.d, wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx, wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty, this._parentID = parentTransform._worldID, this._worldID++;
    }
  }
  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   * @param matrix - The matrix to decompose
   */
  setFromMatrix(matrix) {
    matrix.decompose(this), this._localID++;
  }
  /** The rotation of the object in radians. */
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    this._rotation !== value && (this._rotation = value, this.updateSkew());
  }
};
_Transform.IDENTITY = new _Transform();
let Transform = _Transform;
Transform.prototype.toString = function() {
  return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
};
exports.Transform = Transform;
//# sourceMappingURL=Transform.js.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/const.js":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/math/lib/const.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const PI_2 = Math.PI * 2, RAD_TO_DEG = 180 / Math.PI, DEG_TO_RAD = Math.PI / 180;
var SHAPES = /* @__PURE__ */ ((SHAPES2) => (SHAPES2[SHAPES2.POLY = 0] = "POLY", SHAPES2[SHAPES2.RECT = 1] = "RECT", SHAPES2[SHAPES2.CIRC = 2] = "CIRC", SHAPES2[SHAPES2.ELIP = 3] = "ELIP", SHAPES2[SHAPES2.RREC = 4] = "RREC", SHAPES2))(SHAPES || {});
exports.DEG_TO_RAD = DEG_TO_RAD;
exports.PI_2 = PI_2;
exports.RAD_TO_DEG = RAD_TO_DEG;
exports.SHAPES = SHAPES;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/groupD8.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/math/lib/groupD8.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Matrix = __webpack_require__(/*! ./Matrix.js */ "./node_modules/@pixi/math/lib/Matrix.js");
const ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], rotationCayley = [], rotationMatrices = [], signum = Math.sign;
function init() {
  for (let i = 0; i < 16; i++) {
    const row = [];
    rotationCayley.push(row);
    for (let j = 0; j < 16; j++) {
      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]), _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]), _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]), _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
      for (let k = 0; k < 16; k++)
        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
          row.push(k);
          break;
        }
    }
  }
  for (let i = 0; i < 16; i++) {
    const mat = new Matrix.Matrix();
    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0), rotationMatrices.push(mat);
  }
}
init();
const groupD8 = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @readonly
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @readonly
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @readonly
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @readonly
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @readonly
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @readonly
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @readonly
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @readonly
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @readonly
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @readonly
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @readonly
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @readonly
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: (ind) => ux[ind],
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: (ind) => uy[ind],
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: (ind) => vx[ind],
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: (ind) => vy[ind],
  /**
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: (rotation) => rotation & 8 ? rotation & 15 : -rotation & 7,
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {PIXI.GD8Symmetry} Composed operation
   */
  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
  /**
   * Reverse of `add`.
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @returns {PIXI.GD8Symmetry} Result
   */
  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: (rotation) => rotation ^ 4,
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: (rotation) => (rotation & 3) === 2,
  // rotation % 4 === 2
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: (dx, dy) => Math.abs(dx) * 2 <= Math.abs(dy) ? dy >= 0 ? groupD8.S : groupD8.N : Math.abs(dy) * 2 <= Math.abs(dx) ? dx > 0 ? groupD8.E : groupD8.W : dy > 0 ? dx > 0 ? groupD8.SE : groupD8.SW : dx > 0 ? groupD8.NE : groupD8.NW,
  /**
   * Helps sprite to compensate texture packer rotation.
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
    const mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx, mat.ty = ty, matrix.append(mat);
  }
};
exports.groupD8 = groupD8;
//# sourceMappingURL=groupD8.js.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/math/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Circle = __webpack_require__(/*! ./shapes/Circle.js */ "./node_modules/@pixi/math/lib/shapes/Circle.js"), Ellipse = __webpack_require__(/*! ./shapes/Ellipse.js */ "./node_modules/@pixi/math/lib/shapes/Ellipse.js"), Polygon = __webpack_require__(/*! ./shapes/Polygon.js */ "./node_modules/@pixi/math/lib/shapes/Polygon.js"), Rectangle = __webpack_require__(/*! ./shapes/Rectangle.js */ "./node_modules/@pixi/math/lib/shapes/Rectangle.js"), RoundedRectangle = __webpack_require__(/*! ./shapes/RoundedRectangle.js */ "./node_modules/@pixi/math/lib/shapes/RoundedRectangle.js"), groupD8 = __webpack_require__(/*! ./groupD8.js */ "./node_modules/@pixi/math/lib/groupD8.js");
__webpack_require__(/*! ./IPoint.js */ "./node_modules/@pixi/math/lib/IPoint.js");
__webpack_require__(/*! ./IPointData.js */ "./node_modules/@pixi/math/lib/IPointData.js");
var Matrix = __webpack_require__(/*! ./Matrix.js */ "./node_modules/@pixi/math/lib/Matrix.js"), ObservablePoint = __webpack_require__(/*! ./ObservablePoint.js */ "./node_modules/@pixi/math/lib/ObservablePoint.js"), Point = __webpack_require__(/*! ./Point.js */ "./node_modules/@pixi/math/lib/Point.js"), Transform = __webpack_require__(/*! ./Transform.js */ "./node_modules/@pixi/math/lib/Transform.js"), _const = __webpack_require__(/*! ./const.js */ "./node_modules/@pixi/math/lib/const.js");
exports.Circle = Circle.Circle;
exports.Ellipse = Ellipse.Ellipse;
exports.Polygon = Polygon.Polygon;
exports.Rectangle = Rectangle.Rectangle;
exports.RoundedRectangle = RoundedRectangle.RoundedRectangle;
exports.groupD8 = groupD8.groupD8;
exports.Matrix = Matrix.Matrix;
exports.ObservablePoint = ObservablePoint.ObservablePoint;
exports.Point = Point.Point;
exports.Transform = Transform.Transform;
exports.DEG_TO_RAD = _const.DEG_TO_RAD;
exports.PI_2 = _const.PI_2;
exports.RAD_TO_DEG = _const.RAD_TO_DEG;
exports.SHAPES = _const.SHAPES;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/shapes/Circle.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/math/lib/shapes/Circle.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/@pixi/math/lib/const.js"), Rectangle = __webpack_require__(/*! ./Rectangle.js */ "./node_modules/@pixi/math/lib/shapes/Rectangle.js");
class Circle {
  /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */
  constructor(x = 0, y = 0, radius = 0) {
    this.x = x, this.y = y, this.radius = radius, this.type = _const.SHAPES.CIRC;
  }
  /**
   * Creates a clone of this Circle instance
   * @returns A copy of the Circle
   */
  clone() {
    return new Circle(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   */
  contains(x, y) {
    if (this.radius <= 0)
      return !1;
    const r2 = this.radius * this.radius;
    let dx = this.x - x, dy = this.y - y;
    return dx *= dx, dy *= dy, dx + dy <= r2;
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object
   * @returns The framing rectangle
   */
  getBounds() {
    return new Rectangle.Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }
}
Circle.prototype.toString = function() {
  return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
};
exports.Circle = Circle;
//# sourceMappingURL=Circle.js.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/shapes/Ellipse.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/math/lib/shapes/Ellipse.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/@pixi/math/lib/const.js"), Rectangle = __webpack_require__(/*! ./Rectangle.js */ "./node_modules/@pixi/math/lib/shapes/Rectangle.js");
class Ellipse {
  /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */
  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {
    this.x = x, this.y = y, this.width = halfWidth, this.height = halfHeight, this.type = _const.SHAPES.ELIP;
  }
  /**
   * Creates a clone of this Ellipse instance
   * @returns {PIXI.Ellipse} A copy of the ellipse
   */
  clone() {
    return new Ellipse(this.x, this.y, this.width, this.height);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   */
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    let normx = (x - this.x) / this.width, normy = (y - this.y) / this.height;
    return normx *= normx, normy *= normy, normx + normy <= 1;
  }
  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object
   * @returns The framing rectangle
   */
  getBounds() {
    return new Rectangle.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
  }
}
Ellipse.prototype.toString = function() {
  return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
};
exports.Ellipse = Ellipse;
//# sourceMappingURL=Ellipse.js.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/shapes/Polygon.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/math/lib/shapes/Polygon.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/@pixi/math/lib/const.js");
class Polygon {
  /**
   * @param {PIXI.IPointData[]|number[]} points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */
  constructor(...points) {
    let flat = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat[0] != "number") {
      const p = [];
      for (let i = 0, il = flat.length; i < il; i++)
        p.push(flat[i].x, flat[i].y);
      flat = p;
    }
    this.points = flat, this.type = _const.SHAPES.POLY, this.closeStroke = !0;
  }
  /**
   * Creates a clone of this polygon.
   * @returns - A copy of the polygon.
   */
  clone() {
    const points = this.points.slice(), polygon = new Polygon(points);
    return polygon.closeStroke = this.closeStroke, polygon;
  }
  /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this polygon.
   */
  contains(x, y) {
    let inside = !1;
    const length = this.points.length / 2;
    for (let i = 0, j = length - 1; i < length; j = i++) {
      const xi = this.points[i * 2], yi = this.points[i * 2 + 1], xj = this.points[j * 2], yj = this.points[j * 2 + 1];
      yi > y != yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi && (inside = !inside);
    }
    return inside;
  }
}
Polygon.prototype.toString = function() {
  return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
};
exports.Polygon = Polygon;
//# sourceMappingURL=Polygon.js.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/shapes/Rectangle.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/math/lib/shapes/Rectangle.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/@pixi/math/lib/const.js"), Point = __webpack_require__(/*! ../Point.js */ "./node_modules/@pixi/math/lib/Point.js");
const tempPoints = [new Point.Point(), new Point.Point(), new Point.Point(), new Point.Point()];
class Rectangle {
  /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */
  constructor(x = 0, y = 0, width = 0, height = 0) {
    this.x = Number(x), this.y = Number(y), this.width = Number(width), this.height = Number(height), this.type = _const.SHAPES.RECT;
  }
  /** Returns the left edge of the rectangle. */
  get left() {
    return this.x;
  }
  /** Returns the right edge of the rectangle. */
  get right() {
    return this.x + this.width;
  }
  /** Returns the top edge of the rectangle. */
  get top() {
    return this.y;
  }
  /** Returns the bottom edge of the rectangle. */
  get bottom() {
    return this.y + this.height;
  }
  /** A constant empty rectangle. */
  static get EMPTY() {
    return new Rectangle(0, 0, 0, 0);
  }
  /**
   * Creates a clone of this Rectangle
   * @returns a copy of the rectangle
   */
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
  /**
   * Copies another rectangle to this one.
   * @param rectangle - The rectangle to copy from.
   * @returns Returns itself.
   */
  copyFrom(rectangle) {
    return this.x = rectangle.x, this.y = rectangle.y, this.width = rectangle.width, this.height = rectangle.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @param rectangle - The rectangle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(rectangle) {
    return rectangle.x = this.x, rectangle.y = this.y, rectangle.width = this.width, rectangle.height = this.height, rectangle;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   */
  contains(x, y) {
    return this.width <= 0 || this.height <= 0 ? !1 : x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height;
  }
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */
  intersects(other, transform) {
    if (!transform) {
      const x02 = this.x < other.x ? other.x : this.x;
      if ((this.right > other.right ? other.right : this.right) <= x02)
        return !1;
      const y02 = this.y < other.y ? other.y : this.y;
      return (this.bottom > other.bottom ? other.bottom : this.bottom) > y02;
    }
    const x0 = this.left, x1 = this.right, y0 = this.top, y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0)
      return !1;
    const lt = tempPoints[0].set(other.left, other.top), lb = tempPoints[1].set(other.left, other.bottom), rt = tempPoints[2].set(other.right, other.top), rb = tempPoints[3].set(other.right, other.bottom);
    if (rt.x <= lt.x || lb.y <= lt.y)
      return !1;
    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);
    if (s === 0 || (transform.apply(lt, lt), transform.apply(lb, lb), transform.apply(rt, rt), transform.apply(rb, rb), Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1))
      return !1;
    const nx = s * (lb.y - lt.y), ny = s * (lt.x - lb.x), n00 = nx * x0 + ny * y0, n10 = nx * x1 + ny * y0, n01 = nx * x0 + ny * y1, n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y)
      return !1;
    const mx = s * (lt.y - rt.y), my = s * (rt.x - lt.x), m00 = mx * x0 + my * y0, m10 = mx * x1 + my * y0, m01 = mx * x0 + my * y1, m11 = mx * x1 + my * y1;
    return !(Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y);
  }
  /**
   * Pads the rectangle making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   * @returns Returns itself.
   */
  pad(paddingX = 0, paddingY = paddingX) {
    return this.x -= paddingX, this.y -= paddingY, this.width += paddingX * 2, this.height += paddingY * 2, this;
  }
  /**
   * Fits this rectangle around the passed one.
   * @param rectangle - The rectangle to fit.
   * @returns Returns itself.
   */
  fit(rectangle) {
    const x1 = Math.max(this.x, rectangle.x), x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.max(this.y, rectangle.y), y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    return this.x = x1, this.width = Math.max(x2 - x1, 0), this.y = y1, this.height = Math.max(y2 - y1, 0), this;
  }
  /**
   * Enlarges rectangle that way its corners lie on grid
   * @param resolution - resolution
   * @param eps - precision
   * @returns Returns itself.
   */
  ceil(resolution = 1, eps = 1e-3) {
    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution, y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    return this.x = Math.floor((this.x + eps) * resolution) / resolution, this.y = Math.floor((this.y + eps) * resolution) / resolution, this.width = x2 - this.x, this.height = y2 - this.y, this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   * @param rectangle - The rectangle to include.
   * @returns Returns itself.
   */
  enlarge(rectangle) {
    const x1 = Math.min(this.x, rectangle.x), x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.min(this.y, rectangle.y), y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    return this.x = x1, this.width = x2 - x1, this.y = y1, this.height = y2 - y1, this;
  }
}
Rectangle.prototype.toString = function() {
  return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
};
exports.Rectangle = Rectangle;
//# sourceMappingURL=Rectangle.js.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/shapes/RoundedRectangle.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/math/lib/shapes/RoundedRectangle.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/@pixi/math/lib/const.js");
class RoundedRectangle {
  /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */
  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {
    this.x = x, this.y = y, this.width = width, this.height = height, this.radius = radius, this.type = _const.SHAPES.RREC;
  }
  /**
   * Creates a clone of this Rounded Rectangle.
   * @returns - A copy of the rounded rectangle.
   */
  clone() {
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
   */
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    if (x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height) {
      const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
      if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius)
        return !0;
      let dx = x - (this.x + radius), dy = y - (this.y + radius);
      const radius2 = radius * radius;
      if (dx * dx + dy * dy <= radius2 || (dx = x - (this.x + this.width - radius), dx * dx + dy * dy <= radius2) || (dy = y - (this.y + this.height - radius), dx * dx + dy * dy <= radius2) || (dx = x - (this.x + radius), dx * dx + dy * dy <= radius2))
        return !0;
    }
    return !1;
  }
}
RoundedRectangle.prototype.toString = function() {
  return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
};
exports.RoundedRectangle = RoundedRectangle;
//# sourceMappingURL=RoundedRectangle.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/NineSlicePlane.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/NineSlicePlane.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), SimplePlane = __webpack_require__(/*! ./SimplePlane.js */ "./node_modules/@pixi/mesh-extras/lib/SimplePlane.js");
const DEFAULT_BORDER_SIZE = 10;
class NineSlicePlane extends SimplePlane.SimplePlane {
  /**
   * @param texture - The texture to use on the NineSlicePlane.
   * @param {number} [leftWidth=10] - size of the left vertical bar (A)
   * @param {number} [topHeight=10] - size of the top horizontal bar (C)
   * @param {number} [rightWidth=10] - size of the right vertical bar (B)
   * @param {number} [bottomHeight=10] - size of the bottom horizontal bar (D)
   */
  constructor(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
    super(core.Texture.WHITE, 4, 4), this._origWidth = texture.orig.width, this._origHeight = texture.orig.height, this._width = this._origWidth, this._height = this._origHeight, this._leftWidth = leftWidth ?? texture.defaultBorders?.left ?? DEFAULT_BORDER_SIZE, this._rightWidth = rightWidth ?? texture.defaultBorders?.right ?? DEFAULT_BORDER_SIZE, this._topHeight = topHeight ?? texture.defaultBorders?.top ?? DEFAULT_BORDER_SIZE, this._bottomHeight = bottomHeight ?? texture.defaultBorders?.bottom ?? DEFAULT_BORDER_SIZE, this.texture = texture;
  }
  textureUpdated() {
    this._textureID = this.shader.texture._updateID, this._refresh();
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  /** Updates the horizontal vertices. */
  updateHorizontalVertices() {
    const vertices = this.vertices, scale = this._getMinScale();
    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale, vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale, vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
  }
  /** Updates the vertical vertices. */
  updateVerticalVertices() {
    const vertices = this.vertices, scale = this._getMinScale();
    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale, vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale, vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
  }
  /**
   * Returns the smaller of a set of vertical and horizontal scale of nine slice corners.
   * @returns Smaller number of vertical and horizontal scale.
   */
  _getMinScale() {
    const w = this._leftWidth + this._rightWidth, scaleW = this._width > w ? 1 : this._width / w, h = this._topHeight + this._bottomHeight, scaleH = this._height > h ? 1 : this._height / h;
    return Math.min(scaleW, scaleH);
  }
  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value, this._refresh();
  }
  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value, this._refresh();
  }
  /** The width of the left column. */
  get leftWidth() {
    return this._leftWidth;
  }
  set leftWidth(value) {
    this._leftWidth = value, this._refresh();
  }
  /** The width of the right column. */
  get rightWidth() {
    return this._rightWidth;
  }
  set rightWidth(value) {
    this._rightWidth = value, this._refresh();
  }
  /** The height of the top row. */
  get topHeight() {
    return this._topHeight;
  }
  set topHeight(value) {
    this._topHeight = value, this._refresh();
  }
  /** The height of the bottom row. */
  get bottomHeight() {
    return this._bottomHeight;
  }
  set bottomHeight(value) {
    this._bottomHeight = value, this._refresh();
  }
  /** Refreshes NineSlicePlane coords. All of them. */
  _refresh() {
    const texture = this.texture, uvs = this.geometry.buffers[1].data;
    this._origWidth = texture.orig.width, this._origHeight = texture.orig.height;
    const _uvw = 1 / this._origWidth, _uvh = 1 / this._origHeight;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0, uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0, uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1, uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1, uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth, uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth, uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight, uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();
  }
}
exports.NineSlicePlane = NineSlicePlane;
//# sourceMappingURL=NineSlicePlane.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/SimpleMesh.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/SimpleMesh.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.js");
class SimpleMesh extends mesh.Mesh {
  /**
   * @param texture - The texture to use
   * @param {Float32Array} [vertices] - if you want to specify the vertices
   * @param {Float32Array} [uvs] - if you want to specify the uvs
   * @param {Uint16Array} [indices] - if you want to specify the indices
   * @param drawMode - the drawMode, can be any of the Mesh.DRAW_MODES consts
   */
  constructor(texture = core.Texture.EMPTY, vertices, uvs, indices, drawMode) {
    const geometry = new mesh.MeshGeometry(vertices, uvs, indices);
    geometry.getBuffer("aVertexPosition").static = !1;
    const meshMaterial = new mesh.MeshMaterial(texture);
    super(geometry, meshMaterial, null, drawMode), this.autoUpdate = !0;
  }
  /**
   * Collection of vertices data.
   * @type {Float32Array}
   */
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  _render(renderer) {
    this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), super._render(renderer);
  }
}
exports.SimpleMesh = SimpleMesh;
//# sourceMappingURL=SimpleMesh.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/SimplePlane.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/SimplePlane.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.js"), PlaneGeometry = __webpack_require__(/*! ./geometry/PlaneGeometry.js */ "./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.js");
class SimplePlane extends mesh.Mesh {
  /**
   * @param texture - The texture to use on the SimplePlane.
   * @param verticesX - The number of vertices in the x-axis
   * @param verticesY - The number of vertices in the y-axis
   */
  constructor(texture, verticesX, verticesY) {
    const planeGeometry = new PlaneGeometry.PlaneGeometry(texture.width, texture.height, verticesX, verticesY), meshMaterial = new mesh.MeshMaterial(core.Texture.WHITE);
    super(planeGeometry, meshMaterial), this.texture = texture, this.autoResize = !0;
  }
  /**
   * Method used for overrides, to do something in case texture frame was changed.
   * Meshes based on plane can override it and change more details based on texture.
   */
  textureUpdated() {
    this._textureID = this.shader.texture._updateID;
    const geometry = this.geometry, { width, height } = this.shader.texture;
    this.autoResize && (geometry.width !== width || geometry.height !== height) && (geometry.width = this.shader.texture.width, geometry.height = this.shader.texture.height, geometry.build());
  }
  set texture(value) {
    this.shader.texture !== value && (this.shader.texture = value, this._textureID = -1, value.baseTexture.valid ? this.textureUpdated() : value.once("update", this.textureUpdated, this));
  }
  get texture() {
    return this.shader.texture;
  }
  _render(renderer) {
    this._textureID !== this.shader.texture._updateID && this.textureUpdated(), super._render(renderer);
  }
  destroy(options) {
    this.shader.texture.off("update", this.textureUpdated, this), super.destroy(options);
  }
}
exports.SimplePlane = SimplePlane;
//# sourceMappingURL=SimplePlane.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/SimpleRope.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/SimpleRope.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.js"), RopeGeometry = __webpack_require__(/*! ./geometry/RopeGeometry.js */ "./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.js");
class SimpleRope extends mesh.Mesh {
  /**
   * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.
   * @param texture - The texture to use on the rope.
   * @param points - An array of {@link PIXI.Point} objects to construct this rope.
   * @param {number} textureScale - Optional. Positive values scale rope texture
   * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture
   * and downsampling here. If set to zero, texture will be stretched instead.
   */
  constructor(texture, points, textureScale = 0) {
    const ropeGeometry = new RopeGeometry.RopeGeometry(texture.height, points, textureScale), meshMaterial = new mesh.MeshMaterial(texture);
    textureScale > 0 && (texture.baseTexture.wrapMode = core.WRAP_MODES.REPEAT), super(ropeGeometry, meshMaterial), this.autoUpdate = !0;
  }
  _render(renderer) {
    const geometry = this.geometry;
    (this.autoUpdate || geometry._width !== this.shader.texture.height) && (geometry._width = this.shader.texture.height, geometry.update()), super._render(renderer);
  }
}
exports.SimpleRope = SimpleRope;
//# sourceMappingURL=SimpleRope.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.js");
class PlaneGeometry extends mesh.MeshGeometry {
  /**
   * @param width - The width of the plane.
   * @param height - The height of the plane.
   * @param segWidth - Number of horizontal segments.
   * @param segHeight - Number of vertical segments.
   */
  constructor(width = 100, height = 100, segWidth = 10, segHeight = 10) {
    super(), this.segWidth = segWidth, this.segHeight = segHeight, this.width = width, this.height = height, this.build();
  }
  /**
   * Refreshes plane coordinates
   * @private
   */
  build() {
    const total = this.segWidth * this.segHeight, verts = [], uvs = [], indices = [], segmentsX = this.segWidth - 1, segmentsY = this.segHeight - 1, sizeX = this.width / segmentsX, sizeY = this.height / segmentsY;
    for (let i = 0; i < total; i++) {
      const x = i % this.segWidth, y = i / this.segWidth | 0;
      verts.push(x * sizeX, y * sizeY), uvs.push(x / segmentsX, y / segmentsY);
    }
    const totalSub = segmentsX * segmentsY;
    for (let i = 0; i < totalSub; i++) {
      const xpos = i % segmentsX, ypos = i / segmentsX | 0, value = ypos * this.segWidth + xpos, value2 = ypos * this.segWidth + xpos + 1, value3 = (ypos + 1) * this.segWidth + xpos, value4 = (ypos + 1) * this.segWidth + xpos + 1;
      indices.push(
        value,
        value2,
        value3,
        value2,
        value4,
        value3
      );
    }
    this.buffers[0].data = new Float32Array(verts), this.buffers[1].data = new Float32Array(uvs), this.indexBuffer.data = new Uint16Array(indices), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
  }
}
exports.PlaneGeometry = PlaneGeometry;
//# sourceMappingURL=PlaneGeometry.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.js");
class RopeGeometry extends mesh.MeshGeometry {
  /**
   * @param width - The width (i.e., thickness) of the rope.
   * @param points - An array of {@link PIXI.Point} objects to construct this rope.
   * @param textureScale - By default the rope texture will be stretched to match
   *     rope length. If textureScale is positive this value will be treated as a scaling
   *     factor and the texture will preserve its aspect ratio instead. To create a tiling rope
   *     set baseTexture.wrapMode to {@link PIXI.WRAP_MODES.REPEAT} and use a power of two texture,
   *     then set textureScale=1 to keep the original texture pixel size.
   *     In order to reduce alpha channel artifacts provide a larger texture and downsample -
   *     i.e. set textureScale=0.5 to scale it down twice.
   */
  constructor(width = 200, points, textureScale = 0) {
    super(
      new Float32Array(points.length * 4),
      new Float32Array(points.length * 4),
      new Uint16Array((points.length - 1) * 6)
    ), this.points = points, this._width = width, this.textureScale = textureScale, this.build();
  }
  /**
   * The width (i.e., thickness) of the rope.
   * @readonly
   */
  get width() {
    return this._width;
  }
  /** Refreshes Rope indices and uvs */
  build() {
    const points = this.points;
    if (!points)
      return;
    const vertexBuffer = this.getBuffer("aVertexPosition"), uvBuffer = this.getBuffer("aTextureCoord"), indexBuffer = this.getIndex();
    if (points.length < 1)
      return;
    vertexBuffer.data.length / 4 !== points.length && (vertexBuffer.data = new Float32Array(points.length * 4), uvBuffer.data = new Float32Array(points.length * 4), indexBuffer.data = new Uint16Array((points.length - 1) * 6));
    const uvs = uvBuffer.data, indices = indexBuffer.data;
    uvs[0] = 0, uvs[1] = 0, uvs[2] = 0, uvs[3] = 1;
    let amount = 0, prev = points[0];
    const textureWidth = this._width * this.textureScale, total = points.length;
    for (let i = 0; i < total; i++) {
      const index = i * 4;
      if (this.textureScale > 0) {
        const dx = prev.x - points[i].x, dy = prev.y - points[i].y, distance = Math.sqrt(dx * dx + dy * dy);
        prev = points[i], amount += distance / textureWidth;
      } else
        amount = i / (total - 1);
      uvs[index] = amount, uvs[index + 1] = 0, uvs[index + 2] = amount, uvs[index + 3] = 1;
    }
    let indexCount = 0;
    for (let i = 0; i < total - 1; i++) {
      const index = i * 2;
      indices[indexCount++] = index, indices[indexCount++] = index + 1, indices[indexCount++] = index + 2, indices[indexCount++] = index + 2, indices[indexCount++] = index + 1, indices[indexCount++] = index + 3;
    }
    uvBuffer.update(), indexBuffer.update(), this.updateVertices();
  }
  /** refreshes vertices of Rope mesh */
  updateVertices() {
    const points = this.points;
    if (points.length < 1)
      return;
    let lastPoint = points[0], nextPoint, perpX = 0, perpY = 0;
    const vertices = this.buffers[0].data, total = points.length, halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
    for (let i = 0; i < total; i++) {
      const point = points[i], index = i * 4;
      i < points.length - 1 ? nextPoint = points[i + 1] : nextPoint = point, perpY = -(nextPoint.x - lastPoint.x), perpX = nextPoint.y - lastPoint.y;
      let ratio = (1 - i / (total - 1)) * 10;
      ratio > 1 && (ratio = 1);
      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
      perpLength < 1e-6 ? (perpX = 0, perpY = 0) : (perpX /= perpLength, perpY /= perpLength, perpX *= halfWidth, perpY *= halfWidth), vertices[index] = point.x + perpX, vertices[index + 1] = point.y + perpY, vertices[index + 2] = point.x - perpX, vertices[index + 3] = point.y - perpY, lastPoint = point;
    }
    this.buffers[0].update();
  }
  update() {
    this.textureScale > 0 ? this.build() : this.updateVertices();
  }
}
exports.RopeGeometry = RopeGeometry;
//# sourceMappingURL=RopeGeometry.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var PlaneGeometry = __webpack_require__(/*! ./geometry/PlaneGeometry.js */ "./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.js"), RopeGeometry = __webpack_require__(/*! ./geometry/RopeGeometry.js */ "./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.js"), NineSlicePlane = __webpack_require__(/*! ./NineSlicePlane.js */ "./node_modules/@pixi/mesh-extras/lib/NineSlicePlane.js"), SimpleMesh = __webpack_require__(/*! ./SimpleMesh.js */ "./node_modules/@pixi/mesh-extras/lib/SimpleMesh.js"), SimplePlane = __webpack_require__(/*! ./SimplePlane.js */ "./node_modules/@pixi/mesh-extras/lib/SimplePlane.js"), SimpleRope = __webpack_require__(/*! ./SimpleRope.js */ "./node_modules/@pixi/mesh-extras/lib/SimpleRope.js");
exports.PlaneGeometry = PlaneGeometry.PlaneGeometry;
exports.RopeGeometry = RopeGeometry.RopeGeometry;
exports.NineSlicePlane = NineSlicePlane.NineSlicePlane;
exports.SimpleMesh = SimpleMesh.SimpleMesh;
exports.SimplePlane = SimplePlane.SimplePlane;
exports.SimpleRope = SimpleRope.SimpleRope;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh/lib/Mesh.js":
/*!*********************************************!*\
  !*** ./node_modules/@pixi/mesh/lib/Mesh.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), display = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.js"), MeshBatchUvs = __webpack_require__(/*! ./MeshBatchUvs.js */ "./node_modules/@pixi/mesh/lib/MeshBatchUvs.js");
const tempPoint = new core.Point(), tempPolygon = new core.Polygon(), _Mesh = class _Mesh2 extends display.Container {
  /**
   * @param geometry - The geometry the mesh will use.
   * @param {PIXI.MeshMaterial} shader - The shader the mesh will use.
   * @param state - The state that the WebGL context is required to be in to render the mesh
   *        if no state is provided, uses {@link PIXI.State.for2d} to create a 2D state for PixiJS.
   * @param drawMode - The drawMode, can be any of the {@link PIXI.DRAW_MODES} constants.
   */
  constructor(geometry, shader, state, drawMode = core.DRAW_MODES.TRIANGLES) {
    super(), this.geometry = geometry, this.shader = shader, this.state = state || core.State.for2d(), this.drawMode = drawMode, this.start = 0, this.size = 0, this.uvs = null, this.indices = null, this.vertexData = new Float32Array(1), this.vertexDirty = -1, this._transformID = -1, this._roundPixels = core.settings.ROUND_PIXELS, this.batchUvs = null;
  }
  /**
   * Includes vertex positions, face indices, normals, colors, UVs, and
   * custom attributes within buffers, reducing the cost of passing all
   * this data to the GPU. Can be shared between multiple Mesh objects.
   */
  get geometry() {
    return this._geometry;
  }
  set geometry(value) {
    this._geometry !== value && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = value, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);
  }
  /**
   * To change mesh uv's, change its uvBuffer data and increment its _updateID.
   * @readonly
   */
  get uvBuffer() {
    return this.geometry.buffers[1];
  }
  /**
   * To change mesh vertices, change its uvBuffer data and increment its _updateID.
   * Incrementing _updateID is optional because most of Mesh objects do it anyway.
   * @readonly
   */
  get verticesBuffer() {
    return this.geometry.buffers[0];
  }
  /** Alias for {@link PIXI.Mesh#shader}. */
  set material(value) {
    this.shader = value;
  }
  get material() {
    return this.shader;
  }
  /**
   * The blend mode to be applied to the Mesh. Apply a value of
   * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
   * @default PIXI.BLEND_MODES.NORMAL;
   */
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
   * @default false
   */
  set roundPixels(value) {
    this._roundPixels !== value && (this._transformID = -1), this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  /**
   * The multiply tint applied to the Mesh. This is a hex value. A value of
   * `0xFFFFFF` will remove any tint effect.
   *
   * Null for non-MeshMaterial shaders
   * @default 0xFFFFFF
   */
  get tint() {
    return "tint" in this.shader ? this.shader.tint : null;
  }
  set tint(value) {
    this.shader.tint = value;
  }
  /**
   * The tint color as a RGB integer
   * @ignore
   */
  get tintValue() {
    return this.shader.tintValue;
  }
  /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
  get texture() {
    return "texture" in this.shader ? this.shader.texture : null;
  }
  set texture(value) {
    this.shader.texture = value;
  }
  /**
   * Standard renderer draw.
   * @param renderer - Instance to renderer.
   */
  _render(renderer) {
    const vertices = this.geometry.buffers[0].data;
    this.shader.batchable && this.drawMode === core.DRAW_MODES.TRIANGLES && vertices.length < _Mesh2.BATCHABLE_SIZE * 2 ? this._renderToBatch(renderer) : this._renderDefault(renderer);
  }
  /**
   * Standard non-batching way of rendering.
   * @param renderer - Instance to renderer.
   */
  _renderDefault(renderer) {
    const shader = this.shader;
    shader.alpha = this.worldAlpha, shader.update && shader.update(), renderer.batch.flush(), shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), renderer.shader.bind(shader), renderer.state.set(this.state), renderer.geometry.bind(this.geometry, shader), renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  }
  /**
   * Rendering by using the Batch system.
   * @param renderer - Instance to renderer.
   */
  _renderToBatch(renderer) {
    const geometry = this.geometry, shader = this.shader;
    shader.uvMatrix && (shader.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = geometry.indexBuffer.data, this._tintRGB = shader._tintRGB, this._texture = shader.texture;
    const pluginName = this.material.pluginName;
    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]), renderer.plugins[pluginName].render(this);
  }
  /** Updates vertexData field based on transform and vertices. */
  calculateVertices() {
    const verticesBuffer = this.geometry.buffers[0], vertices = verticesBuffer.data, vertexDirtyId = verticesBuffer._updateID;
    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID)
      return;
    this._transformID = this.transform._worldID, this.vertexData.length !== vertices.length && (this.vertexData = new Float32Array(vertices.length));
    const wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty, vertexData = this.vertexData;
    for (let i = 0; i < vertexData.length / 2; i++) {
      const x = vertices[i * 2], y = vertices[i * 2 + 1];
      vertexData[i * 2] = a * x + c * y + tx, vertexData[i * 2 + 1] = b * x + d * y + ty;
    }
    if (this._roundPixels) {
      const resolution = core.settings.RESOLUTION;
      for (let i = 0; i < vertexData.length; ++i)
        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
    }
    this.vertexDirty = vertexDirtyId;
  }
  /** Updates uv field based on from geometry uv's or batchUvs. */
  calculateUvs() {
    const geomUvs = this.geometry.buffers[1], shader = this.shader;
    shader.uvMatrix.isSimple ? this.uvs = geomUvs.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs.MeshBatchUvs(geomUvs, shader.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);
  }
  /**
   * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
   * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.
   */
  _calculateBounds() {
    this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  }
  /**
   * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.
   * @param point - The point to test.
   * @returns - The result of the test.
   */
  containsPoint(point) {
    if (!this.getBounds().contains(point.x, point.y))
      return !1;
    this.worldTransform.applyInverse(point, tempPoint);
    const vertices = this.geometry.getBuffer("aVertexPosition").data, points = tempPolygon.points, indices = this.geometry.getIndex().data, len = indices.length, step = this.drawMode === 4 ? 3 : 1;
    for (let i = 0; i + 2 < len; i += step) {
      const ind0 = indices[i] * 2, ind1 = indices[i + 1] * 2, ind2 = indices[i + 2] * 2;
      if (points[0] = vertices[ind0], points[1] = vertices[ind0 + 1], points[2] = vertices[ind1], points[3] = vertices[ind1 + 1], points[4] = vertices[ind2], points[5] = vertices[ind2 + 1], tempPolygon.contains(tempPoint.x, tempPoint.y))
        return !0;
    }
    return !1;
  }
  destroy(options) {
    super.destroy(options), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;
  }
};
_Mesh.BATCHABLE_SIZE = 100;
let Mesh = _Mesh;
exports.Mesh = Mesh;
//# sourceMappingURL=Mesh.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh/lib/MeshBatchUvs.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/mesh/lib/MeshBatchUvs.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class MeshBatchUvs {
  /**
   * @param uvBuffer - Buffer with normalized uv's
   * @param uvMatrix - Material UV matrix
   */
  constructor(uvBuffer, uvMatrix) {
    this.uvBuffer = uvBuffer, this.uvMatrix = uvMatrix, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;
  }
  /**
   * Updates
   * @param forceUpdate - force the update
   */
  update(forceUpdate) {
    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)
      return;
    this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
    const data = this.uvBuffer.data;
    (!this.data || this.data.length !== data.length) && (this.data = new Float32Array(data.length)), this.uvMatrix.multiplyUvs(data, this.data), this._updateID++;
  }
}
exports.MeshBatchUvs = MeshBatchUvs;
//# sourceMappingURL=MeshBatchUvs.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh/lib/MeshGeometry.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/mesh/lib/MeshGeometry.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
class MeshGeometry extends core.Geometry {
  /**
   * @param {Float32Array|number[]} [vertices] - Positional data on geometry.
   * @param {Float32Array|number[]} [uvs] - Texture UVs.
   * @param {Uint16Array|number[]} [index] - IndexBuffer
   */
  constructor(vertices, uvs, index) {
    super();
    const verticesBuffer = new core.Buffer(vertices), uvsBuffer = new core.Buffer(uvs, !0), indexBuffer = new core.Buffer(index, !0, !0);
    this.addAttribute("aVertexPosition", verticesBuffer, 2, !1, core.TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, !1, core.TYPES.FLOAT).addIndex(indexBuffer), this._updateId = -1;
  }
  /**
   * If the vertex position is updated.
   * @readonly
   * @private
   */
  get vertexDirtyId() {
    return this.buffers[0]._updateID;
  }
}
exports.MeshGeometry = MeshGeometry;
//# sourceMappingURL=MeshGeometry.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh/lib/MeshMaterial.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/mesh/lib/MeshMaterial.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), mesh$1 = __webpack_require__(/*! ./shader/mesh.frag.js */ "./node_modules/@pixi/mesh/lib/shader/mesh.frag.js"), mesh = __webpack_require__(/*! ./shader/mesh.vert.js */ "./node_modules/@pixi/mesh/lib/shader/mesh.vert.js");
class MeshMaterial extends core.Shader {
  /**
   * @param uSampler - Texture that material uses to render.
   * @param options - Additional options
   * @param {number} [options.alpha=1] - Default alpha.
   * @param {PIXI.ColorSource} [options.tint=0xFFFFFF] - Default tint.
   * @param {string} [options.pluginName='batch'] - Renderer plugin for batching.
   * @param {PIXI.Program} [options.program=0xFFFFFF] - Custom program.
   * @param {object} [options.uniforms] - Custom uniforms.
   */
  constructor(uSampler, options) {
    const uniforms = {
      uSampler,
      alpha: 1,
      uTextureMatrix: core.Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    options = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, options), options.uniforms && Object.assign(uniforms, options.uniforms), super(options.program || core.Program.from(mesh.default, mesh$1.default), uniforms), this._colorDirty = !1, this.uvMatrix = new core.TextureMatrix(uSampler), this.batchable = options.program === void 0, this.pluginName = options.pluginName, this._tintColor = new core.Color(options.tint), this._tintRGB = this._tintColor.toLittleEndianNumber(), this._colorDirty = !0, this.alpha = options.alpha;
  }
  /** Reference to the texture being rendered. */
  get texture() {
    return this.uniforms.uSampler;
  }
  set texture(value) {
    this.uniforms.uSampler !== value && (!this.uniforms.uSampler.baseTexture.alphaMode != !value.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = value, this.uvMatrix.texture = value);
  }
  /**
   * This gets automatically set by the object using this.
   * @default 1
   */
  set alpha(value) {
    value !== this._alpha && (this._alpha = value, this._colorDirty = !0);
  }
  get alpha() {
    return this._alpha;
  }
  /**
   * Multiply tint for the material.
   * @default 0xFFFFFF
   */
  set tint(value) {
    value !== this.tint && (this._tintColor.setValue(value), this._tintRGB = this._tintColor.toLittleEndianNumber(), this._colorDirty = !0);
  }
  get tint() {
    return this._tintColor.value;
  }
  /**
   * Get the internal number from tint color
   * @ignore
   */
  get tintValue() {
    return this._tintColor.toNumber();
  }
  /** Gets called automatically by the Mesh. Intended to be overridden for custom {@link PIXI.MeshMaterial} objects. */
  update() {
    if (this._colorDirty) {
      this._colorDirty = !1;
      const applyToChannels = this.texture.baseTexture.alphaMode;
      core.Color.shared.setValue(this._tintColor).premultiply(this._alpha, applyToChannels).toArray(this.uniforms.uColor);
    }
    this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
  }
}
exports.MeshMaterial = MeshMaterial;
//# sourceMappingURL=MeshMaterial.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/mesh/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Mesh = __webpack_require__(/*! ./Mesh.js */ "./node_modules/@pixi/mesh/lib/Mesh.js"), MeshBatchUvs = __webpack_require__(/*! ./MeshBatchUvs.js */ "./node_modules/@pixi/mesh/lib/MeshBatchUvs.js"), MeshGeometry = __webpack_require__(/*! ./MeshGeometry.js */ "./node_modules/@pixi/mesh/lib/MeshGeometry.js"), MeshMaterial = __webpack_require__(/*! ./MeshMaterial.js */ "./node_modules/@pixi/mesh/lib/MeshMaterial.js");
exports.Mesh = Mesh.Mesh;
exports.MeshBatchUvs = MeshBatchUvs.MeshBatchUvs;
exports.MeshGeometry = MeshGeometry.MeshGeometry;
exports.MeshMaterial = MeshMaterial.MeshMaterial;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh/lib/shader/mesh.frag.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/mesh/lib/shader/mesh.frag.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var fragment = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`;
exports["default"] = fragment;
//# sourceMappingURL=mesh.frag.js.map


/***/ }),

/***/ "./node_modules/@pixi/mesh/lib/shader/mesh.vert.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/mesh/lib/shader/mesh.vert.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var vertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`;
exports["default"] = vertex;
//# sourceMappingURL=mesh.vert.js.map


/***/ }),

/***/ "./node_modules/@pixi/mixin-cache-as-bitmap/lib/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/mixin-cache-as-bitmap/lib/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), display = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.js"), sprite = __webpack_require__(/*! @pixi/sprite */ "./node_modules/@pixi/sprite/lib/index.js");
const _tempMatrix = new core.Matrix();
display.DisplayObject.prototype._cacheAsBitmap = !1;
display.DisplayObject.prototype._cacheData = null;
display.DisplayObject.prototype._cacheAsBitmapResolution = null;
display.DisplayObject.prototype._cacheAsBitmapMultisample = null;
class CacheData {
  constructor() {
    this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;
  }
}
Object.defineProperties(display.DisplayObject.prototype, {
  /**
   * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution
   * but can be overriden for performance. Lower values will reduce memory usage at the expense
   * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.
   * @member {number|null} cacheAsBitmapResolution
   * @memberof PIXI.DisplayObject#
   * @default null
   */
  cacheAsBitmapResolution: {
    get() {
      return this._cacheAsBitmapResolution;
    },
    set(resolution) {
      resolution !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = resolution, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  /**
   * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's
   * sample count is used.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.
   * @member {number|null} cacheAsBitmapMultisample
   * @memberof PIXI.DisplayObject#
   * @default null
   */
  cacheAsBitmapMultisample: {
    get() {
      return this._cacheAsBitmapMultisample;
    },
    set(multisample) {
      multisample !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = multisample, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  /**
   * Set this to true if you want this display object to be cached as a bitmap.
   * This basically takes a snapshot of the display object as it is at that moment. It can
   * provide a performance benefit for complex static displayObjects.
   * To remove simply set this property to `false`
   *
   * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
   * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  cacheAsBitmap: {
    get() {
      return this._cacheAsBitmap;
    },
    set(value) {
      if (this._cacheAsBitmap === value)
        return;
      this._cacheAsBitmap = value;
      let data;
      value ? (this._cacheData || (this._cacheData = new CacheData()), data = this._cacheData, data.originalRender = this.render, data.originalRenderCanvas = this.renderCanvas, data.originalUpdateTransform = this.updateTransform, data.originalCalculateBounds = this.calculateBounds, data.originalGetLocalBounds = this.getLocalBounds, data.originalDestroy = this.destroy, data.originalContainsPoint = this.containsPoint, data.originalMask = this._mask, data.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (data = this._cacheData, data.sprite && this._destroyCachedDisplayObject(), this.render = data.originalRender, this.renderCanvas = data.originalRenderCanvas, this.calculateBounds = data.originalCalculateBounds, this.getLocalBounds = data.originalGetLocalBounds, this.destroy = data.originalDestroy, this.updateTransform = data.originalUpdateTransform, this.containsPoint = data.originalContainsPoint, this._mask = data.originalMask, this.filterArea = data.originalFilterArea);
    }
  }
});
display.DisplayObject.prototype._renderCached = function(renderer) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(renderer), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(renderer));
};
display.DisplayObject.prototype._initCachedDisplayObject = function(renderer) {
  if (this._cacheData?.sprite)
    return;
  const cacheAlpha = this.alpha;
  this.alpha = 1, renderer.batch.flush();
  const bounds = this.getLocalBounds(new core.Rectangle(), !0);
  if (this.filters?.length) {
    const padding = this.filters[0].padding;
    bounds.pad(padding);
  }
  const resolution = this.cacheAsBitmapResolution || renderer.resolution;
  bounds.ceil(resolution), bounds.width = Math.max(bounds.width, 1 / resolution), bounds.height = Math.max(bounds.height, 1 / resolution);
  const cachedRenderTexture = renderer.renderTexture.current, cachedSourceFrame = renderer.renderTexture.sourceFrame.clone(), cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone(), cachedProjectionTransform = renderer.projection.transform, renderTexture = core.RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution,
    multisample: this.cacheAsBitmapMultisample ?? renderer.multisample
  }), textureCacheId = `cacheAsBitmap_${core.utils.uid()}`;
  this._cacheData.textureCacheId = textureCacheId, core.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId), core.Texture.addToCache(renderTexture, textureCacheId);
  const m = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
  this.render = this._cacheData.originalRender, renderer.render(this, { renderTexture, clear: !0, transform: m, skipUpdateTransform: !1 }), renderer.framebuffer.blit(), renderer.projection.transform = cachedProjectionTransform, renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = cacheAlpha;
  const cachedSprite = new sprite.Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform, cachedSprite.anchor.x = -(bounds.x / bounds.width), cachedSprite.anchor.y = -(bounds.y / bounds.height), cachedSprite.alpha = cacheAlpha, cachedSprite._bounds = this._bounds, this._cacheData.sprite = cachedSprite, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
display.DisplayObject.prototype._renderCachedCanvas = function(renderer) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(renderer), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(renderer));
};
display.DisplayObject.prototype._initCachedDisplayObjectCanvas = function(renderer) {
  if (this._cacheData?.sprite)
    return;
  const bounds = this.getLocalBounds(new core.Rectangle(), !0), cacheAlpha = this.alpha;
  this.alpha = 1;
  const cachedRenderTarget = renderer.canvasContext.activeContext, cachedProjectionTransform = renderer._projTransform, resolution = this.cacheAsBitmapResolution || renderer.resolution;
  bounds.ceil(resolution), bounds.width = Math.max(bounds.width, 1 / resolution), bounds.height = Math.max(bounds.height, 1 / resolution);
  const renderTexture = core.RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution
  }), textureCacheId = `cacheAsBitmap_${core.utils.uid()}`;
  this._cacheData.textureCacheId = textureCacheId, core.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId), core.Texture.addToCache(renderTexture, textureCacheId);
  const m = _tempMatrix;
  this.transform.localTransform.copyTo(m), m.invert(), m.tx -= bounds.x, m.ty -= bounds.y, this.renderCanvas = this._cacheData.originalRenderCanvas, renderer.render(this, { renderTexture, clear: !0, transform: m, skipUpdateTransform: !1 }), renderer.canvasContext.activeContext = cachedRenderTarget, renderer._projTransform = cachedProjectionTransform, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = cacheAlpha;
  const cachedSprite = new sprite.Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform, cachedSprite.anchor.x = -(bounds.x / bounds.width), cachedSprite.anchor.y = -(bounds.y / bounds.height), cachedSprite.alpha = cacheAlpha, cachedSprite._bounds = this._bounds, this._cacheData.sprite = cachedSprite, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = renderer._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
display.DisplayObject.prototype._calculateCachedBounds = function() {
  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;
};
display.DisplayObject.prototype._getCachedLocalBounds = function() {
  return this._cacheData.sprite.getLocalBounds(null);
};
display.DisplayObject.prototype._destroyCachedDisplayObject = function() {
  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, core.BaseTexture.removeFromCache(this._cacheData.textureCacheId), core.Texture.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;
};
display.DisplayObject.prototype._cacheAsBitmapDestroy = function(options) {
  this.cacheAsBitmap = !1, this.destroy(options);
};
exports.CacheData = CacheData;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/mixin-get-child-by-name/lib/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/mixin-get-child-by-name/lib/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var display = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.js");
display.DisplayObject.prototype.name = null;
display.Container.prototype.getChildByName = function(name, deep) {
  for (let i = 0, j = this.children.length; i < j; i++)
    if (this.children[i].name === name)
      return this.children[i];
  if (deep)
    for (let i = 0, j = this.children.length; i < j; i++) {
      const child = this.children[i];
      if (!child.getChildByName)
        continue;
      const target = child.getChildByName(name, !0);
      if (target)
        return target;
    }
  return null;
};
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/mixin-get-global-position/lib/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/mixin-get-global-position/lib/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), display = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.js");
display.DisplayObject.prototype.getGlobalPosition = function(point = new core.Point(), skipUpdate = !1) {
  return this.parent ? this.parent.toGlobal(this.position, point, skipUpdate) : (point.x = this.position.x, point.y = this.position.y), point;
};
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/particle-container/lib/ParticleBuffer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/particle-container/lib/ParticleBuffer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
class ParticleBuffer {
  /**
   * @param {object} properties - The properties to upload.
   * @param {boolean[]} dynamicPropertyFlags - Flags for which properties are dynamic.
   * @param {number} size - The size of the batch.
   */
  constructor(properties, dynamicPropertyFlags, size) {
    this.geometry = new core.Geometry(), this.indexBuffer = null, this.size = size, this.dynamicProperties = [], this.staticProperties = [];
    for (let i = 0; i < properties.length; ++i) {
      let property = properties[i];
      property = {
        attributeName: property.attributeName,
        size: property.size,
        uploadFunction: property.uploadFunction,
        type: property.type || core.TYPES.FLOAT,
        offset: property.offset
      }, dynamicPropertyFlags[i] ? this.dynamicProperties.push(property) : this.staticProperties.push(property);
    }
    this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();
  }
  /** Sets up the renderer context and necessary buffers. */
  initBuffers() {
    const geometry = this.geometry;
    let dynamicOffset = 0;
    this.indexBuffer = new core.Buffer(core.utils.createIndicesForQuads(this.size), !0, !0), geometry.addIndex(this.indexBuffer), this.dynamicStride = 0;
    for (let i = 0; i < this.dynamicProperties.length; ++i) {
      const property = this.dynamicProperties[i];
      property.offset = dynamicOffset, dynamicOffset += property.size, this.dynamicStride += property.size;
    }
    const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(dynBuffer), this.dynamicDataUint32 = new Uint32Array(dynBuffer), this.dynamicBuffer = new core.Buffer(this.dynamicData, !1, !1);
    let staticOffset = 0;
    this.staticStride = 0;
    for (let i = 0; i < this.staticProperties.length; ++i) {
      const property = this.staticProperties[i];
      property.offset = staticOffset, staticOffset += property.size, this.staticStride += property.size;
    }
    const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(statBuffer), this.staticDataUint32 = new Uint32Array(statBuffer), this.staticBuffer = new core.Buffer(this.staticData, !0, !1);
    for (let i = 0; i < this.dynamicProperties.length; ++i) {
      const property = this.dynamicProperties[i];
      geometry.addAttribute(
        property.attributeName,
        this.dynamicBuffer,
        0,
        property.type === core.TYPES.UNSIGNED_BYTE,
        property.type,
        this.dynamicStride * 4,
        property.offset * 4
      );
    }
    for (let i = 0; i < this.staticProperties.length; ++i) {
      const property = this.staticProperties[i];
      geometry.addAttribute(
        property.attributeName,
        this.staticBuffer,
        0,
        property.type === core.TYPES.UNSIGNED_BYTE,
        property.type,
        this.staticStride * 4,
        property.offset * 4
      );
    }
  }
  /**
   * Uploads the dynamic properties.
   * @param children - The children to upload.
   * @param startIndex - The index to start at.
   * @param amount - The number to upload.
   */
  uploadDynamic(children, startIndex, amount) {
    for (let i = 0; i < this.dynamicProperties.length; i++) {
      const property = this.dynamicProperties[i];
      property.uploadFunction(
        children,
        startIndex,
        amount,
        property.type === core.TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData,
        this.dynamicStride,
        property.offset
      );
    }
    this.dynamicBuffer._updateID++;
  }
  /**
   * Uploads the static properties.
   * @param children - The children to upload.
   * @param startIndex - The index to start at.
   * @param amount - The number to upload.
   */
  uploadStatic(children, startIndex, amount) {
    for (let i = 0; i < this.staticProperties.length; i++) {
      const property = this.staticProperties[i];
      property.uploadFunction(
        children,
        startIndex,
        amount,
        property.type === core.TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData,
        this.staticStride,
        property.offset
      );
    }
    this.staticBuffer._updateID++;
  }
  /** Destroys the ParticleBuffer. */
  destroy() {
    this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();
  }
}
exports.ParticleBuffer = ParticleBuffer;
//# sourceMappingURL=ParticleBuffer.js.map


/***/ }),

/***/ "./node_modules/@pixi/particle-container/lib/ParticleContainer.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/particle-container/lib/ParticleContainer.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), display = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.js");
class ParticleContainer extends display.Container {
  /**
   * @param maxSize - The maximum number of particles that can be rendered by the container.
   *  Affects size of allocated buffers.
   * @param properties - The properties of children that should be uploaded to the gpu and applied.
   * @param {boolean} [properties.vertices=false] - When true, vertices be uploaded and applied.
   *                  if sprite's ` scale/anchor/trim/frame/orig` is dynamic, please set `true`.
   * @param {boolean} [properties.position=true] - When true, position be uploaded and applied.
   * @param {boolean} [properties.rotation=false] - When true, rotation be uploaded and applied.
   * @param {boolean} [properties.uvs=false] - When true, uvs be uploaded and applied.
   * @param {boolean} [properties.tint=false] - When true, alpha and tint be uploaded and applied.
   * @param {number} [batchSize=16384] - Number of particles per batch. If less than maxSize, it uses maxSize instead.
   * @param {boolean} [autoResize=false] - If true, container allocates more batches in case
   *  there are more than `maxSize` particles.
   */
  constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = !1) {
    super();
    const maxBatchSize = 16384;
    batchSize > maxBatchSize && (batchSize = maxBatchSize), this._properties = [!1, !0, !1, !1, !1], this._maxSize = maxSize, this._batchSize = batchSize, this._buffers = null, this._bufferUpdateIDs = [], this._updateID = 0, this.interactiveChildren = !1, this.blendMode = core.BLEND_MODES.NORMAL, this.autoResize = autoResize, this.roundPixels = !0, this.baseTexture = null, this.setProperties(properties), this._tintColor = new core.Color(0), this.tintRgb = new Float32Array(3), this.tint = 16777215;
  }
  /**
   * Sets the private properties array to dynamic / static based on the passed properties object
   * @param properties - The properties to be uploaded
   */
  setProperties(properties) {
    properties && (this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0], this._properties[1] = "position" in properties ? !!properties.position : this._properties[1], this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2], this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3], this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4]);
  }
  updateTransform() {
    this.displayObjectUpdateTransform();
  }
  /**
   * The tint applied to the container. This is a hex value.
   * A value of 0xFFFFFF will remove any tint effect.
   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
   * @default 0xFFFFFF
   */
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value), this._tintColor.toRgbArray(this.tintRgb);
  }
  /**
   * Renders the container using the WebGL renderer.
   * @param renderer - The WebGL renderer.
   */
  render(renderer) {
    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", () => this.onChildrenChange(0))), renderer.batch.setObjectRenderer(renderer.plugins.particle), renderer.plugins.particle.render(this));
  }
  /**
   * Set the flag that static data should be updated to true
   * @param smallestChildIndex - The smallest child index.
   */
  onChildrenChange(smallestChildIndex) {
    const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
    for (; this._bufferUpdateIDs.length < bufferIndex; )
      this._bufferUpdateIDs.push(0);
    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
  }
  dispose() {
    if (this._buffers) {
      for (let i = 0; i < this._buffers.length; ++i)
        this._buffers[i].destroy();
      this._buffers = null;
    }
  }
  /**
   * Destroys the container
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.children=false] - if set to true, all the children will have their
   *  destroy method called as well. 'options' will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
   *  Should it destroy the texture of the child sprite
   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
   *  Should it destroy the base texture of the child sprite
   */
  destroy(options) {
    super.destroy(options), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;
  }
}
exports.ParticleContainer = ParticleContainer;
//# sourceMappingURL=ParticleContainer.js.map


/***/ }),

/***/ "./node_modules/@pixi/particle-container/lib/ParticleRenderer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/particle-container/lib/ParticleRenderer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), ParticleBuffer = __webpack_require__(/*! ./ParticleBuffer.js */ "./node_modules/@pixi/particle-container/lib/ParticleBuffer.js"), particles$1 = __webpack_require__(/*! ./particles.frag.js */ "./node_modules/@pixi/particle-container/lib/particles.frag.js"), particles = __webpack_require__(/*! ./particles.vert.js */ "./node_modules/@pixi/particle-container/lib/particles.vert.js");
class ParticleRenderer extends core.ObjectRenderer {
  /**
   * @param renderer - The renderer this sprite batch works for.
   */
  constructor(renderer) {
    super(renderer), this.shader = null, this.properties = null, this.tempMatrix = new core.Matrix(), this.properties = [
      // verticesData
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: this.uploadVertices,
        offset: 0
      },
      // positionData
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: this.uploadPosition,
        offset: 0
      },
      // rotationData
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: this.uploadRotation,
        offset: 0
      },
      // uvsData
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: this.uploadUvs,
        offset: 0
      },
      // tintData
      {
        attributeName: "aColor",
        size: 1,
        type: core.TYPES.UNSIGNED_BYTE,
        uploadFunction: this.uploadTint,
        offset: 0
      }
    ], this.shader = core.Shader.from(particles.default, particles$1.default, {}), this.state = core.State.for2d();
  }
  /**
   * Renders the particle container object.
   * @param container - The container to render using this ParticleRenderer.
   */
  render(container) {
    const children = container.children, maxSize = container._maxSize, batchSize = container._batchSize, renderer = this.renderer;
    let totalChildren = children.length;
    if (totalChildren === 0)
      return;
    totalChildren > maxSize && !container.autoResize && (totalChildren = maxSize);
    let buffers = container._buffers;
    buffers || (buffers = container._buffers = this.generateBuffers(container));
    const baseTexture = children[0]._texture.baseTexture, premultiplied = baseTexture.alphaMode > 0;
    this.state.blendMode = core.utils.correctBlendMode(container.blendMode, premultiplied), renderer.state.set(this.state);
    const gl = renderer.gl, m = container.worldTransform.copyTo(this.tempMatrix);
    m.prepend(renderer.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = m.toArray(!0), this.shader.uniforms.uColor = core.Color.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor), this.shader.uniforms.uSampler = baseTexture, this.renderer.shader.bind(this.shader);
    let updateStatic = !1;
    for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
      let amount = totalChildren - i;
      amount > batchSize && (amount = batchSize), j >= buffers.length && buffers.push(this._generateOneMoreBuffer(container));
      const buffer = buffers[j];
      buffer.uploadDynamic(children, i, amount);
      const bid = container._bufferUpdateIDs[j] || 0;
      updateStatic = updateStatic || buffer._updateID < bid, updateStatic && (buffer._updateID = container._updateID, buffer.uploadStatic(children, i, amount)), renderer.geometry.bind(buffer.geometry), gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
    }
  }
  /**
   * Creates one particle buffer for each child in the container we want to render and updates internal properties.
   * @param container - The container to render using this ParticleRenderer
   * @returns - The buffers
   */
  generateBuffers(container) {
    const buffers = [], size = container._maxSize, batchSize = container._batchSize, dynamicPropertyFlags = container._properties;
    for (let i = 0; i < size; i += batchSize)
      buffers.push(new ParticleBuffer.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
    return buffers;
  }
  /**
   * Creates one more particle buffer, because container has autoResize feature.
   * @param container - The container to render using this ParticleRenderer
   * @returns - The generated buffer
   */
  _generateOneMoreBuffer(container) {
    const batchSize = container._batchSize, dynamicPropertyFlags = container._properties;
    return new ParticleBuffer.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
  }
  /**
   * Uploads the vertices.
   * @param children - the array of sprites to render
   * @param startIndex - the index to start from in the children array
   * @param amount - the amount of children that will have their vertices uploaded
   * @param array - The vertices to upload.
   * @param stride - Stride to use for iteration.
   * @param offset - Offset to start at.
   */
  uploadVertices(children, startIndex, amount, array, stride, offset) {
    let w0 = 0, w1 = 0, h0 = 0, h1 = 0;
    for (let i = 0; i < amount; ++i) {
      const sprite = children[startIndex + i], texture = sprite._texture, sx = sprite.scale.x, sy = sprite.scale.y, trim = texture.trim, orig = texture.orig;
      trim ? (w1 = trim.x - sprite.anchor.x * orig.width, w0 = w1 + trim.width, h1 = trim.y - sprite.anchor.y * orig.height, h0 = h1 + trim.height) : (w0 = orig.width * (1 - sprite.anchor.x), w1 = orig.width * -sprite.anchor.x, h0 = orig.height * (1 - sprite.anchor.y), h1 = orig.height * -sprite.anchor.y), array[offset] = w1 * sx, array[offset + 1] = h1 * sy, array[offset + stride] = w0 * sx, array[offset + stride + 1] = h1 * sy, array[offset + stride * 2] = w0 * sx, array[offset + stride * 2 + 1] = h0 * sy, array[offset + stride * 3] = w1 * sx, array[offset + stride * 3 + 1] = h0 * sy, offset += stride * 4;
    }
  }
  /**
   * Uploads the position.
   * @param children - the array of sprites to render
   * @param startIndex - the index to start from in the children array
   * @param amount - the amount of children that will have their positions uploaded
   * @param array - The vertices to upload.
   * @param stride - Stride to use for iteration.
   * @param offset - Offset to start at.
   */
  uploadPosition(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; i++) {
      const spritePosition = children[startIndex + i].position;
      array[offset] = spritePosition.x, array[offset + 1] = spritePosition.y, array[offset + stride] = spritePosition.x, array[offset + stride + 1] = spritePosition.y, array[offset + stride * 2] = spritePosition.x, array[offset + stride * 2 + 1] = spritePosition.y, array[offset + stride * 3] = spritePosition.x, array[offset + stride * 3 + 1] = spritePosition.y, offset += stride * 4;
    }
  }
  /**
   * Uploads the rotation.
   * @param children - the array of sprites to render
   * @param startIndex - the index to start from in the children array
   * @param amount - the amount of children that will have their rotation uploaded
   * @param array - The vertices to upload.
   * @param stride - Stride to use for iteration.
   * @param offset - Offset to start at.
   */
  uploadRotation(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; i++) {
      const spriteRotation = children[startIndex + i].rotation;
      array[offset] = spriteRotation, array[offset + stride] = spriteRotation, array[offset + stride * 2] = spriteRotation, array[offset + stride * 3] = spriteRotation, offset += stride * 4;
    }
  }
  /**
   * Uploads the UVs.
   * @param children - the array of sprites to render
   * @param startIndex - the index to start from in the children array
   * @param amount - the amount of children that will have their rotation uploaded
   * @param array - The vertices to upload.
   * @param stride - Stride to use for iteration.
   * @param offset - Offset to start at.
   */
  uploadUvs(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; ++i) {
      const textureUvs = children[startIndex + i]._texture._uvs;
      textureUvs ? (array[offset] = textureUvs.x0, array[offset + 1] = textureUvs.y0, array[offset + stride] = textureUvs.x1, array[offset + stride + 1] = textureUvs.y1, array[offset + stride * 2] = textureUvs.x2, array[offset + stride * 2 + 1] = textureUvs.y2, array[offset + stride * 3] = textureUvs.x3, array[offset + stride * 3 + 1] = textureUvs.y3, offset += stride * 4) : (array[offset] = 0, array[offset + 1] = 0, array[offset + stride] = 0, array[offset + stride + 1] = 0, array[offset + stride * 2] = 0, array[offset + stride * 2 + 1] = 0, array[offset + stride * 3] = 0, array[offset + stride * 3 + 1] = 0, offset += stride * 4);
    }
  }
  /**
   * Uploads the tint.
   * @param children - the array of sprites to render
   * @param startIndex - the index to start from in the children array
   * @param amount - the amount of children that will have their rotation uploaded
   * @param array - The vertices to upload.
   * @param stride - Stride to use for iteration.
   * @param offset - Offset to start at.
   */
  uploadTint(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; ++i) {
      const sprite = children[startIndex + i], result = core.Color.shared.setValue(sprite._tintRGB).toPremultiplied(sprite.alpha, sprite.texture.baseTexture.alphaMode > 0);
      array[offset] = result, array[offset + stride] = result, array[offset + stride * 2] = result, array[offset + stride * 3] = result, offset += stride * 4;
    }
  }
  /** Destroys the ParticleRenderer. */
  destroy() {
    super.destroy(), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;
  }
}
ParticleRenderer.extension = {
  name: "particle",
  type: core.ExtensionType.RendererPlugin
};
core.extensions.add(ParticleRenderer);
exports.ParticleRenderer = ParticleRenderer;
//# sourceMappingURL=ParticleRenderer.js.map


/***/ }),

/***/ "./node_modules/@pixi/particle-container/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/particle-container/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var ParticleContainer = __webpack_require__(/*! ./ParticleContainer.js */ "./node_modules/@pixi/particle-container/lib/ParticleContainer.js"), ParticleRenderer = __webpack_require__(/*! ./ParticleRenderer.js */ "./node_modules/@pixi/particle-container/lib/ParticleRenderer.js");
exports.ParticleContainer = ParticleContainer.ParticleContainer;
exports.ParticleRenderer = ParticleRenderer.ParticleRenderer;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/particle-container/lib/particles.frag.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/particle-container/lib/particles.frag.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var fragment = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`;
exports["default"] = fragment;
//# sourceMappingURL=particles.frag.js.map


/***/ }),

/***/ "./node_modules/@pixi/particle-container/lib/particles.vert.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/particle-container/lib/particles.vert.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var vertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`;
exports["default"] = vertex;
//# sourceMappingURL=particles.vert.js.map


/***/ }),

/***/ "./node_modules/@pixi/prepare/lib/BasePrepare.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/prepare/lib/BasePrepare.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), display = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.js"), text = __webpack_require__(/*! @pixi/text */ "./node_modules/@pixi/text/lib/index.js"), CountLimiter = __webpack_require__(/*! ./CountLimiter.js */ "./node_modules/@pixi/prepare/lib/CountLimiter.js");
function findMultipleBaseTextures(item, queue) {
  let result = !1;
  if (item?._textures?.length) {
    for (let i = 0; i < item._textures.length; i++)
      if (item._textures[i] instanceof core.Texture) {
        const baseTexture = item._textures[i].baseTexture;
        queue.includes(baseTexture) || (queue.push(baseTexture), result = !0);
      }
  }
  return result;
}
function findBaseTexture(item, queue) {
  if (item.baseTexture instanceof core.BaseTexture) {
    const texture = item.baseTexture;
    return queue.includes(texture) || queue.push(texture), !0;
  }
  return !1;
}
function findTexture(item, queue) {
  if (item._texture && item._texture instanceof core.Texture) {
    const texture = item._texture.baseTexture;
    return queue.includes(texture) || queue.push(texture), !0;
  }
  return !1;
}
function drawText(_helper, item) {
  return item instanceof text.Text ? (item.updateText(!0), !0) : !1;
}
function calculateTextStyle(_helper, item) {
  if (item instanceof text.TextStyle) {
    const font = item.toFontString();
    return text.TextMetrics.measureFont(font), !0;
  }
  return !1;
}
function findText(item, queue) {
  if (item instanceof text.Text) {
    queue.includes(item.style) || queue.push(item.style), queue.includes(item) || queue.push(item);
    const texture = item._texture.baseTexture;
    return queue.includes(texture) || queue.push(texture), !0;
  }
  return !1;
}
function findTextStyle(item, queue) {
  return item instanceof text.TextStyle ? (queue.includes(item) || queue.push(item), !0) : !1;
}
const _BasePrepare = class _BasePrepare2 {
  /**
   * @param {PIXI.IRenderer} renderer - A reference to the current renderer
   */
  constructor(renderer) {
    this.limiter = new CountLimiter.CountLimiter(_BasePrepare2.uploadsPerFrame), this.renderer = renderer, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = () => {
      this.queue && this.prepareItems();
    }, this.registerFindHook(findText), this.registerFindHook(findTextStyle), this.registerFindHook(findMultipleBaseTextures), this.registerFindHook(findBaseTexture), this.registerFindHook(findTexture), this.registerUploadHook(drawText), this.registerUploadHook(calculateTextStyle);
  }
  /**
   * Upload all the textures and graphics to the GPU.
   * @method PIXI.BasePrepare#upload
   * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} [item] -
   *        Container or display object to search for items to upload or the items to upload themselves,
   *        or optionally ommitted, if items have been added using {@link PIXI.BasePrepare#add `prepare.add`}.
   */
  upload(item) {
    return new Promise((resolve) => {
      item && this.add(item), this.queue.length ? (this.completes.push(resolve), this.ticking || (this.ticking = !0, core.Ticker.system.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY))) : resolve();
    });
  }
  /**
   * Handle tick update
   * @private
   */
  tick() {
    setTimeout(this.delayedTick, 0);
  }
  /**
   * Actually prepare items. This is handled outside of the tick because it will take a while
   * and we do NOT want to block the current animation frame from rendering.
   * @private
   */
  prepareItems() {
    for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
      const item = this.queue[0];
      let uploaded = !1;
      if (item && !item._destroyed) {
        for (let i = 0, len = this.uploadHooks.length; i < len; i++)
          if (this.uploadHooks[i](this.uploadHookHelper, item)) {
            this.queue.shift(), uploaded = !0;
            break;
          }
      }
      uploaded || this.queue.shift();
    }
    if (this.queue.length)
      core.Ticker.system.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);
    else {
      this.ticking = !1;
      const completes = this.completes.slice(0);
      this.completes.length = 0;
      for (let i = 0, len = completes.length; i < len; i++)
        completes[i]();
    }
  }
  /**
   * Adds hooks for finding items.
   * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`
   *          function must return `true` if it was able to add item to the queue.
   * @returns Instance of plugin for chaining.
   */
  registerFindHook(addHook) {
    return addHook && this.addHooks.push(addHook), this;
  }
  /**
   * Adds hooks for uploading items.
   * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and
   *          function must return `true` if it was able to handle upload of item.
   * @returns Instance of plugin for chaining.
   */
  registerUploadHook(uploadHook) {
    return uploadHook && this.uploadHooks.push(uploadHook), this;
  }
  /**
   * Manually add an item to the uploading queue.
   * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to
   *        add to the queue
   * @returns Instance of plugin for chaining.
   */
  add(item) {
    for (let i = 0, len = this.addHooks.length; i < len && !this.addHooks[i](item, this.queue); i++)
      ;
    if (item instanceof display.Container)
      for (let i = item.children.length - 1; i >= 0; i--)
        this.add(item.children[i]);
    return this;
  }
  /** Destroys the plugin, don't use after this. */
  destroy() {
    this.ticking && core.Ticker.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;
  }
};
_BasePrepare.uploadsPerFrame = 4;
let BasePrepare = _BasePrepare;
exports.BasePrepare = BasePrepare;
//# sourceMappingURL=BasePrepare.js.map


/***/ }),

/***/ "./node_modules/@pixi/prepare/lib/CountLimiter.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/prepare/lib/CountLimiter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class CountLimiter {
  /**
   * @param maxItemsPerFrame - The maximum number of items that can be prepared each frame.
   */
  constructor(maxItemsPerFrame) {
    this.maxItemsPerFrame = maxItemsPerFrame, this.itemsLeft = 0;
  }
  /** Resets any counting properties to start fresh on a new frame. */
  beginFrame() {
    this.itemsLeft = this.maxItemsPerFrame;
  }
  /**
   * Checks to see if another item can be uploaded. This should only be called once per item.
   * @returns If the item is allowed to be uploaded.
   */
  allowedToUpload() {
    return this.itemsLeft-- > 0;
  }
}
exports.CountLimiter = CountLimiter;
//# sourceMappingURL=CountLimiter.js.map


/***/ }),

/***/ "./node_modules/@pixi/prepare/lib/Prepare.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/prepare/lib/Prepare.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), graphics = __webpack_require__(/*! @pixi/graphics */ "./node_modules/@pixi/graphics/lib/index.js"), BasePrepare = __webpack_require__(/*! ./BasePrepare.js */ "./node_modules/@pixi/prepare/lib/BasePrepare.js");
function uploadBaseTextures(renderer, item) {
  return item instanceof core.BaseTexture ? (item._glTextures[renderer.CONTEXT_UID] || renderer.texture.bind(item), !0) : !1;
}
function uploadGraphics(renderer, item) {
  if (!(item instanceof graphics.Graphics))
    return !1;
  const { geometry } = item;
  item.finishPoly(), geometry.updateBatches();
  const { batches } = geometry;
  for (let i = 0; i < batches.length; i++) {
    const { texture } = batches[i].style;
    texture && uploadBaseTextures(renderer, texture.baseTexture);
  }
  return geometry.batchable || renderer.geometry.bind(geometry, item._resolveDirectShader(renderer)), !0;
}
function findGraphics(item, queue) {
  return item instanceof graphics.Graphics ? (queue.push(item), !0) : !1;
}
class Prepare extends BasePrepare.BasePrepare {
  /**
   * @param {PIXI.Renderer} renderer - A reference to the current renderer
   */
  constructor(renderer) {
    super(renderer), this.uploadHookHelper = this.renderer, this.registerFindHook(findGraphics), this.registerUploadHook(uploadBaseTextures), this.registerUploadHook(uploadGraphics);
  }
}
Prepare.extension = {
  name: "prepare",
  type: core.ExtensionType.RendererSystem
};
core.extensions.add(Prepare);
exports.Prepare = Prepare;
//# sourceMappingURL=Prepare.js.map


/***/ }),

/***/ "./node_modules/@pixi/prepare/lib/TimeLimiter.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/prepare/lib/TimeLimiter.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class TimeLimiter {
  /** @param maxMilliseconds - The maximum milliseconds that can be spent preparing items each frame. */
  constructor(maxMilliseconds) {
    this.maxMilliseconds = maxMilliseconds, this.frameStart = 0;
  }
  /** Resets any counting properties to start fresh on a new frame. */
  beginFrame() {
    this.frameStart = Date.now();
  }
  /**
   * Checks to see if another item can be uploaded. This should only be called once per item.
   * @returns - If the item is allowed to be uploaded.
   */
  allowedToUpload() {
    return Date.now() - this.frameStart < this.maxMilliseconds;
  }
}
exports.TimeLimiter = TimeLimiter;
//# sourceMappingURL=TimeLimiter.js.map


/***/ }),

/***/ "./node_modules/@pixi/prepare/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/prepare/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ./settings.js */ "./node_modules/@pixi/prepare/lib/settings.js");
var BasePrepare = __webpack_require__(/*! ./BasePrepare.js */ "./node_modules/@pixi/prepare/lib/BasePrepare.js"), CountLimiter = __webpack_require__(/*! ./CountLimiter.js */ "./node_modules/@pixi/prepare/lib/CountLimiter.js"), Prepare = __webpack_require__(/*! ./Prepare.js */ "./node_modules/@pixi/prepare/lib/Prepare.js"), TimeLimiter = __webpack_require__(/*! ./TimeLimiter.js */ "./node_modules/@pixi/prepare/lib/TimeLimiter.js");
exports.BasePrepare = BasePrepare.BasePrepare;
exports.CountLimiter = CountLimiter.CountLimiter;
exports.Prepare = Prepare.Prepare;
exports.TimeLimiter = TimeLimiter.TimeLimiter;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/prepare/lib/settings.js":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/prepare/lib/settings.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), BasePrepare = __webpack_require__(/*! ./BasePrepare.js */ "./node_modules/@pixi/prepare/lib/BasePrepare.js");
Object.defineProperties(core.settings, {
  /**
   * Default number of uploads per frame using prepare plugin.
   * @static
   * @memberof PIXI.settings
   * @name UPLOADS_PER_FRAME
   * @deprecated since 7.1.0
   * @see PIXI.BasePrepare.uploadsPerFrame
   * @type {number}
   */
  UPLOADS_PER_FRAME: {
    get() {
      return BasePrepare.BasePrepare.uploadsPerFrame;
    },
    set(value) {
      core.utils.deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"), BasePrepare.BasePrepare.uploadsPerFrame = value;
    }
  }
});
Object.defineProperty(exports, "settings", ({
  enumerable: !0,
  get: function() {
    return core.settings;
  }
}));
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ "./node_modules/@pixi/runner/lib/Runner.js":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/runner/lib/Runner.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class Runner {
  /**
   * @param name - The function name that will be executed on the listeners added to this Runner.
   */
  constructor(name) {
    this.items = [], this._name = name, this._aliasCount = 0;
  }
  /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */
  /**
   * Dispatch/Broadcast Runner to all listeners added to the queue.
   * @param {...any} params - (optional) parameters to pass to each listener
   */
  /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */
  emit(a0, a1, a2, a3, a4, a5, a6, a7) {
    if (arguments.length > 8)
      throw new Error("max arguments reached");
    const { name, items } = this;
    this._aliasCount++;
    for (let i = 0, len = items.length; i < len; i++)
      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
    return items === this.items && this._aliasCount--, this;
  }
  ensureNonAliasedItems() {
    this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
  }
  /**
   * Add a listener to the Runner
   *
   * Runners do not need to have scope or functions passed to them.
   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
   * as the name provided to the Runner when it was created.
   *
   * E.g. A listener passed to this Runner will require a 'complete' function.
   *
   * ```js
   * import { Runner } from '@pixi/runner';
   *
   * const complete = new Runner('complete');
   * ```
   *
   * The scope used will be the object itself.
   * @param {any} item - The object that will be listening.
   */
  add(item) {
    return item[this._name] && (this.ensureNonAliasedItems(), this.remove(item), this.items.push(item)), this;
  }
  /**
   * Remove a single listener from the dispatch queue.
   * @param {any} item - The listener that you would like to remove.
   */
  remove(item) {
    const index = this.items.indexOf(item);
    return index !== -1 && (this.ensureNonAliasedItems(), this.items.splice(index, 1)), this;
  }
  /**
   * Check to see if the listener is already in the Runner
   * @param {any} item - The listener that you would like to check.
   */
  contains(item) {
    return this.items.includes(item);
  }
  /** Remove all listeners from the Runner */
  removeAll() {
    return this.ensureNonAliasedItems(), this.items.length = 0, this;
  }
  /** Remove all references, don't use after this. */
  destroy() {
    this.removeAll(), this.items = null, this._name = null;
  }
  /**
   * `true` if there are no this Runner contains no listeners
   * @readonly
   */
  get empty() {
    return this.items.length === 0;
  }
  /**
   * The name of the runner.
   * @readonly
   */
  get name() {
    return this._name;
  }
}
Object.defineProperties(Runner.prototype, {
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method dispatch
   * @see PIXI.Runner#emit
   */
  dispatch: { value: Runner.prototype.emit },
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method run
   * @see PIXI.Runner#emit
   */
  run: { value: Runner.prototype.emit }
});
exports.Runner = Runner;
//# sourceMappingURL=Runner.js.map


/***/ }),

/***/ "./node_modules/@pixi/runner/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/runner/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Runner = __webpack_require__(/*! ./Runner.js */ "./node_modules/@pixi/runner/lib/Runner.js");
exports.Runner = Runner.Runner;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/settings/lib/ICanvas.js":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/ICanvas.js ***!
  \****************************************************/
/***/ (() => {

"use strict";

//# sourceMappingURL=ICanvas.js.map


/***/ }),

/***/ "./node_modules/@pixi/settings/lib/ICanvasRenderingContext2D.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/ICanvasRenderingContext2D.js ***!
  \**********************************************************************/
/***/ (() => {

"use strict";

//# sourceMappingURL=ICanvasRenderingContext2D.js.map


/***/ }),

/***/ "./node_modules/@pixi/settings/lib/adapter.js":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/adapter.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const BrowserAdapter = {
  /**
   * Creates a canvas element of the given size.
   * This canvas is created using the browser's native canvas element.
   * @param width - width of the canvas
   * @param height - height of the canvas
   */
  createCanvas: (width, height) => {
    const canvas = document.createElement("canvas");
    return canvas.width = width, canvas.height = height, canvas;
  },
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (url, options) => fetch(url, options),
  parseXML: (xml) => new DOMParser().parseFromString(xml, "text/xml")
};
exports.BrowserAdapter = BrowserAdapter;
//# sourceMappingURL=adapter.js.map


/***/ }),

/***/ "./node_modules/@pixi/settings/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var adapter = __webpack_require__(/*! ./adapter.js */ "./node_modules/@pixi/settings/lib/adapter.js");
__webpack_require__(/*! ./ICanvas.js */ "./node_modules/@pixi/settings/lib/ICanvas.js");
__webpack_require__(/*! ./ICanvasRenderingContext2D.js */ "./node_modules/@pixi/settings/lib/ICanvasRenderingContext2D.js");
var settings = __webpack_require__(/*! ./settings.js */ "./node_modules/@pixi/settings/lib/settings.js"), isMobile = __webpack_require__(/*! ./utils/isMobile.js */ "./node_modules/@pixi/settings/lib/utils/isMobile.js");
exports.BrowserAdapter = adapter.BrowserAdapter;
exports.settings = settings.settings;
exports.isMobile = isMobile.isMobile;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/settings/lib/settings.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/settings.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var adapter = __webpack_require__(/*! ./adapter.js */ "./node_modules/@pixi/settings/lib/adapter.js");
const settings = {
  /**
   * This adapter is used to call methods that are platform dependent.
   * For example `document.createElement` only runs on the web but fails in node environments.
   * This allows us to support more platforms by abstracting away specific implementations per platform.
   *
   * By default the adapter is set to work in the browser. However you can create your own
   * by implementing the `IAdapter` interface. See `IAdapter` for more information.
   * @name ADAPTER
   * @memberof PIXI.settings
   * @type {PIXI.IAdapter}
   * @default PIXI.BrowserAdapter
   */
  ADAPTER: adapter.BrowserAdapter,
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: !1,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * @static
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: !1
};
exports.settings = settings;
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ "./node_modules/@pixi/settings/lib/utils/isMobile.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/utils/isMobile.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var isMobileJs = __webpack_require__(/*! ismobilejs */ "./node_modules/ismobilejs/esm/index.js");
const isMobileCall = isMobileJs.default ?? isMobileJs, isMobile = isMobileCall(globalThis.navigator);
exports.isMobile = isMobile;
//# sourceMappingURL=isMobile.js.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-animated/lib/AnimatedSprite.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/sprite-animated/lib/AnimatedSprite.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), sprite = __webpack_require__(/*! @pixi/sprite */ "./node_modules/@pixi/sprite/lib/index.js");
class AnimatedSprite extends sprite.Sprite {
  /**
   * @param textures - An array of {@link PIXI.Texture} or frame
   *  objects that make up the animation.
   * @param {boolean} [autoUpdate=true] - Whether to use Ticker.shared to auto update animation time.
   */
  constructor(textures, autoUpdate = !0) {
    super(textures[0] instanceof core.Texture ? textures[0] : textures[0].texture), this._textures = null, this._durations = null, this._autoUpdate = autoUpdate, this._isConnectedToTicker = !1, this.animationSpeed = 1, this.loop = !0, this.updateAnchor = !1, this.onComplete = null, this.onFrameChange = null, this.onLoop = null, this._currentTime = 0, this._playing = !1, this._previousFrame = null, this.textures = textures;
  }
  /** Stops the AnimatedSprite. */
  stop() {
    this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (core.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1));
  }
  /** Plays the AnimatedSprite. */
  play() {
    this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (core.Ticker.shared.add(this.update, this, core.UPDATE_PRIORITY.HIGH), this._isConnectedToTicker = !0));
  }
  /**
   * Stops the AnimatedSprite and goes to a specific frame.
   * @param frameNumber - Frame index to stop at.
   */
  gotoAndStop(frameNumber) {
    this.stop(), this.currentFrame = frameNumber;
  }
  /**
   * Goes to a specific frame and begins playing the AnimatedSprite.
   * @param frameNumber - Frame index to start at.
   */
  gotoAndPlay(frameNumber) {
    this.currentFrame = frameNumber, this.play();
  }
  /**
   * Updates the object transform for rendering.
   * @param deltaTime - Time since last tick.
   */
  update(deltaTime) {
    if (!this._playing)
      return;
    const elapsed = this.animationSpeed * deltaTime, previousFrame = this.currentFrame;
    if (this._durations !== null) {
      let lag = this._currentTime % 1 * this._durations[this.currentFrame];
      for (lag += elapsed / 60 * 1e3; lag < 0; )
        this._currentTime--, lag += this._durations[this.currentFrame];
      const sign = Math.sign(this.animationSpeed * deltaTime);
      for (this._currentTime = Math.floor(this._currentTime); lag >= this._durations[this.currentFrame]; )
        lag -= this._durations[this.currentFrame] * sign, this._currentTime += sign;
      this._currentTime += lag / this._durations[this.currentFrame];
    } else
      this._currentTime += elapsed;
    this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : previousFrame !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) && this.onLoop(), this.updateTexture());
  }
  /** Updates the displayed texture to match the current frame index. */
  updateTexture() {
    const currentFrame = this.currentFrame;
    this._previousFrame !== currentFrame && (this._previousFrame = currentFrame, this._texture = this._textures[currentFrame], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));
  }
  /**
   * Stops the AnimatedSprite and destroys it.
   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
   *  have been set to that value.
   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy
   *      method called as well. 'options' will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well.
   * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well.
   */
  destroy(options) {
    this.stop(), super.destroy(options), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;
  }
  /**
   * A short hand way of creating an AnimatedSprite from an array of frame ids.
   * @param frames - The array of frames ids the AnimatedSprite will use as its texture frames.
   * @returns - The new animated sprite with the specified frames.
   */
  static fromFrames(frames) {
    const textures = [];
    for (let i = 0; i < frames.length; ++i)
      textures.push(core.Texture.from(frames[i]));
    return new AnimatedSprite(textures);
  }
  /**
   * A short hand way of creating an AnimatedSprite from an array of image ids.
   * @param images - The array of image urls the AnimatedSprite will use as its texture frames.
   * @returns The new animate sprite with the specified images as frames.
   */
  static fromImages(images) {
    const textures = [];
    for (let i = 0; i < images.length; ++i)
      textures.push(core.Texture.from(images[i]));
    return new AnimatedSprite(textures);
  }
  /**
   * The total number of frames in the AnimatedSprite. This is the same as number of textures
   * assigned to the AnimatedSprite.
   * @readonly
   * @default 0
   */
  get totalFrames() {
    return this._textures.length;
  }
  /** The array of textures used for this AnimatedSprite. */
  get textures() {
    return this._textures;
  }
  set textures(value) {
    if (value[0] instanceof core.Texture)
      this._textures = value, this._durations = null;
    else {
      this._textures = [], this._durations = [];
      for (let i = 0; i < value.length; i++)
        this._textures.push(value[i].texture), this._durations.push(value[i].time);
    }
    this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();
  }
  /** The AnimatedSprite's current frame index. */
  get currentFrame() {
    let currentFrame = Math.floor(this._currentTime) % this._textures.length;
    return currentFrame < 0 && (currentFrame += this._textures.length), currentFrame;
  }
  set currentFrame(value) {
    if (value < 0 || value > this.totalFrames - 1)
      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
    const previousFrame = this.currentFrame;
    this._currentTime = value, previousFrame !== this.currentFrame && this.updateTexture();
  }
  /**
   * Indicates if the AnimatedSprite is currently playing.
   * @readonly
   */
  get playing() {
    return this._playing;
  }
  /** Whether to use Ticker.shared to auto update animation time. */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    value !== this._autoUpdate && (this._autoUpdate = value, !this._autoUpdate && this._isConnectedToTicker ? (core.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (core.Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));
  }
}
exports.AnimatedSprite = AnimatedSprite;
//# sourceMappingURL=AnimatedSprite.js.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-animated/lib/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/sprite-animated/lib/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var AnimatedSprite = __webpack_require__(/*! ./AnimatedSprite.js */ "./node_modules/@pixi/sprite-animated/lib/AnimatedSprite.js");
exports.AnimatedSprite = AnimatedSprite.AnimatedSprite;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/TilingSprite.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/TilingSprite.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), sprite = __webpack_require__(/*! @pixi/sprite */ "./node_modules/@pixi/sprite/lib/index.js");
const tempPoint = new core.Point();
class TilingSprite extends sprite.Sprite {
  /**
   * Note: The wrap mode of the texture is forced to REPEAT on render if the size of the texture
   * is a power of two, the texture's wrap mode is CLAMP, and the texture hasn't been bound yet.
   * @param texture - The texture of the tiling sprite.
   * @param width - The width of the tiling sprite.
   * @param height - The height of the tiling sprite.
   */
  constructor(texture, width = 100, height = 100) {
    super(texture), this.tileTransform = new core.Transform(), this._width = width, this._height = height, this.uvMatrix = this.texture.uvMatrix || new core.TextureMatrix(texture), this.pluginName = "tilingSprite", this.uvRespectAnchor = !1;
  }
  /**
   * Changes frame clamping in corresponding textureTransform, shortcut
   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
   * @default 0.5
   * @member {number}
   */
  get clampMargin() {
    return this.uvMatrix.clampMargin;
  }
  set clampMargin(value) {
    this.uvMatrix.clampMargin = value, this.uvMatrix.update(!0);
  }
  /** The scaling of the image that is being tiled. */
  get tileScale() {
    return this.tileTransform.scale;
  }
  set tileScale(value) {
    this.tileTransform.scale.copyFrom(value);
  }
  /** The offset of the image that is being tiled. */
  get tilePosition() {
    return this.tileTransform.position;
  }
  set tilePosition(value) {
    this.tileTransform.position.copyFrom(value);
  }
  /**
   * @protected
   */
  _onTextureUpdate() {
    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;
  }
  /**
   * Renders the object using the WebGL renderer
   * @param renderer - The renderer
   */
  _render(renderer) {
    const texture = this._texture;
    !texture || !texture.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]), renderer.plugins[this.pluginName].render(this));
  }
  /** Updates the bounds of the tiling sprite. */
  _calculateBounds() {
    const minX = this._width * -this._anchor._x, minY = this._height * -this._anchor._y, maxX = this._width * (1 - this._anchor._x), maxY = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  /**
   * Gets the local bounds of the sprite object.
   * @param rect - Optional output rectangle.
   * @returns The bounds.
   */
  getLocalBounds(rect) {
    return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), rect || (this._localBoundsRect || (this._localBoundsRect = new core.Rectangle()), rect = this._localBoundsRect), this._bounds.getRectangle(rect)) : super.getLocalBounds.call(this, rect);
  }
  /**
   * Checks if a point is inside this tiling sprite.
   * @param point - The point to check.
   * @returns Whether or not the sprite contains the point.
   */
  containsPoint(point) {
    this.worldTransform.applyInverse(point, tempPoint);
    const width = this._width, height = this._height, x1 = -width * this.anchor._x;
    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
      const y1 = -height * this.anchor._y;
      if (tempPoint.y >= y1 && tempPoint.y < y1 + height)
        return !0;
    }
    return !1;
  }
  /**
   * Destroys this sprite and optionally its texture and children
   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
   *      method called as well. 'options' will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
   * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
   */
  destroy(options) {
    super.destroy(options), this.tileTransform = null, this.uvMatrix = null;
  }
  /**
   * Helper function that creates a new tiling sprite based on the source you provide.
   * The source can be - frame id, image url, video url, canvas element, video element, base texture
   * @static
   * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from
   * @param {object} options - See {@link PIXI.BaseTexture}'s constructor for options.
   * @param {number} options.width - required width of the tiling sprite
   * @param {number} options.height - required height of the tiling sprite
   * @returns {PIXI.TilingSprite} The newly created texture
   */
  static from(source, options) {
    const texture = source instanceof core.Texture ? source : core.Texture.from(source, options);
    return new TilingSprite(
      texture,
      options.width,
      options.height
    );
  }
  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
  /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
  }
}
exports.TilingSprite = TilingSprite;
//# sourceMappingURL=TilingSprite.js.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), spriteTiling$1 = __webpack_require__(/*! ./sprite-tiling.frag.js */ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling.frag.js"), spriteTiling = __webpack_require__(/*! ./sprite-tiling.vert.js */ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling.vert.js"), spriteTilingFallback$1 = __webpack_require__(/*! ./sprite-tiling-fallback.frag.js */ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.frag.js"), spriteTilingFallback = __webpack_require__(/*! ./sprite-tiling-fallback.vert.js */ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.vert.js"), spriteTilingSimple = __webpack_require__(/*! ./sprite-tiling-simple.frag.js */ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.frag.js");
const tempMat = new core.Matrix();
class TilingSpriteRenderer extends core.ObjectRenderer {
  /**
   * constructor for renderer
   * @param {PIXI.Renderer} renderer - The renderer this tiling awesomeness works for.
   */
  constructor(renderer) {
    super(renderer), renderer.runners.contextChange.add(this), this.quad = new core.QuadUv(), this.state = core.State.for2d();
  }
  /** Creates shaders when context is initialized. */
  contextChange() {
    const renderer = this.renderer, uniforms = { globals: renderer.globalUniforms };
    this.simpleShader = core.Shader.from(spriteTilingFallback.default, spriteTilingSimple.default, uniforms), this.shader = renderer.context.webGLVersion > 1 ? core.Shader.from(spriteTiling.default, spriteTiling$1.default, uniforms) : core.Shader.from(spriteTilingFallback.default, spriteTilingFallback$1.default, uniforms);
  }
  /**
   * @param {PIXI.TilingSprite} ts - tilingSprite to be rendered
   */
  render(ts) {
    const renderer = this.renderer, quad = this.quad;
    let vertices = quad.vertices;
    vertices[0] = vertices[6] = ts._width * -ts.anchor.x, vertices[1] = vertices[3] = ts._height * -ts.anchor.y, vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x), vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
    const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0, anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
    vertices = quad.uvs, vertices[0] = vertices[6] = -anchorX, vertices[1] = vertices[3] = -anchorY, vertices[2] = vertices[4] = 1 - anchorX, vertices[5] = vertices[7] = 1 - anchorY, quad.invalidate();
    const tex = ts._texture, baseTex = tex.baseTexture, premultiplied = baseTex.alphaMode > 0, lt = ts.tileTransform.localTransform, uv = ts.uvMatrix;
    let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
    isSimple && (baseTex._glTextures[renderer.CONTEXT_UID] ? isSimple = baseTex.wrapMode !== core.WRAP_MODES.CLAMP : baseTex.wrapMode === core.WRAP_MODES.CLAMP && (baseTex.wrapMode = core.WRAP_MODES.REPEAT));
    const shader = isSimple ? this.simpleShader : this.shader, w = tex.width, h = tex.height, W = ts._width, H = ts._height;
    tempMat.set(
      lt.a * w / W,
      lt.b * w / H,
      lt.c * h / W,
      lt.d * h / H,
      lt.tx / W,
      lt.ty / H
    ), tempMat.invert(), isSimple ? tempMat.prepend(uv.mapCoord) : (shader.uniforms.uMapCoord = uv.mapCoord.toArray(!0), shader.uniforms.uClampFrame = uv.uClampFrame, shader.uniforms.uClampOffset = uv.uClampOffset), shader.uniforms.uTransform = tempMat.toArray(!0), shader.uniforms.uColor = core.Color.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor), shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(!0), shader.uniforms.uSampler = tex, renderer.shader.bind(shader), renderer.geometry.bind(quad), this.state.blendMode = core.utils.correctBlendMode(ts.blendMode, premultiplied), renderer.state.set(this.state), renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
  }
}
TilingSpriteRenderer.extension = {
  name: "tilingSprite",
  type: core.ExtensionType.RendererPlugin
};
core.extensions.add(TilingSpriteRenderer);
exports.TilingSpriteRenderer = TilingSpriteRenderer;
//# sourceMappingURL=TilingSpriteRenderer.js.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var TilingSprite = __webpack_require__(/*! ./TilingSprite.js */ "./node_modules/@pixi/sprite-tiling/lib/TilingSprite.js"), TilingSpriteRenderer = __webpack_require__(/*! ./TilingSpriteRenderer.js */ "./node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.js");
exports.TilingSprite = TilingSprite.TilingSprite;
exports.TilingSpriteRenderer = TilingSpriteRenderer.TilingSpriteRenderer;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.frag.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.frag.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var gl1FragmentSrc = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`;
exports["default"] = gl1FragmentSrc;
//# sourceMappingURL=sprite-tiling-fallback.frag.js.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.vert.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.vert.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var gl1VertexSrc = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`;
exports["default"] = gl1VertexSrc;
//# sourceMappingURL=sprite-tiling-fallback.vert.js.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.frag.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.frag.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var fragmentSimpleSrc = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`;
exports["default"] = fragmentSimpleSrc;
//# sourceMappingURL=sprite-tiling-simple.frag.js.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling.frag.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling.frag.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var gl2FragmentSrc = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`;
exports["default"] = gl2FragmentSrc;
//# sourceMappingURL=sprite-tiling.frag.js.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling.vert.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling.vert.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var gl2VertexSrc = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`;
exports["default"] = gl2VertexSrc;
//# sourceMappingURL=sprite-tiling.vert.js.map


/***/ }),

/***/ "./node_modules/@pixi/sprite/lib/Sprite.js":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/sprite/lib/Sprite.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), display = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.js");
const tempPoint = new core.Point(), indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
class Sprite extends display.Container {
  /** @param texture - The texture for this sprite. */
  constructor(texture) {
    super(), this._anchor = new core.ObservablePoint(
      this._onAnchorUpdate,
      this,
      texture ? texture.defaultAnchor.x : 0,
      texture ? texture.defaultAnchor.y : 0
    ), this._texture = null, this._width = 0, this._height = 0, this._tintColor = new core.Color(16777215), this._tintRGB = null, this.tint = 16777215, this.blendMode = core.BLEND_MODES.NORMAL, this._cachedTint = 16777215, this.uvs = null, this.texture = texture || core.Texture.EMPTY, this.vertexData = new Float32Array(8), this.vertexTrimmedData = null, this._transformID = -1, this._textureID = -1, this._transformTrimmedID = -1, this._textureTrimmedID = -1, this.indices = indices, this.pluginName = "batch", this.isSprite = !0, this._roundPixels = core.settings.ROUND_PIXELS;
  }
  /** When the texture is updated, this event will fire to update the scale and frame. */
  _onTextureUpdate() {
    this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = core.utils.sign(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = core.utils.sign(this.scale.y) * this._height / this._texture.orig.height);
  }
  /** Called when the anchor position updates. */
  _onAnchorUpdate() {
    this._transformID = -1, this._transformTrimmedID = -1;
  }
  /** Calculates worldTransform * vertices, store it in vertexData. */
  calculateVertices() {
    const texture = this._texture;
    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID)
      return;
    this._textureID !== texture._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = texture._updateID;
    const wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty, vertexData = this.vertexData, trim = texture.trim, orig = texture.orig, anchor = this._anchor;
    let w0 = 0, w1 = 0, h0 = 0, h1 = 0;
    if (trim ? (w1 = trim.x - anchor._x * orig.width, w0 = w1 + trim.width, h1 = trim.y - anchor._y * orig.height, h0 = h1 + trim.height) : (w1 = -anchor._x * orig.width, w0 = w1 + orig.width, h1 = -anchor._y * orig.height, h0 = h1 + orig.height), vertexData[0] = a * w1 + c * h1 + tx, vertexData[1] = d * h1 + b * w1 + ty, vertexData[2] = a * w0 + c * h1 + tx, vertexData[3] = d * h1 + b * w0 + ty, vertexData[4] = a * w0 + c * h0 + tx, vertexData[5] = d * h0 + b * w0 + ty, vertexData[6] = a * w1 + c * h0 + tx, vertexData[7] = d * h0 + b * w1 + ty, this._roundPixels) {
      const resolution = core.settings.RESOLUTION;
      for (let i = 0; i < vertexData.length; ++i)
        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
    }
  }
  /**
   * Calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData.
   *
   * This is used to ensure that the true width and height of a trimmed texture is respected.
   */
  calculateTrimmedVertices() {
    if (!this.vertexTrimmedData)
      this.vertexTrimmedData = new Float32Array(8);
    else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
      return;
    this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
    const texture = this._texture, vertexData = this.vertexTrimmedData, orig = texture.orig, anchor = this._anchor, wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty, w1 = -anchor._x * orig.width, w0 = w1 + orig.width, h1 = -anchor._y * orig.height, h0 = h1 + orig.height;
    if (vertexData[0] = a * w1 + c * h1 + tx, vertexData[1] = d * h1 + b * w1 + ty, vertexData[2] = a * w0 + c * h1 + tx, vertexData[3] = d * h1 + b * w0 + ty, vertexData[4] = a * w0 + c * h0 + tx, vertexData[5] = d * h0 + b * w0 + ty, vertexData[6] = a * w1 + c * h0 + tx, vertexData[7] = d * h0 + b * w1 + ty, this._roundPixels) {
      const resolution = core.settings.RESOLUTION;
      for (let i = 0; i < vertexData.length; ++i)
        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
    }
  }
  /**
   *
   * Renders the object using the WebGL renderer
   * @param renderer - The webgl renderer to use.
   */
  _render(renderer) {
    this.calculateVertices(), renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]), renderer.plugins[this.pluginName].render(this);
  }
  /** Updates the bounds of the sprite. */
  _calculateBounds() {
    const trim = this._texture.trim, orig = this._texture.orig;
    !trim || trim.width === orig.width && trim.height === orig.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
  }
  /**
   * Gets the local bounds of the sprite object.
   * @param rect - Optional output rectangle.
   * @returns The bounds.
   */
  getLocalBounds(rect) {
    return this.children.length === 0 ? (this._localBounds || (this._localBounds = new display.Bounds()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), rect || (this._localBoundsRect || (this._localBoundsRect = new core.Rectangle()), rect = this._localBoundsRect), this._localBounds.getRectangle(rect)) : super.getLocalBounds.call(this, rect);
  }
  /**
   * Tests if a point is inside this sprite
   * @param point - the point to test
   * @returns The result of the test
   */
  containsPoint(point) {
    this.worldTransform.applyInverse(point, tempPoint);
    const width = this._texture.orig.width, height = this._texture.orig.height, x1 = -width * this.anchor.x;
    let y1 = 0;
    return tempPoint.x >= x1 && tempPoint.x < x1 + width && (y1 = -height * this.anchor.y, tempPoint.y >= y1 && tempPoint.y < y1 + height);
  }
  /**
   * Destroys this sprite and optionally its texture and children.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param [options.children=false] - if set to true, all the children will have their destroy
   *      method called as well. 'options' will be passed on to those calls.
   * @param [options.texture=false] - Should it destroy the current texture of the sprite as well
   * @param [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
   */
  destroy(options) {
    if (super.destroy(options), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, typeof options == "boolean" ? options : options?.texture) {
      const destroyBaseTexture = typeof options == "boolean" ? options : options?.baseTexture;
      this._texture.destroy(!!destroyBaseTexture);
    }
    this._texture = null;
  }
  // some helper functions..
  /**
   * Helper function that creates a new sprite based on the source you provide.
   * The source can be - frame id, image url, video url, canvas element, video element, base texture
   * @param {string|PIXI.Texture|HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source
   *     - Source to create texture from
   * @param {object} [options] - See {@link PIXI.BaseTexture}'s constructor for options.
   * @returns The newly created sprite
   */
  static from(source, options) {
    const texture = source instanceof core.Texture ? source : core.Texture.from(source, options);
    return new Sprite(texture);
  }
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   *
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   *
   * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.
   * @default false
   */
  set roundPixels(value) {
    this._roundPixels !== value && (this._transformID = -1, this._transformTrimmedID = -1), this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    const s = core.utils.sign(this.scale.x) || 1;
    this.scale.x = s * value / this._texture.orig.width, this._width = value;
  }
  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    const s = core.utils.sign(this.scale.y) || 1;
    this.scale.y = s * value / this._texture.orig.height, this._height = value;
  }
  /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}
   * and passed to the constructor.
   *
   * The default is `(0,0)`, this means the sprite's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * import { Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite(Texture.WHITE);
   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    this._anchor.copyFrom(value);
  }
  /**
   * The tint applied to the sprite. This is a hex value.
   *
   * A value of 0xFFFFFF will remove any tint effect.
   * @default 0xFFFFFF
   */
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value), this._tintRGB = this._tintColor.toLittleEndianNumber();
  }
  /**
   * Get the tint as a RGB integer.
   * @ignore
   */
  get tintValue() {
    return this._tintColor.toNumber();
  }
  /** The texture that the sprite is using. */
  get texture() {
    return this._texture;
  }
  set texture(value) {
    this._texture !== value && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = value || core.Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, value && (value.baseTexture.valid ? this._onTextureUpdate() : value.once("update", this._onTextureUpdate, this)));
  }
}
exports.Sprite = Sprite;
//# sourceMappingURL=Sprite.js.map


/***/ }),

/***/ "./node_modules/@pixi/sprite/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/sprite/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Sprite = __webpack_require__(/*! ./Sprite.js */ "./node_modules/@pixi/sprite/lib/Sprite.js");
exports.Sprite = Sprite.Sprite;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/spritesheet/lib/Spritesheet.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/spritesheet/lib/Spritesheet.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
const _Spritesheet = class _Spritesheet2 {
  /**
   * @param texture - Reference to the source BaseTexture object.
   * @param {object} data - Spritesheet image data.
   * @param resolutionFilename - The filename to consider when determining
   *        the resolution of the spritesheet. If not provided, the imageUrl will
   *        be used on the BaseTexture.
   */
  constructor(texture, data, resolutionFilename = null) {
    this.linkedSheets = [], this._texture = texture instanceof core.Texture ? texture : null, this.baseTexture = texture instanceof core.BaseTexture ? texture : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = data;
    const resource = this.baseTexture.resource;
    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
  }
  /**
   * Generate the resolution from the filename or fallback
   * to the meta.scale field of the JSON data.
   * @param resolutionFilename - The filename to use for resolving
   *        the default resolution.
   * @returns Resolution to use for spritesheet.
   */
  _updateResolution(resolutionFilename = null) {
    const { scale } = this.data.meta;
    let resolution = core.utils.getResolutionOfUrl(resolutionFilename, null);
    return resolution === null && (resolution = parseFloat(scale ?? "1")), resolution !== 1 && this.baseTexture.setResolution(resolution), resolution;
  }
  /**
   * Parser spritesheet from loaded data. This is done asynchronously
   * to prevent creating too many Texture within a single process.
   * @method PIXI.Spritesheet#parse
   */
  parse() {
    return new Promise((resolve) => {
      this._callback = resolve, this._batchIndex = 0, this._frameKeys.length <= _Spritesheet2.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
    });
  }
  /**
   * Process a batch of frames
   * @param initialFrameIndex - The index of frame to start.
   */
  _processFrames(initialFrameIndex) {
    let frameIndex = initialFrameIndex;
    const maxFrames = _Spritesheet2.BATCH_SIZE;
    for (; frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length; ) {
      const i = this._frameKeys[frameIndex], data = this._frames[i], rect = data.frame;
      if (rect) {
        let frame = null, trim = null;
        const sourceSize = data.trimmed !== !1 && data.sourceSize ? data.sourceSize : data.frame, orig = new core.Rectangle(
          0,
          0,
          Math.floor(sourceSize.w) / this.resolution,
          Math.floor(sourceSize.h) / this.resolution
        );
        data.rotated ? frame = new core.Rectangle(
          Math.floor(rect.x) / this.resolution,
          Math.floor(rect.y) / this.resolution,
          Math.floor(rect.h) / this.resolution,
          Math.floor(rect.w) / this.resolution
        ) : frame = new core.Rectangle(
          Math.floor(rect.x) / this.resolution,
          Math.floor(rect.y) / this.resolution,
          Math.floor(rect.w) / this.resolution,
          Math.floor(rect.h) / this.resolution
        ), data.trimmed !== !1 && data.spriteSourceSize && (trim = new core.Rectangle(
          Math.floor(data.spriteSourceSize.x) / this.resolution,
          Math.floor(data.spriteSourceSize.y) / this.resolution,
          Math.floor(rect.w) / this.resolution,
          Math.floor(rect.h) / this.resolution
        )), this.textures[i] = new core.Texture(
          this.baseTexture,
          frame,
          orig,
          trim,
          data.rotated ? 2 : 0,
          data.anchor,
          data.borders
        ), core.Texture.addToCache(this.textures[i], i.toString());
      }
      frameIndex++;
    }
  }
  /** Parse animations config. */
  _processAnimations() {
    const animations = this.data.animations || {};
    for (const animName in animations) {
      this.animations[animName] = [];
      for (let i = 0; i < animations[animName].length; i++) {
        const frameName = animations[animName][i];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  }
  /** The parse has completed. */
  _parseComplete() {
    const callback = this._callback;
    this._callback = null, this._batchIndex = 0, callback.call(this, this.textures);
  }
  /** Begin the next batch of textures. */
  _nextBatch() {
    this._processFrames(this._batchIndex * _Spritesheet2.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
      this._batchIndex * _Spritesheet2.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
    }, 0);
  }
  /**
   * Destroy Spritesheet and don't use after this.
   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
   */
  destroy(destroyBase = !1) {
    for (const i in this.textures)
      this.textures[i].destroy();
    this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, destroyBase && (this._texture?.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];
  }
};
_Spritesheet.BATCH_SIZE = 1e3;
let Spritesheet = _Spritesheet;
exports.Spritesheet = Spritesheet;
//# sourceMappingURL=Spritesheet.js.map


/***/ }),

/***/ "./node_modules/@pixi/spritesheet/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/spritesheet/lib/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Spritesheet = __webpack_require__(/*! ./Spritesheet.js */ "./node_modules/@pixi/spritesheet/lib/Spritesheet.js"), spritesheetAsset = __webpack_require__(/*! ./spritesheetAsset.js */ "./node_modules/@pixi/spritesheet/lib/spritesheetAsset.js");
exports.Spritesheet = Spritesheet.Spritesheet;
exports.spritesheetAsset = spritesheetAsset.spritesheetAsset;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/spritesheet/lib/spritesheetAsset.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/spritesheet/lib/spritesheetAsset.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var assets = __webpack_require__(/*! @pixi/assets */ "./node_modules/@pixi/assets/lib/index.js"), core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), Spritesheet = __webpack_require__(/*! ./Spritesheet.js */ "./node_modules/@pixi/spritesheet/lib/Spritesheet.js");
const validImages = ["jpg", "png", "jpeg", "avif", "webp"];
function getCacheableAssets(keys, asset, ignoreMultiPack) {
  const out = {};
  if (keys.forEach((key) => {
    out[key] = asset;
  }), Object.keys(asset.textures).forEach((key) => {
    out[key] = asset.textures[key];
  }), !ignoreMultiPack) {
    const basePath = core.utils.path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i) => {
      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, !0);
      Object.assign(out, out2);
    });
  }
  return out;
}
const spritesheetAsset = {
  extension: core.ExtensionType.Asset,
  /** Handle the caching of the related Spritesheet Textures */
  cache: {
    test: (asset) => asset instanceof Spritesheet.Spritesheet,
    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, !1)
  },
  /** Resolve the the resolution of the asset. */
  resolver: {
    test: (value) => {
      const split = value.split("?")[0].split("."), extension = split.pop(), format = split.pop();
      return extension === "json" && validImages.includes(format);
    },
    parse: (value) => {
      const split = value.split(".");
      return {
        resolution: parseFloat(core.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
        format: split[split.length - 2],
        src: value
      };
    }
  },
  /**
   * Loader plugin that parses sprite sheets!
   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
   * If it is, we load the spritesheets image and parse the data into PIXI.Spritesheet
   * All textures in the sprite sheet are then added to the cache
   * @ignore
   */
  loader: {
    name: "spritesheetLoader",
    extension: {
      type: core.ExtensionType.LoadParser,
      priority: assets.LoaderParserPriority.Normal
    },
    async testParse(asset, options) {
      return core.utils.path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
    },
    async parse(asset, options, loader) {
      let basePath = core.utils.path.dirname(options.src);
      basePath && basePath.lastIndexOf("/") !== basePath.length - 1 && (basePath += "/");
      let imagePath = basePath + asset.meta.image;
      imagePath = assets.copySearchParams(imagePath, options.src);
      const texture = (await loader.load([imagePath]))[imagePath], spritesheet = new Spritesheet.Spritesheet(
        texture.baseTexture,
        asset,
        options.src
      );
      await spritesheet.parse();
      const multiPacks = asset?.meta?.related_multi_packs;
      if (Array.isArray(multiPacks)) {
        const promises = [];
        for (const item of multiPacks) {
          if (typeof item != "string")
            continue;
          let itemUrl = basePath + item;
          options.data?.ignoreMultiPack || (itemUrl = assets.copySearchParams(itemUrl, options.src), promises.push(loader.load({
            src: itemUrl,
            data: {
              ignoreMultiPack: !0
            }
          })));
        }
        const res = await Promise.all(promises);
        spritesheet.linkedSheets = res, res.forEach((item) => {
          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
        });
      }
      return spritesheet;
    },
    unload(spritesheet) {
      spritesheet.destroy(!0);
    }
  }
};
core.extensions.add(spritesheetAsset);
exports.spritesheetAsset = spritesheetAsset;
//# sourceMappingURL=spritesheetAsset.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/BitmapFont.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/BitmapFont.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), text = __webpack_require__(/*! @pixi/text */ "./node_modules/@pixi/text/lib/index.js"), BitmapFontData = __webpack_require__(/*! ./BitmapFontData.js */ "./node_modules/@pixi/text-bitmap/lib/BitmapFontData.js"), index = __webpack_require__(/*! ./formats/index.js */ "./node_modules/@pixi/text-bitmap/lib/formats/index.js");
__webpack_require__(/*! ./utils/index.js */ "./node_modules/@pixi/text-bitmap/lib/utils/index.js");
var resolveCharacters = __webpack_require__(/*! ./utils/resolveCharacters.js */ "./node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.js"), drawGlyph = __webpack_require__(/*! ./utils/drawGlyph.js */ "./node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.js"), extractCharCode = __webpack_require__(/*! ./utils/extractCharCode.js */ "./node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.js");
const _BitmapFont = class _BitmapFont2 {
  /**
   * @param data
   * @param textures
   * @param ownsTextures - Setting to `true` will destroy page textures
   *        when the font is uninstalled.
   */
  constructor(data, textures, ownsTextures) {
    const [info] = data.info, [common] = data.common, [page] = data.page, [distanceField] = data.distanceField, res = core.utils.getResolutionOfUrl(page.file), pageTextures = {};
    this._ownsTextures = ownsTextures, this.font = info.face, this.size = info.size, this.lineHeight = common.lineHeight / res, this.chars = {}, this.pageTextures = pageTextures;
    for (let i = 0; i < data.page.length; i++) {
      const { id, file } = data.page[i];
      pageTextures[id] = textures instanceof Array ? textures[i] : textures[file], distanceField?.fieldType && distanceField.fieldType !== "none" && (pageTextures[id].baseTexture.alphaMode = core.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA, pageTextures[id].baseTexture.mipmap = core.MIPMAP_MODES.OFF);
    }
    for (let i = 0; i < data.char.length; i++) {
      const { id, page: page2 } = data.char[i];
      let { x, y, width, height, xoffset, yoffset, xadvance } = data.char[i];
      x /= res, y /= res, width /= res, height /= res, xoffset /= res, yoffset /= res, xadvance /= res;
      const rect = new core.Rectangle(
        x + pageTextures[page2].frame.x / res,
        y + pageTextures[page2].frame.y / res,
        width,
        height
      );
      this.chars[id] = {
        xOffset: xoffset,
        yOffset: yoffset,
        xAdvance: xadvance,
        kerning: {},
        texture: new core.Texture(
          pageTextures[page2].baseTexture,
          rect
        ),
        page: page2
      };
    }
    for (let i = 0; i < data.kerning.length; i++) {
      let { first, second, amount } = data.kerning[i];
      first /= res, second /= res, amount /= res, this.chars[second] && (this.chars[second].kerning[first] = amount);
    }
    this.distanceFieldRange = distanceField?.distanceRange, this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? "none";
  }
  /** Remove references to created glyph textures. */
  destroy() {
    for (const id in this.chars)
      this.chars[id].texture.destroy(), this.chars[id].texture = null;
    for (const id in this.pageTextures)
      this._ownsTextures && this.pageTextures[id].destroy(!0), this.pageTextures[id] = null;
    this.chars = null, this.pageTextures = null;
  }
  /**
   * Register a new bitmap font.
   * @param data - The
   *        characters map that could be provided as xml or raw string.
   * @param textures - List of textures for each page.
   * @param ownsTextures - Set to `true` to destroy page textures
   *        when the font is uninstalled. By default fonts created with
   *        `BitmapFont.from` or from the `BitmapFontLoader` are `true`.
   * @returns {PIXI.BitmapFont} Result font object with font, size, lineHeight
   *         and char fields.
   */
  static install(data, textures, ownsTextures) {
    let fontData;
    if (data instanceof BitmapFontData.BitmapFontData)
      fontData = data;
    else {
      const format = index.autoDetectFormat(data);
      if (!format)
        throw new Error("Unrecognized data format for font.");
      fontData = format.parse(data);
    }
    textures instanceof core.Texture && (textures = [textures]);
    const font = new _BitmapFont2(fontData, textures, ownsTextures);
    return _BitmapFont2.available[font.font] = font, font;
  }
  /**
   * Remove bitmap font by name.
   * @param name - Name of the font to uninstall.
   */
  static uninstall(name) {
    const font = _BitmapFont2.available[name];
    if (!font)
      throw new Error(`No font found named '${name}'`);
    font.destroy(), delete _BitmapFont2.available[name];
  }
  /**
   * Generates a bitmap-font for the given style and character set. This does not support
   * kernings yet. With `style` properties, only the following non-layout properties are used:
   *
   * - {@link PIXI.TextStyle#dropShadow|dropShadow}
   * - {@link PIXI.TextStyle#dropShadowDistance|dropShadowDistance}
   * - {@link PIXI.TextStyle#dropShadowColor|dropShadowColor}
   * - {@link PIXI.TextStyle#dropShadowBlur|dropShadowBlur}
   * - {@link PIXI.TextStyle#dropShadowAngle|dropShadowAngle}
   * - {@link PIXI.TextStyle#fill|fill}
   * - {@link PIXI.TextStyle#fillGradientStops|fillGradientStops}
   * - {@link PIXI.TextStyle#fillGradientType|fillGradientType}
   * - {@link PIXI.TextStyle#fontFamily|fontFamily}
   * - {@link PIXI.TextStyle#fontSize|fontSize}
   * - {@link PIXI.TextStyle#fontVariant|fontVariant}
   * - {@link PIXI.TextStyle#fontWeight|fontWeight}
   * - {@link PIXI.TextStyle#lineJoin|lineJoin}
   * - {@link PIXI.TextStyle#miterLimit|miterLimit}
   * - {@link PIXI.TextStyle#stroke|stroke}
   * - {@link PIXI.TextStyle#strokeThickness|strokeThickness}
   * - {@link PIXI.TextStyle#textBaseline|textBaseline}
   * @param name - The name of the custom font to use with BitmapText.
   * @param textStyle - Style options to render with BitmapFont.
   * @param options - Setup options for font or name of the font.
   * @returns Font generated by style options.
   * @example
   * import { BitmapFont, BitmapText } from 'pixi.js';
   *
   * BitmapFont.from('TitleFont', {
   *     fontFamily: 'Arial',
   *     fontSize: 12,
   *     strokeThickness: 2,
   *     fill: 'purple',
   * });
   *
   * const title = new BitmapText('This is the title', { fontName: 'TitleFont' });
   */
  static from(name, textStyle, options) {
    if (!name)
      throw new Error("[BitmapFont] Property `name` is required.");
    const {
      chars,
      padding,
      resolution,
      textureWidth,
      textureHeight,
      ...baseOptions
    } = Object.assign({}, _BitmapFont2.defaultOptions, options), charsList = resolveCharacters.resolveCharacters(chars), style = textStyle instanceof text.TextStyle ? textStyle : new text.TextStyle(textStyle), lineWidth = textureWidth, fontData = new BitmapFontData.BitmapFontData();
    fontData.info[0] = {
      face: style.fontFamily,
      size: style.fontSize
    }, fontData.common[0] = {
      lineHeight: style.fontSize
    };
    let positionX = 0, positionY = 0, canvas, context, baseTexture, maxCharHeight = 0;
    const baseTextures = [], textures = [];
    for (let i = 0; i < charsList.length; i++) {
      canvas || (canvas = core.settings.ADAPTER.createCanvas(), canvas.width = textureWidth, canvas.height = textureHeight, context = canvas.getContext("2d"), baseTexture = new core.BaseTexture(canvas, { resolution, ...baseOptions }), baseTextures.push(baseTexture), textures.push(new core.Texture(baseTexture)), fontData.page.push({
        id: textures.length - 1,
        file: ""
      }));
      const character = charsList[i], metrics = text.TextMetrics.measureText(character, style, !1, canvas), width = metrics.width, height = Math.ceil(metrics.height), textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
      if (positionY >= textureHeight - height * resolution) {
        if (positionY === 0)
          throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        --i, canvas = null, context = null, baseTexture = null, positionY = 0, positionX = 0, maxCharHeight = 0;
        continue;
      }
      if (maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight), textureGlyphWidth * resolution + positionX >= lineWidth) {
        if (positionX === 0)
          throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        --i, positionY += maxCharHeight * resolution, positionY = Math.ceil(positionY), positionX = 0, maxCharHeight = 0;
        continue;
      }
      drawGlyph.drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);
      const id = extractCharCode.extractCharCode(metrics.text);
      fontData.char.push({
        id,
        page: textures.length - 1,
        x: positionX / resolution,
        y: positionY / resolution,
        width: textureGlyphWidth,
        height,
        xoffset: 0,
        yoffset: 0,
        xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)
      }), positionX += (textureGlyphWidth + 2 * padding) * resolution, positionX = Math.ceil(positionX);
    }
    if (!options?.skipKerning)
      for (let i = 0, len = charsList.length; i < len; i++) {
        const first = charsList[i];
        for (let j = 0; j < len; j++) {
          const second = charsList[j], c1 = context.measureText(first).width, c2 = context.measureText(second).width, amount = context.measureText(first + second).width - (c1 + c2);
          amount && fontData.kerning.push({
            first: extractCharCode.extractCharCode(first),
            second: extractCharCode.extractCharCode(second),
            amount
          });
        }
      }
    const font = new _BitmapFont2(fontData, textures, !0);
    return _BitmapFont2.available[name] !== void 0 && _BitmapFont2.uninstall(name), _BitmapFont2.available[name] = font, font;
  }
};
_BitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "], /**
* This character set includes all decimal digits (from 0 to 9).
* @type {string[][]}
* @example
* BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })
*/
_BitmapFont.NUMERIC = [["0", "9"]], /**
* This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.
* @type {string[][]}
*/
_BitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], /**
* This character set consists of all the ASCII table.
* @member {string[][]}
* @see http://www.asciitable.com/
*/
_BitmapFont.ASCII = [[" ", "~"]], /**
* Collection of default options when using `BitmapFont.from`.
* @property {number} [resolution=1] -
* @property {number} [textureWidth=512] -
* @property {number} [textureHeight=512] -
* @property {number} [padding=4] -
* @property {string|string[]|string[][]} chars = PIXI.BitmapFont.ALPHANUMERIC
*/
_BitmapFont.defaultOptions = {
  resolution: 1,
  textureWidth: 512,
  textureHeight: 512,
  padding: 4,
  chars: _BitmapFont.ALPHANUMERIC
}, /** Collection of available/installed fonts. */
_BitmapFont.available = {};
let BitmapFont = _BitmapFont;
exports.BitmapFont = BitmapFont;
//# sourceMappingURL=BitmapFont.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/BitmapFontData.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/BitmapFontData.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class BitmapFontData {
  constructor() {
    this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];
  }
}
exports.BitmapFontData = BitmapFontData;
//# sourceMappingURL=BitmapFontData.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/BitmapText.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/BitmapText.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), display = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.js"), mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.js"), BitmapFont = __webpack_require__(/*! ./BitmapFont.js */ "./node_modules/@pixi/text-bitmap/lib/BitmapFont.js"), msdf$1 = __webpack_require__(/*! ./shader/msdf.frag.js */ "./node_modules/@pixi/text-bitmap/lib/shader/msdf.frag.js"), msdf = __webpack_require__(/*! ./shader/msdf.vert.js */ "./node_modules/@pixi/text-bitmap/lib/shader/msdf.vert.js");
__webpack_require__(/*! ./utils/index.js */ "./node_modules/@pixi/text-bitmap/lib/utils/index.js");
var splitTextToCharacters = __webpack_require__(/*! ./utils/splitTextToCharacters.js */ "./node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.js"), extractCharCode = __webpack_require__(/*! ./utils/extractCharCode.js */ "./node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.js");
const pageMeshDataDefaultPageMeshData = [], pageMeshDataMSDFPageMeshData = [], charRenderDataPool = [], _BitmapText = class _BitmapText2 extends display.Container {
  /**
   * @param text - A string that you would like the text to display.
   * @param style - The style parameters.
   * @param {string} style.fontName - The installed BitmapFont name.
   * @param {number} [style.fontSize] - The size of the font in pixels, e.g. 24. If undefined,
   *.     this will default to the BitmapFont size.
   * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center', 'right' or 'justify'),
   *      does not affect single line text.
   * @param {PIXI.ColorSource} [style.tint=0xFFFFFF] - The tint color.
   * @param {number} [style.letterSpacing=0] - The amount of spacing between letters.
   * @param {number} [style.maxWidth=0] - The max width of the text before line wrapping.
   */
  constructor(text, style = {}) {
    super();
    const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign(
      {},
      _BitmapText2.styleDefaults,
      style
    );
    if (!BitmapFont.BitmapFont.available[fontName])
      throw new Error(`Missing BitmapFont "${fontName}"`);
    this._activePagesMeshData = [], this._textWidth = 0, this._textHeight = 0, this._align = align, this._tintColor = new core.Color(tint), this._font = void 0, this._fontName = fontName, this._fontSize = fontSize, this.text = text, this._maxWidth = maxWidth, this._maxLineHeight = 0, this._letterSpacing = letterSpacing, this._anchor = new core.ObservablePoint(() => {
      this.dirty = !0;
    }, this, 0, 0), this._roundPixels = core.settings.ROUND_PIXELS, this.dirty = !0, this._resolution = core.settings.RESOLUTION, this._autoResolution = !0, this._textureCache = {};
  }
  /** Renders text and updates it when needed. This should only be called if the BitmapFont is regenerated. */
  updateText() {
    const data = BitmapFont.BitmapFont.available[this._fontName], fontSize = this.fontSize, scale = fontSize / data.size, pos = new core.Point(), chars = [], lineWidths = [], lineSpaces = [], text = this._text.replace(/(?:\r\n|\r)/g, `
`) || " ", charsInput = splitTextToCharacters.splitTextToCharacters(text), maxWidth = this._maxWidth * data.size / fontSize, pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    let prevCharCode = null, lastLineWidth = 0, maxLineWidth = 0, line = 0, lastBreakPos = -1, lastBreakWidth = 0, spacesRemoved = 0, maxLineHeight = 0, spaceCount = 0;
    for (let i = 0; i < charsInput.length; i++) {
      const char = charsInput[i], charCode = extractCharCode.extractCharCode(char);
      if (/(?:\s)/.test(char) && (lastBreakPos = i, lastBreakWidth = lastLineWidth, spaceCount++), char === "\r" || char === `
`) {
        lineWidths.push(lastLineWidth), lineSpaces.push(-1), maxLineWidth = Math.max(maxLineWidth, lastLineWidth), ++line, ++spacesRemoved, pos.x = 0, pos.y += data.lineHeight, prevCharCode = null, spaceCount = 0;
        continue;
      }
      const charData = data.chars[charCode];
      if (!charData)
        continue;
      prevCharCode && charData.kerning[prevCharCode] && (pos.x += charData.kerning[prevCharCode]);
      const charRenderData = charRenderDataPool.pop() || {
        texture: core.Texture.EMPTY,
        line: 0,
        charCode: 0,
        prevSpaces: 0,
        position: new core.Point()
      };
      charRenderData.texture = charData.texture, charRenderData.line = line, charRenderData.charCode = charCode, charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2), charRenderData.position.y = Math.round(pos.y + charData.yOffset), charRenderData.prevSpaces = spaceCount, chars.push(charRenderData), lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width), pos.x += charData.xAdvance + this._letterSpacing, maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height), prevCharCode = charCode, lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth && (++spacesRemoved, core.utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos), i = lastBreakPos, lastBreakPos = -1, lineWidths.push(lastBreakWidth), lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0), maxLineWidth = Math.max(maxLineWidth, lastBreakWidth), line++, pos.x = 0, pos.y += data.lineHeight, prevCharCode = null, spaceCount = 0);
    }
    const lastChar = charsInput[charsInput.length - 1];
    lastChar !== "\r" && lastChar !== `
` && (/(?:\s)/.test(lastChar) && (lastLineWidth = lastBreakWidth), lineWidths.push(lastLineWidth), maxLineWidth = Math.max(maxLineWidth, lastLineWidth), lineSpaces.push(-1));
    const lineAlignOffsets = [];
    for (let i = 0; i <= line; i++) {
      let alignOffset = 0;
      this._align === "right" ? alignOffset = maxLineWidth - lineWidths[i] : this._align === "center" ? alignOffset = (maxLineWidth - lineWidths[i]) / 2 : this._align === "justify" && (alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i]), lineAlignOffsets.push(alignOffset);
    }
    const lenChars = chars.length, pagesMeshData = {}, newPagesMeshData = [], activePagesMeshData = this._activePagesMeshData;
    pageMeshDataPool.push(...activePagesMeshData);
    for (let i = 0; i < lenChars; i++) {
      const texture = chars[i].texture, baseTextureUid = texture.baseTexture.uid;
      if (!pagesMeshData[baseTextureUid]) {
        let pageMeshData = pageMeshDataPool.pop();
        if (!pageMeshData) {
          const geometry = new mesh.MeshGeometry();
          let material, meshBlendMode;
          data.distanceFieldType === "none" ? (material = new mesh.MeshMaterial(core.Texture.EMPTY), meshBlendMode = core.BLEND_MODES.NORMAL) : (material = new mesh.MeshMaterial(
            core.Texture.EMPTY,
            { program: core.Program.from(msdf.default, msdf$1.default), uniforms: { uFWidth: 0 } }
          ), meshBlendMode = core.BLEND_MODES.NORMAL_NPM);
          const mesh$1 = new mesh.Mesh(geometry, material);
          mesh$1.blendMode = meshBlendMode, pageMeshData = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh: mesh$1,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        pageMeshData.index = 0, pageMeshData.indexCount = 0, pageMeshData.vertexCount = 0, pageMeshData.uvsCount = 0, pageMeshData.total = 0;
        const { _textureCache } = this;
        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new core.Texture(texture.baseTexture), pageMeshData.mesh.texture = _textureCache[baseTextureUid], pageMeshData.mesh.tint = this._tintColor.value, newPagesMeshData.push(pageMeshData), pagesMeshData[baseTextureUid] = pageMeshData;
      }
      pagesMeshData[baseTextureUid].total++;
    }
    for (let i = 0; i < activePagesMeshData.length; i++)
      newPagesMeshData.includes(activePagesMeshData[i]) || this.removeChild(activePagesMeshData[i].mesh);
    for (let i = 0; i < newPagesMeshData.length; i++)
      newPagesMeshData[i].mesh.parent !== this && this.addChild(newPagesMeshData[i].mesh);
    this._activePagesMeshData = newPagesMeshData;
    for (const i in pagesMeshData) {
      const pageMeshData = pagesMeshData[i], total = pageMeshData.total;
      if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < mesh.Mesh.BATCHABLE_SIZE * 2)
        pageMeshData.vertices = new Float32Array(4 * 2 * total), pageMeshData.uvs = new Float32Array(4 * 2 * total), pageMeshData.indices = new Uint16Array(6 * total);
      else {
        const total2 = pageMeshData.total, vertices = pageMeshData.vertices;
        for (let i2 = total2 * 4 * 2; i2 < vertices.length; i2++)
          vertices[i2] = 0;
      }
      pageMeshData.mesh.size = 6 * total;
    }
    for (let i = 0; i < lenChars; i++) {
      const char = chars[i];
      let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
      this._roundPixels && (offset = Math.round(offset));
      const xPos = offset * scale, yPos = char.position.y * scale, texture = char.texture, pageMesh = pagesMeshData[texture.baseTexture.uid], textureFrame = texture.frame, textureUvs = texture._uvs, index = pageMesh.index++;
      pageMesh.indices[index * 6 + 0] = 0 + index * 4, pageMesh.indices[index * 6 + 1] = 1 + index * 4, pageMesh.indices[index * 6 + 2] = 2 + index * 4, pageMesh.indices[index * 6 + 3] = 0 + index * 4, pageMesh.indices[index * 6 + 4] = 2 + index * 4, pageMesh.indices[index * 6 + 5] = 3 + index * 4, pageMesh.vertices[index * 8 + 0] = xPos, pageMesh.vertices[index * 8 + 1] = yPos, pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale, pageMesh.vertices[index * 8 + 3] = yPos, pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale, pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale, pageMesh.vertices[index * 8 + 6] = xPos, pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale, pageMesh.uvs[index * 8 + 0] = textureUvs.x0, pageMesh.uvs[index * 8 + 1] = textureUvs.y0, pageMesh.uvs[index * 8 + 2] = textureUvs.x1, pageMesh.uvs[index * 8 + 3] = textureUvs.y1, pageMesh.uvs[index * 8 + 4] = textureUvs.x2, pageMesh.uvs[index * 8 + 5] = textureUvs.y2, pageMesh.uvs[index * 8 + 6] = textureUvs.x3, pageMesh.uvs[index * 8 + 7] = textureUvs.y3;
    }
    this._textWidth = maxLineWidth * scale, this._textHeight = (pos.y + data.lineHeight) * scale;
    for (const i in pagesMeshData) {
      const pageMeshData = pagesMeshData[i];
      if (this.anchor.x !== 0 || this.anchor.y !== 0) {
        let vertexCount = 0;
        const anchorOffsetX = this._textWidth * this.anchor.x, anchorOffsetY = this._textHeight * this.anchor.y;
        for (let i2 = 0; i2 < pageMeshData.total; i2++)
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY, pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY, pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY, pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
      }
      this._maxLineHeight = maxLineHeight * scale;
      const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition"), textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord"), indexBuffer = pageMeshData.mesh.geometry.getIndex();
      vertexBuffer.data = pageMeshData.vertices, textureBuffer.data = pageMeshData.uvs, indexBuffer.data = pageMeshData.indices, vertexBuffer.update(), textureBuffer.update(), indexBuffer.update();
    }
    for (let i = 0; i < chars.length; i++)
      charRenderDataPool.push(chars[i]);
    this._font = data, this.dirty = !1;
  }
  updateTransform() {
    this.validate(), this.containerUpdateTransform();
  }
  _render(renderer) {
    this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0);
    const { distanceFieldRange, distanceFieldType, size } = BitmapFont.BitmapFont.available[this._fontName];
    if (distanceFieldType !== "none") {
      const { a, b, c, d } = this.worldTransform, dx = Math.sqrt(a * a + b * b), dy = Math.sqrt(c * c + d * d), worldScale = (Math.abs(dx) + Math.abs(dy)) / 2, fontScale = this.fontSize / size, resolution = renderer._view.resolution;
      for (const mesh2 of this._activePagesMeshData)
        mesh2.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;
    }
    super._render(renderer);
  }
  /**
   * Validates text before calling parent's getLocalBounds
   * @returns - The rectangular bounding area
   */
  getLocalBounds() {
    return this.validate(), super.getLocalBounds();
  }
  /**
   * Updates text when needed
   * @private
   */
  validate() {
    const font = BitmapFont.BitmapFont.available[this._fontName];
    if (!font)
      throw new Error(`Missing BitmapFont "${this._fontName}"`);
    this._font !== font && (this.dirty = !0), this.dirty && this.updateText();
  }
  /**
   * The tint of the BitmapText object.
   * @default 0xffffff
   */
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    if (this.tint !== value) {
      this._tintColor.setValue(value);
      for (let i = 0; i < this._activePagesMeshData.length; i++)
        this._activePagesMeshData[i].mesh.tint = value;
    }
  }
  /**
   * The alignment of the BitmapText object.
   * @member {string}
   * @default 'left'
   */
  get align() {
    return this._align;
  }
  set align(value) {
    this._align !== value && (this._align = value, this.dirty = !0);
  }
  /** The name of the BitmapFont. */
  get fontName() {
    return this._fontName;
  }
  set fontName(value) {
    if (!BitmapFont.BitmapFont.available[value])
      throw new Error(`Missing BitmapFont "${value}"`);
    this._fontName !== value && (this._fontName = value, this.dirty = !0);
  }
  /** The size of the font to display. */
  get fontSize() {
    return this._fontSize ?? BitmapFont.BitmapFont.available[this._fontName].size;
  }
  set fontSize(value) {
    this._fontSize !== value && (this._fontSize = value, this.dirty = !0);
  }
  /**
   * The anchor sets the origin point of the text.
   *
   * The default is `(0,0)`, this means the text's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    typeof value == "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
  }
  /** The text of the BitmapText object. */
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text ?? ""), this._text !== text && (this._text = text, this.dirty = !0);
  }
  /**
   * The max width of this bitmap text in pixels. If the text provided is longer than the
   * value provided, line breaks will be automatically inserted in the last whitespace.
   * Disable by setting the value to 0.
   */
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(value) {
    this._maxWidth !== value && (this._maxWidth = value, this.dirty = !0);
  }
  /**
   * The max line height. This is useful when trying to use the total height of the Text,
   * i.e. when trying to vertically align.
   * @readonly
   */
  get maxLineHeight() {
    return this.validate(), this._maxLineHeight;
  }
  /**
   * The width of the overall text, different from fontSize,
   * which is defined in the style object.
   * @readonly
   */
  get textWidth() {
    return this.validate(), this._textWidth;
  }
  /** Additional space between characters. */
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(value) {
    this._letterSpacing !== value && (this._letterSpacing = value, this.dirty = !0);
  }
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
   * @default PIXI.settings.ROUND_PIXELS
   */
  get roundPixels() {
    return this._roundPixels;
  }
  set roundPixels(value) {
    value !== this._roundPixels && (this._roundPixels = value, this.dirty = !0);
  }
  /**
   * The height of the overall text, different from fontSize,
   * which is defined in the style object.
   * @readonly
   */
  get textHeight() {
    return this.validate(), this._textHeight;
  }
  /**
   * The resolution / device pixel ratio of the canvas.
   *
   * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
   * @default 1
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = !1, this._resolution !== value && (this._resolution = value, this.dirty = !0);
  }
  destroy(options) {
    const { _textureCache } = this, pageMeshDataPool = BitmapFont.BitmapFont.available[this._fontName].distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    pageMeshDataPool.push(...this._activePagesMeshData);
    for (const pageMeshData of this._activePagesMeshData)
      this.removeChild(pageMeshData.mesh);
    this._activePagesMeshData = [], pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {
      page.mesh.texture = core.Texture.EMPTY;
    });
    for (const id in _textureCache)
      _textureCache[id].destroy(), delete _textureCache[id];
    this._font = null, this._tintColor = null, this._textureCache = null, super.destroy(options);
  }
};
_BitmapText.styleDefaults = {
  align: "left",
  tint: 16777215,
  maxWidth: 0,
  letterSpacing: 0
};
let BitmapText = _BitmapText;
exports.BitmapText = BitmapText;
//# sourceMappingURL=BitmapText.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/BitmapTextStyle.js":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/BitmapTextStyle.js ***!
  \***************************************************************/
/***/ (() => {

"use strict";

//# sourceMappingURL=BitmapTextStyle.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/formats/TextFormat.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/formats/TextFormat.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var BitmapFontData = __webpack_require__(/*! ../BitmapFontData.js */ "./node_modules/@pixi/text-bitmap/lib/BitmapFontData.js");
class TextFormat {
  /**
   * Check if resource refers to txt font data.
   * @param data
   * @returns - True if resource could be treated as font data, false otherwise.
   */
  static test(data) {
    return typeof data == "string" && data.startsWith("info face=");
  }
  /**
   * Convert text font data to a javascript object.
   * @param txt - Raw string data to be converted
   * @returns - Parsed font data
   */
  static parse(txt) {
    const items = txt.match(/^[a-z]+\s+.+$/gm), rawData = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (const i in items) {
      const name = items[i].match(/^[a-z]+/gm)[0], attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), itemData = {};
      for (const i2 in attributeList) {
        const split = attributeList[i2].split("="), key = split[0], strValue = split[1].replace(/"/gm, ""), floatValue = parseFloat(strValue), value = isNaN(floatValue) ? strValue : floatValue;
        itemData[key] = value;
      }
      rawData[name].push(itemData);
    }
    const font = new BitmapFontData.BitmapFontData();
    return rawData.info.forEach((info) => font.info.push({
      face: info.face,
      size: parseInt(info.size, 10)
    })), rawData.common.forEach((common) => font.common.push({
      lineHeight: parseInt(common.lineHeight, 10)
    })), rawData.page.forEach((page) => font.page.push({
      id: parseInt(page.id, 10),
      file: page.file
    })), rawData.char.forEach((char) => font.char.push({
      id: parseInt(char.id, 10),
      page: parseInt(char.page, 10),
      x: parseInt(char.x, 10),
      y: parseInt(char.y, 10),
      width: parseInt(char.width, 10),
      height: parseInt(char.height, 10),
      xoffset: parseInt(char.xoffset, 10),
      yoffset: parseInt(char.yoffset, 10),
      xadvance: parseInt(char.xadvance, 10)
    })), rawData.kerning.forEach((kerning) => font.kerning.push({
      first: parseInt(kerning.first, 10),
      second: parseInt(kerning.second, 10),
      amount: parseInt(kerning.amount, 10)
    })), rawData.distanceField.forEach((df) => font.distanceField.push({
      distanceRange: parseInt(df.distanceRange, 10),
      fieldType: df.fieldType
    })), font;
  }
}
exports.TextFormat = TextFormat;
//# sourceMappingURL=TextFormat.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var BitmapFontData = __webpack_require__(/*! ../BitmapFontData.js */ "./node_modules/@pixi/text-bitmap/lib/BitmapFontData.js");
class XMLFormat {
  /**
   * Check if resource refers to xml font data.
   * @param data
   * @returns - True if resource could be treated as font data, false otherwise.
   */
  static test(data) {
    const xml = data;
    return typeof data != "string" && "getElementsByTagName" in data && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
  }
  /**
   * Convert the XML into BitmapFontData that we can use.
   * @param xml
   * @returns - Data to use for BitmapFont
   */
  static parse(xml) {
    const data = new BitmapFontData.BitmapFontData(), info = xml.getElementsByTagName("info"), common = xml.getElementsByTagName("common"), page = xml.getElementsByTagName("page"), char = xml.getElementsByTagName("char"), kerning = xml.getElementsByTagName("kerning"), distanceField = xml.getElementsByTagName("distanceField");
    for (let i = 0; i < info.length; i++)
      data.info.push({
        face: info[i].getAttribute("face"),
        size: parseInt(info[i].getAttribute("size"), 10)
      });
    for (let i = 0; i < common.length; i++)
      data.common.push({
        lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)
      });
    for (let i = 0; i < page.length; i++)
      data.page.push({
        id: parseInt(page[i].getAttribute("id"), 10) || 0,
        file: page[i].getAttribute("file")
      });
    for (let i = 0; i < char.length; i++) {
      const letter = char[i];
      data.char.push({
        id: parseInt(letter.getAttribute("id"), 10),
        page: parseInt(letter.getAttribute("page"), 10) || 0,
        x: parseInt(letter.getAttribute("x"), 10),
        y: parseInt(letter.getAttribute("y"), 10),
        width: parseInt(letter.getAttribute("width"), 10),
        height: parseInt(letter.getAttribute("height"), 10),
        xoffset: parseInt(letter.getAttribute("xoffset"), 10),
        yoffset: parseInt(letter.getAttribute("yoffset"), 10),
        xadvance: parseInt(letter.getAttribute("xadvance"), 10)
      });
    }
    for (let i = 0; i < kerning.length; i++)
      data.kerning.push({
        first: parseInt(kerning[i].getAttribute("first"), 10),
        second: parseInt(kerning[i].getAttribute("second"), 10),
        amount: parseInt(kerning[i].getAttribute("amount"), 10)
      });
    for (let i = 0; i < distanceField.length; i++)
      data.distanceField.push({
        fieldType: distanceField[i].getAttribute("fieldType"),
        distanceRange: parseInt(distanceField[i].getAttribute("distanceRange"), 10)
      });
    return data;
  }
}
exports.XMLFormat = XMLFormat;
//# sourceMappingURL=XMLFormat.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), XMLFormat = __webpack_require__(/*! ./XMLFormat.js */ "./node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.js");
class XMLStringFormat {
  /**
   * Check if resource refers to text xml font data.
   * @param data
   * @returns - True if resource could be treated as font data, false otherwise.
   */
  static test(data) {
    return typeof data == "string" && data.includes("<font>") ? XMLFormat.XMLFormat.test(core.settings.ADAPTER.parseXML(data)) : !1;
  }
  /**
   * Convert the text XML into BitmapFontData that we can use.
   * @param xmlTxt
   * @returns - Data to use for BitmapFont
   */
  static parse(xmlTxt) {
    return XMLFormat.XMLFormat.parse(core.settings.ADAPTER.parseXML(xmlTxt));
  }
}
exports.XMLStringFormat = XMLStringFormat;
//# sourceMappingURL=XMLStringFormat.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/formats/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/formats/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var TextFormat = __webpack_require__(/*! ./TextFormat.js */ "./node_modules/@pixi/text-bitmap/lib/formats/TextFormat.js"), XMLFormat = __webpack_require__(/*! ./XMLFormat.js */ "./node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.js"), XMLStringFormat = __webpack_require__(/*! ./XMLStringFormat.js */ "./node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.js");
const formats = [
  TextFormat.TextFormat,
  XMLFormat.XMLFormat,
  XMLStringFormat.XMLStringFormat
];
function autoDetectFormat(data) {
  for (let i = 0; i < formats.length; i++)
    if (formats[i].test(data))
      return formats[i];
  return null;
}
exports.TextFormat = TextFormat.TextFormat;
exports.XMLFormat = XMLFormat.XMLFormat;
exports.XMLStringFormat = XMLStringFormat.XMLStringFormat;
exports.autoDetectFormat = autoDetectFormat;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var BitmapFont = __webpack_require__(/*! ./BitmapFont.js */ "./node_modules/@pixi/text-bitmap/lib/BitmapFont.js"), BitmapFontData = __webpack_require__(/*! ./BitmapFontData.js */ "./node_modules/@pixi/text-bitmap/lib/BitmapFontData.js"), BitmapText = __webpack_require__(/*! ./BitmapText.js */ "./node_modules/@pixi/text-bitmap/lib/BitmapText.js");
__webpack_require__(/*! ./BitmapTextStyle.js */ "./node_modules/@pixi/text-bitmap/lib/BitmapTextStyle.js");
var index = __webpack_require__(/*! ./formats/index.js */ "./node_modules/@pixi/text-bitmap/lib/formats/index.js"), loadBitmapFont = __webpack_require__(/*! ./loadBitmapFont.js */ "./node_modules/@pixi/text-bitmap/lib/loadBitmapFont.js"), TextFormat = __webpack_require__(/*! ./formats/TextFormat.js */ "./node_modules/@pixi/text-bitmap/lib/formats/TextFormat.js"), XMLFormat = __webpack_require__(/*! ./formats/XMLFormat.js */ "./node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.js"), XMLStringFormat = __webpack_require__(/*! ./formats/XMLStringFormat.js */ "./node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.js");
exports.BitmapFont = BitmapFont.BitmapFont;
exports.BitmapFontData = BitmapFontData.BitmapFontData;
exports.BitmapText = BitmapText.BitmapText;
exports.autoDetectFormat = index.autoDetectFormat;
exports.loadBitmapFont = loadBitmapFont.loadBitmapFont;
exports.TextFormat = TextFormat.TextFormat;
exports.XMLFormat = XMLFormat.XMLFormat;
exports.XMLStringFormat = XMLStringFormat.XMLStringFormat;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/loadBitmapFont.js":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/loadBitmapFont.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var assets = __webpack_require__(/*! @pixi/assets */ "./node_modules/@pixi/assets/lib/index.js"), core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), BitmapFont = __webpack_require__(/*! ./BitmapFont.js */ "./node_modules/@pixi/text-bitmap/lib/BitmapFont.js");
__webpack_require__(/*! ./formats/index.js */ "./node_modules/@pixi/text-bitmap/lib/formats/index.js");
var TextFormat = __webpack_require__(/*! ./formats/TextFormat.js */ "./node_modules/@pixi/text-bitmap/lib/formats/TextFormat.js"), XMLStringFormat = __webpack_require__(/*! ./formats/XMLStringFormat.js */ "./node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.js");
const validExtensions = [".xml", ".fnt"], loadBitmapFont = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: assets.LoaderParserPriority.Normal
  },
  name: "loadBitmapFont",
  test(url) {
    return validExtensions.includes(core.utils.path.extname(url).toLowerCase());
  },
  async testParse(data) {
    return TextFormat.TextFormat.test(data) || XMLStringFormat.XMLStringFormat.test(data);
  },
  async parse(asset, data, loader) {
    const fontData = TextFormat.TextFormat.test(asset) ? TextFormat.TextFormat.parse(asset) : XMLStringFormat.XMLStringFormat.parse(asset), { src } = data, { page: pages } = fontData, textureUrls = [];
    for (let i = 0; i < pages.length; ++i) {
      const pageFile = pages[i].file;
      let imagePath = core.utils.path.join(core.utils.path.dirname(src), pageFile);
      imagePath = assets.copySearchParams(imagePath, src), textureUrls.push(imagePath);
    }
    const loadedTextures = await loader.load(textureUrls), textures = textureUrls.map((url) => loadedTextures[url]);
    return BitmapFont.BitmapFont.install(fontData, textures, !0);
  },
  async load(url, _options) {
    return (await core.settings.ADAPTER.fetch(url)).text();
  },
  unload(bitmapFont) {
    bitmapFont.destroy();
  }
};
core.extensions.add(loadBitmapFont);
exports.loadBitmapFont = loadBitmapFont;
//# sourceMappingURL=loadBitmapFont.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/shader/msdf.frag.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/shader/msdf.frag.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var msdfFrag = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // Gamma correction for coverage-like alpha\r
  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r
  float gamma = mix(1.0, 1.0 / 2.2, luma);\r
  float coverage = pow(uColor.a * alpha, gamma);  \r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, coverage);\r
}\r
`;
exports["default"] = msdfFrag;
//# sourceMappingURL=msdf.frag.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/shader/msdf.vert.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/shader/msdf.vert.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: !0 }));
var msdfVert = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`;
exports["default"] = msdfVert;
//# sourceMappingURL=msdf.vert.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.js":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), generateFillStyle = __webpack_require__(/*! ./generateFillStyle.js */ "./node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.js");
function drawGlyph(canvas, context, metrics, x, y, resolution, style) {
  const char = metrics.text, fontProperties = metrics.fontProperties;
  context.translate(x, y), context.scale(resolution, resolution);
  const tx = style.strokeThickness / 2, ty = -(style.strokeThickness / 2);
  if (context.font = style.toFontString(), context.lineWidth = style.strokeThickness, context.textBaseline = style.textBaseline, context.lineJoin = style.lineJoin, context.miterLimit = style.miterLimit, context.fillStyle = generateFillStyle.generateFillStyle(canvas, context, style, resolution, [char], metrics), context.strokeStyle = style.stroke, style.dropShadow) {
    const dropShadowColor = style.dropShadowColor, dropShadowBlur = style.dropShadowBlur * resolution, dropShadowDistance = style.dropShadowDistance * resolution;
    context.shadowColor = core.Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString(), context.shadowBlur = dropShadowBlur, context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance, context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
  } else
    context.shadowColor = "black", context.shadowBlur = 0, context.shadowOffsetX = 0, context.shadowOffsetY = 0;
  style.stroke && style.strokeThickness && context.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent), style.fill && context.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent), context.setTransform(1, 0, 0, 1, 0, 0), context.fillStyle = "rgba(0, 0, 0, 0)";
}
exports.drawGlyph = drawGlyph;
//# sourceMappingURL=drawGlyph.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function extractCharCode(str) {
  return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);
}
exports.extractCharCode = extractCharCode;
//# sourceMappingURL=extractCharCode.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var text = __webpack_require__(/*! @pixi/text */ "./node_modules/@pixi/text/lib/index.js");
function generateFillStyle(canvas, context, style, resolution, lines, metrics) {
  const fillStyle = style.fill;
  if (Array.isArray(fillStyle)) {
    if (fillStyle.length === 1)
      return fillStyle[0];
  } else
    return fillStyle;
  let gradient;
  const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0, padding = style.padding || 0, width = canvas.width / resolution - dropShadowCorrection - padding * 2, height = canvas.height / resolution - dropShadowCorrection - padding * 2, fill = fillStyle.slice(), fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    const lengthPlus1 = fill.length + 1;
    for (let i = 1; i < lengthPlus1; ++i)
      fillGradientStops.push(i / lengthPlus1);
  }
  if (fill.unshift(fillStyle[0]), fillGradientStops.unshift(0), fill.push(fillStyle[fillStyle.length - 1]), fillGradientStops.push(1), style.fillGradientType === text.TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context.createLinearGradient(width / 2, padding, width / 2, height + padding);
    let lastIterationStop = 0;
    const gradStopLineHeight = (metrics.fontProperties.fontSize + style.strokeThickness) / height;
    for (let i = 0; i < lines.length; i++) {
      const thisLineTop = metrics.lineHeight * i;
      for (let j = 0; j < fill.length; j++) {
        let lineStop = 0;
        typeof fillGradientStops[j] == "number" ? lineStop = fillGradientStops[j] : lineStop = j / fill.length;
        const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        let clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1), gradient.addColorStop(clampedStop, fill[j]), lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context.createLinearGradient(padding, height / 2, width + padding, height / 2);
    const totalIterations = fill.length + 1;
    let currentIteration = 1;
    for (let i = 0; i < fill.length; i++) {
      let stop;
      typeof fillGradientStops[i] == "number" ? stop = fillGradientStops[i] : stop = currentIteration / totalIterations, gradient.addColorStop(stop, fill[i]), currentIteration++;
    }
  }
  return gradient;
}
exports.generateFillStyle = generateFillStyle;
//# sourceMappingURL=generateFillStyle.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/utils/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/utils/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var drawGlyph = __webpack_require__(/*! ./drawGlyph.js */ "./node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.js"), extractCharCode = __webpack_require__(/*! ./extractCharCode.js */ "./node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.js"), generateFillStyle = __webpack_require__(/*! ./generateFillStyle.js */ "./node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.js"), resolveCharacters = __webpack_require__(/*! ./resolveCharacters.js */ "./node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.js"), splitTextToCharacters = __webpack_require__(/*! ./splitTextToCharacters.js */ "./node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.js");
exports.drawGlyph = drawGlyph.drawGlyph;
exports.extractCharCode = extractCharCode.extractCharCode;
exports.generateFillStyle = generateFillStyle.generateFillStyle;
exports.resolveCharacters = resolveCharacters.resolveCharacters;
exports.splitTextToCharacters = splitTextToCharacters.splitTextToCharacters;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var splitTextToCharacters = __webpack_require__(/*! ./splitTextToCharacters.js */ "./node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.js");
function resolveCharacters(chars) {
  typeof chars == "string" && (chars = [chars]);
  const result = [];
  for (let i = 0, j = chars.length; i < j; i++) {
    const item = chars[i];
    if (Array.isArray(item)) {
      if (item.length !== 2)
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      const startCode = item[0].charCodeAt(0), endCode = item[1].charCodeAt(0);
      if (endCode < startCode)
        throw new Error("[BitmapFont]: Invalid character range.");
      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++)
        result.push(String.fromCharCode(i2));
    } else
      result.push(...splitTextToCharacters.splitTextToCharacters(item));
  }
  if (result.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return result;
}
exports.resolveCharacters = resolveCharacters;
//# sourceMappingURL=resolveCharacters.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function splitTextToCharacters(text) {
  return Array.from ? Array.from(text) : text.split("");
}
exports.splitTextToCharacters = splitTextToCharacters;
//# sourceMappingURL=splitTextToCharacters.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-html/lib/HTMLText.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/text-html/lib/HTMLText.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), sprite = __webpack_require__(/*! @pixi/sprite */ "./node_modules/@pixi/sprite/lib/index.js"), text = __webpack_require__(/*! @pixi/text */ "./node_modules/@pixi/text/lib/index.js"), HTMLTextStyle = __webpack_require__(/*! ./HTMLTextStyle.js */ "./node_modules/@pixi/text-html/lib/HTMLTextStyle.js");
const _HTMLText = class _HTMLText2 extends sprite.Sprite {
  /**
   * @param {string} [text] - Text contents
   * @param {PIXI.HTMLTextStyle|PIXI.TextStyle|PIXI.ITextStyle} [style] - Style setting to use.
   *        Strongly recommend using an HTMLTextStyle object. Providing a PIXI.TextStyle
   *        will convert the TextStyle to an HTMLTextStyle and will no longer be linked.
   */
  constructor(text2 = "", style = {}) {
    super(core.Texture.EMPTY), this._text = null, this._style = null, this._autoResolution = !0, this.localStyleID = -1, this.dirty = !1, this._updateID = 0, this.ownsStyle = !1;
    const image = new Image(), texture = core.Texture.from(image, {
      scaleMode: core.settings.SCALE_MODE,
      resourceOptions: {
        autoLoad: !1
      }
    });
    texture.orig = new core.Rectangle(), texture.trim = new core.Rectangle(), this.texture = texture;
    const nssvg = "http://www.w3.org/2000/svg", nsxhtml = "http://www.w3.org/1999/xhtml", svgRoot = document.createElementNS(nssvg, "svg"), foreignObject = document.createElementNS(nssvg, "foreignObject"), domElement = document.createElementNS(nsxhtml, "div"), styleElement = document.createElementNS(nsxhtml, "style");
    foreignObject.setAttribute("width", "10000"), foreignObject.setAttribute("height", "10000"), foreignObject.style.overflow = "hidden", svgRoot.appendChild(foreignObject), this.maxWidth = _HTMLText2.defaultMaxWidth, this.maxHeight = _HTMLText2.defaultMaxHeight, this._domElement = domElement, this._styleElement = styleElement, this._svgRoot = svgRoot, this._foreignObject = foreignObject, this._foreignObject.appendChild(styleElement), this._foreignObject.appendChild(domElement), this._image = image, this._loadImage = new Image(), this._autoResolution = _HTMLText2.defaultAutoResolution, this._resolution = _HTMLText2.defaultResolution ?? core.settings.RESOLUTION, this.text = text2, this.style = style;
  }
  /**
   * Calculate the size of the output text without actually drawing it.
   * This includes the `padding` in the `style` object.
   * This can be used as a fast-pass to do things like text-fitting.
   * @param {object} [overrides] - Overrides for the text, style, and resolution.
   * @param {string} [overrides.text] - The text to measure, if not specified, the current text is used.
   * @param {PIXI.HTMLTextStyle} [overrides.style] - The style to measure, if not specified, the current style is used.
   * @param {number} [overrides.resolution] - The resolution to measure, if not specified, the current resolution is used.
   * @returns {PIXI.ISize} Width and height of the measured text.
   */
  measureText(overrides) {
    const { text: text2, style, resolution } = Object.assign({
      text: this._text,
      style: this._style,
      resolution: this._resolution
    }, overrides);
    Object.assign(this._domElement, {
      innerHTML: text2,
      style: style.toCSS(resolution)
    }), this._styleElement.textContent = style.toGlobalCSS(), document.body.appendChild(this._svgRoot);
    const contentBounds = this._domElement.getBoundingClientRect();
    this._svgRoot.remove();
    const { width, height } = contentBounds;
    (width > this.maxWidth || height > this.maxHeight) && console.warn("[HTMLText] Large expanse of text, increase HTMLText.maxWidth or HTMLText.maxHeight property.");
    const contentWidth = Math.min(this.maxWidth, Math.ceil(width)), contentHeight = Math.min(this.maxHeight, Math.ceil(height));
    return this._svgRoot.setAttribute("width", contentWidth.toString()), this._svgRoot.setAttribute("height", contentHeight.toString()), text2 !== this._text && (this._domElement.innerHTML = this._text), style !== this._style && (Object.assign(this._domElement, { style: this._style?.toCSS(resolution) }), this._styleElement.textContent = this._style?.toGlobalCSS()), {
      width: contentWidth + style.padding * 2,
      height: contentHeight + style.padding * 2
    };
  }
  /**
   * Manually refresh the text.
   * @public
   * @param {boolean} respectDirty - Whether to abort updating the
   *        text if the Text isn't dirty and the function is called.
   */
  async updateText(respectDirty = !0) {
    const { style, _image: image, _loadImage: loadImage } = this;
    if (this.localStyleID !== style.styleID && (this.dirty = !0, this.localStyleID = style.styleID), !this.dirty && respectDirty)
      return;
    const { width, height } = this.measureText();
    image.width = loadImage.width = Math.ceil(Math.max(1, width)), image.height = loadImage.height = Math.ceil(Math.max(1, height)), this._updateID++;
    const updateID = this._updateID;
    await new Promise((resolve) => {
      loadImage.onload = async () => {
        if (updateID < this._updateID) {
          resolve();
          return;
        }
        await style.onBeforeDraw(), image.src = loadImage.src, loadImage.onload = null, loadImage.src = "", this.updateTexture(), resolve();
      };
      const svgURL = new XMLSerializer().serializeToString(this._svgRoot);
      loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;
    });
  }
  /** The raw image element that is rendered under-the-hood. */
  get source() {
    return this._image;
  }
  /**
   * Update the texture resource.
   * @private
   */
  updateTexture() {
    const { style, texture, _image: image, resolution } = this, { padding } = style, { baseTexture } = texture;
    texture.trim.width = texture._frame.width = image.width / resolution, texture.trim.height = texture._frame.height = image.height / resolution, texture.trim.x = -padding, texture.trim.y = -padding, texture.orig.width = texture._frame.width - padding * 2, texture.orig.height = texture._frame.height - padding * 2, this._onTextureUpdate(), baseTexture.setRealSize(image.width, image.height, resolution), this.dirty = !1;
  }
  /**
   * Renders the object using the WebGL renderer
   * @param {PIXI.Renderer} renderer - The renderer
   * @private
   */
  _render(renderer) {
    this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0), this.updateText(!0), super._render(renderer);
  }
  /**
   * Renders the object using the Canvas Renderer.
   * @private
   * @param {PIXI.CanvasRenderer} renderer - The renderer
   */
  _renderCanvas(renderer) {
    this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0), this.updateText(!0), super._renderCanvas(renderer);
  }
  /**
   * Get the local bounds.
   * @param {PIXI.Rectangle} rect - Input rectangle.
   * @returns {PIXI.Rectangle} Local bounds
   */
  getLocalBounds(rect) {
    return this.updateText(!0), super.getLocalBounds(rect);
  }
  _calculateBounds() {
    this.updateText(!0), this.calculateVertices(), this._bounds.addQuad(this.vertexData);
  }
  /**
   * Handle dirty style changes
   * @private
   */
  _onStyleChange() {
    this.dirty = !0;
  }
  /**
   * Destroy this Text object. Don't use after calling.
   * @param {boolean|object} options - Same as Sprite destroy options.
   */
  destroy(options) {
    typeof options == "boolean" && (options = { children: options }), options = Object.assign({}, _HTMLText2.defaultDestroyOptions, options), super.destroy(options);
    const forceClear = null;
    this.ownsStyle && this._style?.cleanFonts(), this._style = forceClear, this._svgRoot?.remove(), this._svgRoot = forceClear, this._domElement?.remove(), this._domElement = forceClear, this._foreignObject?.remove(), this._foreignObject = forceClear, this._styleElement?.remove(), this._styleElement = forceClear, this._loadImage.src = "", this._loadImage.onload = null, this._loadImage = forceClear, this._image.src = "", this._image = forceClear;
  }
  /**
   * Get the width in pixels.
   * @member {number}
   */
  get width() {
    return this.updateText(!0), Math.abs(this.scale.x) * this._image.width / this.resolution;
  }
  set width(value) {
    this.updateText(!0);
    const s = core.utils.sign(this.scale.x) || 1;
    this.scale.x = s * value / this._image.width / this.resolution, this._width = value;
  }
  /**
   * Get the height in pixels.
   * @member {number}
   */
  get height() {
    return this.updateText(!0), Math.abs(this.scale.y) * this._image.height / this.resolution;
  }
  set height(value) {
    this.updateText(!0);
    const s = core.utils.sign(this.scale.y) || 1;
    this.scale.y = s * value / this._image.height / this.resolution, this._height = value;
  }
  /** The base style to render with text. */
  get style() {
    return this._style;
  }
  set style(style) {
    this._style !== style && (style = style || {}, style instanceof HTMLTextStyle.HTMLTextStyle ? (this.ownsStyle = !1, this._style = style) : style instanceof text.TextStyle ? (console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle"), this.ownsStyle = !0, this._style = HTMLTextStyle.HTMLTextStyle.from(style)) : (this.ownsStyle = !0, this._style = new HTMLTextStyle.HTMLTextStyle(style)), this.localStyleID = -1, this.dirty = !0);
  }
  /**
   * Contents of text. This can be HTML text and include tags.
   * @example
   * const text = new HTMLText('This is a <em>styled</em> text!');
   * @member {string}
   */
  get text() {
    return this._text;
  }
  set text(text2) {
    text2 = String(text2 === "" || text2 === null || text2 === void 0 ? " " : text2), text2 = this.sanitiseText(text2), this._text !== text2 && (this._text = text2, this.dirty = !0);
  }
  /**
   * The resolution / device pixel ratio of the canvas.
   * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
   * @member {number}
   * @default 1
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = !1, this._resolution !== value && (this._resolution = value, this.dirty = !0);
  }
  /**
   * Sanitise text - replace `<br>` with `<br/>`, `&nbsp;` with `&#160;`
   * @param text
   * @see https://www.sitepoint.com/community/t/xhtml-1-0-transitional-xml-parsing-error-entity-nbsp-not-defined/3392/3
   */
  sanitiseText(text2) {
    return text2.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;");
  }
};
_HTMLText.defaultDestroyOptions = {
  texture: !0,
  children: !1,
  baseTexture: !0
}, /** Default maxWidth, set at construction */
_HTMLText.defaultMaxWidth = 2024, /** Default maxHeight, set at construction */
_HTMLText.defaultMaxHeight = 2024, /** Default autoResolution for all HTMLText objects */
_HTMLText.defaultAutoResolution = !0;
let HTMLText = _HTMLText;
exports.HTMLText = HTMLText;
//# sourceMappingURL=HTMLText.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-html/lib/HTMLTextStyle.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/text-html/lib/HTMLTextStyle.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), text = __webpack_require__(/*! @pixi/text */ "./node_modules/@pixi/text/lib/index.js");
const _HTMLTextStyle = class _HTMLTextStyle2 extends text.TextStyle {
  constructor() {
    super(...arguments), this._fonts = [], this._overrides = [], this._stylesheet = "", this.fontsDirty = !1;
  }
  /**
   * Convert a TextStyle to HTMLTextStyle
   * @param originalStyle
   * @example
   * import {TextStyle } from 'pixi.js';
   * import {HTMLTextStyle} from '@pixi/text-html';
   * const style = new TextStyle();
   * const htmlStyle = HTMLTextStyle.from(style);
   */
  static from(originalStyle) {
    return new _HTMLTextStyle2(
      Object.keys(_HTMLTextStyle2.defaultOptions).reduce((obj, prop) => ({ ...obj, [prop]: originalStyle[prop] }), {})
    );
  }
  /** Clear the current font */
  cleanFonts() {
    this._fonts.length > 0 && (this._fonts.forEach((font) => {
      URL.revokeObjectURL(font.src), font.refs--, font.refs === 0 && (font.fontFace && document.fonts.delete(font.fontFace), delete _HTMLTextStyle2.availableFonts[font.originalUrl]);
    }), this.fontFamily = "Arial", this._fonts.length = 0, this.styleID++, this.fontsDirty = !0);
  }
  /**
   * Because of how HTMLText renders, fonts need to be imported
   * @param url
   * @param options
   */
  loadFont(url, options = {}) {
    const { availableFonts } = _HTMLTextStyle2;
    if (availableFonts[url]) {
      const font = availableFonts[url];
      return this._fonts.push(font), font.refs++, this.styleID++, this.fontsDirty = !0, Promise.resolve();
    }
    return core.settings.ADAPTER.fetch(url).then((response) => response.blob()).then(async (blob) => new Promise((resolve, reject) => {
      const src = URL.createObjectURL(blob), reader = new FileReader();
      reader.onload = () => resolve([src, reader.result]), reader.onerror = reject, reader.readAsDataURL(blob);
    })).then(async ([src, dataSrc]) => {
      const font = Object.assign({
        family: core.utils.path.basename(url, core.utils.path.extname(url)),
        weight: "normal",
        style: "normal",
        display: "auto",
        src,
        dataSrc,
        refs: 1,
        originalUrl: url,
        fontFace: null
      }, options);
      availableFonts[url] = font, this._fonts.push(font), this.styleID++;
      const fontFace = new FontFace(font.family, `url(${font.src})`, {
        weight: font.weight,
        style: font.style,
        display: font.display
      });
      font.fontFace = fontFace, await fontFace.load(), document.fonts.add(fontFace), await document.fonts.ready, this.styleID++, this.fontsDirty = !0;
    });
  }
  /**
   * Add a style override, this can be any CSS property
   * it will override any built-in style. This is the
   * property and the value as a string (e.g., `color: red`).
   * This will override any other internal style.
   * @param {string} value - CSS style(s) to add.
   * @example
   * style.addOverride('background-color: red');
   */
  addOverride(...value) {
    const toAdd = value.filter((v) => !this._overrides.includes(v));
    toAdd.length > 0 && (this._overrides.push(...toAdd), this.styleID++);
  }
  /**
   * Remove any overrides that match the value.
   * @param {string} value - CSS style to remove.
   * @example
   * style.removeOverride('background-color: red');
   */
  removeOverride(...value) {
    const toRemove = value.filter((v) => this._overrides.includes(v));
    toRemove.length > 0 && (this._overrides = this._overrides.filter((v) => !toRemove.includes(v)), this.styleID++);
  }
  /**
   * Internally converts all of the style properties into CSS equivalents.
   * @param scale
   * @returns The CSS style string, for setting `style` property of root HTMLElement.
   */
  toCSS(scale) {
    return [
      `transform: scale(${scale})`,
      "transform-origin: top left",
      "display: inline-block",
      `color: ${this.normalizeColor(this.fill)}`,
      `font-size: ${this.fontSize}px`,
      `font-family: ${this.fontFamily}`,
      `font-weight: ${this.fontWeight}`,
      `font-style: ${this.fontStyle}`,
      `font-variant: ${this.fontVariant}`,
      `letter-spacing: ${this.letterSpacing}px`,
      `text-align: ${this.align}`,
      `padding: ${this.padding}px`,
      `white-space: ${this.whiteSpace}`,
      ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [],
      ...this.wordWrap ? [
        `word-wrap: ${this.breakWords ? "break-all" : "break-word"}`,
        `max-width: ${this.wordWrapWidth}px`
      ] : [],
      ...this.strokeThickness ? [
        `-webkit-text-stroke-width: ${this.strokeThickness}px`,
        `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        `text-stroke-width: ${this.strokeThickness}px`,
        `text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        "paint-order: stroke"
      ] : [],
      ...this.dropShadow ? [this.dropShadowToCSS()] : [],
      ...this._overrides
    ].join(";");
  }
  /** Get the font CSS styles from the loaded font, If available. */
  toGlobalCSS() {
    return this._fonts.reduce((result, font) => `${result}
            @font-face {
                font-family: "${font.family}";
                src: url('${font.dataSrc}');
                font-weight: ${font.weight};
                font-style: ${font.style};
                font-display: ${font.display};
            }`, this._stylesheet);
  }
  /** Internal stylesheet contents, useful for creating rules for rendering */
  get stylesheet() {
    return this._stylesheet;
  }
  set stylesheet(value) {
    this._stylesheet !== value && (this._stylesheet = value, this.styleID++);
  }
  /**
   * Convert numerical colors into hex-strings
   * @param color
   */
  normalizeColor(color) {
    return Array.isArray(color) && (color = core.utils.rgb2hex(color)), typeof color == "number" ? core.utils.hex2string(color) : color;
  }
  /** Convert the internal drop-shadow settings to CSS text-shadow */
  dropShadowToCSS() {
    let color = this.normalizeColor(this.dropShadowColor);
    const alpha = this.dropShadowAlpha, x = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance), y = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
    color.startsWith("#") && alpha < 1 && (color += (alpha * 255 | 0).toString(16).padStart(2, "0"));
    const position = `${x}px ${y}px`;
    return this.dropShadowBlur > 0 ? `text-shadow: ${position} ${this.dropShadowBlur}px ${color}` : `text-shadow: ${position} ${color}`;
  }
  /** Resets all properties to the defaults specified in TextStyle.prototype._default */
  reset() {
    Object.assign(this, _HTMLTextStyle2.defaultOptions);
  }
  /**
   * Called after the image is loaded but before drawing to the canvas.
   * Mostly used to handle Safari's font loading bug.
   * @ignore
   */
  onBeforeDraw() {
    const { fontsDirty: prevFontsDirty } = this;
    return this.fontsDirty = !1, this.isSafari && this._fonts.length > 0 && prevFontsDirty ? new Promise((resolve) => setTimeout(resolve, 100)) : Promise.resolve();
  }
  /**
   * Proving that Safari is the new IE
   * @ignore
   */
  get isSafari() {
    const { userAgent } = core.settings.ADAPTER.getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
  }
  set fillGradientStops(_value) {
    console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText");
  }
  get fillGradientStops() {
    return super.fillGradientStops;
  }
  set fillGradientType(_value) {
    console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText");
  }
  get fillGradientType() {
    return super.fillGradientType;
  }
  set miterLimit(_value) {
    console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");
  }
  get miterLimit() {
    return super.miterLimit;
  }
  set trim(_value) {
    console.warn("[HTMLTextStyle] trim is not supported by HTMLText");
  }
  get trim() {
    return super.trim;
  }
  set textBaseline(_value) {
    console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");
  }
  get textBaseline() {
    return super.textBaseline;
  }
  set leading(_value) {
    console.warn("[HTMLTextStyle] leading is not supported by HTMLText");
  }
  get leading() {
    return super.leading;
  }
  set lineJoin(_value) {
    console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");
  }
  get lineJoin() {
    return super.lineJoin;
  }
};
_HTMLTextStyle.availableFonts = {}, /**
* List of default options, these are largely the same as TextStyle,
* with the exception of whiteSpace, which is set to 'normal' by default.
*/
_HTMLTextStyle.defaultOptions = {
  /** Align */
  align: "left",
  /** Break words */
  breakWords: !1,
  /** Drop shadow */
  dropShadow: !1,
  /** Drop shadow alpha */
  dropShadowAlpha: 1,
  /**
   * Drop shadow angle
   * @type {number}
   * @default Math.PI / 6
   */
  dropShadowAngle: Math.PI / 6,
  /** Drop shadow blur */
  dropShadowBlur: 0,
  /** Drop shadow color */
  dropShadowColor: "black",
  /** Drop shadow distance */
  dropShadowDistance: 5,
  /** Fill */
  fill: "black",
  /** Font family */
  fontFamily: "Arial",
  /** Font size */
  fontSize: 26,
  /** Font style */
  fontStyle: "normal",
  /** Font variant */
  fontVariant: "normal",
  /** Font weight */
  fontWeight: "normal",
  /** Letter spacing */
  letterSpacing: 0,
  /** Line height */
  lineHeight: 0,
  /** Padding */
  padding: 0,
  /** Stroke */
  stroke: "black",
  /** Stroke thickness */
  strokeThickness: 0,
  /** White space */
  whiteSpace: "normal",
  /** Word wrap */
  wordWrap: !1,
  /** Word wrap width */
  wordWrapWidth: 100
};
let HTMLTextStyle = _HTMLTextStyle;
exports.HTMLTextStyle = HTMLTextStyle;
//# sourceMappingURL=HTMLTextStyle.js.map


/***/ }),

/***/ "./node_modules/@pixi/text-html/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/text-html/lib/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var HTMLText = __webpack_require__(/*! ./HTMLText.js */ "./node_modules/@pixi/text-html/lib/HTMLText.js"), HTMLTextStyle = __webpack_require__(/*! ./HTMLTextStyle.js */ "./node_modules/@pixi/text-html/lib/HTMLTextStyle.js");
exports.HTMLText = HTMLText.HTMLText;
exports.HTMLTextStyle = HTMLTextStyle.HTMLTextStyle;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/text/lib/Text.js":
/*!*********************************************!*\
  !*** ./node_modules/@pixi/text/lib/Text.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), sprite = __webpack_require__(/*! @pixi/sprite */ "./node_modules/@pixi/sprite/lib/index.js"), _const = __webpack_require__(/*! ./const.js */ "./node_modules/@pixi/text/lib/const.js"), TextMetrics = __webpack_require__(/*! ./TextMetrics.js */ "./node_modules/@pixi/text/lib/TextMetrics.js"), TextStyle = __webpack_require__(/*! ./TextStyle.js */ "./node_modules/@pixi/text/lib/TextStyle.js");
const defaultDestroyOptions = {
  texture: !0,
  children: !1,
  baseTexture: !0
}, _Text = class _Text2 extends sprite.Sprite {
  /**
   * @param text - The string that you would like the text to display
   * @param style - The style parameters
   * @param canvas - The canvas element for drawing text
   */
  constructor(text, style, canvas) {
    let ownCanvas = !1;
    canvas || (canvas = core.settings.ADAPTER.createCanvas(), ownCanvas = !0), canvas.width = 3, canvas.height = 3;
    const texture = core.Texture.from(canvas);
    texture.orig = new core.Rectangle(), texture.trim = new core.Rectangle(), super(texture), this._ownCanvas = ownCanvas, this.canvas = canvas, this.context = canvas.getContext("2d", {
      // required for trimming to work without warnings
      willReadFrequently: !0
    }), this._resolution = _Text2.defaultResolution ?? core.settings.RESOLUTION, this._autoResolution = _Text2.defaultAutoResolution, this._text = null, this._style = null, this._styleListener = null, this._font = "", this.text = text, this.style = style, this.localStyleID = -1;
  }
  /**
   * @see PIXI.TextMetrics.experimentalLetterSpacing
   * @deprecated since 7.1.0
   */
  static get experimentalLetterSpacing() {
    return TextMetrics.TextMetrics.experimentalLetterSpacing;
  }
  static set experimentalLetterSpacing(value) {
    core.utils.deprecation(
      "7.1.0",
      "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"
    ), TextMetrics.TextMetrics.experimentalLetterSpacing = value;
  }
  /**
   * Renders text to its canvas, and updates its texture.
   *
   * By default this is used internally to ensure the texture is correct before rendering,
   * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,
   * and then shared across multiple Sprites.
   * @param respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.
   */
  updateText(respectDirty) {
    const style = this._style;
    if (this.localStyleID !== style.styleID && (this.dirty = !0, this.localStyleID = style.styleID), !this.dirty && respectDirty)
      return;
    this._font = this._style.toFontString();
    const context = this.context, measured = TextMetrics.TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), width = measured.width, height = measured.height, lines = measured.lines, lineHeight = measured.lineHeight, lineWidths = measured.lineWidths, maxLineWidth = measured.maxLineWidth, fontProperties = measured.fontProperties;
    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution), context.scale(this._resolution, this._resolution), context.clearRect(0, 0, this.canvas.width, this.canvas.height), context.font = this._font, context.lineWidth = style.strokeThickness, context.textBaseline = style.textBaseline, context.lineJoin = style.lineJoin, context.miterLimit = style.miterLimit;
    let linePositionX, linePositionY;
    const passesCount = style.dropShadow ? 2 : 1;
    for (let i = 0; i < passesCount; ++i) {
      const isShadowPass = style.dropShadow && i === 0, dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0, dsOffsetShadow = dsOffsetText * this._resolution;
      if (isShadowPass) {
        context.fillStyle = "black", context.strokeStyle = "black";
        const dropShadowColor = style.dropShadowColor, dropShadowBlur = style.dropShadowBlur * this._resolution, dropShadowDistance = style.dropShadowDistance * this._resolution;
        context.shadowColor = core.Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString(), context.shadowBlur = dropShadowBlur, context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance, context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
      } else
        context.fillStyle = this._generateFillStyle(style, lines, measured), context.strokeStyle = style.stroke, context.shadowColor = "black", context.shadowBlur = 0, context.shadowOffsetX = 0, context.shadowOffsetY = 0;
      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      lineHeight - fontProperties.fontSize < 0 && (linePositionYShift = 0);
      for (let i2 = 0; i2 < lines.length; i2++)
        linePositionX = style.strokeThickness / 2, linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift, style.align === "right" ? linePositionX += maxLineWidth - lineWidths[i2] : style.align === "center" && (linePositionX += (maxLineWidth - lineWidths[i2]) / 2), style.stroke && style.strokeThickness && this.drawLetterSpacing(
          lines[i2],
          linePositionX + style.padding,
          linePositionY + style.padding - dsOffsetText,
          !0
        ), style.fill && this.drawLetterSpacing(
          lines[i2],
          linePositionX + style.padding,
          linePositionY + style.padding - dsOffsetText
        );
    }
    this.updateTexture();
  }
  /**
   * Render the text with letter-spacing.
   * @param text - The text to draw
   * @param x - Horizontal position to draw the text
   * @param y - Vertical position to draw the text
   * @param isStroke - Is this drawing for the outside stroke of the
   *  text? If not, it's for the inside fill
   */
  drawLetterSpacing(text, x, y, isStroke = !1) {
    const letterSpacing = this._style.letterSpacing;
    let useExperimentalLetterSpacing = !1;
    if (TextMetrics.TextMetrics.experimentalLetterSpacingSupported && (TextMetrics.TextMetrics.experimentalLetterSpacing ? (this.context.letterSpacing = `${letterSpacing}px`, this.context.textLetterSpacing = `${letterSpacing}px`, useExperimentalLetterSpacing = !0) : (this.context.letterSpacing = "0px", this.context.textLetterSpacing = "0px")), letterSpacing === 0 || useExperimentalLetterSpacing) {
      isStroke ? this.context.strokeText(text, x, y) : this.context.fillText(text, x, y);
      return;
    }
    let currentPosition = x;
    const stringArray = TextMetrics.TextMetrics.graphemeSegmenter(text);
    let previousWidth = this.context.measureText(text).width, currentWidth = 0;
    for (let i = 0; i < stringArray.length; ++i) {
      const currentChar = stringArray[i];
      isStroke ? this.context.strokeText(currentChar, currentPosition, y) : this.context.fillText(currentChar, currentPosition, y);
      let textStr = "";
      for (let j = i + 1; j < stringArray.length; ++j)
        textStr += stringArray[j];
      currentWidth = this.context.measureText(textStr).width, currentPosition += previousWidth - currentWidth + letterSpacing, previousWidth = currentWidth;
    }
  }
  /** Updates texture size based on canvas size. */
  updateTexture() {
    const canvas = this.canvas;
    if (this._style.trim) {
      const trimmed = core.utils.trimCanvas(canvas);
      trimmed.data && (canvas.width = trimmed.width, canvas.height = trimmed.height, this.context.putImageData(trimmed.data, 0, 0));
    }
    const texture = this._texture, style = this._style, padding = style.trim ? 0 : style.padding, baseTexture = texture.baseTexture;
    texture.trim.width = texture._frame.width = canvas.width / this._resolution, texture.trim.height = texture._frame.height = canvas.height / this._resolution, texture.trim.x = -padding, texture.trim.y = -padding, texture.orig.width = texture._frame.width - padding * 2, texture.orig.height = texture._frame.height - padding * 2, this._onTextureUpdate(), baseTexture.setRealSize(canvas.width, canvas.height, this._resolution), texture.updateUvs(), this.dirty = !1;
  }
  /**
   * Renders the object using the WebGL renderer
   * @param renderer - The renderer
   */
  _render(renderer) {
    this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0), this.updateText(!0), super._render(renderer);
  }
  /** Updates the transform on all children of this container for rendering. */
  updateTransform() {
    this.updateText(!0), super.updateTransform();
  }
  getBounds(skipUpdate, rect) {
    return this.updateText(!0), this._textureID === -1 && (skipUpdate = !1), super.getBounds(skipUpdate, rect);
  }
  /**
   * Gets the local bounds of the text object.
   * @param rect - The output rectangle.
   * @returns The bounds.
   */
  getLocalBounds(rect) {
    return this.updateText(!0), super.getLocalBounds.call(this, rect);
  }
  /** Calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account. */
  _calculateBounds() {
    this.calculateVertices(), this._bounds.addQuad(this.vertexData);
  }
  /**
   * Generates the fill style. Can automatically generate a gradient based on the fill style being an array
   * @param style - The style.
   * @param lines - The lines of text.
   * @param metrics
   * @returns The fill style
   */
  _generateFillStyle(style, lines, metrics) {
    const fillStyle = style.fill;
    if (Array.isArray(fillStyle)) {
      if (fillStyle.length === 1)
        return fillStyle[0];
    } else
      return fillStyle;
    let gradient;
    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0, padding = style.padding || 0, width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2, height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2, fill = fillStyle.slice(), fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      const lengthPlus1 = fill.length + 1;
      for (let i = 1; i < lengthPlus1; ++i)
        fillGradientStops.push(i / lengthPlus1);
    }
    if (fill.unshift(fillStyle[0]), fillGradientStops.unshift(0), fill.push(fillStyle[fillStyle.length - 1]), fillGradientStops.push(1), style.fillGradientType === _const.TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
      const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      for (let i = 0; i < lines.length; i++) {
        const lastLineBottom = metrics.lineHeight * (i - 1) + textHeight, thisLineTop = metrics.lineHeight * i;
        let thisLineGradientStart = thisLineTop;
        i > 0 && lastLineBottom > thisLineTop && (thisLineGradientStart = (thisLineTop + lastLineBottom) / 2);
        const thisLineBottom = thisLineTop + textHeight, nextLineTop = metrics.lineHeight * (i + 1);
        let thisLineGradientEnd = thisLineBottom;
        i + 1 < lines.length && nextLineTop < thisLineBottom && (thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2);
        const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
        for (let j = 0; j < fill.length; j++) {
          let lineStop = 0;
          typeof fillGradientStops[j] == "number" ? lineStop = fillGradientStops[j] : lineStop = j / fill.length;
          let globalStop = Math.min(1, Math.max(
            0,
            thisLineGradientStart / height + lineStop * gradStopLineHeight
          ));
          globalStop = Number(globalStop.toFixed(5)), gradient.addColorStop(globalStop, fill[j]);
        }
      }
    } else {
      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
      const totalIterations = fill.length + 1;
      let currentIteration = 1;
      for (let i = 0; i < fill.length; i++) {
        let stop;
        typeof fillGradientStops[i] == "number" ? stop = fillGradientStops[i] : stop = currentIteration / totalIterations, gradient.addColorStop(stop, fill[i]), currentIteration++;
      }
    }
    return gradient;
  }
  /**
   * Destroys this text object.
   *
   * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as
   * the majority of the time the texture will not be shared with any other Sprites.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.children=false] - if set to true, all the children will have their
   *  destroy method called as well. 'options' will be passed on to those calls.
   * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well
   * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well
   */
  destroy(options) {
    typeof options == "boolean" && (options = { children: options }), options = Object.assign({}, defaultDestroyOptions, options), super.destroy(options), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;
  }
  /** The width of the Text, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    this.updateText(!0);
    const s = core.utils.sign(this.scale.x) || 1;
    this.scale.x = s * value / this._texture.orig.width, this._width = value;
  }
  /** The height of the Text, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    this.updateText(!0);
    const s = core.utils.sign(this.scale.y) || 1;
    this.scale.y = s * value / this._texture.orig.height, this._height = value;
  }
  /**
   * Set the style of the text.
   *
   * Set up an event listener to listen for changes on the style object and mark the text as dirty.
   *
   * If setting the `style` can also be partial {@link PIXI.ITextStyle}.
   */
  get style() {
    return this._style;
  }
  set style(style) {
    style = style || {}, style instanceof TextStyle.TextStyle ? this._style = style : this._style = new TextStyle.TextStyle(style), this.localStyleID = -1, this.dirty = !0;
  }
  /** Set the copy for the text object. To split a line you can use '\n'. */
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text ?? ""), this._text !== text && (this._text = text, this.dirty = !0);
  }
  /**
   * The resolution / device pixel ratio of the canvas.
   *
   * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
   * @default 1
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = !1, this._resolution !== value && (this._resolution = value, this.dirty = !0);
  }
};
_Text.defaultAutoResolution = !0;
let Text = _Text;
exports.Text = Text;
//# sourceMappingURL=Text.js.map


/***/ }),

/***/ "./node_modules/@pixi/text/lib/TextMetrics.js":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/text/lib/TextMetrics.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
const contextSettings = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: !0
}, _TextMetrics = class _TextMetrics2 {
  /**
   * Checking that we can use modern canvas 2D API.
   *
   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
   * @see PIXI.TextMetrics.experimentalLetterSpacing
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/letterSpacing
   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
   */
  static get experimentalLetterSpacingSupported() {
    let result = _TextMetrics2._experimentalLetterSpacingSupported;
    if (result !== void 0) {
      const proto = core.settings.ADAPTER.getCanvasRenderingContext2D().prototype;
      result = _TextMetrics2._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
    }
    return result;
  }
  /**
   * @param text - the text that was measured
   * @param style - the style that was measured
   * @param width - the measured width of the text
   * @param height - the measured height of the text
   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
   * @param lineWidths - an array of the line widths for each line matched to `lines`
   * @param lineHeight - the measured line height for this style
   * @param maxLineWidth - the maximum line width for all measured lines
   * @param {PIXI.IFontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
   */
  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text, this.style = style, this.width = width, this.height = height, this.lines = lines, this.lineWidths = lineWidths, this.lineHeight = lineHeight, this.maxLineWidth = maxLineWidth, this.fontProperties = fontProperties;
  }
  /**
   * Measures the supplied string of text and returns a Rectangle.
   * @param text - The text to measure.
   * @param style - The text style to use for measuring
   * @param wordWrap - Override for if word-wrap should be applied to the text.
   * @param canvas - optional specification of the canvas to use for measuring.
   * @returns Measured width and height of the text.
   */
  static measureText(text, style, wordWrap, canvas = _TextMetrics2._canvas) {
    wordWrap = wordWrap ?? style.wordWrap;
    const font = style.toFontString(), fontProperties = _TextMetrics2.measureFont(font);
    fontProperties.fontSize === 0 && (fontProperties.fontSize = style.fontSize, fontProperties.ascent = style.fontSize);
    const context = canvas.getContext("2d", contextSettings);
    context.font = font;
    const lines = (wordWrap ? _TextMetrics2.wordWrap(text, style, canvas) : text).split(/(?:\r\n|\r|\n)/), lineWidths = new Array(lines.length);
    let maxLineWidth = 0;
    for (let i = 0; i < lines.length; i++) {
      const lineWidth = _TextMetrics2._measureText(lines[i], style.letterSpacing, context);
      lineWidths[i] = lineWidth, maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    let width = maxLineWidth + style.strokeThickness;
    style.dropShadow && (width += style.dropShadowDistance);
    const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
    let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + style.leading + (lines.length - 1) * (lineHeight + style.leading);
    return style.dropShadow && (height += style.dropShadowDistance), new _TextMetrics2(
      text,
      style,
      width,
      height,
      lines,
      lineWidths,
      lineHeight + style.leading,
      maxLineWidth,
      fontProperties
    );
  }
  static _measureText(text, letterSpacing, context) {
    let useExperimentalLetterSpacing = !1;
    _TextMetrics2.experimentalLetterSpacingSupported && (_TextMetrics2.experimentalLetterSpacing ? (context.letterSpacing = `${letterSpacing}px`, context.textLetterSpacing = `${letterSpacing}px`, useExperimentalLetterSpacing = !0) : (context.letterSpacing = "0px", context.textLetterSpacing = "0px"));
    let width = context.measureText(text).width;
    return width > 0 && (useExperimentalLetterSpacing ? width -= letterSpacing : width += (_TextMetrics2.graphemeSegmenter(text).length - 1) * letterSpacing), width;
  }
  /**
   * Applies newlines to a string to have it optimally fit into the horizontal
   * bounds set by the Text object's wordWrapWidth property.
   * @param text - String to apply word wrapping to
   * @param style - the style to use when wrapping
   * @param canvas - optional specification of the canvas to use for measuring.
   * @returns New string with new lines applied where required
   */
  static wordWrap(text, style, canvas = _TextMetrics2._canvas) {
    const context = canvas.getContext("2d", contextSettings);
    let width = 0, line = "", lines = "";
    const cache = /* @__PURE__ */ Object.create(null), { letterSpacing, whiteSpace } = style, collapseSpaces = _TextMetrics2.collapseSpaces(whiteSpace), collapseNewlines = _TextMetrics2.collapseNewlines(whiteSpace);
    let canPrependSpaces = !collapseSpaces;
    const wordWrapWidth = style.wordWrapWidth + letterSpacing, tokens = _TextMetrics2.tokenize(text);
    for (let i = 0; i < tokens.length; i++) {
      let token = tokens[i];
      if (_TextMetrics2.isNewline(token)) {
        if (!collapseNewlines) {
          lines += _TextMetrics2.addLine(line), canPrependSpaces = !collapseSpaces, line = "", width = 0;
          continue;
        }
        token = " ";
      }
      if (collapseSpaces) {
        const currIsBreakingSpace = _TextMetrics2.isBreakingSpace(token), lastIsBreakingSpace = _TextMetrics2.isBreakingSpace(line[line.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace)
          continue;
      }
      const tokenWidth = _TextMetrics2.getFromCache(token, letterSpacing, cache, context);
      if (tokenWidth > wordWrapWidth)
        if (line !== "" && (lines += _TextMetrics2.addLine(line), line = "", width = 0), _TextMetrics2.canBreakWords(token, style.breakWords)) {
          const characters = _TextMetrics2.wordWrapSplit(token);
          for (let j = 0; j < characters.length; j++) {
            let char = characters[j], lastChar = char, k = 1;
            for (; characters[j + k]; ) {
              const nextChar = characters[j + k];
              if (!_TextMetrics2.canBreakChars(lastChar, nextChar, token, j, style.breakWords))
                char += nextChar;
              else
                break;
              lastChar = nextChar, k++;
            }
            j += k - 1;
            const characterWidth = _TextMetrics2.getFromCache(char, letterSpacing, cache, context);
            characterWidth + width > wordWrapWidth && (lines += _TextMetrics2.addLine(line), canPrependSpaces = !1, line = "", width = 0), line += char, width += characterWidth;
          }
        } else {
          line.length > 0 && (lines += _TextMetrics2.addLine(line), line = "", width = 0);
          const isLastToken = i === tokens.length - 1;
          lines += _TextMetrics2.addLine(token, !isLastToken), canPrependSpaces = !1, line = "", width = 0;
        }
      else
        tokenWidth + width > wordWrapWidth && (canPrependSpaces = !1, lines += _TextMetrics2.addLine(line), line = "", width = 0), (line.length > 0 || !_TextMetrics2.isBreakingSpace(token) || canPrependSpaces) && (line += token, width += tokenWidth);
    }
    return lines += _TextMetrics2.addLine(line, !1), lines;
  }
  /**
   * Convienience function for logging each line added during the wordWrap method.
   * @param line    - The line of text to add
   * @param newLine - Add new line character to end
   * @returns A formatted line
   */
  static addLine(line, newLine = !0) {
    return line = _TextMetrics2.trimRight(line), line = newLine ? `${line}
` : line, line;
  }
  /**
   * Gets & sets the widths of calculated characters in a cache object
   * @param key            - The key
   * @param letterSpacing  - The letter spacing
   * @param cache          - The cache
   * @param context        - The canvas context
   * @returns The from cache.
   */
  static getFromCache(key, letterSpacing, cache, context) {
    let width = cache[key];
    return typeof width != "number" && (width = _TextMetrics2._measureText(key, letterSpacing, context) + letterSpacing, cache[key] = width), width;
  }
  /**
   * Determines whether we should collapse breaking spaces.
   * @param whiteSpace - The TextStyle property whiteSpace
   * @returns Should collapse
   */
  static collapseSpaces(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  }
  /**
   * Determines whether we should collapse newLine chars.
   * @param whiteSpace - The white space
   * @returns should collapse
   */
  static collapseNewlines(whiteSpace) {
    return whiteSpace === "normal";
  }
  /**
   * Trims breaking whitespaces from string.
   * @param text - The text
   * @returns Trimmed string
   */
  static trimRight(text) {
    if (typeof text != "string")
      return "";
    for (let i = text.length - 1; i >= 0; i--) {
      const char = text[i];
      if (!_TextMetrics2.isBreakingSpace(char))
        break;
      text = text.slice(0, -1);
    }
    return text;
  }
  /**
   * Determines if char is a newline.
   * @param char - The character
   * @returns True if newline, False otherwise.
   */
  static isNewline(char) {
    return typeof char != "string" ? !1 : _TextMetrics2._newlines.includes(char.charCodeAt(0));
  }
  /**
   * Determines if char is a breaking whitespace.
   *
   * It allows one to determine whether char should be a breaking whitespace
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param char - The character
   * @param [_nextChar] - The next character
   * @returns True if whitespace, False otherwise.
   */
  static isBreakingSpace(char, _nextChar) {
    return typeof char != "string" ? !1 : _TextMetrics2._breakingSpaces.includes(char.charCodeAt(0));
  }
  /**
   * Splits a string into words, breaking-spaces and newLine characters
   * @param text - The text
   * @returns A tokenized array
   */
  static tokenize(text) {
    const tokens = [];
    let token = "";
    if (typeof text != "string")
      return tokens;
    for (let i = 0; i < text.length; i++) {
      const char = text[i], nextChar = text[i + 1];
      if (_TextMetrics2.isBreakingSpace(char, nextChar) || _TextMetrics2.isNewline(char)) {
        token !== "" && (tokens.push(token), token = ""), tokens.push(char);
        continue;
      }
      token += char;
    }
    return token !== "" && tokens.push(token), tokens;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to customise which words should break
   * Examples are if the token is CJK or numbers.
   * It must return a boolean.
   * @param _token - The token
   * @param breakWords - The style attr break words
   * @returns Whether to break word or not
   */
  static canBreakWords(_token, breakWords) {
    return breakWords;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to determine whether a pair of characters
   * should be broken by newlines
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param _char - The character
   * @param _nextChar - The next character
   * @param _token - The token/word the characters are from
   * @param _index - The index in the token of the char
   * @param _breakWords - The style attr break words
   * @returns whether to break word or not
   */
  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
    return !0;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It is called when a token (usually a word) has to be split into separate pieces
   * in order to determine the point to break a word.
   * It must return an array of characters.
   * @param token - The token to split
   * @returns The characters of the token
   * @see TextMetrics.graphemeSegmenter
   */
  static wordWrapSplit(token) {
    return _TextMetrics2.graphemeSegmenter(token);
  }
  /**
   * Calculates the ascent, descent and fontSize of a given font-style
   * @param font - String representing the style of the font
   * @returns Font properties object
   */
  static measureFont(font) {
    if (_TextMetrics2._fonts[font])
      return _TextMetrics2._fonts[font];
    const properties = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    }, canvas = _TextMetrics2._canvas, context = _TextMetrics2._context;
    context.font = font;
    const metricsString = _TextMetrics2.METRICS_STRING + _TextMetrics2.BASELINE_SYMBOL, width = Math.ceil(context.measureText(metricsString).width);
    let baseline = Math.ceil(context.measureText(_TextMetrics2.BASELINE_SYMBOL).width);
    const height = Math.ceil(_TextMetrics2.HEIGHT_MULTIPLIER * baseline);
    if (baseline = baseline * _TextMetrics2.BASELINE_MULTIPLIER | 0, width === 0 || height === 0)
      return _TextMetrics2._fonts[font] = properties, properties;
    canvas.width = width, canvas.height = height, context.fillStyle = "#f00", context.fillRect(0, 0, width, height), context.font = font, context.textBaseline = "alphabetic", context.fillStyle = "#000", context.fillText(metricsString, 0, baseline);
    const imagedata = context.getImageData(0, 0, width, height).data, pixels = imagedata.length, line = width * 4;
    let i = 0, idx = 0, stop = !1;
    for (i = 0; i < baseline; ++i) {
      for (let j = 0; j < line; j += 4)
        if (imagedata[idx + j] !== 255) {
          stop = !0;
          break;
        }
      if (!stop)
        idx += line;
      else
        break;
    }
    for (properties.ascent = baseline - i, idx = pixels - line, stop = !1, i = height; i > baseline; --i) {
      for (let j = 0; j < line; j += 4)
        if (imagedata[idx + j] !== 255) {
          stop = !0;
          break;
        }
      if (!stop)
        idx -= line;
      else
        break;
    }
    return properties.descent = i - baseline, properties.fontSize = properties.ascent + properties.descent, _TextMetrics2._fonts[font] = properties, properties;
  }
  /**
   * Clear font metrics in metrics cache.
   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
   */
  static clearMetrics(font = "") {
    font ? delete _TextMetrics2._fonts[font] : _TextMetrics2._fonts = {};
  }
  /**
   * Cached canvas element for measuring text
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _canvas() {
    if (!_TextMetrics2.__canvas) {
      let canvas;
      try {
        const c = new OffscreenCanvas(0, 0);
        if (c.getContext("2d", contextSettings)?.measureText)
          return _TextMetrics2.__canvas = c, c;
        canvas = core.settings.ADAPTER.createCanvas();
      } catch {
        canvas = core.settings.ADAPTER.createCanvas();
      }
      canvas.width = canvas.height = 10, _TextMetrics2.__canvas = canvas;
    }
    return _TextMetrics2.__canvas;
  }
  /**
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _context() {
    return _TextMetrics2.__context || (_TextMetrics2.__context = _TextMetrics2._canvas.getContext("2d", contextSettings)), _TextMetrics2.__context;
  }
};
_TextMetrics.METRICS_STRING = "|\xC9q\xC5", /** Baseline symbol for calculate font metrics. */
_TextMetrics.BASELINE_SYMBOL = "M", /** Baseline multiplier for calculate font metrics. */
_TextMetrics.BASELINE_MULTIPLIER = 1.4, /** Height multiplier for setting height of canvas to calculate font metrics. */
_TextMetrics.HEIGHT_MULTIPLIER = 2, /**
* A Unicode "character", or "grapheme cluster", can be composed of multiple Unicode code points,
* such as letters with diacritical marks (e.g. `'\u0065\u0301'`, letter e with acute)
* or emojis with modifiers (e.g. `'\uD83E\uDDD1\u200D\uD83D\uDCBB'`, technologist).
* The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,
* PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.
* If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),
* you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}
* or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be
* relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.
*/
_TextMetrics.graphemeSegmenter = (() => {
  if (typeof Intl?.Segmenter == "function") {
    const segmenter = new Intl.Segmenter();
    return (s) => [...segmenter.segment(s)].map((x) => x.segment);
  }
  return (s) => [...s];
})(), /**
* New rendering behavior for letter-spacing which uses Chrome's new native API. This will
* lead to more accurate letter-spacing results because it does not try to manually draw
* each character. However, this Chrome API is experimental and may not serve all cases yet.
* @see PIXI.TextMetrics.experimentalLetterSpacingSupported
*/
_TextMetrics.experimentalLetterSpacing = !1, /** Cache of {@see PIXI.TextMetrics.FontMetrics} objects. */
_TextMetrics._fonts = {}, /** Cache of new line chars. */
_TextMetrics._newlines = [
  10,
  // line feed
  13
  // carriage return
], /** Cache of breaking spaces. */
_TextMetrics._breakingSpaces = [
  9,
  // character tabulation
  32,
  // space
  8192,
  // en quad
  8193,
  // em quad
  8194,
  // en space
  8195,
  // em space
  8196,
  // three-per-em space
  8197,
  // four-per-em space
  8198,
  // six-per-em space
  8200,
  // punctuation space
  8201,
  // thin space
  8202,
  // hair space
  8287,
  // medium mathematical space
  12288
  // ideographic space
];
let TextMetrics = _TextMetrics;
exports.TextMetrics = TextMetrics;
//# sourceMappingURL=TextMetrics.js.map


/***/ }),

/***/ "./node_modules/@pixi/text/lib/TextStyle.js":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/text/lib/TextStyle.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ./const.js */ "./node_modules/@pixi/text/lib/const.js"), core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js");
const genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
], _TextStyle = class _TextStyle2 {
  /**
   * @param style - TextStyle properties to be set on the text. See {@link PIXI.TextStyle.defaultStyle}
   *       for the default values.
   */
  constructor(style) {
    this.styleID = 0, this.reset(), deepCopyProperties(this, style, style);
  }
  /**
   * Creates a new TextStyle object with the same values as this one.
   * Note that the only the properties of the object are cloned.
   *
   * @return New cloned TextStyle object
   */
  clone() {
    const clonedProperties = {};
    return deepCopyProperties(clonedProperties, this, _TextStyle2.defaultStyle), new _TextStyle2(clonedProperties);
  }
  /** Resets all properties to the defaults specified in TextStyle.prototype._default */
  reset() {
    deepCopyProperties(this, _TextStyle2.defaultStyle, _TextStyle2.defaultStyle);
  }
  /**
   * Alignment for multiline text, does not affect single line text.
   *
   * @member {'left'|'center'|'right'|'justify'}
   */
  get align() {
    return this._align;
  }
  set align(align) {
    this._align !== align && (this._align = align, this.styleID++);
  }
  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(breakWords) {
    this._breakWords !== breakWords && (this._breakWords = breakWords, this.styleID++);
  }
  /** Set a drop shadow for the text. */
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(dropShadow) {
    this._dropShadow !== dropShadow && (this._dropShadow = dropShadow, this.styleID++);
  }
  /** Set alpha for the drop shadow. */
  get dropShadowAlpha() {
    return this._dropShadowAlpha;
  }
  set dropShadowAlpha(dropShadowAlpha) {
    this._dropShadowAlpha !== dropShadowAlpha && (this._dropShadowAlpha = dropShadowAlpha, this.styleID++);
  }
  /** Set a angle of the drop shadow. */
  get dropShadowAngle() {
    return this._dropShadowAngle;
  }
  set dropShadowAngle(dropShadowAngle) {
    this._dropShadowAngle !== dropShadowAngle && (this._dropShadowAngle = dropShadowAngle, this.styleID++);
  }
  /** Set a shadow blur radius. */
  get dropShadowBlur() {
    return this._dropShadowBlur;
  }
  set dropShadowBlur(dropShadowBlur) {
    this._dropShadowBlur !== dropShadowBlur && (this._dropShadowBlur = dropShadowBlur, this.styleID++);
  }
  /** A fill style to be used on the dropshadow e.g., 'red', '#00FF00'. */
  get dropShadowColor() {
    return this._dropShadowColor;
  }
  set dropShadowColor(dropShadowColor) {
    const outputColor = getColor(dropShadowColor);
    this._dropShadowColor !== outputColor && (this._dropShadowColor = outputColor, this.styleID++);
  }
  /** Set a distance of the drop shadow. */
  get dropShadowDistance() {
    return this._dropShadowDistance;
  }
  set dropShadowDistance(dropShadowDistance) {
    this._dropShadowDistance !== dropShadowDistance && (this._dropShadowDistance = dropShadowDistance, this.styleID++);
  }
  /**
   * A canvas fillstyle that will be used on the text e.g., 'red', '#00FF00'.
   *
   * Can be an array to create a gradient e.g., `['#000000','#FFFFFF']`
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
   *
   * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
   */
  get fill() {
    return this._fill;
  }
  set fill(fill) {
    const outputColor = getColor(fill);
    this._fill !== outputColor && (this._fill = outputColor, this.styleID++);
  }
  /**
   * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
   *
   * @type {PIXI.TEXT_GRADIENT}
   */
  get fillGradientType() {
    return this._fillGradientType;
  }
  set fillGradientType(fillGradientType) {
    this._fillGradientType !== fillGradientType && (this._fillGradientType = fillGradientType, this.styleID++);
  }
  /**
   * If fill is an array of colours to create a gradient, this array can set the stop points
   * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
   */
  get fillGradientStops() {
    return this._fillGradientStops;
  }
  set fillGradientStops(fillGradientStops) {
    areArraysEqual(this._fillGradientStops, fillGradientStops) || (this._fillGradientStops = fillGradientStops, this.styleID++);
  }
  /**
   * The font family, can be a single font name, or a list of names where the first
   * is the preferred font.
   */
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(fontFamily) {
    this.fontFamily !== fontFamily && (this._fontFamily = fontFamily, this.styleID++);
  }
  /**
   * The font size
   * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
   */
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(fontSize) {
    this._fontSize !== fontSize && (this._fontSize = fontSize, this.styleID++);
  }
  /**
   * The font style.
   *
   * @member {'normal'|'italic'|'oblique'}
   */
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(fontStyle) {
    this._fontStyle !== fontStyle && (this._fontStyle = fontStyle, this.styleID++);
  }
  /**
   * The font variant.
   *
   * @member {'normal'|'small-caps'}
   */
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(fontVariant) {
    this._fontVariant !== fontVariant && (this._fontVariant = fontVariant, this.styleID++);
  }
  /**
   * The font weight.
   *
   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(fontWeight) {
    this._fontWeight !== fontWeight && (this._fontWeight = fontWeight, this.styleID++);
  }
  /** The amount of spacing between letters, default is 0. */
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(letterSpacing) {
    this._letterSpacing !== letterSpacing && (this._letterSpacing = letterSpacing, this.styleID++);
  }
  /** The line height, a number that represents the vertical space that a letter uses. */
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(lineHeight) {
    this._lineHeight !== lineHeight && (this._lineHeight = lineHeight, this.styleID++);
  }
  /** The space between lines. */
  get leading() {
    return this._leading;
  }
  set leading(leading) {
    this._leading !== leading && (this._leading = leading, this.styleID++);
  }
  /**
   * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
   * Default is 'miter' (creates a sharp corner).
   *
   * @member {'miter'|'round'|'bevel'}
   */
  get lineJoin() {
    return this._lineJoin;
  }
  set lineJoin(lineJoin) {
    this._lineJoin !== lineJoin && (this._lineJoin = lineJoin, this.styleID++);
  }
  /**
   * The miter limit to use when using the 'miter' lineJoin mode.
   *
   * This can reduce or increase the spikiness of rendered text.
   */
  get miterLimit() {
    return this._miterLimit;
  }
  set miterLimit(miterLimit) {
    this._miterLimit !== miterLimit && (this._miterLimit = miterLimit, this.styleID++);
  }
  /**
   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
   * by adding padding to all sides of the text.
   */
  get padding() {
    return this._padding;
  }
  set padding(padding) {
    this._padding !== padding && (this._padding = padding, this.styleID++);
  }
  /**
   * A canvas fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'
   */
  get stroke() {
    return this._stroke;
  }
  set stroke(stroke) {
    const outputColor = getColor(stroke);
    this._stroke !== outputColor && (this._stroke = outputColor, this.styleID++);
  }
  /**
   * A number that represents the thickness of the stroke.
   *
   * @default 0
   */
  get strokeThickness() {
    return this._strokeThickness;
  }
  set strokeThickness(strokeThickness) {
    this._strokeThickness !== strokeThickness && (this._strokeThickness = strokeThickness, this.styleID++);
  }
  /**
   * The baseline of the text that is rendered.
   *
   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(textBaseline) {
    this._textBaseline !== textBaseline && (this._textBaseline = textBaseline, this.styleID++);
  }
  /** Trim transparent borders. */
  get trim() {
    return this._trim;
  }
  set trim(trim) {
    this._trim !== trim && (this._trim = trim, this.styleID++);
  }
  /**
   * How newlines and spaces should be handled.
   * Default is 'pre' (preserve, preserve).
   *
   *  value       | New lines     |   Spaces
   *  ---         | ---           |   ---
   * 'normal'     | Collapse      |   Collapse
   * 'pre'        | Preserve      |   Preserve
   * 'pre-line'   | Preserve      |   Collapse
   *
   * @member {'normal'|'pre'|'pre-line'}
   */
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(whiteSpace) {
    this._whiteSpace !== whiteSpace && (this._whiteSpace = whiteSpace, this.styleID++);
  }
  /** Indicates if word wrap should be used. */
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(wordWrap) {
    this._wordWrap !== wordWrap && (this._wordWrap = wordWrap, this.styleID++);
  }
  /** The width at which text will wrap, it needs wordWrap to be set to true. */
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(wordWrapWidth) {
    this._wordWrapWidth !== wordWrapWidth && (this._wordWrapWidth = wordWrapWidth, this.styleID++);
  }
  /**
   * Generates a font style string to use for `TextMetrics.measureFont()`.
   *
   * @return Font style string, for passing to `TextMetrics.measureFont()`
   */
  toFontString() {
    const fontSizeString = typeof this.fontSize == "number" ? `${this.fontSize}px` : this.fontSize;
    let fontFamilies = this.fontFamily;
    Array.isArray(this.fontFamily) || (fontFamilies = this.fontFamily.split(","));
    for (let i = fontFamilies.length - 1; i >= 0; i--) {
      let fontFamily = fontFamilies[i].trim();
      !/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily) && (fontFamily = `"${fontFamily}"`), fontFamilies[i] = fontFamily;
    }
    return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }
};
_TextStyle.defaultStyle = {
  /**
   * See {@link PIXI.TextStyle.align}
   * @type {'left'|'center'|'right'|'justify'}
   */
  align: "left",
  /** See {@link PIXI.TextStyle.breakWords} */
  breakWords: !1,
  /** See {@link PIXI.TextStyle.dropShadow} */
  dropShadow: !1,
  /** See {@link PIXI.TextStyle.dropShadowAlpha} */
  dropShadowAlpha: 1,
  /**
   * See {@link PIXI.TextStyle.dropShadowAngle}
   * @type {number}
   * @default Math.PI / 6
   */
  dropShadowAngle: Math.PI / 6,
  /** See {@link PIXI.TextStyle.dropShadowBlur} */
  dropShadowBlur: 0,
  /**
   * See {@link PIXI.TextStyle.dropShadowColor}
   * @type {string|number}
   */
  dropShadowColor: "black",
  /** See {@link PIXI.TextStyle.dropShadowDistance} */
  dropShadowDistance: 5,
  /**
   * See {@link PIXI.TextStyle.fill}
   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
   */
  fill: "black",
  /**
   * See {@link PIXI.TextStyle.fillGradientType}
   * @type {PIXI.TEXT_GRADIENT}
   * @default PIXI.TEXT_GRADIENT.LINEAR_VERTICAL
   */
  fillGradientType: _const.TEXT_GRADIENT.LINEAR_VERTICAL,
  /**
   * See {@link PIXI.TextStyle.fillGradientStops}
   * @type {number[]}
   * @default []
   */
  fillGradientStops: [],
  /**
   * See {@link PIXI.TextStyle.fontFamily}
   * @type {string|string[]}
   */
  fontFamily: "Arial",
  /**
   * See {@link PIXI.TextStyle.fontSize}
   * @type {number|string} 
   */
  fontSize: 26,
  /**
   * See {@link PIXI.TextStyle.fontStyle}
   * @type {'normal'|'italic'|'oblique'}
   */
  fontStyle: "normal",
  /**
   * See {@link PIXI.TextStyle.fontVariant}
   * @type {'normal'|'small-caps'}
   */
  fontVariant: "normal",
  /**
   * See {@link PIXI.TextStyle.fontWeight}
   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */
  fontWeight: "normal",
  /** See {@link PIXI.TextStyle.leading} */
  leading: 0,
  /** See {@link PIXI.TextStyle.letterSpacing} */
  letterSpacing: 0,
  /** See {@link PIXI.TextStyle.lineHeight} */
  lineHeight: 0,
  /**
   * See {@link PIXI.TextStyle.lineJoin}
   * @type {'miter'|'round'|'bevel'}
   */
  lineJoin: "miter",
  /** See {@link PIXI.TextStyle.miterLimit} */
  miterLimit: 10,
  /** See {@link PIXI.TextStyle.padding} */
  padding: 0,
  /**
   * See {@link PIXI.TextStyle.stroke}
   * @type {string|number}
   */
  stroke: "black",
  /** See {@link PIXI.TextStyle.strokeThickness} */
  strokeThickness: 0,
  /**
   * See {@link PIXI.TextStyle.textBaseline} 
   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */
  textBaseline: "alphabetic",
  /** See {@link PIXI.TextStyle.trim} */
  trim: !1,
  /**
   * See {@link PIXI.TextStyle.whiteSpace}
   * @type {'normal'|'pre'|'pre-line'}
   */
  whiteSpace: "pre",
  /** See {@link PIXI.TextStyle.wordWrap} */
  wordWrap: !1,
  /** See {@link PIXI.TextStyle.wordWrapWidth} */
  wordWrapWidth: 100
};
let TextStyle = _TextStyle;
function getColor(color) {
  const temp = core.Color.shared, format = (color2) => {
    const res = temp.setValue(color2);
    return res.alpha === 1 ? res.toHex() : res.toRgbaString();
  };
  return Array.isArray(color) ? color.map(format) : format(color);
}
function areArraysEqual(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2) || array1.length !== array2.length)
    return !1;
  for (let i = 0; i < array1.length; ++i)
    if (array1[i] !== array2[i])
      return !1;
  return !0;
}
function deepCopyProperties(target, source, propertyObj) {
  for (const prop in propertyObj)
    Array.isArray(source[prop]) ? target[prop] = source[prop].slice() : target[prop] = source[prop];
}
exports.TextStyle = TextStyle;
//# sourceMappingURL=TextStyle.js.map


/***/ }),

/***/ "./node_modules/@pixi/text/lib/const.js":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/text/lib/const.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var TEXT_GRADIENT = /* @__PURE__ */ ((TEXT_GRADIENT2) => (TEXT_GRADIENT2[TEXT_GRADIENT2.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", TEXT_GRADIENT2[TEXT_GRADIENT2.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL", TEXT_GRADIENT2))(TEXT_GRADIENT || {});
exports.TEXT_GRADIENT = TEXT_GRADIENT;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ "./node_modules/@pixi/text/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/text/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ./const.js */ "./node_modules/@pixi/text/lib/const.js"), Text = __webpack_require__(/*! ./Text.js */ "./node_modules/@pixi/text/lib/Text.js"), TextMetrics = __webpack_require__(/*! ./TextMetrics.js */ "./node_modules/@pixi/text/lib/TextMetrics.js"), TextStyle = __webpack_require__(/*! ./TextStyle.js */ "./node_modules/@pixi/text/lib/TextStyle.js");
exports.TEXT_GRADIENT = _const.TEXT_GRADIENT;
exports.Text = Text.Text;
exports.TextMetrics = TextMetrics.TextMetrics;
exports.TextStyle = TextStyle.TextStyle;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/Ticker.js":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/Ticker.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ./const.js */ "./node_modules/@pixi/ticker/lib/const.js"), TickerListener = __webpack_require__(/*! ./TickerListener.js */ "./node_modules/@pixi/ticker/lib/TickerListener.js");
const _Ticker = class _Ticker2 {
  constructor() {
    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new TickerListener.TickerListener(null, null, 1 / 0), this.deltaMS = 1 / _Ticker2.targetFPMS, this.elapsedMS = 1 / _Ticker2.targetFPMS, this._tick = (time) => {
      this._requestId = null, this.started && (this.update(time), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
    };
  }
  /**
   * Conditionally requests a new animation frame.
   * If a frame has not already been requested, and if the internal
   * emitter has listeners, a new frame is requested.
   * @private
   */
  _requestIfNeeded() {
    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
  }
  /**
   * Conditionally cancels a pending animation frame.
   * @private
   */
  _cancelIfNeeded() {
    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
  }
  /**
   * Conditionally requests a new animation frame.
   * If the ticker has been started it checks if a frame has not already
   * been requested, and if the internal emitter has listeners. If these
   * conditions are met, a new frame is requested. If the ticker has not
   * been started, but autoStart is `true`, then the ticker starts now,
   * and continues with the previous conditions to request a new frame.
   * @private
   */
  _startIfPossible() {
    this.started ? this._requestIfNeeded() : this.autoStart && this.start();
  }
  /**
   * Register a handler for tick events. Calls continuously unless
   * it is removed or the ticker is stopped.
   * @param fn - The listener function to be added for updates
   * @param context - The listener context
   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */
  add(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener.TickerListener(fn, context, priority));
  }
  /**
   * Add a handler for the tick event which is only execute once.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */
  addOnce(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener.TickerListener(fn, context, priority, !0));
  }
  /**
   * Internally adds the event handler so that it can be sorted by priority.
   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
   * before the rendering.
   * @private
   * @param listener - Current listener being added.
   * @returns This instance of a ticker
   */
  _addListener(listener) {
    let current = this._head.next, previous = this._head;
    if (!current)
      listener.connect(previous);
    else {
      for (; current; ) {
        if (listener.priority > current.priority) {
          listener.connect(previous);
          break;
        }
        previous = current, current = current.next;
      }
      listener.previous || listener.connect(previous);
    }
    return this._startIfPossible(), this;
  }
  /**
   * Removes any handlers matching the function and context parameters.
   * If no handlers are left after removing, then it cancels the animation frame.
   * @param fn - The listener function to be removed
   * @param context - The listener context to be removed
   * @returns This instance of a ticker
   */
  remove(fn, context) {
    let listener = this._head.next;
    for (; listener; )
      listener.match(fn, context) ? listener = listener.destroy() : listener = listener.next;
    return this._head.next || this._cancelIfNeeded(), this;
  }
  /**
   * The number of listeners on this ticker, calculated by walking through linked list
   * @readonly
   * @member {number}
   */
  get count() {
    if (!this._head)
      return 0;
    let count = 0, current = this._head;
    for (; current = current.next; )
      count++;
    return count;
  }
  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
  start() {
    this.started || (this.started = !0, this._requestIfNeeded());
  }
  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
  stop() {
    this.started && (this.started = !1, this._cancelIfNeeded());
  }
  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
  destroy() {
    if (!this._protected) {
      this.stop();
      let listener = this._head.next;
      for (; listener; )
        listener = listener.destroy(!0);
      this._head.destroy(), this._head = null;
    }
  }
  /**
   * Triggers an update. An update entails setting the
   * current {@link PIXI.Ticker#elapsedMS},
   * the current {@link PIXI.Ticker#deltaTime},
   * invoking all listeners with current deltaTime,
   * and then finally setting {@link PIXI.Ticker#lastTime}
   * with the value of currentTime that was provided.
   * This method will be called automatically by animation
   * frame callbacks if the ticker instance has been started
   * and listeners are added.
   * @param {number} [currentTime=performance.now()] - the current time of execution
   */
  update(currentTime = performance.now()) {
    let elapsedMS;
    if (currentTime > this.lastTime) {
      if (elapsedMS = this.elapsedMS = currentTime - this.lastTime, elapsedMS > this._maxElapsedMS && (elapsedMS = this._maxElapsedMS), elapsedMS *= this.speed, this._minElapsedMS) {
        const delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS)
          return;
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS, this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;
      const head = this._head;
      let listener = head.next;
      for (; listener; )
        listener = listener.emit(this.deltaTime);
      head.next || this._cancelIfNeeded();
    } else
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    this.lastTime = currentTime;
  }
  /**
   * The frames per second at which this ticker is running.
   * The default is approximately 60 in most modern browsers.
   * **Note:** This does not factor in the value of
   * {@link PIXI.Ticker#speed}, which is specific
   * to scaling {@link PIXI.Ticker#deltaTime}.
   * @member {number}
   * @readonly
   */
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  /**
   * Manages the maximum amount of milliseconds allowed to
   * elapse between invoking {@link PIXI.Ticker#update}.
   * This value is used to cap {@link PIXI.Ticker#deltaTime},
   * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
   * When setting this property it is clamped to a value between
   * `0` and `Ticker.targetFPMS * 1000`.
   * @member {number}
   * @default 10
   */
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(fps) {
    const minFPS = Math.min(this.maxFPS, fps), minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);
    this._maxElapsedMS = 1 / minFPMS;
  }
  /**
   * Manages the minimum amount of milliseconds required to
   * elapse between invoking {@link PIXI.Ticker#update}.
   * This will effect the measured value of {@link PIXI.Ticker#FPS}.
   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
   * Otherwise it will be at least `minFPS`
   * @member {number}
   * @default 0
   */
  get maxFPS() {
    return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
  }
  set maxFPS(fps) {
    if (fps === 0)
      this._minElapsedMS = 0;
    else {
      const maxFPS = Math.max(this.minFPS, fps);
      this._minElapsedMS = 1 / (maxFPS / 1e3);
    }
  }
  /**
   * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
   * {@link PIXI.VideoResource} to update animation frames / video textures.
   *
   * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
   *
   * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
   * @example
   * import { Ticker } from 'pixi.js';
   *
   * const ticker = Ticker.shared;
   * // Set this to prevent starting this ticker when listeners are added.
   * // By default this is true only for the PIXI.Ticker.shared instance.
   * ticker.autoStart = false;
   *
   * // FYI, call this to ensure the ticker is stopped. It should be stopped
   * // if you have not attempted to render anything yet.
   * ticker.stop();
   *
   * // Call this when you are ready for a running shared ticker.
   * ticker.start();
   * @example
   * import { autoDetectRenderer, Container } from 'pixi.js';
   *
   * // You may use the shared ticker to render...
   * const renderer = autoDetectRenderer();
   * const stage = new Container();
   * document.body.appendChild(renderer.view);
   * ticker.add((time) => renderer.render(stage));
   *
   * // Or you can just update it manually.
   * ticker.autoStart = false;
   * ticker.stop();
   * const animate = (time) => {
   *     ticker.update(time);
   *     renderer.render(stage);
   *     requestAnimationFrame(animate);
   * };
   * animate(performance.now());
   * @member {PIXI.Ticker}
   * @static
   */
  static get shared() {
    if (!_Ticker2._shared) {
      const shared = _Ticker2._shared = new _Ticker2();
      shared.autoStart = !0, shared._protected = !0;
    }
    return _Ticker2._shared;
  }
  /**
   * The system ticker instance used by {@link PIXI.BasePrepare} for core timing
   * functionality that shouldn't usually need to be paused, unlike the `shared`
   * ticker which drives visual animations and rendering which may want to be paused.
   *
   * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
   * @member {PIXI.Ticker}
   * @static
   */
  static get system() {
    if (!_Ticker2._system) {
      const system = _Ticker2._system = new _Ticker2();
      system.autoStart = !0, system._protected = !0;
    }
    return _Ticker2._system;
  }
};
_Ticker.targetFPMS = 0.06;
let Ticker = _Ticker;
exports.Ticker = Ticker;
//# sourceMappingURL=Ticker.js.map


/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/TickerListener.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/TickerListener.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

class TickerListener {
  /**
   * Constructor
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting
   * @param once - If the handler should fire once
   */
  constructor(fn, context = null, priority = 0, once = !1) {
    this.next = null, this.previous = null, this._destroyed = !1, this.fn = fn, this.context = context, this.priority = priority, this.once = once;
  }
  /**
   * Simple compare function to figure out if a function and context match.
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @returns `true` if the listener match the arguments
   */
  match(fn, context = null) {
    return this.fn === fn && this.context === context;
  }
  /**
   * Emit by calling the current function.
   * @private
   * @param deltaTime - time since the last emit.
   * @returns Next ticker
   */
  emit(deltaTime) {
    this.fn && (this.context ? this.fn.call(this.context, deltaTime) : this.fn(deltaTime));
    const redirect = this.next;
    return this.once && this.destroy(!0), this._destroyed && (this.next = null), redirect;
  }
  /**
   * Connect to the list.
   * @private
   * @param previous - Input node, previous listener
   */
  connect(previous) {
    this.previous = previous, previous.next && (previous.next.previous = this), this.next = previous.next, previous.next = this;
  }
  /**
   * Destroy and don't use after this.
   * @private
   * @param hard - `true` to remove the `next` reference, this
   *        is considered a hard destroy. Soft destroy maintains the next reference.
   * @returns The listener to redirect while emitting or removing.
   */
  destroy(hard = !1) {
    this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
    const redirect = this.next;
    return this.next = hard ? null : redirect, this.previous = null, redirect;
  }
}
exports.TickerListener = TickerListener;
//# sourceMappingURL=TickerListener.js.map


/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/TickerPlugin.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/TickerPlugin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var extensions = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.js"), _const = __webpack_require__(/*! ./const.js */ "./node_modules/@pixi/ticker/lib/const.js"), Ticker = __webpack_require__(/*! ./Ticker.js */ "./node_modules/@pixi/ticker/lib/Ticker.js");
class TickerPlugin {
  /**
   * Initialize the plugin with scope of application instance
   * @static
   * @private
   * @param {object} [options] - See application options
   */
  static init(options) {
    options = Object.assign({
      autoStart: !0,
      sharedTicker: !1
    }, options), Object.defineProperty(
      this,
      "ticker",
      {
        set(ticker) {
          this._ticker && this._ticker.remove(this.render, this), this._ticker = ticker, ticker && ticker.add(this.render, this, _const.UPDATE_PRIORITY.LOW);
        },
        get() {
          return this._ticker;
        }
      }
    ), this.stop = () => {
      this._ticker.stop();
    }, this.start = () => {
      this._ticker.start();
    }, this._ticker = null, this.ticker = options.sharedTicker ? Ticker.Ticker.shared : new Ticker.Ticker(), options.autoStart && this.start();
  }
  /**
   * Clean up the ticker, scoped to application.
   * @static
   * @private
   */
  static destroy() {
    if (this._ticker) {
      const oldTicker = this._ticker;
      this.ticker = null, oldTicker.destroy();
    }
  }
}
TickerPlugin.extension = extensions.ExtensionType.Application;
extensions.extensions.add(TickerPlugin);
exports.TickerPlugin = TickerPlugin;
//# sourceMappingURL=TickerPlugin.js.map


/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/const.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/const.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => (UPDATE_PRIORITY2[UPDATE_PRIORITY2.INTERACTION = 50] = "INTERACTION", UPDATE_PRIORITY2[UPDATE_PRIORITY2.HIGH = 25] = "HIGH", UPDATE_PRIORITY2[UPDATE_PRIORITY2.NORMAL = 0] = "NORMAL", UPDATE_PRIORITY2[UPDATE_PRIORITY2.LOW = -25] = "LOW", UPDATE_PRIORITY2[UPDATE_PRIORITY2.UTILITY = -50] = "UTILITY", UPDATE_PRIORITY2))(UPDATE_PRIORITY || {});
exports.UPDATE_PRIORITY = UPDATE_PRIORITY;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ./settings.js */ "./node_modules/@pixi/ticker/lib/settings.js");
var _const = __webpack_require__(/*! ./const.js */ "./node_modules/@pixi/ticker/lib/const.js"), Ticker = __webpack_require__(/*! ./Ticker.js */ "./node_modules/@pixi/ticker/lib/Ticker.js"), TickerPlugin = __webpack_require__(/*! ./TickerPlugin.js */ "./node_modules/@pixi/ticker/lib/TickerPlugin.js");
exports.UPDATE_PRIORITY = _const.UPDATE_PRIORITY;
exports.Ticker = Ticker.Ticker;
exports.TickerPlugin = TickerPlugin.TickerPlugin;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/settings.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/settings.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js"), utils = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.js"), Ticker = __webpack_require__(/*! ./Ticker.js */ "./node_modules/@pixi/ticker/lib/Ticker.js");
Object.defineProperties(settings.settings, {
  /**
   * Target frames per millisecond.
   * @static
   * @name TARGET_FPMS
   * @memberof PIXI.settings
   * @type {number}
   * @deprecated since 7.1.0
   * @see PIXI.Ticker.targetFPMS
   */
  TARGET_FPMS: {
    get() {
      return Ticker.Ticker.targetFPMS;
    },
    set(value) {
      utils.deprecation("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"), Ticker.Ticker.targetFPMS = value;
    }
  }
});
Object.defineProperty(exports, "settings", ({
  enumerable: !0,
  get: function() {
    return settings.settings;
  }
}));
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/browser/detectVideoAlphaMode.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/browser/detectVideoAlphaMode.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js");
let promise;
async function detectVideoAlphaMode() {
  return promise ?? (promise = (async () => {
    const gl = document.createElement("canvas").getContext("webgl");
    if (!gl)
      return constants.ALPHA_MODES.UNPACK;
    const video = await new Promise((resolve) => {
      const video2 = document.createElement("video");
      video2.onloadeddata = () => resolve(video2), video2.onerror = () => resolve(null), video2.autoplay = !1, video2.crossOrigin = "anonymous", video2.preload = "auto", video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", video2.load();
    });
    if (!video)
      return constants.ALPHA_MODES.UNPACK;
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer), gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      texture,
      0
    ), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    const pixel = new Uint8Array(4);
    return gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel), gl.deleteFramebuffer(framebuffer), gl.deleteTexture(texture), gl.getExtension("WEBGL_lose_context")?.loseContext(), pixel[0] <= pixel[3] ? constants.ALPHA_MODES.PMA : constants.ALPHA_MODES.UNPACK;
  })()), promise;
}
exports.detectVideoAlphaMode = detectVideoAlphaMode;
//# sourceMappingURL=detectVideoAlphaMode.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/browser/hello.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/browser/hello.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var deprecation = __webpack_require__(/*! ../logging/deprecation.js */ "./node_modules/@pixi/utils/lib/logging/deprecation.js");
function skipHello() {
  deprecation.deprecation("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello");
}
function sayHello() {
  deprecation.deprecation("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`);
}
exports.sayHello = sayHello;
exports.skipHello = skipHello;
//# sourceMappingURL=hello.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/browser/isWebGLSupported.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/browser/isWebGLSupported.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../settings.js */ "./node_modules/@pixi/utils/lib/settings.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js");
let supported;
function isWebGLSupported() {
  return typeof supported > "u" && (supported = function() {
    const contextOptions = {
      stencil: !0,
      failIfMajorPerformanceCaveat: settings.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
    };
    try {
      if (!settings.settings.ADAPTER.getWebGLRenderingContext())
        return !1;
      const canvas = settings.settings.ADAPTER.createCanvas();
      let gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
      const success = !!gl?.getContextAttributes()?.stencil;
      if (gl) {
        const loseContext = gl.getExtension("WEBGL_lose_context");
        loseContext && loseContext.loseContext();
      }
      return gl = null, success;
    } catch {
      return !1;
    }
  }()), supported;
}
exports.isWebGLSupported = isWebGLSupported;
//# sourceMappingURL=isWebGLSupported.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/color/hex.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/color/hex.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var color = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.js"), deprecation = __webpack_require__(/*! ../logging/deprecation.js */ "./node_modules/@pixi/utils/lib/logging/deprecation.js");
function hex2rgb(hex, out = []) {
  return deprecation.deprecation("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead"), color.Color.shared.setValue(hex).toRgbArray(out);
}
function hex2string(hex) {
  return deprecation.deprecation("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead"), color.Color.shared.setValue(hex).toHex();
}
function string2hex(string) {
  return deprecation.deprecation("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead"), color.Color.shared.setValue(string).toNumber();
}
function rgb2hex(rgb) {
  return deprecation.deprecation("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead"), color.Color.shared.setValue(rgb).toNumber();
}
exports.hex2rgb = hex2rgb;
exports.hex2string = hex2string;
exports.rgb2hex = rgb2hex;
exports.string2hex = string2hex;
//# sourceMappingURL=hex.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/color/premultiply.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/color/premultiply.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var color = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.js"), constants = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.js"), deprecation = __webpack_require__(/*! ../logging/deprecation.js */ "./node_modules/@pixi/utils/lib/logging/deprecation.js");
function mapPremultipliedBlendModes() {
  const pm = [], npm = [];
  for (let i = 0; i < 32; i++)
    pm[i] = i, npm[i] = i;
  pm[constants.BLEND_MODES.NORMAL_NPM] = constants.BLEND_MODES.NORMAL, pm[constants.BLEND_MODES.ADD_NPM] = constants.BLEND_MODES.ADD, pm[constants.BLEND_MODES.SCREEN_NPM] = constants.BLEND_MODES.SCREEN, npm[constants.BLEND_MODES.NORMAL] = constants.BLEND_MODES.NORMAL_NPM, npm[constants.BLEND_MODES.ADD] = constants.BLEND_MODES.ADD_NPM, npm[constants.BLEND_MODES.SCREEN] = constants.BLEND_MODES.SCREEN_NPM;
  const array = [];
  return array.push(npm), array.push(pm), array;
}
const premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(blendMode, premultiplied) {
  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
}
function premultiplyRgba(rgb, alpha, out, premultiply = !0) {
  return deprecation.deprecation("7.2.0", "utils.premultiplyRgba has moved to Color.premultiply"), color.Color.shared.setValue(rgb).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
}
function premultiplyTint(tint, alpha) {
  return deprecation.deprecation("7.2.0", "utils.premultiplyTint has moved to Color.toPremultiplied"), color.Color.shared.setValue(tint).toPremultiplied(alpha);
}
function premultiplyTintToRgba(tint, alpha, out, premultiply = !0) {
  return deprecation.deprecation("7.2.0", "utils.premultiplyTintToRgba has moved to Color.premultiply"), color.Color.shared.setValue(tint).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
}
exports.correctBlendMode = correctBlendMode;
exports.premultiplyBlendMode = premultiplyBlendMode;
exports.premultiplyRgba = premultiplyRgba;
exports.premultiplyTint = premultiplyTint;
exports.premultiplyTintToRgba = premultiplyTintToRgba;
//# sourceMappingURL=premultiply.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/const.js":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/utils/lib/const.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
exports.DATA_URI = DATA_URI;
//# sourceMappingURL=const.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/createIndicesForQuads.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/createIndicesForQuads.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function createIndicesForQuads(size, outBuffer = null) {
  const totalIndices = size * 6;
  if (outBuffer = outBuffer || new Uint16Array(totalIndices), outBuffer.length !== totalIndices)
    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)
    outBuffer[i + 0] = j + 0, outBuffer[i + 1] = j + 1, outBuffer[i + 2] = j + 2, outBuffer[i + 3] = j + 0, outBuffer[i + 4] = j + 2, outBuffer[i + 5] = j + 3;
  return outBuffer;
}
exports.createIndicesForQuads = createIndicesForQuads;
//# sourceMappingURL=createIndicesForQuads.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/getBufferType.js":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/getBufferType.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function getBufferType(array) {
  if (array.BYTES_PER_ELEMENT === 4)
    return array instanceof Float32Array ? "Float32Array" : array instanceof Uint32Array ? "Uint32Array" : "Int32Array";
  if (array.BYTES_PER_ELEMENT === 2) {
    if (array instanceof Uint16Array)
      return "Uint16Array";
  } else if (array.BYTES_PER_ELEMENT === 1 && array instanceof Uint8Array)
    return "Uint8Array";
  return null;
}
exports.getBufferType = getBufferType;
//# sourceMappingURL=getBufferType.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/interleaveTypedArrays.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/interleaveTypedArrays.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var getBufferType = __webpack_require__(/*! ./getBufferType.js */ "./node_modules/@pixi/utils/lib/data/getBufferType.js");
const map = { Float32Array, Uint32Array, Int32Array, Uint8Array };
function interleaveTypedArrays(arrays, sizes) {
  let outSize = 0, stride = 0;
  const views = {};
  for (let i = 0; i < arrays.length; i++)
    stride += sizes[i], outSize += arrays[i].length;
  const buffer = new ArrayBuffer(outSize * 4);
  let out = null, littleOffset = 0;
  for (let i = 0; i < arrays.length; i++) {
    const size = sizes[i], array = arrays[i], type = getBufferType.getBufferType(array);
    views[type] || (views[type] = new map[type](buffer)), out = views[type];
    for (let j = 0; j < array.length; j++) {
      const indexStart = (j / size | 0) * stride + littleOffset, index = j % size;
      out[indexStart + index] = array[j];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}
exports.interleaveTypedArrays = interleaveTypedArrays;
//# sourceMappingURL=interleaveTypedArrays.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/pow2.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/pow2.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function nextPow2(v) {
  return v += v === 0 ? 1 : 0, --v, v |= v >>> 1, v |= v >>> 2, v |= v >>> 4, v |= v >>> 8, v |= v >>> 16, v + 1;
}
function isPow2(v) {
  return !(v & v - 1) && !!v;
}
function log2(v) {
  let r = (v > 65535 ? 1 : 0) << 4;
  v >>>= r;
  let shift = (v > 255 ? 1 : 0) << 3;
  return v >>>= shift, r |= shift, shift = (v > 15 ? 1 : 0) << 2, v >>>= shift, r |= shift, shift = (v > 3 ? 1 : 0) << 1, v >>>= shift, r |= shift, r | v >> 1;
}
exports.isPow2 = isPow2;
exports.log2 = log2;
exports.nextPow2 = nextPow2;
//# sourceMappingURL=pow2.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/removeItems.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/removeItems.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i;
  if (startIdx >= length || removeCount === 0)
    return;
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i = startIdx; i < len; ++i)
    arr[i] = arr[i + removeCount];
  arr.length = len;
}
exports.removeItems = removeItems;
//# sourceMappingURL=removeItems.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/sign.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/sign.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function sign(n) {
  return n === 0 ? 0 : n < 0 ? -1 : 1;
}
exports.sign = sign;
//# sourceMappingURL=sign.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/uid.js":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/uid.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

let nextUid = 0;
function uid() {
  return ++nextUid;
}
exports.uid = uid;
//# sourceMappingURL=uid.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/utils/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ./settings.js */ "./node_modules/@pixi/utils/lib/settings.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js"), eventemitter3 = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js"), earcut = __webpack_require__(/*! earcut */ "./node_modules/earcut/src/earcut.js"), url = __webpack_require__(/*! ./url.js */ "./node_modules/@pixi/utils/lib/url.js"), path = __webpack_require__(/*! ./path.js */ "./node_modules/@pixi/utils/lib/path.js"), detectVideoAlphaMode = __webpack_require__(/*! ./browser/detectVideoAlphaMode.js */ "./node_modules/@pixi/utils/lib/browser/detectVideoAlphaMode.js"), hello = __webpack_require__(/*! ./browser/hello.js */ "./node_modules/@pixi/utils/lib/browser/hello.js"), isWebGLSupported = __webpack_require__(/*! ./browser/isWebGLSupported.js */ "./node_modules/@pixi/utils/lib/browser/isWebGLSupported.js"), hex = __webpack_require__(/*! ./color/hex.js */ "./node_modules/@pixi/utils/lib/color/hex.js"), premultiply = __webpack_require__(/*! ./color/premultiply.js */ "./node_modules/@pixi/utils/lib/color/premultiply.js"), _const = __webpack_require__(/*! ./const.js */ "./node_modules/@pixi/utils/lib/const.js"), createIndicesForQuads = __webpack_require__(/*! ./data/createIndicesForQuads.js */ "./node_modules/@pixi/utils/lib/data/createIndicesForQuads.js"), getBufferType = __webpack_require__(/*! ./data/getBufferType.js */ "./node_modules/@pixi/utils/lib/data/getBufferType.js"), interleaveTypedArrays = __webpack_require__(/*! ./data/interleaveTypedArrays.js */ "./node_modules/@pixi/utils/lib/data/interleaveTypedArrays.js"), pow2 = __webpack_require__(/*! ./data/pow2.js */ "./node_modules/@pixi/utils/lib/data/pow2.js"), removeItems = __webpack_require__(/*! ./data/removeItems.js */ "./node_modules/@pixi/utils/lib/data/removeItems.js"), sign = __webpack_require__(/*! ./data/sign.js */ "./node_modules/@pixi/utils/lib/data/sign.js"), uid = __webpack_require__(/*! ./data/uid.js */ "./node_modules/@pixi/utils/lib/data/uid.js"), deprecation = __webpack_require__(/*! ./logging/deprecation.js */ "./node_modules/@pixi/utils/lib/logging/deprecation.js"), BoundingBox = __webpack_require__(/*! ./media/BoundingBox.js */ "./node_modules/@pixi/utils/lib/media/BoundingBox.js"), caches = __webpack_require__(/*! ./media/caches.js */ "./node_modules/@pixi/utils/lib/media/caches.js"), CanvasRenderTarget = __webpack_require__(/*! ./media/CanvasRenderTarget.js */ "./node_modules/@pixi/utils/lib/media/CanvasRenderTarget.js"), getCanvasBoundingBox = __webpack_require__(/*! ./media/getCanvasBoundingBox.js */ "./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.js"), trimCanvas = __webpack_require__(/*! ./media/trimCanvas.js */ "./node_modules/@pixi/utils/lib/media/trimCanvas.js"), decomposeDataUri = __webpack_require__(/*! ./network/decomposeDataUri.js */ "./node_modules/@pixi/utils/lib/network/decomposeDataUri.js"), determineCrossOrigin = __webpack_require__(/*! ./network/determineCrossOrigin.js */ "./node_modules/@pixi/utils/lib/network/determineCrossOrigin.js"), getResolutionOfUrl = __webpack_require__(/*! ./network/getResolutionOfUrl.js */ "./node_modules/@pixi/utils/lib/network/getResolutionOfUrl.js");
__webpack_require__(/*! ./types/index.js */ "./node_modules/@pixi/utils/lib/types/index.js");
Object.defineProperty(exports, "isMobile", ({
  enumerable: !0,
  get: function() {
    return settings.isMobile;
  }
}));
exports.EventEmitter = eventemitter3;
exports.earcut = earcut;
exports.url = url.url;
exports.path = path.path;
exports.detectVideoAlphaMode = detectVideoAlphaMode.detectVideoAlphaMode;
exports.sayHello = hello.sayHello;
exports.skipHello = hello.skipHello;
exports.isWebGLSupported = isWebGLSupported.isWebGLSupported;
exports.hex2rgb = hex.hex2rgb;
exports.hex2string = hex.hex2string;
exports.rgb2hex = hex.rgb2hex;
exports.string2hex = hex.string2hex;
exports.correctBlendMode = premultiply.correctBlendMode;
exports.premultiplyBlendMode = premultiply.premultiplyBlendMode;
exports.premultiplyRgba = premultiply.premultiplyRgba;
exports.premultiplyTint = premultiply.premultiplyTint;
exports.premultiplyTintToRgba = premultiply.premultiplyTintToRgba;
exports.DATA_URI = _const.DATA_URI;
exports.createIndicesForQuads = createIndicesForQuads.createIndicesForQuads;
exports.getBufferType = getBufferType.getBufferType;
exports.interleaveTypedArrays = interleaveTypedArrays.interleaveTypedArrays;
exports.isPow2 = pow2.isPow2;
exports.log2 = pow2.log2;
exports.nextPow2 = pow2.nextPow2;
exports.removeItems = removeItems.removeItems;
exports.sign = sign.sign;
exports.uid = uid.uid;
exports.deprecation = deprecation.deprecation;
exports.BoundingBox = BoundingBox.BoundingBox;
exports.BaseTextureCache = caches.BaseTextureCache;
exports.ProgramCache = caches.ProgramCache;
exports.TextureCache = caches.TextureCache;
exports.clearTextureCache = caches.clearTextureCache;
exports.destroyTextureCache = caches.destroyTextureCache;
exports.CanvasRenderTarget = CanvasRenderTarget.CanvasRenderTarget;
exports.getCanvasBoundingBox = getCanvasBoundingBox.getCanvasBoundingBox;
exports.trimCanvas = trimCanvas.trimCanvas;
exports.decomposeDataUri = decomposeDataUri.decomposeDataUri;
exports.determineCrossOrigin = determineCrossOrigin.determineCrossOrigin;
exports.getResolutionOfUrl = getResolutionOfUrl.getResolutionOfUrl;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/logging/deprecation.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/logging/deprecation.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const warnings = {};
function deprecation(version, message, ignoreDepth = 3) {
  if (warnings[message])
    return;
  let stack = new Error().stack;
  typeof stack > "u" ? console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`) : (stack = stack.split(`
`).splice(ignoreDepth).join(`
`), console.groupCollapsed ? (console.groupCollapsed(
    "%cPixiJS Deprecation Warning: %c%s",
    "color:#614108;background:#fffbe6",
    "font-weight:normal;color:#614108;background:#fffbe6",
    `${message}
Deprecated since v${version}`
  ), console.warn(stack), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`), console.warn(stack))), warnings[message] = !0;
}
exports.deprecation = deprecation;
//# sourceMappingURL=deprecation.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/media/BoundingBox.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/media/BoundingBox.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const _BoundingBox = class {
  /**
   * @param left - The left coordinate value of the bounding box.
   * @param top - The top coordinate value of the bounding box.
   * @param right - The right coordinate value of the bounding box.
   * @param bottom - The bottom coordinate value of the bounding box.
   */
  constructor(left, top, right, bottom) {
    this.left = left, this.top = top, this.right = right, this.bottom = bottom;
  }
  /** The width of the bounding box. */
  get width() {
    return this.right - this.left;
  }
  /** The height of the bounding box. */
  get height() {
    return this.bottom - this.top;
  }
  /** Determines whether the BoundingBox is empty. */
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
};
_BoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);
let BoundingBox = _BoundingBox;
exports.BoundingBox = BoundingBox;
//# sourceMappingURL=BoundingBox.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/media/CanvasRenderTarget.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/media/CanvasRenderTarget.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js");
class CanvasRenderTarget {
  /**
   * @param width - the width for the newly created canvas
   * @param height - the height for the newly created canvas
   * @param {number} [resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the canvas
   */
  constructor(width, height, resolution) {
    this._canvas = settings.settings.ADAPTER.createCanvas(), this._context = this._canvas.getContext("2d"), this.resolution = resolution || settings.settings.RESOLUTION, this.resize(width, height);
  }
  /**
   * Clears the canvas that was created by the CanvasRenderTarget class.
   * @private
   */
  clear() {
    this._checkDestroyed(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
  }
  /**
   * Resizes the canvas to the specified width and height.
   * @param desiredWidth - the desired width of the canvas
   * @param desiredHeight - the desired height of the canvas
   */
  resize(desiredWidth, desiredHeight) {
    this._checkDestroyed(), this._canvas.width = Math.round(desiredWidth * this.resolution), this._canvas.height = Math.round(desiredHeight * this.resolution);
  }
  /** Destroys this canvas. */
  destroy() {
    this._context = null, this._canvas = null;
  }
  /**
   * The width of the canvas buffer in pixels.
   * @member {number}
   */
  get width() {
    return this._checkDestroyed(), this._canvas.width;
  }
  set width(val) {
    this._checkDestroyed(), this._canvas.width = Math.round(val);
  }
  /**
   * The height of the canvas buffer in pixels.
   * @member {number}
   */
  get height() {
    return this._checkDestroyed(), this._canvas.height;
  }
  set height(val) {
    this._checkDestroyed(), this._canvas.height = Math.round(val);
  }
  /** The Canvas object that belongs to this CanvasRenderTarget. */
  get canvas() {
    return this._checkDestroyed(), this._canvas;
  }
  /** A CanvasRenderingContext2D object representing a two-dimensional rendering context. */
  get context() {
    return this._checkDestroyed(), this._context;
  }
  _checkDestroyed() {
    if (this._canvas === null)
      throw new TypeError("The CanvasRenderTarget has already been destroyed");
  }
}
exports.CanvasRenderTarget = CanvasRenderTarget;
//# sourceMappingURL=CanvasRenderTarget.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/media/caches.js":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/media/caches.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

const ProgramCache = {}, TextureCache = /* @__PURE__ */ Object.create(null), BaseTextureCache = /* @__PURE__ */ Object.create(null);
function destroyTextureCache() {
  let key;
  for (key in TextureCache)
    TextureCache[key].destroy();
  for (key in BaseTextureCache)
    BaseTextureCache[key].destroy();
}
function clearTextureCache() {
  let key;
  for (key in TextureCache)
    delete TextureCache[key];
  for (key in BaseTextureCache)
    delete BaseTextureCache[key];
}
exports.BaseTextureCache = BaseTextureCache;
exports.ProgramCache = ProgramCache;
exports.TextureCache = TextureCache;
exports.clearTextureCache = clearTextureCache;
exports.destroyTextureCache = destroyTextureCache;
//# sourceMappingURL=caches.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var BoundingBox = __webpack_require__(/*! ./BoundingBox.js */ "./node_modules/@pixi/utils/lib/media/BoundingBox.js");
function checkRow(data, width, y) {
  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)
    if (data[index + 3] !== 0)
      return !1;
  return !0;
}
function checkColumn(data, width, x, top, bottom) {
  const stride = 4 * width;
  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride)
    if (data[index + 3] !== 0)
      return !1;
  return !0;
}
function getCanvasBoundingBox(canvas) {
  const { width, height } = canvas, context = canvas.getContext("2d", {
    willReadFrequently: !0
  });
  if (context === null)
    throw new TypeError("Failed to get canvas 2D context");
  const data = context.getImageData(0, 0, width, height).data;
  let left = 0, top = 0, right = width - 1, bottom = height - 1;
  for (; top < height && checkRow(data, width, top); )
    ++top;
  if (top === height)
    return BoundingBox.BoundingBox.EMPTY;
  for (; checkRow(data, width, bottom); )
    --bottom;
  for (; checkColumn(data, width, left, top, bottom); )
    ++left;
  for (; checkColumn(data, width, right, top, bottom); )
    --right;
  return ++right, ++bottom, new BoundingBox.BoundingBox(left, top, right, bottom);
}
exports.getCanvasBoundingBox = getCanvasBoundingBox;
//# sourceMappingURL=getCanvasBoundingBox.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/media/trimCanvas.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/media/trimCanvas.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var getCanvasBoundingBox = __webpack_require__(/*! ./getCanvasBoundingBox.js */ "./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.js");
function trimCanvas(canvas) {
  const boundingBox = getCanvasBoundingBox.getCanvasBoundingBox(canvas), { width, height } = boundingBox;
  let data = null;
  if (!boundingBox.isEmpty()) {
    const context = canvas.getContext("2d");
    if (context === null)
      throw new TypeError("Failed to get canvas 2D context");
    data = context.getImageData(
      boundingBox.left,
      boundingBox.top,
      width,
      height
    );
  }
  return { width, height, data };
}
exports.trimCanvas = trimCanvas;
//# sourceMappingURL=trimCanvas.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/network/decomposeDataUri.js":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/network/decomposeDataUri.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _const = __webpack_require__(/*! ../const.js */ "./node_modules/@pixi/utils/lib/const.js");
function decomposeDataUri(dataUri) {
  const dataUriMatch = _const.DATA_URI.exec(dataUri);
  if (dataUriMatch)
    return {
      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,
      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,
      charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,
      encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,
      data: dataUriMatch[5]
    };
}
exports.decomposeDataUri = decomposeDataUri;
//# sourceMappingURL=decomposeDataUri.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/network/determineCrossOrigin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/network/determineCrossOrigin.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function determineCrossOrigin(url, loc = globalThis.location) {
  if (url.startsWith("data:"))
    return "";
  loc = loc || globalThis.location;
  const parsedUrl = new URL(url, document.baseURI);
  return parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol ? "anonymous" : "";
}
exports.determineCrossOrigin = determineCrossOrigin;
//# sourceMappingURL=determineCrossOrigin.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/network/getResolutionOfUrl.js":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/network/getResolutionOfUrl.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../settings.js */ "./node_modules/@pixi/utils/lib/settings.js");
var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js");
function getResolutionOfUrl(url, defaultValue = 1) {
  const resolution = settings.settings.RETINA_PREFIX?.exec(url);
  return resolution ? parseFloat(resolution[1]) : defaultValue;
}
exports.getResolutionOfUrl = getResolutionOfUrl;
//# sourceMappingURL=getResolutionOfUrl.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/path.js":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/utils/lib/path.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js");
function assertPath(path2) {
  if (typeof path2 != "string")
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
}
function removeUrlParams(url) {
  return url.split("?")[0].split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "", lastSegmentLength = 0, lastSlash = -1, dots = 0, code = -1;
  for (let i = 0; i <= path2.length; ++i) {
    if (i < path2.length)
      code = path2.charCodeAt(i);
    else {
      if (code === 47)
        break;
      code = 47;
    }
    if (code === 47) {
      if (!(lastSlash === i - 1 || dots === 1))
        if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                lastSlashIndex === -1 ? (res = "", lastSegmentLength = 0) : (res = res.slice(0, lastSlashIndex), lastSegmentLength = res.length - 1 - res.lastIndexOf("/")), lastSlash = i, dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "", lastSegmentLength = 0, lastSlash = i, dots = 0;
              continue;
            }
          }
          allowAboveRoot && (res.length > 0 ? res += "/.." : res = "..", lastSegmentLength = 2);
        } else
          res.length > 0 ? res += `/${path2.slice(lastSlash + 1, i)}` : res = path2.slice(lastSlash + 1, i), lastSegmentLength = i - lastSlash - 1;
      lastSlash = i, dots = 0;
    } else
      code === 46 && dots !== -1 ? ++dots : dots = -1;
  }
  return res;
}
const path = {
  /**
   * Converts a path to posix format.
   * @param path - The path to convert to posix
   */
  toPosix(path2) {
    return replaceAll(path2, "\\", "/");
  },
  /**
   * Checks if the path is a URL e.g. http://, https://
   * @param path - The path to check
   */
  isUrl(path2) {
    return /^https?:/.test(this.toPosix(path2));
  },
  /**
   * Checks if the path is a data URL
   * @param path - The path to check
   */
  isDataUrl(path2) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
  },
  /**
   * Checks if the path is a blob URL
   * @param path - The path to check
   */
  isBlobUrl(path2) {
    return path2.startsWith("blob:");
  },
  /**
   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
   * This will return true for windows file paths
   * @param path - The path to check
   */
  hasProtocol(path2) {
    return /^[^/:]+:/.test(this.toPosix(path2));
  },
  /**
   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
   * @param path - The path to get the protocol from
   */
  getProtocol(path2) {
    assertPath(path2), path2 = this.toPosix(path2);
    const matchFile = /^file:\/\/\//.exec(path2);
    if (matchFile)
      return matchFile[0];
    const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
    return matchProtocol ? matchProtocol[0] : "";
  },
  /**
   * Converts URL to an absolute path.
   * When loading from a Web Worker, we must use absolute paths.
   * If the URL is already absolute we return it as is
   * If it's not, we convert it
   * @param url - The URL to test
   * @param customBaseUrl - The base URL to use
   * @param customRootUrl - The root URL to use
   */
  toAbsolute(url, customBaseUrl, customRootUrl) {
    if (assertPath(url), this.isDataUrl(url) || this.isBlobUrl(url))
      return url;
    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.settings.ADAPTER.getBaseUrl())), rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
    return url = this.toPosix(url), url.startsWith("/") ? path.join(rootUrl, url.slice(1)) : this.isAbsolute(url) ? url : this.join(baseUrl, url);
  },
  /**
   * Normalizes the given path, resolving '..' and '.' segments
   * @param path - The path to normalize
   */
  normalize(path2) {
    if (assertPath(path2), path2.length === 0)
      return ".";
    if (this.isDataUrl(path2) || this.isBlobUrl(path2))
      return path2;
    path2 = this.toPosix(path2);
    let protocol = "";
    const isAbsolute = path2.startsWith("/");
    this.hasProtocol(path2) && (protocol = this.rootname(path2), path2 = path2.slice(protocol.length));
    const trailingSeparator = path2.endsWith("/");
    return path2 = normalizeStringPosix(path2, !1), path2.length > 0 && trailingSeparator && (path2 += "/"), isAbsolute ? `/${path2}` : protocol + path2;
  },
  /**
   * Determines if path is an absolute path.
   * Absolute paths can be urls, data urls, or paths on disk
   * @param path - The path to test
   */
  isAbsolute(path2) {
    return assertPath(path2), path2 = this.toPosix(path2), this.hasProtocol(path2) ? !0 : path2.startsWith("/");
  },
  /**
   * Joins all given path segments together using the platform-specific separator as a delimiter,
   * then normalizes the resulting path
   * @param segments - The segments of the path to join
   */
  join(...segments) {
    if (segments.length === 0)
      return ".";
    let joined;
    for (let i = 0; i < segments.length; ++i) {
      const arg = segments[i];
      if (assertPath(arg), arg.length > 0)
        if (joined === void 0)
          joined = arg;
        else {
          const prevArg = segments[i - 1] ?? "";
          this.extname(prevArg) ? joined += `/../${arg}` : joined += `/${arg}`;
        }
    }
    return joined === void 0 ? "." : this.normalize(joined);
  },
  /**
   * Returns the directory name of a path
   * @param path - The path to parse
   */
  dirname(path2) {
    if (assertPath(path2), path2.length === 0)
      return ".";
    path2 = this.toPosix(path2);
    let code = path2.charCodeAt(0);
    const hasRoot = code === 47;
    let end = -1, matchedSlash = !0;
    const proto = this.getProtocol(path2), origpath = path2;
    path2 = path2.slice(proto.length);
    for (let i = path2.length - 1; i >= 1; --i)
      if (code = path2.charCodeAt(i), code === 47) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else
        matchedSlash = !1;
    return end === -1 ? hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto : hasRoot && end === 1 ? "//" : proto + path2.slice(0, end);
  },
  /**
   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
   * @param path - The path to parse
   */
  rootname(path2) {
    assertPath(path2), path2 = this.toPosix(path2);
    let root = "";
    if (path2.startsWith("/") ? root = "/" : root = this.getProtocol(path2), this.isUrl(path2)) {
      const index = path2.indexOf("/", root.length);
      index !== -1 ? root = path2.slice(0, index) : root = path2, root.endsWith("/") || (root += "/");
    }
    return root;
  },
  /**
   * Returns the last portion of a path
   * @param path - The path to test
   * @param ext - Optional extension to remove
   */
  basename(path2, ext) {
    assertPath(path2), ext && assertPath(ext), path2 = removeUrlParams(this.toPosix(path2));
    let start = 0, end = -1, matchedSlash = !0, i;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
      if (ext.length === path2.length && ext === path2)
        return "";
      let extIdx = ext.length - 1, firstNonSlashEnd = -1;
      for (i = path2.length - 1; i >= 0; --i) {
        const code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else
          firstNonSlashEnd === -1 && (matchedSlash = !1, firstNonSlashEnd = i + 1), extIdx >= 0 && (code === ext.charCodeAt(extIdx) ? --extIdx === -1 && (end = i) : (extIdx = -1, end = firstNonSlashEnd));
      }
      return start === end ? end = firstNonSlashEnd : end === -1 && (end = path2.length), path2.slice(start, end);
    }
    for (i = path2.length - 1; i >= 0; --i)
      if (path2.charCodeAt(i) === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else
        end === -1 && (matchedSlash = !1, end = i + 1);
    return end === -1 ? "" : path2.slice(start, end);
  },
  /**
   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
   * the first character of the basename of path, an empty string is returned.
   * @param path - The path to parse
   */
  extname(path2) {
    assertPath(path2), path2 = removeUrlParams(this.toPosix(path2));
    let startDot = -1, startPart = 0, end = -1, matchedSlash = !0, preDotState = 0;
    for (let i = path2.length - 1; i >= 0; --i) {
      const code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      end === -1 && (matchedSlash = !1, end = i + 1), code === 46 ? startDot === -1 ? startDot = i : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -1);
    }
    return startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? "" : path2.slice(startDot, end);
  },
  /**
   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
   * @param path - The path to parse
   */
  parse(path2) {
    assertPath(path2);
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path2.length === 0)
      return ret;
    path2 = removeUrlParams(this.toPosix(path2));
    let code = path2.charCodeAt(0);
    const isAbsolute = this.isAbsolute(path2);
    let start;
    const protocol = "";
    ret.root = this.rootname(path2), isAbsolute || this.hasProtocol(path2) ? start = 1 : start = 0;
    let startDot = -1, startPart = 0, end = -1, matchedSlash = !0, i = path2.length - 1, preDotState = 0;
    for (; i >= start; --i) {
      if (code = path2.charCodeAt(i), code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      end === -1 && (matchedSlash = !1, end = i + 1), code === 46 ? startDot === -1 ? startDot = i : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -1);
    }
    return startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? end !== -1 && (startPart === 0 && isAbsolute ? ret.base = ret.name = path2.slice(1, end) : ret.base = ret.name = path2.slice(startPart, end)) : (startPart === 0 && isAbsolute ? (ret.name = path2.slice(1, startDot), ret.base = path2.slice(1, end)) : (ret.name = path2.slice(startPart, startDot), ret.base = path2.slice(startPart, end)), ret.ext = path2.slice(startDot, end)), ret.dir = this.dirname(path2), protocol && (ret.dir = protocol + ret.dir), ret;
  },
  sep: "/",
  delimiter: ":"
};
exports.path = path;
//# sourceMappingURL=path.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/settings.js":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/settings.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var settings = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.js");
settings.settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
Object.defineProperty(exports, "settings", ({
  enumerable: !0,
  get: function() {
    return settings.settings;
  }
}));
//# sourceMappingURL=settings.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/types/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/types/index.js ***!
  \*****************************************************/
/***/ (() => {

"use strict";

//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/url.js":
/*!*********************************************!*\
  !*** ./node_modules/@pixi/utils/lib/url.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var url$1 = __webpack_require__(/*! url */ "./node_modules/url/url.js"), deprecation = __webpack_require__(/*! ./logging/deprecation.js */ "./node_modules/@pixi/utils/lib/logging/deprecation.js");
const url = {
  /**
   * @deprecated since 7.3.0
   */
  get parse() {
    return deprecation.deprecation("7.3.0", "utils.url.parse is deprecated, use native URL API instead."), url$1.parse;
  },
  /**
   * @deprecated since 7.3.0
   */
  get format() {
    return deprecation.deprecation("7.3.0", "utils.url.format is deprecated, use native URL API instead."), url$1.format;
  },
  /**
   * @deprecated since 7.3.0
   */
  get resolve() {
    return deprecation.deprecation("7.3.0", "utils.url.resolve is deprecated, use native URL API instead."), url$1.resolve;
  }
};
exports.url = url;
//# sourceMappingURL=url.js.map


/***/ }),

/***/ "./node_modules/@tweenjs/tween.js/dist/tween.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tweenjs/tween.js/dist/tween.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Easing: () => (/* binding */ Easing),
/* harmony export */   Group: () => (/* binding */ Group),
/* harmony export */   Interpolation: () => (/* binding */ Interpolation),
/* harmony export */   Sequence: () => (/* binding */ Sequence),
/* harmony export */   Tween: () => (/* binding */ Tween),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getAll: () => (/* binding */ getAll),
/* harmony export */   nextId: () => (/* binding */ nextId),
/* harmony export */   now: () => (/* binding */ now$1),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   removeAll: () => (/* binding */ removeAll),
/* harmony export */   update: () => (/* binding */ update)
/* harmony export */ });
/**
 * The Ease class provides a collection of easing functions for use with tween.js.
 */
var Easing = {
    Linear: {
        None: function (amount) {
            return amount;
        },
    },
    Quadratic: {
        In: function (amount) {
            return amount * amount;
        },
        Out: function (amount) {
            return amount * (2 - amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount;
            }
            return -0.5 * (--amount * (amount - 2) - 1);
        },
    },
    Cubic: {
        In: function (amount) {
            return amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount + 2);
        },
    },
    Quartic: {
        In: function (amount) {
            return amount * amount * amount * amount;
        },
        Out: function (amount) {
            return 1 - --amount * amount * amount * amount;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount;
            }
            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
        },
    },
    Quintic: {
        In: function (amount) {
            return amount * amount * amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
        },
    },
    Sinusoidal: {
        In: function (amount) {
            return 1 - Math.cos((amount * Math.PI) / 2);
        },
        Out: function (amount) {
            return Math.sin((amount * Math.PI) / 2);
        },
        InOut: function (amount) {
            return 0.5 * (1 - Math.cos(Math.PI * amount));
        },
    },
    Exponential: {
        In: function (amount) {
            return amount === 0 ? 0 : Math.pow(1024, amount - 1);
        },
        Out: function (amount) {
            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            if ((amount *= 2) < 1) {
                return 0.5 * Math.pow(1024, amount - 1);
            }
            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
        },
    },
    Circular: {
        In: function (amount) {
            return 1 - Math.sqrt(1 - amount * amount);
        },
        Out: function (amount) {
            return Math.sqrt(1 - --amount * amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
        },
    },
    Elastic: {
        In: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
        },
        Out: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            amount *= 2;
            if (amount < 1) {
                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
            }
            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
        },
    },
    Back: {
        In: function (amount) {
            var s = 1.70158;
            return amount * amount * ((s + 1) * amount - s);
        },
        Out: function (amount) {
            var s = 1.70158;
            return --amount * amount * ((s + 1) * amount + s) + 1;
        },
        InOut: function (amount) {
            var s = 1.70158 * 1.525;
            if ((amount *= 2) < 1) {
                return 0.5 * (amount * amount * ((s + 1) * amount - s));
            }
            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
        },
    },
    Bounce: {
        In: function (amount) {
            return 1 - Easing.Bounce.Out(1 - amount);
        },
        Out: function (amount) {
            if (amount < 1 / 2.75) {
                return 7.5625 * amount * amount;
            }
            else if (amount < 2 / 2.75) {
                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
            }
            else if (amount < 2.5 / 2.75) {
                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
            }
            else {
                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
            }
        },
        InOut: function (amount) {
            if (amount < 0.5) {
                return Easing.Bounce.In(amount * 2) * 0.5;
            }
            return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
        },
    },
};

var now;
// Include a performance.now polyfill.
// In node.js, use process.hrtime.
// eslint-disable-next-line
// @ts-ignore
if (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {
    now = function () {
        // eslint-disable-next-line
        // @ts-ignore
        var time = process.hrtime();
        // Convert [seconds, nanoseconds] to milliseconds.
        return time[0] * 1000 + time[1] / 1000000;
    };
}
// In a browser, use self.performance.now if it is available.
else if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {
    // This must be bound, because directly assigning this function
    // leads to an invocation exception in Chrome.
    now = self.performance.now.bind(self.performance);
}
// Use Date.now if it is available.
else if (Date.now !== undefined) {
    now = Date.now;
}
// Otherwise, use 'new Date().getTime()'.
else {
    now = function () {
        return new Date().getTime();
    };
}
var now$1 = now;

/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tween
 */
var Group = /** @class */ (function () {
    function Group() {
        this._tweens = {};
        this._tweensAddedDuringUpdate = {};
    }
    Group.prototype.getAll = function () {
        var _this = this;
        return Object.keys(this._tweens).map(function (tweenId) {
            return _this._tweens[tweenId];
        });
    };
    Group.prototype.removeAll = function () {
        this._tweens = {};
    };
    Group.prototype.add = function (tween) {
        this._tweens[tween.getId()] = tween;
        this._tweensAddedDuringUpdate[tween.getId()] = tween;
    };
    Group.prototype.remove = function (tween) {
        delete this._tweens[tween.getId()];
        delete this._tweensAddedDuringUpdate[tween.getId()];
    };
    Group.prototype.update = function (time, preserve) {
        if (time === void 0) { time = now$1(); }
        if (preserve === void 0) { preserve = false; }
        var tweenIds = Object.keys(this._tweens);
        if (tweenIds.length === 0) {
            return false;
        }
        // Tweens are updated in "batches". If you add a new tween during an
        // update, then the new tween will be updated in the next batch.
        // If you remove a tween during an update, it may or may not be updated.
        // However, if the removed tween was added during the current batch,
        // then it will not be updated.
        while (tweenIds.length > 0) {
            this._tweensAddedDuringUpdate = {};
            for (var i = 0; i < tweenIds.length; i++) {
                var tween = this._tweens[tweenIds[i]];
                var autoStart = !preserve;
                if (tween && tween.update(time, autoStart) === false && !preserve) {
                    delete this._tweens[tweenIds[i]];
                }
            }
            tweenIds = Object.keys(this._tweensAddedDuringUpdate);
        }
        return true;
    };
    return Group;
}());

/**
 *
 */
var Interpolation = {
    Linear: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = Interpolation.Utils.Linear;
        if (k < 0) {
            return fn(v[0], v[1], f);
        }
        if (k > 1) {
            return fn(v[m], v[m - 1], m - f);
        }
        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
    },
    Bezier: function (v, k) {
        var b = 0;
        var n = v.length - 1;
        var pw = Math.pow;
        var bn = Interpolation.Utils.Bernstein;
        for (var i = 0; i <= n; i++) {
            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
        }
        return b;
    },
    CatmullRom: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = Interpolation.Utils.CatmullRom;
        if (v[0] === v[m]) {
            if (k < 0) {
                i = Math.floor((f = m * (1 + k)));
            }
            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
        }
        else {
            if (k < 0) {
                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
            }
            if (k > 1) {
                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
            }
            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
        }
    },
    Utils: {
        Linear: function (p0, p1, t) {
            return (p1 - p0) * t + p0;
        },
        Bernstein: function (n, i) {
            var fc = Interpolation.Utils.Factorial;
            return fc(n) / fc(i) / fc(n - i);
        },
        Factorial: (function () {
            var a = [1];
            return function (n) {
                var s = 1;
                if (a[n]) {
                    return a[n];
                }
                for (var i = n; i > 1; i--) {
                    s *= i;
                }
                a[n] = s;
                return s;
            };
        })(),
        CatmullRom: function (p0, p1, p2, p3, t) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            var t2 = t * t;
            var t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        },
    },
};

/**
 * Utils
 */
var Sequence = /** @class */ (function () {
    function Sequence() {
    }
    Sequence.nextId = function () {
        return Sequence._nextId++;
    };
    Sequence._nextId = 0;
    return Sequence;
}());

var mainGroup = new Group();

/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */
var Tween = /** @class */ (function () {
    function Tween(_object, _group) {
        if (_group === void 0) { _group = mainGroup; }
        this._object = _object;
        this._group = _group;
        this._isPaused = false;
        this._pauseStart = 0;
        this._valuesStart = {};
        this._valuesEnd = {};
        this._valuesStartRepeat = {};
        this._duration = 1000;
        this._initialRepeat = 0;
        this._repeat = 0;
        this._yoyo = false;
        this._isPlaying = false;
        this._reversed = false;
        this._delayTime = 0;
        this._startTime = 0;
        this._easingFunction = Easing.Linear.None;
        this._interpolationFunction = Interpolation.Linear;
        this._chainedTweens = [];
        this._onStartCallbackFired = false;
        this._id = Sequence.nextId();
        this._isChainStopped = false;
        this._goToEnd = false;
    }
    Tween.prototype.getId = function () {
        return this._id;
    };
    Tween.prototype.isPlaying = function () {
        return this._isPlaying;
    };
    Tween.prototype.isPaused = function () {
        return this._isPaused;
    };
    Tween.prototype.to = function (properties, duration) {
        // TODO? restore this, then update the 07_dynamic_to example to set fox
        // tween's to on each update. That way the behavior is opt-in (there's
        // currently no opt-out).
        // for (const prop in properties) this._valuesEnd[prop] = properties[prop]
        this._valuesEnd = Object.create(properties);
        if (duration !== undefined) {
            this._duration = duration;
        }
        return this;
    };
    Tween.prototype.duration = function (d) {
        this._duration = d;
        return this;
    };
    Tween.prototype.start = function (time) {
        if (this._isPlaying) {
            return this;
        }
        // eslint-disable-next-line
        this._group && this._group.add(this);
        this._repeat = this._initialRepeat;
        if (this._reversed) {
            // If we were reversed (f.e. using the yoyo feature) then we need to
            // flip the tween direction back to forward.
            this._reversed = false;
            for (var property in this._valuesStartRepeat) {
                this._swapEndStartRepeatValues(property);
                this._valuesStart[property] = this._valuesStartRepeat[property];
            }
        }
        this._isPlaying = true;
        this._isPaused = false;
        this._onStartCallbackFired = false;
        this._isChainStopped = false;
        this._startTime = time !== undefined ? (typeof time === 'string' ? now$1() + parseFloat(time) : time) : now$1();
        this._startTime += this._delayTime;
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);
        return this;
    };
    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {
        for (var property in _valuesEnd) {
            var startValue = _object[property];
            var startValueIsArray = Array.isArray(startValue);
            var propType = startValueIsArray ? 'array' : typeof startValue;
            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
            // If `to()` specifies a property that doesn't exist in the source object,
            // we should not set that property in the object
            if (propType === 'undefined' || propType === 'function') {
                continue;
            }
            // Check if an Array was provided as property value
            if (isInterpolationList) {
                var endValues = _valuesEnd[property];
                if (endValues.length === 0) {
                    continue;
                }
                // handle an array of relative values
                endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));
                // Create a local copy of the Array with the start value at the front
                _valuesEnd[property] = [startValue].concat(endValues);
            }
            // handle the deepness of the values
            if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {
                _valuesStart[property] = startValueIsArray ? [] : {};
                // eslint-disable-next-line
                for (var prop in startValue) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStart[property][prop] = startValue[prop];
                }
                _valuesStartRepeat[property] = startValueIsArray ? [] : {}; // TODO? repeat nested values? And yoyo? And array values?
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);
            }
            else {
                // Save the starting value, but only once.
                if (typeof _valuesStart[property] === 'undefined') {
                    _valuesStart[property] = startValue;
                }
                if (!startValueIsArray) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
                }
                if (isInterpolationList) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
                }
                else {
                    _valuesStartRepeat[property] = _valuesStart[property] || 0;
                }
            }
        }
    };
    Tween.prototype.stop = function () {
        if (!this._isChainStopped) {
            this._isChainStopped = true;
            this.stopChainedTweens();
        }
        if (!this._isPlaying) {
            return this;
        }
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        this._isPlaying = false;
        this._isPaused = false;
        if (this._onStopCallback) {
            this._onStopCallback(this._object);
        }
        return this;
    };
    Tween.prototype.end = function () {
        this._goToEnd = true;
        this.update(Infinity);
        return this;
    };
    Tween.prototype.pause = function (time) {
        if (time === void 0) { time = now$1(); }
        if (this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = true;
        this._pauseStart = time;
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        return this;
    };
    Tween.prototype.resume = function (time) {
        if (time === void 0) { time = now$1(); }
        if (!this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = false;
        this._startTime += time - this._pauseStart;
        this._pauseStart = 0;
        // eslint-disable-next-line
        this._group && this._group.add(this);
        return this;
    };
    Tween.prototype.stopChainedTweens = function () {
        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
            this._chainedTweens[i].stop();
        }
        return this;
    };
    Tween.prototype.group = function (group) {
        this._group = group;
        return this;
    };
    Tween.prototype.delay = function (amount) {
        this._delayTime = amount;
        return this;
    };
    Tween.prototype.repeat = function (times) {
        this._initialRepeat = times;
        this._repeat = times;
        return this;
    };
    Tween.prototype.repeatDelay = function (amount) {
        this._repeatDelayTime = amount;
        return this;
    };
    Tween.prototype.yoyo = function (yoyo) {
        this._yoyo = yoyo;
        return this;
    };
    Tween.prototype.easing = function (easingFunction) {
        this._easingFunction = easingFunction;
        return this;
    };
    Tween.prototype.interpolation = function (interpolationFunction) {
        this._interpolationFunction = interpolationFunction;
        return this;
    };
    Tween.prototype.chain = function () {
        var tweens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            tweens[_i] = arguments[_i];
        }
        this._chainedTweens = tweens;
        return this;
    };
    Tween.prototype.onStart = function (callback) {
        this._onStartCallback = callback;
        return this;
    };
    Tween.prototype.onUpdate = function (callback) {
        this._onUpdateCallback = callback;
        return this;
    };
    Tween.prototype.onRepeat = function (callback) {
        this._onRepeatCallback = callback;
        return this;
    };
    Tween.prototype.onComplete = function (callback) {
        this._onCompleteCallback = callback;
        return this;
    };
    Tween.prototype.onStop = function (callback) {
        this._onStopCallback = callback;
        return this;
    };
    /**
     * @returns true if the tween is still playing after the update, false
     * otherwise (calling update on a paused tween still returns true because
     * it is still playing, just paused).
     */
    Tween.prototype.update = function (time, autoStart) {
        if (time === void 0) { time = now$1(); }
        if (autoStart === void 0) { autoStart = true; }
        if (this._isPaused)
            return true;
        var property;
        var elapsed;
        var endTime = this._startTime + this._duration;
        if (!this._goToEnd && !this._isPlaying) {
            if (time > endTime)
                return false;
            if (autoStart)
                this.start(time);
        }
        this._goToEnd = false;
        if (time < this._startTime) {
            return true;
        }
        if (this._onStartCallbackFired === false) {
            if (this._onStartCallback) {
                this._onStartCallback(this._object);
            }
            this._onStartCallbackFired = true;
        }
        elapsed = (time - this._startTime) / this._duration;
        elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
        var value = this._easingFunction(elapsed);
        // properties transformations
        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
        if (this._onUpdateCallback) {
            this._onUpdateCallback(this._object, elapsed);
        }
        if (elapsed === 1) {
            if (this._repeat > 0) {
                if (isFinite(this._repeat)) {
                    this._repeat--;
                }
                // Reassign starting values, restart by making startTime = now
                for (property in this._valuesStartRepeat) {
                    if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {
                        this._valuesStartRepeat[property] =
                            // eslint-disable-next-line
                            // @ts-ignore FIXME?
                            this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
                    }
                    if (this._yoyo) {
                        this._swapEndStartRepeatValues(property);
                    }
                    this._valuesStart[property] = this._valuesStartRepeat[property];
                }
                if (this._yoyo) {
                    this._reversed = !this._reversed;
                }
                if (this._repeatDelayTime !== undefined) {
                    this._startTime = time + this._repeatDelayTime;
                }
                else {
                    this._startTime = time + this._delayTime;
                }
                if (this._onRepeatCallback) {
                    this._onRepeatCallback(this._object);
                }
                return true;
            }
            else {
                if (this._onCompleteCallback) {
                    this._onCompleteCallback(this._object);
                }
                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                    // Make the chained tweens start exactly at the time they should,
                    // even if the `update()` method was called way past the duration of the tween
                    this._chainedTweens[i].start(this._startTime + this._duration);
                }
                this._isPlaying = false;
                return false;
            }
        }
        return true;
    };
    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
        for (var property in _valuesEnd) {
            // Don't update properties that do not exist in the source object
            if (_valuesStart[property] === undefined) {
                continue;
            }
            var start = _valuesStart[property] || 0;
            var end = _valuesEnd[property];
            var startIsArray = Array.isArray(_object[property]);
            var endIsArray = Array.isArray(end);
            var isInterpolationList = !startIsArray && endIsArray;
            if (isInterpolationList) {
                _object[property] = this._interpolationFunction(end, value);
            }
            else if (typeof end === 'object' && end) {
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._updateProperties(_object[property], start, end, value);
            }
            else {
                // Parses relative end values with start as base (e.g.: +10, -3)
                end = this._handleRelativeValue(start, end);
                // Protect against non numeric properties.
                if (typeof end === 'number') {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _object[property] = start + (end - start) * value;
                }
            }
        }
    };
    Tween.prototype._handleRelativeValue = function (start, end) {
        if (typeof end !== 'string') {
            return end;
        }
        if (end.charAt(0) === '+' || end.charAt(0) === '-') {
            return start + parseFloat(end);
        }
        else {
            return parseFloat(end);
        }
    };
    Tween.prototype._swapEndStartRepeatValues = function (property) {
        var tmp = this._valuesStartRepeat[property];
        var endValue = this._valuesEnd[property];
        if (typeof endValue === 'string') {
            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
        }
        else {
            this._valuesStartRepeat[property] = this._valuesEnd[property];
        }
        this._valuesEnd[property] = tmp;
    };
    return Tween;
}());

var VERSION = '18.6.4';

/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */
var nextId = Sequence.nextId;
/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tweens.
 */
var TWEEN = mainGroup;
// This is the best way to export things in a way that's compatible with both ES
// Modules and CommonJS, without build hacks, and so as not to break the
// existing API.
// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
var getAll = TWEEN.getAll.bind(TWEEN);
var removeAll = TWEEN.removeAll.bind(TWEEN);
var add = TWEEN.add.bind(TWEEN);
var remove = TWEEN.remove.bind(TWEEN);
var update = TWEEN.update.bind(TWEEN);
var exports = {
    Easing: Easing,
    Group: Group,
    Interpolation: Interpolation,
    now: now$1,
    Sequence: Sequence,
    nextId: nextId,
    Tween: Tween,
    VERSION: VERSION,
    getAll: getAll,
    removeAll: removeAll,
    add: add,
    remove: remove,
    update: update,
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);



/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var setFunctionLength = __webpack_require__(/*! set-function-length */ "./node_modules/set-function-length/index.js");

var $TypeError = GetIntrinsic('%TypeError%');
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	if (typeof originalFunction !== 'function') {
		throw new $TypeError('a function is required');
	}
	var func = $reflectApply(bind, $call, arguments);
	return setFunctionLength(
		func,
		1 + $max(0, originalFunction.length - (arguments.length - 1)),
		true
	);
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/define-data-property/index.js":
/*!****************************************************!*\
  !*** ./node_modules/define-data-property/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasPropertyDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/has-property-descriptors/index.js")();

var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $defineProperty = hasPropertyDescriptors && GetIntrinsic('%Object.defineProperty%', true);
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

var $SyntaxError = GetIntrinsic('%SyntaxError%');
var $TypeError = GetIntrinsic('%TypeError%');

var gopd = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

/** @type {(obj: Record<PropertyKey, unknown>, property: PropertyKey, value: unknown, nonEnumerable?: boolean | null, nonWritable?: boolean | null, nonConfigurable?: boolean | null, loose?: boolean) => void} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};


/***/ }),

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


module.exports = earcut;
module.exports["default"] = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    var p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var hasProto = __webpack_require__(/*! has-proto */ "./node_modules/has-proto/index.js")();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/hasown/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/gopd/index.js":
/*!************************************!*\
  !*** ./node_modules/gopd/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "./node_modules/has-property-descriptors/index.js":
/*!********************************************************!*\
  !*** ./node_modules/has-property-descriptors/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
			return true;
		} catch (e) {
			// IE 8 has a broken defineProperty
			return false;
		}
	}
	return false;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!hasPropertyDescriptors()) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),

/***/ "./node_modules/has-proto/index.js":
/*!*****************************************!*\
  !*** ./node_modules/has-proto/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


var test = {
	foo: {}
};

var $Object = Object;

module.exports = function hasProto() {
	return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
};


/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/hasown/index.js":
/*!**************************************!*\
  !*** ./node_modules/hasown/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

/** @type {(o: {}, p: PropertyKey) => p is keyof o} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ "./node_modules/ismobilejs/esm/index.js":
/*!**********************************************!*\
  !*** ./node_modules/ismobilejs/esm/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _isMobile__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _isMobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isMobile */ "./node_modules/ismobilejs/esm/isMobile.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/ismobilejs/esm/isMobile.js":
/*!*************************************************!*\
  !*** ./node_modules/ismobilejs/esm/isMobile.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isMobile)
/* harmony export */ });
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function (navigator) {
    return (typeof navigator !== 'undefined' &&
        navigator.platform === 'MacIntel' &&
        typeof navigator.maxTouchPoints === 'number' &&
        navigator.maxTouchPoints > 1 &&
        typeof MSStream === 'undefined');
};
function createMatch(userAgent) {
    return function (regex) { return regex.test(userAgent); };
}
function isMobile(param) {
    var nav = {
        userAgent: '',
        platform: '',
        maxTouchPoints: 0
    };
    if (!param && typeof navigator !== 'undefined') {
        nav = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            maxTouchPoints: navigator.maxTouchPoints || 0
        };
    }
    else if (typeof param === 'string') {
        nav.userAgent = param;
    }
    else if (param && param.userAgent) {
        nav = {
            userAgent: param.userAgent,
            platform: param.platform,
            maxTouchPoints: param.maxTouchPoints || 0
        };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split('[FBAN');
    if (typeof tmp[1] !== 'undefined') {
        userAgent = tmp[0];
    }
    tmp = userAgent.split('Twitter');
    if (typeof tmp[1] !== 'undefined') {
        userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
        apple: {
            phone: match(appleIphone) && !match(windowsPhone),
            ipod: match(appleIpod),
            tablet: !match(appleIphone) &&
                (match(appleTablet) || isAppleTabletOnIos13(nav)) &&
                !match(windowsPhone),
            universal: match(appleUniversal),
            device: (match(appleIphone) ||
                match(appleIpod) ||
                match(appleTablet) ||
                match(appleUniversal) ||
                isAppleTabletOnIos13(nav)) &&
                !match(windowsPhone)
        },
        amazon: {
            phone: match(amazonPhone),
            tablet: !match(amazonPhone) && match(amazonTablet),
            device: match(amazonPhone) || match(amazonTablet)
        },
        android: {
            phone: (!match(windowsPhone) && match(amazonPhone)) ||
                (!match(windowsPhone) && match(androidPhone)),
            tablet: !match(windowsPhone) &&
                !match(amazonPhone) &&
                !match(androidPhone) &&
                (match(amazonTablet) || match(androidTablet)),
            device: (!match(windowsPhone) &&
                (match(amazonPhone) ||
                    match(amazonTablet) ||
                    match(androidPhone) ||
                    match(androidTablet))) ||
                match(/\bokhttp\b/i)
        },
        windows: {
            phone: match(windowsPhone),
            tablet: match(windowsTablet),
            device: match(windowsPhone) || match(windowsTablet)
        },
        other: {
            blackberry: match(otherBlackBerry),
            blackberry10: match(otherBlackBerry10),
            opera: match(otherOpera),
            firefox: match(otherFirefox),
            chrome: match(otherChrome),
            device: match(otherBlackBerry) ||
                match(otherBlackBerry10) ||
                match(otherOpera) ||
                match(otherFirefox) ||
                match(otherChrome)
        },
        any: false,
        phone: false,
        tablet: false
    };
    result.any =
        result.apple.device ||
            result.android.device ||
            result.windows.device ||
            result.other.device;
    result.phone =
        result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet =
        result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
}
//# sourceMappingURL=isMobile.js.map

/***/ }),

/***/ "./node_modules/object-inspect/index.js":
/*!**********************************************!*\
  !*** ./node_modules/object-inspect/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __webpack_require__(/*! ./util.inspect */ "?4f7e");
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (obj === __webpack_require__.g) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters.js":
/*!*********************************************!*\
  !*** ./node_modules/pixi.js/lib/filters.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), filterAlpha = __webpack_require__(/*! @pixi/filter-alpha */ "./node_modules/@pixi/filter-alpha/lib/index.js"), filterBlur = __webpack_require__(/*! @pixi/filter-blur */ "./node_modules/@pixi/filter-blur/lib/index.js"), filterColorMatrix = __webpack_require__(/*! @pixi/filter-color-matrix */ "./node_modules/@pixi/filter-color-matrix/lib/index.js"), filterDisplacement = __webpack_require__(/*! @pixi/filter-displacement */ "./node_modules/@pixi/filter-displacement/lib/index.js"), filterFxaa = __webpack_require__(/*! @pixi/filter-fxaa */ "./node_modules/@pixi/filter-fxaa/lib/index.js"), filterNoise = __webpack_require__(/*! @pixi/filter-noise */ "./node_modules/@pixi/filter-noise/lib/index.js");
const filters = {
  /**
   * @class
   * @memberof PIXI.filters
   * @deprecated since 7.1.0
   * @see PIXI.AlphaFilter
   */
  AlphaFilter: filterAlpha.AlphaFilter,
  /**
   * @class
   * @memberof PIXI.filters
   * @deprecated since 7.1.0
   * @see PIXI.BlurFilter
   */
  BlurFilter: filterBlur.BlurFilter,
  /**
   * @class
   * @memberof PIXI.filters
   * @deprecated since 7.1.0
   * @see PIXI.BlurFilterPass
   */
  BlurFilterPass: filterBlur.BlurFilterPass,
  /**
   * @class
   * @memberof PIXI.filters
   * @deprecated since 7.1.0
   * @see PIXI.ColorMatrixFilter
   */
  ColorMatrixFilter: filterColorMatrix.ColorMatrixFilter,
  /**
   * @class
   * @memberof PIXI.filters
   * @deprecated since 7.1.0
   * @see PIXI.DisplacementFilter
   */
  DisplacementFilter: filterDisplacement.DisplacementFilter,
  /**
   * @class
   * @memberof PIXI.filters
   * @deprecated since 7.1.0
   * @see PIXI.FXAAFilter
   */
  FXAAFilter: filterFxaa.FXAAFilter,
  /**
   * @class
   * @memberof PIXI.filters
   * @deprecated since 7.1.0
   * @see PIXI.NoiseFilter
   */
  NoiseFilter: filterNoise.NoiseFilter
};
Object.entries(filters).forEach(([key, FilterClass]) => {
  Object.defineProperty(filters, key, {
    get() {
      return core.utils.deprecation("7.1.0", `filters.${key} has moved to ${key}`), FilterClass;
    }
  });
});
exports.filters = filters;
//# sourceMappingURL=filters.js.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/pixi.js/lib/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! @pixi/mixin-cache-as-bitmap */ "./node_modules/@pixi/mixin-cache-as-bitmap/lib/index.js");
__webpack_require__(/*! @pixi/mixin-get-child-by-name */ "./node_modules/@pixi/mixin-get-child-by-name/lib/index.js");
__webpack_require__(/*! @pixi/mixin-get-global-position */ "./node_modules/@pixi/mixin-get-global-position/lib/index.js");
var filters = __webpack_require__(/*! ./filters.js */ "./node_modules/pixi.js/lib/filters.js"), accessibility = __webpack_require__(/*! @pixi/accessibility */ "./node_modules/@pixi/accessibility/lib/index.js"), app = __webpack_require__(/*! @pixi/app */ "./node_modules/@pixi/app/lib/index.js"), assets = __webpack_require__(/*! @pixi/assets */ "./node_modules/@pixi/assets/lib/index.js"), compressedTextures = __webpack_require__(/*! @pixi/compressed-textures */ "./node_modules/@pixi/compressed-textures/lib/index.js"), core = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.js"), display = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.js"), events = __webpack_require__(/*! @pixi/events */ "./node_modules/@pixi/events/lib/index.js"), extract = __webpack_require__(/*! @pixi/extract */ "./node_modules/@pixi/extract/lib/index.js"), filterAlpha = __webpack_require__(/*! @pixi/filter-alpha */ "./node_modules/@pixi/filter-alpha/lib/index.js"), filterBlur = __webpack_require__(/*! @pixi/filter-blur */ "./node_modules/@pixi/filter-blur/lib/index.js"), filterColorMatrix = __webpack_require__(/*! @pixi/filter-color-matrix */ "./node_modules/@pixi/filter-color-matrix/lib/index.js"), filterDisplacement = __webpack_require__(/*! @pixi/filter-displacement */ "./node_modules/@pixi/filter-displacement/lib/index.js"), filterFxaa = __webpack_require__(/*! @pixi/filter-fxaa */ "./node_modules/@pixi/filter-fxaa/lib/index.js"), filterNoise = __webpack_require__(/*! @pixi/filter-noise */ "./node_modules/@pixi/filter-noise/lib/index.js"), graphics = __webpack_require__(/*! @pixi/graphics */ "./node_modules/@pixi/graphics/lib/index.js"), mesh = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.js"), meshExtras = __webpack_require__(/*! @pixi/mesh-extras */ "./node_modules/@pixi/mesh-extras/lib/index.js"), particleContainer = __webpack_require__(/*! @pixi/particle-container */ "./node_modules/@pixi/particle-container/lib/index.js"), prepare = __webpack_require__(/*! @pixi/prepare */ "./node_modules/@pixi/prepare/lib/index.js"), sprite = __webpack_require__(/*! @pixi/sprite */ "./node_modules/@pixi/sprite/lib/index.js"), spriteAnimated = __webpack_require__(/*! @pixi/sprite-animated */ "./node_modules/@pixi/sprite-animated/lib/index.js"), spriteTiling = __webpack_require__(/*! @pixi/sprite-tiling */ "./node_modules/@pixi/sprite-tiling/lib/index.js"), spritesheet = __webpack_require__(/*! @pixi/spritesheet */ "./node_modules/@pixi/spritesheet/lib/index.js"), text = __webpack_require__(/*! @pixi/text */ "./node_modules/@pixi/text/lib/index.js"), textBitmap = __webpack_require__(/*! @pixi/text-bitmap */ "./node_modules/@pixi/text-bitmap/lib/index.js"), textHtml = __webpack_require__(/*! @pixi/text-html */ "./node_modules/@pixi/text-html/lib/index.js");
exports.filters = filters.filters;
Object.keys(accessibility).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return accessibility[k];
    }
  });
});
Object.keys(app).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return app[k];
    }
  });
});
Object.keys(assets).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return assets[k];
    }
  });
});
Object.keys(compressedTextures).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return compressedTextures[k];
    }
  });
});
Object.keys(core).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return core[k];
    }
  });
});
Object.keys(display).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return display[k];
    }
  });
});
Object.keys(events).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return events[k];
    }
  });
});
Object.keys(extract).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return extract[k];
    }
  });
});
Object.keys(filterAlpha).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return filterAlpha[k];
    }
  });
});
Object.keys(filterBlur).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return filterBlur[k];
    }
  });
});
Object.keys(filterColorMatrix).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return filterColorMatrix[k];
    }
  });
});
Object.keys(filterDisplacement).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return filterDisplacement[k];
    }
  });
});
Object.keys(filterFxaa).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return filterFxaa[k];
    }
  });
});
Object.keys(filterNoise).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return filterNoise[k];
    }
  });
});
Object.keys(graphics).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return graphics[k];
    }
  });
});
Object.keys(mesh).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return mesh[k];
    }
  });
});
Object.keys(meshExtras).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return meshExtras[k];
    }
  });
});
Object.keys(particleContainer).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return particleContainer[k];
    }
  });
});
Object.keys(prepare).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return prepare[k];
    }
  });
});
Object.keys(sprite).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return sprite[k];
    }
  });
});
Object.keys(spriteAnimated).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return spriteAnimated[k];
    }
  });
});
Object.keys(spriteTiling).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return spriteTiling[k];
    }
  });
});
Object.keys(spritesheet).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return spritesheet[k];
    }
  });
});
Object.keys(text).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return text[k];
    }
  });
});
Object.keys(textBitmap).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return textBitmap[k];
    }
  });
});
Object.keys(textHtml).forEach(function(k) {
  k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k) && Object.defineProperty(exports, k, {
    enumerable: !0,
    get: function() {
      return textHtml[k];
    }
  });
});
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/punycode/punycode.js":
/*!*******************************************!*\
  !*** ./node_modules/punycode/punycode.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));


/***/ }),

/***/ "./node_modules/qs/lib/formats.js":
/*!****************************************!*\
  !*** ./node_modules/qs/lib/formats.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ "./node_modules/qs/lib/index.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "./node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "./node_modules/qs/lib/parse.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/parse.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (cleanRoot !== '__proto__') {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "./node_modules/qs/lib/stringify.js":
/*!******************************************!*\
  !*** ./node_modules/qs/lib/stringify.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getSideChannel = __webpack_require__(/*! side-channel */ "./node_modules/side-channel/index.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + '[]' : prefix;

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + key : '[' + key + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            strictNullHandling,
            skipNulls,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (opts && 'commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }
    var commaRoundTrip = generateArrayPrefix === 'comma' && opts && opts.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "./node_modules/qs/lib/utils.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/utils.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        /* eslint operator-linebreak: [2, "before"] */
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),

/***/ "./node_modules/set-function-length/index.js":
/*!***************************************************!*\
  !*** ./node_modules/set-function-length/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var define = __webpack_require__(/*! define-data-property */ "./node_modules/define-data-property/index.js");
var hasDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/has-property-descriptors/index.js")();
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

var $TypeError = GetIntrinsic('%TypeError%');
var $floor = GetIntrinsic('%Math.floor%');

module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(fn, 'length', length, true, true);
		} else {
			define(fn, 'length', length);
		}
	}
	return fn;
};


/***/ }),

/***/ "./node_modules/side-channel/index.js":
/*!********************************************!*\
  !*** ./node_modules/side-channel/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var inspect = __webpack_require__(/*! object-inspect */ "./node_modules/object-inspect/index.js");

var $TypeError = GetIntrinsic('%TypeError%');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
 * This function traverses the list returning the node corresponding to the
 * given key.
 *
 * That node is also moved to the head of the list, so that if it's accessed
 * again we don't need to traverse the whole list. By doing so, all the recently
 * used nodes can be accessed relatively quickly.
 */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			curr.next = list.next;
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = { // eslint-disable-line no-param-reassign
			key: key,
			next: objects.next,
			value: value
		};
	}
};
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

module.exports = function getSideChannel() {
	var $wm;
	var $m;
	var $o;
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					/*
					 * Initialize the linked list as an empty node, so that we don't have
					 * to special-case handling of the first node: we can always refer to
					 * it as (previous node).next, instead of something like (list).head
					 */
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};


/***/ }),

/***/ "./src/controllers/PortController.ts":
/*!*******************************************!*\
  !*** ./src/controllers/PortController.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PortController = void 0;
class PortController {
    constructor(port, portView) {
        this.port = port;
        this.portView = portView;
    }
    processShip(ship) {
        const dock = this.port.findEmptyDock();
        if (dock) {
            dock.occupy();
            ship.processAtDock(dock);
            setTimeout(() => {
                dock.release();
                dock.setCargo(ship.type === 'red');
                this.portView.update();
            }, 5000); // Час перебування корабля у порту
        }
    }
    canAcceptShip() {
        return this.port.findEmptyDock() !== null;
    }
}
exports.PortController = PortController;


/***/ }),

/***/ "./src/controllers/QueueManager.ts":
/*!*****************************************!*\
  !*** ./src/controllers/QueueManager.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QueueManager = void 0;
class QueueManager {
    constructor() {
        this.loadingQueue = [];
        this.unloadingQueue = [];
    }
    addToQueue(ship) {
        if (ship.type === 'green') {
            this.loadingQueue.push(ship);
        }
        else {
            this.unloadingQueue.push(ship);
        }
    }
    getNextShip() {
        if (this.unloadingQueue.length > 0) {
            return this.unloadingQueue.shift() || null;
        }
        else if (this.loadingQueue.length > 0) {
            return this.loadingQueue.shift() || null;
        }
        return null;
    }
    hasShips() {
        return this.loadingQueue.length > 0 || this.unloadingQueue.length > 0;
    }
}
exports.QueueManager = QueueManager;


/***/ }),

/***/ "./src/controllers/SeaController.ts":
/*!******************************************!*\
  !*** ./src/controllers/SeaController.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SeaController = void 0;
const pixi_js_1 = __webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.js");
const Ship_1 = __webpack_require__(/*! ../models/Ship */ "./src/models/Ship.ts");
const ShipView_1 = __webpack_require__(/*! ../views/ShipView */ "./src/views/ShipView.ts");
const ShipController_1 = __webpack_require__(/*! ./ShipController */ "./src/controllers/ShipController.ts");
const QueueManager_1 = __webpack_require__(/*! ./QueueManager */ "./src/controllers/QueueManager.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/utils/index.ts");
const tween_js_1 = __importDefault(__webpack_require__(/*! @tweenjs/tween.js */ "./node_modules/@tweenjs/tween.js/dist/tween.esm.js"));
const SeaView_1 = __webpack_require__(/*! ../views/SeaView */ "./src/views/SeaView.ts");
// interface ShipType {
//     ship: Ship;
//     shipView: ShipView;
//     shipController: ShipController;
// }
class SeaController {
    constructor() {
        this.ships = [];
        this.queueManager = new QueueManager_1.QueueManager();
        this.seaView = new SeaView_1.SeaView();
        this.createShips();
        this.processQueue();
    }
    // private setToShipsList(shipModel: ShipType) {
    //     this.ships.push(shipModel);
    // }
    createShips() {
        setInterval(() => {
            const shipType = utils_1.Utils.randomInt(0, 1) === 0 ? 'green' : 'red';
            const ship = new Ship_1.Ship(shipType);
            const shipView = new ShipView_1.ShipView(ship);
            const shipController = new ShipController_1.ShipController(ship, shipView, this.seaView.getPortController());
            // Визначаємо початкову позицію корабля
            const startPosition = new pixi_js_1.Point(-500, utils_1.Utils.randomInt(200, 500));
            shipView.setPosition(startPosition);
            // Додаємо корабель до черги
            // Анімація руху корабля до очікуваної позиції біля порту
            const portPosition = new pixi_js_1.Point(200, utils_1.Utils.randomInt(100, 300));
            shipController.moveToPort(portPosition);
            this.queueManager.addToQueue(ship);
            this.ships.push(shipController);
        }, 5000); // Частота появи кораблів
    }
    processQueue() {
        setInterval(() => {
            // if (this.seaView.getPortController().canAcceptShip() && this.queueManager.hasShips()) {
            //     const ship = this.queueManager.getNextShip();
            //     if (ship) {
            //         this.seaView.getPortController().processShip(ship);
            //     }
            // }
            const ship = this.queueManager.getNextShip();
            if (ship) {
                this.seaView.getPortController().processShip(ship);
            }
        }, 1000); // Періодична перевірка черги
    }
    start() {
        // this.app.ticker.add(delta => this.gameUpdate(delta));
        this.seaView.getAppParams().ticker.add((delta) => {
            this.gameUpdate(delta);
        });
    }
    gameUpdate(delta) {
        tween_js_1.default.update();
        // Game logic updates
    }
}
exports.SeaController = SeaController;


/***/ }),

/***/ "./src/controllers/ShipController.ts":
/*!*******************************************!*\
  !*** ./src/controllers/ShipController.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShipController = void 0;
class ShipController {
    constructor(ship, shipView, portController) {
        this.ship = ship;
        this.shipView = shipView;
        this.portController = portController;
    }
    moveToPort(portPosition) {
        this.shipView.animateMovement(portPosition);
        // Додаткова логіка для взаємодії з портом
    }
    leavePort() {
        this.ship.leaveDock();
        // Логіка для виходу корабля з порту
    }
}
exports.ShipController = ShipController;


/***/ }),

/***/ "./src/models/Dock.ts":
/*!****************************!*\
  !*** ./src/models/Dock.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dock = void 0;
class Dock {
    constructor() {
        this.occupied = false;
        this.cargo = false;
    }
    occupy() {
        this.occupied = true;
    }
    release() {
        this.occupied = false;
    }
    isOccupied() {
        return this.occupied;
    }
    setCargo(cargo) {
        this.cargo = cargo;
    }
    hasCargo() {
        return this.cargo;
    }
}
exports.Dock = Dock;


/***/ }),

/***/ "./src/models/Port.ts":
/*!****************************!*\
  !*** ./src/models/Port.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Port = void 0;
const Dock_1 = __webpack_require__(/*! ./Dock */ "./src/models/Dock.ts");
class Port {
    constructor(dockCount) {
        this.docks = [];
        for (let i = 0; i < dockCount; i++) {
            this.docks.push(new Dock_1.Dock());
        }
    }
    getDocks() {
        return this.docks;
    }
    findEmptyDock() {
        return this.docks.find(dock => !dock.isOccupied()) || null;
    }
}
exports.Port = Port;
// src/models/Port.ts
// import { Dock } from './Dock';
// import { Ship, ShipType } from './Ship';
// export class Port {
//     docks: Dock[];
//     greenQueue: Ship[];
//     redQueue: Ship[];
//     constructor(docks: Dock[]) {
//         this.docks = docks;
//         this.greenQueue = [];
//         this.redQueue = [];
//     }
//     // Методи для управління портом та розподілу кораблів
// }


/***/ }),

/***/ "./src/models/Ship.ts":
/*!****************************!*\
  !*** ./src/models/Ship.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Ship = void 0;
class Ship {
    constructor(type) {
        this.dock = null;
        this.type = type;
    }
    processAtDock(dock) {
        this.dock = dock;
        // Логіка обробки корабля на пристані
    }
    leaveDock() {
        this.dock = null;
    }
    isAtDock() {
        return this.dock !== null;
    }
}
exports.Ship = Ship;
// src/models/Ship.ts
// export enum ShipType {
//     Green, // Зелений - приходить за вантажем
//     Red    // Червоний - приходить з вантажем
// }
// export class Ship {
//     type: ShipType;
//     isLoaded: boolean;
//     capacity: number;
//     position: { x: number, y: number };
//     constructor(type: ShipType, capacity: number, position: { x: number, y: number }) {
//         this.type = type;
//         this.isLoaded = type === ShipType.Red;
//         this.capacity = capacity;
//         this.position = position;
//     }
//     // Методи для управління станом корабля
// }


/***/ }),

/***/ "./src/utils/index.ts":
/*!****************************!*\
  !*** ./src/utils/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utils = void 0;
class Utils {
    static randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
}
exports.Utils = Utils;


/***/ }),

/***/ "./src/views/DockView.ts":
/*!*******************************!*\
  !*** ./src/views/DockView.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DockView = void 0;
// src/views/DockView.ts
const pixi_js_1 = __webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.js");
class DockView {
    constructor(dock, position) {
        this.dock = dock;
        this.graphics = new pixi_js_1.Graphics();
        this.position = position;
        this.draw();
    }
    draw() {
        this.graphics.clear();
        // Встановлюємо колір залежно від статусу пристані
        const color = this.dock.isOccupied() ? 0x0000FF : 0xCCCCCC; // Синій, якщо зайнято, інакше - світло-сірий
        this.graphics.beginFill(color);
        this.graphics.lineStyle(1, 1, 1, 1);
        this.graphics.drawRect(this.position.x + 10, this.position.y + 10, 80, 50); // Розміри пристані
        this.graphics.endFill();
    }
    // Оновлення відображення при зміні статусу пристані
    update() {
        this.draw();
    }
}
exports.DockView = DockView;


/***/ }),

/***/ "./src/views/PortView.ts":
/*!*******************************!*\
  !*** ./src/views/PortView.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PortView = void 0;
const pixi_js_1 = __webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.js");
const DockView_1 = __webpack_require__(/*! ./DockView */ "./src/views/DockView.ts");
class PortView {
    constructor(port, app) {
        this.dockViews = [];
        this.port = port;
        this.portGraphics = new pixi_js_1.Graphics();
        app.stage.addChild(this.portGraphics);
        this.appStage = app;
        // this.dockGraphics = new Graphics();
        // this.dockGraphics.addChild(new Container())
        // app.stage.addChild(this.dockGraphics);
        this.drawPort();
        this.drawDocks(this.dockViews, this.appStage);
    }
    drawPort() {
        this.portGraphics.clear();
        // this.portGraphics.width = this.appStage.screen.width / 2;
        // this.appStage.screen.height = app.screen.height / 2;
        // this.portGraphics.beginFill(0xffff00); // Колір порту
        this.portGraphics.lineStyle(2.5, 0x2e8b57); // Тип лін��ї
        this.portGraphics.drawRect(100, 100, 350, 400); // Розміри порту
        this.portGraphics.endFill();
    }
    drawDocks(dockViews, app) {
        // this.port.getDocks().forEach((dock, index) => {
        //     this.dockGraphics.beginFill(dock.hasCargo() ? 0x0000ff : 0xffffff, dock.isOccupied() ? 1 : 0.5);
        //     // this.dockGraphics.scale.x = -0.2; // Перевертаємо контейнер
        //     this.dockGraphics.position.x = 100;
        //     this.dockGraphics.lineStyle(5, 5);
        //     this.dockGraphics.position.y = 100;
        //     this.dockGraphics.drawRect(100 + index * 100, 100, 80, 100);
        //     this.dockGraphics.endFill();
        // });
        this.port.getDocks().forEach((dock, index) => {
            const dockView = new DockView_1.DockView(dock, { x: 100, y: 100 + (index + 0.5) * 80 });
            dockViews.push(dockView);
            app.stage.addChild(dockView.graphics);
        });
    }
    update() {
        this.drawDocks(this.dockViews, this.appStage);
    }
}
exports.PortView = PortView;


/***/ }),

/***/ "./src/views/SeaView.ts":
/*!******************************!*\
  !*** ./src/views/SeaView.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SeaView = void 0;
const pixi_js_1 = __webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.js");
const Port_1 = __webpack_require__(/*! ../models/Port */ "./src/models/Port.ts");
const PortView_1 = __webpack_require__(/*! ../views/PortView */ "./src/views/PortView.ts");
const PortController_1 = __webpack_require__(/*! ../controllers/PortController */ "./src/controllers/PortController.ts");
class SeaView {
    constructor() {
        this.app = new pixi_js_1.Application({ width: 800, height: 600, backgroundColor: 0x1099bb });
        document.body.appendChild(this.app.view);
        this.port = new Port_1.Port(4); // 4 пристані
        this.portView = new PortView_1.PortView(this.port, this.app);
        this.portController = new PortController_1.PortController(this.port, this.portView);
        // const dockViews: DockView[] = [];
        // this.port.getDocks().forEach((dock, index) => {
        //     const dockView = new DockView(dock, { x: 100, y: 100 + index * 60 });
        //     dockViews.push(dockView);
        //     this.app.stage.addChild(dockView.graphics);
        // });
    }
    getPortController() {
        return this.portController;
    }
    getAppParams() {
        return this.app;
    }
}
exports.SeaView = SeaView;


/***/ }),

/***/ "./src/views/ShipView.ts":
/*!*******************************!*\
  !*** ./src/views/ShipView.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShipView = void 0;
const pixi_js_1 = __webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.js");
var TWEEN = __webpack_require__(/*! @tweenjs/tween.js */ "./node_modules/@tweenjs/tween.js/dist/tween.esm.js");
class ShipView {
    constructor(shipModel) {
        this.shipModel = shipModel;
        this.shipGraphics = new pixi_js_1.Graphics();
        this.shipSprite = new pixi_js_1.Sprite(pixi_js_1.Texture.WHITE);
        // this.shipSprite.tint = this.shipModel.type === 'green' ? 0x00ff00 : 0xff0000;
        // this.shipSprite.width = 50; // Припустимо, що розмір корабля - 50x20
        // this.shipSprite.height = 20;
        this.shipGraphics.clear();
        // Встановлюємо колір залежно від статусу пристані
        const color = this.shipModel.type === 'green' ? 0x00ff00 : 0xff0000;
        this.shipGraphics.beginFill(color);
        this.shipGraphics.lineStyle(1, 1, 1, 1);
        this.shipGraphics.drawRect(this.shipGraphics.position.x + 5, this.shipGraphics.position.y + 5, 40, 20); // Розміри пристані
        this.shipGraphics.endFill();
    }
    setPosition(position) {
        this.shipSprite.x = position.x;
        this.shipSprite.y = position.y;
    }
    animateMovement(destination) {
        new TWEEN.Tween(this.shipGraphics.position)
            .to({ x: destination.x, y: destination.y }, 5000)
            .easing(TWEEN.Easing.Quadratic.Out)
            .start();
    }
    get view() {
        return this.shipSprite;
    }
}
exports.ShipView = ShipView;
// src/views/ShipView.ts
// import * as PIXI from 'pixi.js';
// import { Ship, ShipType } from '../models/Ship';
// export class ShipView {
//     ship: Ship;
//     graphics: PIXI.Graphics;
//     constructor(ship: Ship, app: PIXI.Application) {
//         this.ship = ship;
//         this.graphics = new PIXI.Graphics();
//         this.drawShip();
//         app.stage.addChild(this.graphics);
//     }
//     drawShip() {
//         this.graphics.clear();
//         this.graphics.beginFill(this.ship.type === ShipType.Green ? 0x00ff00 : 0xff0000);
//         this.graphics.drawRect(this.ship.position.x, this.ship.position.y, 50, 20); // Припустимі розміри корабля
//         this.graphics.endFill();
//     }
//     // Методи для анімації та оновлення візуалізації корабля
// }


/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */



var punycode = __webpack_require__(/*! punycode */ "./node_modules/punycode/punycode.js");

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

/*
 * define these here so at least they only have to be
 * compiled once on the first module load.
 */
var protocolPattern = /^([a-z0-9.+-]+:)/i,
  portPattern = /:[0-9]*$/,

  // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,

  /*
   * RFC 2396: characters reserved for delimiting URLs.
   * We actually just auto-escape these.
   */
  delims = [
    '<', '>', '"', '`', ' ', '\r', '\n', '\t'
  ],

  // RFC 2396: characters not allowed for various reasons.
  unwise = [
    '{', '}', '|', '\\', '^', '`'
  ].concat(delims),

  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),
  /*
   * Characters that are never ever allowed in a hostname.
   * Note that any invalid chars are also handled, but these
   * are the ones that are *expected* to be seen, so we fast-path
   * them.
   */
  nonHostChars = [
    '%', '/', '?', ';', '#'
  ].concat(autoEscape),
  hostEndingChars = [
    '/', '?', '#'
  ],
  hostnameMaxLen = 255,
  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  // protocols that can allow "unsafe" and "unwise" chars.
  unsafeProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that never have a hostname.
  hostlessProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that always contain a // bit.
  slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  },
  querystring = __webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof url === 'object' && url instanceof Url) { return url; }

  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  /*
   * Copy chrome, IE, opera backslash-handling behavior.
   * Back slashes before the query string get converted to forward slashes
   * See: https://code.google.com/p/chromium/issues/detail?id=25916
   */
  var queryIndex = url.indexOf('?'),
    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
    uSplit = url.split(splitter),
    slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  /*
   * trim before proceeding.
   * This is to support parse stuff like "  http://foo.com  \n"
   */
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  /*
   * figure out if it's got a host
   * user@server is *always* interpreted as a hostname, and url
   * resolution will treat //foo/bar as host=foo,path=bar because that's
   * how the browser resolves relative URLs.
   */
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {

    /*
     * there's a hostname.
     * the first instance of /, ?, ;, or # ends the host.
     *
     * If there is an @ in the hostname, then non-host chars *are* allowed
     * to the left of the last @ sign, unless some host-ending character
     * comes *before* the @-sign.
     * URLs are obnoxious.
     *
     * ex:
     * http://a@b@c/ => user:a@b host:c
     * http://a@b?@c => user:a host:c path:/?@c
     */

    /*
     * v0.12 TODO(isaacs): This is not quite how Chrome does things.
     * Review our test case against browsers more comprehensively.
     */

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }

    /*
     * at this point, either we have an explicit point where the
     * auth portion cannot go past, or the last @ char is the decider.
     */
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      /*
       * atSign must be in auth portion.
       * http://a@b/c@d => host:b auth:a path:/c@d
       */
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    /*
     * Now we have a portion which is definitely the auth.
     * Pull that off.
     */
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) { hostEnd = rest.length; }

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    /*
     * we've indicated that there is a hostname,
     * so even if it's empty, it has to be present.
     */
    this.hostname = this.hostname || '';

    /*
     * if hostname begins with [ and ends with ]
     * assume that it's an IPv6 address.
     */
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) { continue; }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              /*
               * we replace non-ASCII char with a temporary placeholder
               * we need this to make sure size of hostname is not
               * broken by replacing non-ASCII by nothing
               */
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      /*
       * IDNA Support: Returns a punycoded representation of "domain".
       * It only converts parts of the domain name that
       * have non-ASCII characters, i.e. it doesn't matter if
       * you call it with a domain that already is ASCII-only.
       */
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    /*
     * strip [ and ] from the hostname
     * the host field still retains them, though
     */
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  /*
   * now rest is set to the post-host stuff.
   * chop off any delim chars.
   */
  if (!unsafeProtocol[lowerProto]) {

    /*
     * First, make 100% sure that any "autoEscape" chars get
     * escaped, even if encodeURIComponent doesn't think they
     * need to be.
     */
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) { continue; }
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  // to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  /*
   * ensure it's an object, and not a string url.
   * If it's an obj, this is a no-op.
   * this way, you can call url_format() on strings
   * to clean up potentially wonky urls.
   */
  if (typeof obj === 'string') { obj = urlParse(obj); }
  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
    pathname = this.pathname || '',
    hash = this.hash || '',
    host = false,
    query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {
    query = querystring.stringify(this.query, {
      arrayFormat: 'repeat',
      addQueryPrefix: false
    });
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }

  /*
   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
   * unless they had them to begin with.
   */
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }
  if (search && search.charAt(0) !== '?') { search = '?' + search; }

  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) { return relative; }
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (typeof relative === 'string') {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  /*
   * hash is always overridden, no matter what.
   * even href="" will remove it.
   */
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }
    }

    // urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = '/';
      result.path = result.pathname;
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    /*
     * if it's a known url protocol, then changing
     * the protocol does weird things
     * first, if it's not file:, then we MUST have a host,
     * and if there was a path
     * to begin with, then we MUST have a path.
     * if it is file:, then the host is dropped,
     * because that's known to be hostless.
     * anything else is assumed to be absolute.
     */
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift())) { }
      if (!relative.host) { relative.host = ''; }
      if (!relative.hostname) { relative.hostname = ''; }
      if (relPath[0] !== '') { relPath.unshift(''); }
      if (relPath.length < 2) { relPath.unshift(''); }
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),
    removeAllDots = mustEndAbs,
    srcPath = result.pathname && result.pathname.split('/') || [],
    relPath = relative.pathname && relative.pathname.split('/') || [],
    psychotic = result.protocol && !slashedProtocol[result.protocol];

  /*
   * if the url is a non-slashed url, then relative
   * links like ../.. should be able
   * to crawl up to the hostname, as well.  This is strange.
   * result.protocol has already been set by now.
   * Later on, put the first path part into the host field.
   */
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    /*
     * it's relative
     * throw away the existing file, and take the new path instead.
     */
    if (!srcPath) { srcPath = []; }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    /*
     * just pull out the search.
     * like href='?foo'.
     * Put this after the other two cases because it simplifies the booleans
     */
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      /*
       * occationaly the auth can get stuck only in host
       * this especially happens in cases like
       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
       */
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    // to support http.request
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    /*
     * no path at all.  easy.
     * we've already handled the other stuff above.
     */
    result.pathname = null;
    // to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  /*
   * if a url ENDs in . or .., then it must get a trailing slash.
   * however, if it ends in anything else non-slashy,
   * then it must NOT get a trailing slash.
   */
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

  /*
   * strip single dots, resolve double dots to parent dir
   * if the path tries to go above the root, `up` ends up > 0
   */
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
    result.host = result.hostname;
    /*
     * occationaly the auth can get stuck only in host
     * this especially happens in cases like
     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
     */
    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (srcPath.length > 0) {
    result.pathname = srcPath.join('/');
  } else {
    result.pathname = null;
    result.path = null;
  }

  // to support request.http
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;


/***/ }),

/***/ "?4f7e":
/*!********************************!*\
  !*** ./util.inspect (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
const SeaController_1 = __webpack_require__(/*! ./controllers/SeaController */ "./src/controllers/SeaController.ts");
window.onload = () => {
    const appRender = new SeaController_1.SeaController();
    appRender.start();
};

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxzQkFBc0I7QUFDM0UsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRCxzQkFBc0I7QUFDdEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxT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QUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QixhQUFhLFFBQVE7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdXJCQUF1ckI7QUFDdnJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRFQUE0RTtBQUN6RjtBQUNBLDJCQUEyQix1QkFBdUI7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDO0FBQ3RDOzs7Ozs7Ozs7Ozs7QUMzRWE7QUFDYixnQkFBZ0IsbUJBQU8sQ0FBQyxvRUFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxzQkFBc0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0Isb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0JBQXNCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDOztBQUU3Qyx3REFBd0Q7QUFDeEQsd0RBQXdEO0FBQ3hELHdEQUF3RDtBQUN4RCx3REFBd0Q7O0FBRXhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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QUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7OztBQ3ROQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxtQkFBbUIsS0FBMEI7QUFDN0M7QUFDQSxrQkFBa0IsS0FBeUI7QUFDM0M7QUFDQSx5QkFBeUIscUJBQU0sZ0JBQWdCLHFCQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQWdFO0FBQ3JGLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUNBO1dBQ0E7V0FDQTs7Ozs7Ozs7Ozs7O0FDSmE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLG1CQUFPLENBQUMsdUVBQTZCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hY2Nlc3NpYmlsaXR5L2xpYi9BY2Nlc3NpYmlsaXR5TWFuYWdlci5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2FjY2Vzc2liaWxpdHkvbGliL2FjY2Vzc2libGVUYXJnZXQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hY2Nlc3NpYmlsaXR5L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2FwcC9saWIvQXBwbGljYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hcHAvbGliL1Jlc2l6ZVBsdWdpbi5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2FwcC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL0Fzc2V0RXh0ZW5zaW9uLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9Bc3NldHMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL0JhY2tncm91bmRMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2NhY2hlL0NhY2hlLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9jYWNoZS9DYWNoZVBhcnNlci5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvY2FjaGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2NhY2hlL3BhcnNlcnMvY2FjaGVUZXh0dXJlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2NhY2hlL3BhcnNlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2RldGVjdGlvbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RBdmlmLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9kZXRlY3Rpb25zL3BhcnNlcnMvZGV0ZWN0RGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RNcDQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RPZ3YuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RXZWJtLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9kZXRlY3Rpb25zL3BhcnNlcnMvZGV0ZWN0V2VicC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvZGV0ZWN0aW9ucy9wYXJzZXJzL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9kZXRlY3Rpb25zL3V0aWxzL3Rlc3RJbWFnZUZvcm1hdC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvZGV0ZWN0aW9ucy91dGlscy90ZXN0VmlkZW9Gb3JtYXQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvTG9hZGVyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL0xvYWRlclBhcnNlci5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvV29ya2VyTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL2xvYWRKc29uLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy9sb2FkVHh0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy9sb2FkV2ViRm9udC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRTVkcuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRUZXh0dXJlcy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFZpZGVvLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy91dGlscy9jcmVhdGVUZXh0dXJlLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy91dGlscy9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvcmVzb2x2ZXIvUmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3Jlc29sdmVyL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9yZXNvbHZlci9wYXJzZXJzL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9yZXNvbHZlci9wYXJzZXJzL3Jlc29sdmVUZXh0dXJlVXJsLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9yZXNvbHZlci90eXBlcy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3V0aWxzL2NoZWNrRGF0YVVybC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvdXRpbHMvY2hlY2tFeHRlbnNpb24uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3V0aWxzL2NvbnZlcnRUb0xpc3QuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3V0aWxzL2NvcHlTZWFyY2hQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3V0aWxzL2NyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3V0aWxzL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi91dGlscy9pc1NpbmdsZUl0ZW0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb2xvci9saWIvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb2xvci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb2xvcmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb2xvcmQvcGx1Z2lucy9uYW1lcy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL2NvbnN0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9sb2FkZXJzL2NvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL2xvYWRlcnMvZGV0ZWN0Q29tcHJlc3NlZFRleHR1cmVzLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvbG9hZGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL2xvYWRlcnMvbG9hZEREUy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL2xvYWRlcnMvbG9hZEtUWC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL2xvYWRlcnMvcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvcGFyc2Vycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3BhcnNlcnMvcGFyc2VERFMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9wYXJzZXJzL3BhcnNlS1RYLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvcmVzb3VyY2VzL0Jsb2JSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3Jlc291cmNlcy9Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvcmVzb3VyY2VzL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29uc3RhbnRzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL0lSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL1JlbmRlcmVyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYXV0b0RldGVjdFJlbmRlcmVyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmFja2dyb3VuZC9CYWNrZ3JvdW5kU3lzdGVtLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvQmF0Y2hEcmF3Q2FsbC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL0JhdGNoR2VvbWV0cnkuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC9CYXRjaFJlbmRlcmVyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvQmF0Y2hTaGFkZXJHZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC9CYXRjaFN5c3RlbS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL0JhdGNoVGV4dHVyZUFycmF5LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvT2JqZWN0UmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC9jYW5VcGxvYWRTYW1lQnVmZmVyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvbWF4UmVjb21tZW5kZWRUZXh0dXJlcy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL3RleHR1cmUuZnJhZy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL3RleHR1cmUudmVydC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2NvbnRleHQvQ29udGV4dFN5c3RlbS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvRmlsdGVyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZmlsdGVycy9GaWx0ZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvRmlsdGVyU3lzdGVtLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZmlsdGVycy9JRmlsdGVyVGFyZ2V0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZmlsdGVycy9kZWZhdWx0RmlsdGVyLmZyYWcuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9maWx0ZXJzL2RlZmF1bHRGaWx0ZXIudmVydC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvc3ByaXRlTWFzay9TcHJpdGVNYXNrRmlsdGVyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZmlsdGVycy9zcHJpdGVNYXNrL3Nwcml0ZU1hc2tGaWx0ZXIuZnJhZy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvc3ByaXRlTWFzay9zcHJpdGVNYXNrRmlsdGVyLnZlcnQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFnbWVudHMvZGVmYXVsdC52ZXJ0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZnJhZ21lbnRzL2RlZmF1bHRGaWx0ZXIudmVydC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZyYWdtZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZyYW1lYnVmZmVyL0ZyYW1lYnVmZmVyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZnJhbWVidWZmZXIvRnJhbWVidWZmZXJTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFtZWJ1ZmZlci9HTEZyYW1lYnVmZmVyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZnJhbWVidWZmZXIvTXVsdGlzYW1wbGVTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9BdHRyaWJ1dGUuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9CdWZmZXIuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9CdWZmZXJTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9HTEJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2dlb21ldHJ5L0dlb21ldHJ5LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZ2VvbWV0cnkvR2VvbWV0cnlTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9WaWV3YWJsZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2dlb21ldHJ5L3V0aWxzL2ludGVybGVhdmVUeXBlZEFycmF5cy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9BYnN0cmFjdE1hc2tTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9tYXNrL01hc2tEYXRhLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9NYXNrU3lzdGVtLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9TY2lzc29yU3lzdGVtLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9TdGVuY2lsU3lzdGVtLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvcGx1Z2luL1BsdWdpblN5c3RlbS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3Byb2plY3Rpb24vUHJvamVjdGlvblN5c3RlbS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3JlbmRlclRleHR1cmUvQmFzZVJlbmRlclRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9yZW5kZXJUZXh0dXJlL0dlbmVyYXRlVGV4dHVyZVN5c3RlbS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3JlbmRlclRleHR1cmUvUmVuZGVyVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3JlbmRlclRleHR1cmUvUmVuZGVyVGV4dHVyZVBvb2wuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9yZW5kZXJUZXh0dXJlL1JlbmRlclRleHR1cmVTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9yZW5kZXIvT2JqZWN0UmVuZGVyZXJTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci9HTFByb2dyYW0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvUHJvZ3JhbS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci9TaGFkZXIuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvU2hhZGVyU3lzdGVtLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL1VuaWZvcm1Hcm91cC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci9kZWZhdWx0UHJvZ3JhbS5mcmFnLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL2RlZmF1bHRQcm9ncmFtLnZlcnQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlci5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9jb21waWxlU2hhZGVyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2RlZmF1bHRWYWx1ZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZW5lcmF0ZVByb2dyYW0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZW5lcmF0ZVVuaWZvcm1zU3luYy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZXRBdHRyaWJ1dGVEYXRhLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2dldE1heEZyYWdtZW50UHJlY2lzaW9uLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2dldFRlc3RDb250ZXh0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2dldFVuaWZvcm1EYXRhLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2xvZ1Byb2dyYW1FcnJvci5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9tYXBTaXplLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL21hcFR5cGUuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvc2V0UHJlY2lzaW9uLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL3VuaWZvcm1QYXJzZXJzLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL3Vuc2FmZUV2YWxTdXBwb3J0ZWQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zdGFydHVwL1N0YXJ0dXBTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zdGF0ZS9TdGF0ZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3N0YXRlL1N0YXRlU3lzdGVtLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc3RhdGUvdXRpbHMvbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc3lzdGVtL0lTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zeXN0ZW0vU3lzdGVtTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3N5c3RlbXMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9CYXNlVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL0dMVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL1RleHR1cmUuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9UZXh0dXJlR0NTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9UZXh0dXJlTWF0cml4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvVGV4dHVyZVN5c3RlbS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL1RleHR1cmVVdnMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9yZXNvdXJjZXMvQWJzdHJhY3RNdWx0aVJlc291cmNlLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0FycmF5UmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9yZXNvdXJjZXMvQmFzZUltYWdlUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9yZXNvdXJjZXMvQnVmZmVyUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9yZXNvdXJjZXMvQ2FudmFzUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9yZXNvdXJjZXMvQ3ViZVJlc291cmNlLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0ltYWdlQml0bWFwUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9yZXNvdXJjZXMvSW1hZ2VSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9SZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9TVkdSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9WaWRlb1Jlc291cmNlLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL2F1dG9EZXRlY3RSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3V0aWxzL21hcEludGVybmFsRm9ybWF0VG9TYW1wbGVyVHlwZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3V0aWxzL21hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdHJhbnNmb3JtRmVlZGJhY2svVHJhbnNmb3JtRmVlZGJhY2suanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90cmFuc2Zvcm1GZWVkYmFjay9UcmFuc2Zvcm1GZWVkYmFja1N5c3RlbS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3V0aWxzL1F1YWQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi91dGlscy9RdWFkVXYuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi92aWV3L1ZpZXdTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9kaXNwbGF5L2xpYi9Cb3VuZHMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9kaXNwbGF5L2xpYi9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9kaXNwbGF5L2xpYi9EaXNwbGF5T2JqZWN0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZGlzcGxheS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9kaXNwbGF5L2xpYi9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2V2ZW50cy9saWIvRXZlbnRCb3VuZGFyeS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2V2ZW50cy9saWIvRXZlbnRTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL0V2ZW50VGlja2VyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9GZWRlcmF0ZWRFdmVudC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2V2ZW50cy9saWIvRmVkZXJhdGVkRXZlbnRNYXAuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL0ZlZGVyYXRlZEV2ZW50VGFyZ2V0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9GZWRlcmF0ZWRNb3VzZUV2ZW50LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9GZWRlcmF0ZWRQb2ludGVyRXZlbnQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL0ZlZGVyYXRlZFdoZWVsRXZlbnQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZXh0ZW5zaW9ucy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9leHRyYWN0L2xpYi9FeHRyYWN0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZXh0cmFjdC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItYWxwaGEvbGliL0FscGhhRmlsdGVyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWFscGhhL2xpYi9hbHBoYS5mcmFnLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWFscGhhL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1ibHVyL2xpYi9CbHVyRmlsdGVyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWJsdXIvbGliL0JsdXJGaWx0ZXJQYXNzLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWJsdXIvbGliL2dlbmVyYXRlQmx1ckZyYWdTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItYmx1ci9saWIvZ2VuZXJhdGVCbHVyVmVydFNvdXJjZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1ibHVyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1jb2xvci1tYXRyaXgvbGliL0NvbG9yTWF0cml4RmlsdGVyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWNvbG9yLW1hdHJpeC9saWIvY29sb3JNYXRyaXguZnJhZy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1jb2xvci1tYXRyaXgvbGliL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWRpc3BsYWNlbWVudC9saWIvRGlzcGxhY2VtZW50RmlsdGVyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWRpc3BsYWNlbWVudC9saWIvZGlzcGxhY2VtZW50LmZyYWcuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItZGlzcGxhY2VtZW50L2xpYi9kaXNwbGFjZW1lbnQudmVydC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1kaXNwbGFjZW1lbnQvbGliL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWZ4YWEvbGliL0ZYQUFGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItZnhhYS9saWIvZnhhYS5mcmFnLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWZ4YWEvbGliL2Z4YWEudmVydC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1meGFhL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1ub2lzZS9saWIvTm9pc2VGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItbm9pc2UvbGliL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLW5vaXNlL2xpYi9ub2lzZS5mcmFnLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL0dyYXBoaWNzLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL0dyYXBoaWNzRGF0YS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi9HcmFwaGljc0dlb21ldHJ5LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL2NvbnN0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3N0eWxlcy9GaWxsU3R5bGUuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvc3R5bGVzL0xpbmVTdHlsZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9BcmNVdGlscy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9CYXRjaFBhcnQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvQmV6aWVyVXRpbHMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvUXVhZHJhdGljVXRpbHMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvYnVpbGRDaXJjbGUuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvYnVpbGRMaW5lLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3V0aWxzL2J1aWxkUG9seS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9idWlsZFJlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9idWlsZFJvdW5kZWRSZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9JUG9pbnQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9JUG9pbnREYXRhLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvTWF0cml4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvT2JzZXJ2YWJsZVBvaW50LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9UcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9jb25zdC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL2dyb3VwRDguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL3NoYXBlcy9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9zaGFwZXMvRWxsaXBzZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL3NoYXBlcy9Qb2x5Z29uLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvc2hhcGVzL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL3NoYXBlcy9Sb3VuZGVkUmVjdGFuZ2xlLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL05pbmVTbGljZVBsYW5lLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL1NpbXBsZU1lc2guanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoLWV4dHJhcy9saWIvU2ltcGxlUGxhbmUuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoLWV4dHJhcy9saWIvU2ltcGxlUm9wZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gtZXh0cmFzL2xpYi9nZW9tZXRyeS9QbGFuZUdlb21ldHJ5LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL2dlb21ldHJ5L1JvcGVHZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gtZXh0cmFzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gvbGliL01lc2guanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoL2xpYi9NZXNoQmF0Y2hVdnMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoL2xpYi9NZXNoR2VvbWV0cnkuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoL2xpYi9NZXNoTWF0ZXJpYWwuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gvbGliL3NoYWRlci9tZXNoLmZyYWcuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoL2xpYi9zaGFkZXIvbWVzaC52ZXJ0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvbWl4aW4tY2FjaGUtYXMtYml0bWFwL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21peGluLWdldC1jaGlsZC1ieS1uYW1lL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21peGluLWdldC1nbG9iYWwtcG9zaXRpb24vbGliL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvcGFydGljbGUtY29udGFpbmVyL2xpYi9QYXJ0aWNsZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3BhcnRpY2xlLWNvbnRhaW5lci9saWIvUGFydGljbGVDb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9wYXJ0aWNsZS1jb250YWluZXIvbGliL1BhcnRpY2xlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9wYXJ0aWNsZS1jb250YWluZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvcGFydGljbGUtY29udGFpbmVyL2xpYi9wYXJ0aWNsZXMuZnJhZy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3BhcnRpY2xlLWNvbnRhaW5lci9saWIvcGFydGljbGVzLnZlcnQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9wcmVwYXJlL2xpYi9CYXNlUHJlcGFyZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3ByZXBhcmUvbGliL0NvdW50TGltaXRlci5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3ByZXBhcmUvbGliL1ByZXBhcmUuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9wcmVwYXJlL2xpYi9UaW1lTGltaXRlci5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3ByZXBhcmUvbGliL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvcHJlcGFyZS9saWIvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9ydW5uZXIvbGliL1J1bm5lci5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3J1bm5lci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9zZXR0aW5ncy9saWIvSUNhbnZhcy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3NldHRpbmdzL2xpYi9JQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvc2V0dGluZ3MvbGliL2FkYXB0ZXIuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9zZXR0aW5ncy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9zZXR0aW5ncy9saWIvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9zZXR0aW5ncy9saWIvdXRpbHMvaXNNb2JpbGUuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtYW5pbWF0ZWQvbGliL0FuaW1hdGVkU3ByaXRlLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLWFuaW1hdGVkL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZS10aWxpbmcvbGliL1RpbGluZ1Nwcml0ZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZS10aWxpbmcvbGliL1RpbGluZ1Nwcml0ZVJlbmRlcmVyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtdGlsaW5nL2xpYi9zcHJpdGUtdGlsaW5nLWZhbGxiYWNrLmZyYWcuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtdGlsaW5nL2xpYi9zcHJpdGUtdGlsaW5nLWZhbGxiYWNrLnZlcnQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtdGlsaW5nL2xpYi9zcHJpdGUtdGlsaW5nLXNpbXBsZS5mcmFnLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvc3ByaXRlLXRpbGluZy5mcmFnLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvc3ByaXRlLXRpbGluZy52ZXJ0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlL2xpYi9TcHJpdGUuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUvbGliL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlc2hlZXQvbGliL1Nwcml0ZXNoZWV0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlc2hlZXQvbGliL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlc2hlZXQvbGliL3Nwcml0ZXNoZWV0QXNzZXQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvQml0bWFwRm9udC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9CaXRtYXBGb250RGF0YS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9CaXRtYXBUZXh0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL0JpdG1hcFRleHRTdHlsZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9mb3JtYXRzL1RleHRGb3JtYXQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvZm9ybWF0cy9YTUxGb3JtYXQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvZm9ybWF0cy9YTUxTdHJpbmdGb3JtYXQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvZm9ybWF0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9sb2FkQml0bWFwRm9udC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9zaGFkZXIvbXNkZi5mcmFnLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL3NoYWRlci9tc2RmLnZlcnQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvdXRpbHMvZHJhd0dseXBoLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL3V0aWxzL2V4dHJhY3RDaGFyQ29kZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi91dGlscy9nZW5lcmF0ZUZpbGxTdHlsZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi91dGlscy9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi91dGlscy9yZXNvbHZlQ2hhcmFjdGVycy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi91dGlscy9zcGxpdFRleHRUb0NoYXJhY3RlcnMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWh0bWwvbGliL0hUTUxUZXh0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1odG1sL2xpYi9IVE1MVGV4dFN0eWxlLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1odG1sL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQvbGliL1RleHQuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0L2xpYi9UZXh0TWV0cmljcy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQvbGliL1RleHRTdHlsZS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQvbGliL2NvbnN0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS90aWNrZXIvbGliL1RpY2tlci5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RpY2tlci9saWIvVGlja2VyTGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS90aWNrZXIvbGliL1RpY2tlclBsdWdpbi5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RpY2tlci9saWIvY29uc3QuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS90aWNrZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdGlja2VyL2xpYi9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9icm93c2VyL2RldGVjdFZpZGVvQWxwaGFNb2RlLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2Jyb3dzZXIvaGVsbG8uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvYnJvd3Nlci9pc1dlYkdMU3VwcG9ydGVkLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2NvbG9yL2hleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9jb2xvci9wcmVtdWx0aXBseS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9jb25zdC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9kYXRhL2NyZWF0ZUluZGljZXNGb3JRdWFkcy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9kYXRhL2dldEJ1ZmZlclR5cGUuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvZGF0YS9pbnRlcmxlYXZlVHlwZWRBcnJheXMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvZGF0YS9wb3cyLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2RhdGEvcmVtb3ZlSXRlbXMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvZGF0YS9zaWduLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2RhdGEvdWlkLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2xvZ2dpbmcvZGVwcmVjYXRpb24uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvbWVkaWEvQm91bmRpbmdCb3guanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvbWVkaWEvQ2FudmFzUmVuZGVyVGFyZ2V0LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL21lZGlhL2NhY2hlcy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9tZWRpYS9nZXRDYW52YXNCb3VuZGluZ0JveC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9tZWRpYS90cmltQ2FudmFzLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL25ldHdvcmsvZGVjb21wb3NlRGF0YVVyaS5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9uZXR3b3JrL2RldGVybWluZUNyb3NzT3JpZ2luLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL25ldHdvcmsvZ2V0UmVzb2x1dGlvbk9mVXJsLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL3BhdGguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvdXJsLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvQHR3ZWVuanMvdHdlZW4uanMvZGlzdC90d2Vlbi5lc20uanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvZGVmaW5lLWRhdGEtcHJvcGVydHkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9lYXJjdXQvc3JjL2VhcmN1dC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9nb3BkL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvaGFzLXByb3BlcnR5LWRlc2NyaXB0b3JzL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvaGFzLXByb3RvL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9zaGFtcy5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL2hhc293bi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL2lzbW9iaWxlanMvZXNtL2luZGV4LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvaXNtb2JpbGVqcy9lc20vaXNNb2JpbGUuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9vYmplY3QtaW5zcGVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2ZpbHRlcnMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvcXMvbGliL2Zvcm1hdHMuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9xcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9xcy9saWIvcGFyc2UuanMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL25vZGVfbW9kdWxlcy9xcy9saWIvc3RyaW5naWZ5LmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvcXMvbGliL3V0aWxzLmpzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvc2V0LWZ1bmN0aW9uLWxlbmd0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vbm9kZV9tb2R1bGVzL3NpZGUtY2hhbm5lbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vc3JjL2NvbnRyb2xsZXJzL1BvcnRDb250cm9sbGVyLnRzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9zcmMvY29udHJvbGxlcnMvUXVldWVNYW5hZ2VyLnRzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9zcmMvY29udHJvbGxlcnMvU2VhQ29udHJvbGxlci50cyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vc3JjL2NvbnRyb2xsZXJzL1NoaXBDb250cm9sbGVyLnRzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9zcmMvbW9kZWxzL0RvY2sudHMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL3NyYy9tb2RlbHMvUG9ydC50cyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vc3JjL21vZGVscy9TaGlwLnRzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9zcmMvdXRpbHMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC8uL3NyYy92aWV3cy9Eb2NrVmlldy50cyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vc3JjL3ZpZXdzL1BvcnRWaWV3LnRzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9zcmMvdmlld3MvU2VhVmlldy50cyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwLy4vc3JjL3ZpZXdzL1NoaXBWaWV3LnRzIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwL2lnbm9yZWR8QzpcXHZpdGFsaWk1MDVcXG15X3Byb2dlY3RzXFxpR2VtaW5nLXByb2plY3RzXFxzZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwXFxub2RlX21vZHVsZXNcXG9iamVjdC1pbnNwZWN0fC4vdXRpbC5pbnNwZWN0Iiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9zZWFwb3J0LXZpc3VhbGl6ZXItdHMtYXBwL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vc2VhcG9ydC12aXN1YWxpemVyLXRzLWFwcC93ZWJwYWNrL3J1bnRpbWUvbm9kZSBtb2R1bGUgZGVjb3JhdG9yIiwid2VicGFjazovL3NlYXBvcnQtdmlzdWFsaXplci10cy1hcHAvLi9zcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCBkaXNwbGF5ID0gcmVxdWlyZShcIkBwaXhpL2Rpc3BsYXlcIiksIGV2ZW50cyA9IHJlcXVpcmUoXCJAcGl4aS9ldmVudHNcIiksIGFjY2Vzc2libGVUYXJnZXQgPSByZXF1aXJlKFwiLi9hY2Nlc3NpYmxlVGFyZ2V0LmpzXCIpO1xuZGlzcGxheS5EaXNwbGF5T2JqZWN0Lm1peGluKGFjY2Vzc2libGVUYXJnZXQuYWNjZXNzaWJsZVRhcmdldCk7XG5jb25zdCBLRVlfQ09ERV9UQUIgPSA5LCBESVZfVE9VQ0hfU0laRSA9IDEwMCwgRElWX1RPVUNIX1BPU19YID0gMCwgRElWX1RPVUNIX1BPU19ZID0gMCwgRElWX1RPVUNIX1pJTkRFWCA9IDIsIERJVl9IT09LX1NJWkUgPSAxLCBESVZfSE9PS19QT1NfWCA9IC0xZTMsIERJVl9IT09LX1BPU19ZID0gLTFlMywgRElWX0hPT0tfWklOREVYID0gMjtcbmNsYXNzIEFjY2Vzc2liaWxpdHlNYW5hZ2VyIHtcbiAgLy8gMmZwc1xuICAvKipcbiAgICogQHBhcmFtIHtQSVhJLkNhbnZhc1JlbmRlcmVyfFBJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcmVuZGVyZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5kZWJ1ZyA9ICExLCB0aGlzLl9pc0FjdGl2ZSA9ICExLCB0aGlzLl9pc01vYmlsZUFjY2Vzc2liaWxpdHkgPSAhMSwgdGhpcy5wb29sID0gW10sIHRoaXMucmVuZGVySWQgPSAwLCB0aGlzLmNoaWxkcmVuID0gW10sIHRoaXMuYW5kcm9pZFVwZGF0ZUNvdW50ID0gMCwgdGhpcy5hbmRyb2lkVXBkYXRlRnJlcXVlbmN5ID0gNTAwLCB0aGlzLl9ob29rRGl2ID0gbnVsbCwgKGNvcmUudXRpbHMuaXNNb2JpbGUudGFibGV0IHx8IGNvcmUudXRpbHMuaXNNb2JpbGUucGhvbmUpICYmIHRoaXMuY3JlYXRlVG91Y2hIb29rKCk7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUud2lkdGggPSBgJHtESVZfVE9VQ0hfU0laRX1weGAsIGRpdi5zdHlsZS5oZWlnaHQgPSBgJHtESVZfVE9VQ0hfU0laRX1weGAsIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgZGl2LnN0eWxlLnRvcCA9IGAke0RJVl9UT1VDSF9QT1NfWH1weGAsIGRpdi5zdHlsZS5sZWZ0ID0gYCR7RElWX1RPVUNIX1BPU19ZfXB4YCwgZGl2LnN0eWxlLnpJbmRleCA9IERJVl9UT1VDSF9aSU5ERVgudG9TdHJpbmcoKSwgdGhpcy5kaXYgPSBkaXYsIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlciwgdGhpcy5fb25LZXlEb3duID0gdGhpcy5fb25LZXlEb3duLmJpbmQodGhpcyksIHRoaXMuX29uTW91c2VNb3ZlID0gdGhpcy5fb25Nb3VzZU1vdmUuYmluZCh0aGlzKSwgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9vbktleURvd24sICExKTtcbiAgfVxuICAvKipcbiAgICogVmFsdWUgb2YgYHRydWVgIGlmIGFjY2Vzc2liaWxpdHkgaXMgY3VycmVudGx5IGFjdGl2ZSBhbmQgYWNjZXNzaWJpbGl0eSBsYXllcnMgYXJlIHNob3dpbmcuXG4gICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0FjdGl2ZTtcbiAgfVxuICAvKipcbiAgICogVmFsdWUgb2YgYHRydWVgIGlmIGFjY2Vzc2liaWxpdHkgaXMgZW5hYmxlZCBmb3IgdG91Y2ggZGV2aWNlcy5cbiAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgaXNNb2JpbGVBY2Nlc3NpYmlsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9pc01vYmlsZUFjY2Vzc2liaWxpdHk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIHRvdWNoIGhvb2tzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlVG91Y2hIb29rKCkge1xuICAgIGNvbnN0IGhvb2tEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGhvb2tEaXYuc3R5bGUud2lkdGggPSBgJHtESVZfSE9PS19TSVpFfXB4YCwgaG9va0Rpdi5zdHlsZS5oZWlnaHQgPSBgJHtESVZfSE9PS19TSVpFfXB4YCwgaG9va0Rpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgaG9va0Rpdi5zdHlsZS50b3AgPSBgJHtESVZfSE9PS19QT1NfWH1weGAsIGhvb2tEaXYuc3R5bGUubGVmdCA9IGAke0RJVl9IT09LX1BPU19ZfXB4YCwgaG9va0Rpdi5zdHlsZS56SW5kZXggPSBESVZfSE9PS19aSU5ERVgudG9TdHJpbmcoKSwgaG9va0Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiNGRjAwMDBcIiwgaG9va0Rpdi50aXRsZSA9IFwic2VsZWN0IHRvIGVuYWJsZSBhY2Nlc3NpYmlsaXR5IGZvciB0aGlzIGNvbnRlbnRcIiwgaG9va0Rpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5faXNNb2JpbGVBY2Nlc3NpYmlsaXR5ID0gITAsIHRoaXMuYWN0aXZhdGUoKSwgdGhpcy5kZXN0cm95VG91Y2hIb29rKCk7XG4gICAgfSksIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaG9va0RpdiksIHRoaXMuX2hvb2tEaXYgPSBob29rRGl2O1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgdG91Y2ggaG9va3MuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXN0cm95VG91Y2hIb29rKCkge1xuICAgIHRoaXMuX2hvb2tEaXYgJiYgKGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5faG9va0RpdiksIHRoaXMuX2hvb2tEaXYgPSBudWxsKTtcbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGluZyB3aWxsIGNhdXNlIHRoZSBBY2Nlc3NpYmlsaXR5IGxheWVyIHRvIGJlIHNob3duLlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIGEgdXNlciBwcmVzc2VzIHRoZSB0YWIga2V5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5faXNBY3RpdmUgfHwgKHRoaXMuX2lzQWN0aXZlID0gITAsIGdsb2JhbFRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSwgITApLCBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93biwgITEpLCB0aGlzLnJlbmRlcmVyLm9uKFwicG9zdHJlbmRlclwiLCB0aGlzLnVwZGF0ZSwgdGhpcyksIHRoaXMucmVuZGVyZXIudmlldy5wYXJlbnROb2RlPy5hcHBlbmRDaGlsZCh0aGlzLmRpdikpO1xuICB9XG4gIC8qKlxuICAgKiBEZWFjdGl2YXRpbmcgd2lsbCBjYXVzZSB0aGUgQWNjZXNzaWJpbGl0eSBsYXllciB0byBiZSBoaWRkZW4uXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gYSB1c2VyIG1vdmVzIHRoZSBtb3VzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgIXRoaXMuX2lzQWN0aXZlIHx8IHRoaXMuX2lzTW9iaWxlQWNjZXNzaWJpbGl0eSB8fCAodGhpcy5faXNBY3RpdmUgPSAhMSwgZ2xvYmFsVGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlLCAhMCksIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fb25LZXlEb3duLCAhMSksIHRoaXMucmVuZGVyZXIub2ZmKFwicG9zdHJlbmRlclwiLCB0aGlzLnVwZGF0ZSksIHRoaXMuZGl2LnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKHRoaXMuZGl2KSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgcmVjdXJzaXZlIGZ1bmN0aW9uIHdpbGwgcnVuIHRocm91Z2ggdGhlIHNjZW5lIGdyYXBoIGFuZCBhZGQgYW55IG5ldyBhY2Nlc3NpYmxlIG9iamVjdHMgdG8gdGhlIERPTSBsYXllci5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtQSVhJLkNvbnRhaW5lcn0gZGlzcGxheU9iamVjdCAtIFRoZSBEaXNwbGF5T2JqZWN0IHRvIGNoZWNrLlxuICAgKi9cbiAgdXBkYXRlQWNjZXNzaWJsZU9iamVjdHMoZGlzcGxheU9iamVjdCkge1xuICAgIGlmICghZGlzcGxheU9iamVjdC52aXNpYmxlIHx8ICFkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVDaGlsZHJlbilcbiAgICAgIHJldHVybjtcbiAgICBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGUgJiYgZGlzcGxheU9iamVjdC5pc0ludGVyYWN0aXZlKCkgJiYgKGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVBY3RpdmUgfHwgdGhpcy5hZGRDaGlsZChkaXNwbGF5T2JqZWN0KSwgZGlzcGxheU9iamVjdC5yZW5kZXJJZCA9IHRoaXMucmVuZGVySWQpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4pXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzLnVwZGF0ZUFjY2Vzc2libGVPYmplY3RzKGNoaWxkcmVuW2ldKTtcbiAgfVxuICAvKipcbiAgICogQmVmb3JlIGVhY2ggcmVuZGVyIHRoaXMgZnVuY3Rpb24gd2lsbCBlbnN1cmUgdGhhdCBhbGwgZGl2cyBhcmUgbWFwcGVkIGNvcnJlY3RseSB0byB0aGVpciBEaXNwbGF5T2JqZWN0cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoY29yZS51dGlscy5pc01vYmlsZS5hbmRyb2lkLmRldmljZSAmJiBub3cgPCB0aGlzLmFuZHJvaWRVcGRhdGVDb3VudCB8fCAodGhpcy5hbmRyb2lkVXBkYXRlQ291bnQgPSBub3cgKyB0aGlzLmFuZHJvaWRVcGRhdGVGcmVxdWVuY3ksICF0aGlzLnJlbmRlcmVyLnJlbmRlcmluZ1RvU2NyZWVuKSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZCAmJiB0aGlzLnVwZGF0ZUFjY2Vzc2libGVPYmplY3RzKHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkKTtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMucmVuZGVyZXIudmlldy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgeyB3aWR0aDogdmlld1dpZHRoLCBoZWlnaHQ6IHZpZXdIZWlnaHQsIHJlc29sdXRpb24gfSA9IHRoaXMucmVuZGVyZXIsIHN4ID0gd2lkdGggLyB2aWV3V2lkdGggKiByZXNvbHV0aW9uLCBzeSA9IGhlaWdodCAvIHZpZXdIZWlnaHQgKiByZXNvbHV0aW9uO1xuICAgIGxldCBkaXYgPSB0aGlzLmRpdjtcbiAgICBkaXYuc3R5bGUubGVmdCA9IGAke3h9cHhgLCBkaXYuc3R5bGUudG9wID0gYCR7eX1weGAsIGRpdi5zdHlsZS53aWR0aCA9IGAke3ZpZXdXaWR0aH1weGAsIGRpdi5zdHlsZS5oZWlnaHQgPSBgJHt2aWV3SGVpZ2h0fXB4YDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC5yZW5kZXJJZCAhPT0gdGhpcy5yZW5kZXJJZClcbiAgICAgICAgY2hpbGQuX2FjY2Vzc2libGVBY3RpdmUgPSAhMSwgY29yZS51dGlscy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBpLCAxKSwgdGhpcy5kaXYucmVtb3ZlQ2hpbGQoY2hpbGQuX2FjY2Vzc2libGVEaXYpLCB0aGlzLnBvb2wucHVzaChjaGlsZC5fYWNjZXNzaWJsZURpdiksIGNoaWxkLl9hY2Nlc3NpYmxlRGl2ID0gbnVsbCwgaS0tO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGRpdiA9IGNoaWxkLl9hY2Nlc3NpYmxlRGl2O1xuICAgICAgICBsZXQgaGl0QXJlYSA9IGNoaWxkLmhpdEFyZWE7XG4gICAgICAgIGNvbnN0IHd0ID0gY2hpbGQud29ybGRUcmFuc2Zvcm07XG4gICAgICAgIGNoaWxkLmhpdEFyZWEgPyAoZGl2LnN0eWxlLmxlZnQgPSBgJHsod3QudHggKyBoaXRBcmVhLnggKiB3dC5hKSAqIHN4fXB4YCwgZGl2LnN0eWxlLnRvcCA9IGAkeyh3dC50eSArIGhpdEFyZWEueSAqIHd0LmQpICogc3l9cHhgLCBkaXYuc3R5bGUud2lkdGggPSBgJHtoaXRBcmVhLndpZHRoICogd3QuYSAqIHN4fXB4YCwgZGl2LnN0eWxlLmhlaWdodCA9IGAke2hpdEFyZWEuaGVpZ2h0ICogd3QuZCAqIHN5fXB4YCkgOiAoaGl0QXJlYSA9IGNoaWxkLmdldEJvdW5kcygpLCB0aGlzLmNhcEhpdEFyZWEoaGl0QXJlYSksIGRpdi5zdHlsZS5sZWZ0ID0gYCR7aGl0QXJlYS54ICogc3h9cHhgLCBkaXYuc3R5bGUudG9wID0gYCR7aGl0QXJlYS55ICogc3l9cHhgLCBkaXYuc3R5bGUud2lkdGggPSBgJHtoaXRBcmVhLndpZHRoICogc3h9cHhgLCBkaXYuc3R5bGUuaGVpZ2h0ID0gYCR7aGl0QXJlYS5oZWlnaHQgKiBzeX1weGAsIGRpdi50aXRsZSAhPT0gY2hpbGQuYWNjZXNzaWJsZVRpdGxlICYmIGNoaWxkLmFjY2Vzc2libGVUaXRsZSAhPT0gbnVsbCAmJiAoZGl2LnRpdGxlID0gY2hpbGQuYWNjZXNzaWJsZVRpdGxlKSwgZGl2LmdldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIikgIT09IGNoaWxkLmFjY2Vzc2libGVIaW50ICYmIGNoaWxkLmFjY2Vzc2libGVIaW50ICE9PSBudWxsICYmIGRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGNoaWxkLmFjY2Vzc2libGVIaW50KSksIChjaGlsZC5hY2Nlc3NpYmxlVGl0bGUgIT09IGRpdi50aXRsZSB8fCBjaGlsZC50YWJJbmRleCAhPT0gZGl2LnRhYkluZGV4KSAmJiAoZGl2LnRpdGxlID0gY2hpbGQuYWNjZXNzaWJsZVRpdGxlLCBkaXYudGFiSW5kZXggPSBjaGlsZC50YWJJbmRleCwgdGhpcy5kZWJ1ZyAmJiB0aGlzLnVwZGF0ZURlYnVnSFRNTChkaXYpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW5kZXJJZCsrO1xuICB9XG4gIC8qKlxuICAgKiBwcml2YXRlIGZ1bmN0aW9uIHRoYXQgd2lsbCB2aXN1YWxseSBhZGQgdGhlIGluZm9ybWF0aW9uIHRvIHRoZVxuICAgKiBhY2Nlc3NhYmlsaXR5IGRpdlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaXYgLVxuICAgKi9cbiAgdXBkYXRlRGVidWdIVE1MKGRpdikge1xuICAgIGRpdi5pbm5lckhUTUwgPSBgdHlwZTogJHtkaXYudHlwZX08L2JyPiB0aXRsZSA6ICR7ZGl2LnRpdGxlfTwvYnI+IHRhYkluZGV4OiAke2Rpdi50YWJJbmRleH1gO1xuICB9XG4gIC8qKlxuICAgKiBBZGp1c3QgdGhlIGhpdCBhcmVhIGJhc2VkIG9uIHRoZSBib3VuZHMgb2YgYSBkaXNwbGF5IG9iamVjdFxuICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBoaXRBcmVhIC0gQm91bmRzIG9mIHRoZSBjaGlsZFxuICAgKi9cbiAgY2FwSGl0QXJlYShoaXRBcmVhKSB7XG4gICAgaGl0QXJlYS54IDwgMCAmJiAoaGl0QXJlYS53aWR0aCArPSBoaXRBcmVhLngsIGhpdEFyZWEueCA9IDApLCBoaXRBcmVhLnkgPCAwICYmIChoaXRBcmVhLmhlaWdodCArPSBoaXRBcmVhLnksIGhpdEFyZWEueSA9IDApO1xuICAgIGNvbnN0IHsgd2lkdGg6IHZpZXdXaWR0aCwgaGVpZ2h0OiB2aWV3SGVpZ2h0IH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIGhpdEFyZWEueCArIGhpdEFyZWEud2lkdGggPiB2aWV3V2lkdGggJiYgKGhpdEFyZWEud2lkdGggPSB2aWV3V2lkdGggLSBoaXRBcmVhLngpLCBoaXRBcmVhLnkgKyBoaXRBcmVhLmhlaWdodCA+IHZpZXdIZWlnaHQgJiYgKGhpdEFyZWEuaGVpZ2h0ID0gdmlld0hlaWdodCAtIGhpdEFyZWEueSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBEaXNwbGF5T2JqZWN0IHRvIHRoZSBhY2Nlc3NpYmlsaXR5IG1hbmFnZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGRpc3BsYXlPYmplY3QgLSBUaGUgY2hpbGQgdG8gbWFrZSBhY2Nlc3NpYmxlLlxuICAgKi9cbiAgYWRkQ2hpbGQoZGlzcGxheU9iamVjdCkge1xuICAgIGxldCBkaXYgPSB0aGlzLnBvb2wucG9wKCk7XG4gICAgZGl2IHx8IChkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpLCBkaXYuc3R5bGUud2lkdGggPSBgJHtESVZfVE9VQ0hfU0laRX1weGAsIGRpdi5zdHlsZS5oZWlnaHQgPSBgJHtESVZfVE9VQ0hfU0laRX1weGAsIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmRlYnVnID8gXCJyZ2JhKDI1NSwyNTUsMjU1LDAuNSlcIiA6IFwidHJhbnNwYXJlbnRcIiwgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiLCBkaXYuc3R5bGUuekluZGV4ID0gRElWX1RPVUNIX1pJTkRFWC50b1N0cmluZygpLCBkaXYuc3R5bGUuYm9yZGVyU3R5bGUgPSBcIm5vbmVcIiwgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiY2hyb21lXCIpID8gZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcIm9mZlwiKSA6IGRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJwb2xpdGVcIiksIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL3J2Oi4qR2Vja29cXC8vKSA/IGRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLXJlbGV2YW50XCIsIFwiYWRkaXRpb25zXCIpIDogZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtcmVsZXZhbnRcIiwgXCJ0ZXh0XCIpLCBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKSksIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5fb25Gb2N1cy5iaW5kKHRoaXMpKSwgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLl9vbkZvY3VzT3V0LmJpbmQodGhpcykpKSwgZGl2LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVQb2ludGVyRXZlbnRzLCBkaXYudHlwZSA9IGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVR5cGUsIGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVRpdGxlICYmIGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVRpdGxlICE9PSBudWxsID8gZGl2LnRpdGxlID0gZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlVGl0bGUgOiAoIWRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZUhpbnQgfHwgZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludCA9PT0gbnVsbCkgJiYgKGRpdi50aXRsZSA9IGBkaXNwbGF5T2JqZWN0ICR7ZGlzcGxheU9iamVjdC50YWJJbmRleH1gKSwgZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludCAmJiBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50ICE9PSBudWxsICYmIGRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZUhpbnQpLCB0aGlzLmRlYnVnICYmIHRoaXMudXBkYXRlRGVidWdIVE1MKGRpdiksIGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVBY3RpdmUgPSAhMCwgZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZURpdiA9IGRpdiwgZGl2LmRpc3BsYXlPYmplY3QgPSBkaXNwbGF5T2JqZWN0LCB0aGlzLmNoaWxkcmVuLnB1c2goZGlzcGxheU9iamVjdCksIHRoaXMuZGl2LmFwcGVuZENoaWxkKGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVEaXYpLCBkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlRGl2LnRhYkluZGV4ID0gZGlzcGxheU9iamVjdC50YWJJbmRleDtcbiAgfVxuICAvKipcbiAgICogRGlzcGF0Y2ggZXZlbnRzIHdpdGggdGhlIEV2ZW50U3lzdGVtLlxuICAgKiBAcGFyYW0gZVxuICAgKiBAcGFyYW0gdHlwZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rpc3BhdGNoRXZlbnQoZSwgdHlwZSkge1xuICAgIGNvbnN0IHsgZGlzcGxheU9iamVjdDogdGFyZ2V0IH0gPSBlLnRhcmdldCwgYm91bmRyeSA9IHRoaXMucmVuZGVyZXIuZXZlbnRzLnJvb3RCb3VuZGFyeSwgZXZlbnQgPSBPYmplY3QuYXNzaWduKG5ldyBldmVudHMuRmVkZXJhdGVkRXZlbnQoYm91bmRyeSksIHsgdGFyZ2V0IH0pO1xuICAgIGJvdW5kcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkLCB0eXBlLmZvckVhY2goKHR5cGUyKSA9PiBib3VuZHJ5LmRpc3BhdGNoRXZlbnQoZXZlbnQsIHR5cGUyKSk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcHMgdGhlIGRpdiBidXR0b24gcHJlc3MgdG8gcGl4aSdzIEV2ZW50U3lzdGVtIChjbGljaylcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIC0gVGhlIGNsaWNrIGV2ZW50LlxuICAgKi9cbiAgX29uQ2xpY2soZSkge1xuICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoZSwgW1wiY2xpY2tcIiwgXCJwb2ludGVydGFwXCIsIFwidGFwXCJdKTtcbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgZGl2IGZvY3VzIGV2ZW50cyB0byBwaXhpJ3MgRXZlbnRTeXN0ZW0gKG1vdXNlb3ZlcilcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGb2N1c0V2ZW50fSBlIC0gVGhlIGZvY3VzIGV2ZW50LlxuICAgKi9cbiAgX29uRm9jdXMoZSkge1xuICAgIGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiKSB8fCBlLnRhcmdldC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJhc3NlcnRpdmVcIiksIHRoaXMuX2Rpc3BhdGNoRXZlbnQoZSwgW1wibW91c2VvdmVyXCJdKTtcbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgZGl2IGZvY3VzIGV2ZW50cyB0byBwaXhpJ3MgRXZlbnRTeXN0ZW0gKG1vdXNlb3V0KVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0ZvY3VzRXZlbnR9IGUgLSBUaGUgZm9jdXNvdXQgZXZlbnQuXG4gICAqL1xuICBfb25Gb2N1c091dChlKSB7XG4gICAgZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIpIHx8IGUudGFyZ2V0LnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKSwgdGhpcy5fZGlzcGF0Y2hFdmVudChlLCBbXCJtb3VzZW91dFwiXSk7XG4gIH1cbiAgLyoqXG4gICAqIElzIGNhbGxlZCB3aGVuIGEga2V5IGlzIHByZXNzZWRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlIC0gVGhlIGtleWRvd24gZXZlbnQuXG4gICAqL1xuICBfb25LZXlEb3duKGUpIHtcbiAgICBlLmtleUNvZGUgPT09IEtFWV9DT0RFX1RBQiAmJiB0aGlzLmFjdGl2YXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIElzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBhY3Jvc3MgdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIC0gVGhlIG1vdXNlIGV2ZW50LlxuICAgKi9cbiAgX29uTW91c2VNb3ZlKGUpIHtcbiAgICBlLm1vdmVtZW50WCA9PT0gMCAmJiBlLm1vdmVtZW50WSA9PT0gMCB8fCB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIGFjY2Vzc2liaWxpdHkgbWFuYWdlciAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveVRvdWNoSG9vaygpLCB0aGlzLmRpdiA9IG51bGwsIGdsb2JhbFRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSwgITApLCBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93biksIHRoaXMucG9vbCA9IG51bGwsIHRoaXMuY2hpbGRyZW4gPSBudWxsLCB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuQWNjZXNzaWJpbGl0eU1hbmFnZXIuZXh0ZW5zaW9uID0ge1xuICBuYW1lOiBcImFjY2Vzc2liaWxpdHlcIixcbiAgdHlwZTogW1xuICAgIGNvcmUuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclBsdWdpbixcbiAgICBjb3JlLkV4dGVuc2lvblR5cGUuQ2FudmFzUmVuZGVyZXJQbHVnaW5cbiAgXVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQoQWNjZXNzaWJpbGl0eU1hbmFnZXIpO1xuZXhwb3J0cy5BY2Nlc3NpYmlsaXR5TWFuYWdlciA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWNjZXNzaWJpbGl0eU1hbmFnZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGFjY2Vzc2libGVUYXJnZXQgPSB7XG4gIC8qKlxuICAgKiAgRmxhZyBmb3IgaWYgdGhlIG9iamVjdCBpcyBhY2Nlc3NpYmxlLiBJZiB0cnVlIEFjY2Vzc2liaWxpdHlNYW5hZ2VyIHdpbGwgb3ZlcmxheSBhXG4gICAqICAgc2hhZG93IGRpdiB3aXRoIGF0dHJpYnV0ZXMgc2V0XG4gICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqL1xuICBhY2Nlc3NpYmxlOiAhMSxcbiAgLyoqXG4gICAqIFNldHMgdGhlIHRpdGxlIGF0dHJpYnV0ZSBvZiB0aGUgc2hhZG93IGRpdlxuICAgKiBJZiBhY2Nlc3NpYmxlVGl0bGUgQU5EIGFjY2Vzc2libGVIaW50IGhhcyBub3QgYmVlbiB0aGlzIHdpbGwgZGVmYXVsdCB0byAnZGlzcGxheU9iamVjdCBbdGFiSW5kZXhdJ1xuICAgKiBAbWVtYmVyIHs/c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKi9cbiAgYWNjZXNzaWJsZVRpdGxlOiBudWxsLFxuICAvKipcbiAgICogU2V0cyB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUgb2YgdGhlIHNoYWRvdyBkaXZcbiAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKi9cbiAgYWNjZXNzaWJsZUhpbnQ6IG51bGwsXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBwcml2YXRlXG4gICAqIEB0b2RvIE5lZWRzIGRvY3MuXG4gICAqL1xuICB0YWJJbmRleDogMCxcbiAgLyoqXG4gICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEB0b2RvIE5lZWRzIGRvY3MuXG4gICAqL1xuICBfYWNjZXNzaWJsZUFjdGl2ZTogITEsXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgKi9cbiAgX2FjY2Vzc2libGVEaXY6IG51bGwsXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSB0eXBlIG9mIGRpdiB0aGUgYWNjZXNzaWJsZSBsYXllciBpcy4gU2NyZWVuIHJlYWRlcnMgdHJlYXQgdGhlIGVsZW1lbnQgZGlmZmVyZW50bHlcbiAgICogZGVwZW5kaW5nIG9uIHRoaXMgdHlwZS4gRGVmYXVsdHMgdG8gYnV0dG9uLlxuICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0ICdidXR0b24nXG4gICAqL1xuICBhY2Nlc3NpYmxlVHlwZTogXCJidXR0b25cIixcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHBvaW50ZXItZXZlbnRzIHRoZSBhY2Nlc3NpYmxlIGRpdiB3aWxsIHVzZVxuICAgKiBEZWZhdWx0cyB0byBhdXRvLlxuICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0ICdhdXRvJ1xuICAgKi9cbiAgYWNjZXNzaWJsZVBvaW50ZXJFdmVudHM6IFwiYXV0b1wiLFxuICAvKipcbiAgICogU2V0dGluZyB0byBmYWxzZSB3aWxsIHByZXZlbnQgYW55IGNoaWxkcmVuIGluc2lkZSB0aGlzIGNvbnRhaW5lciB0b1xuICAgKiBiZSBhY2Nlc3NpYmxlLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBhY2Nlc3NpYmxlQ2hpbGRyZW46ICEwLFxuICByZW5kZXJJZDogLTFcbn07XG5leHBvcnRzLmFjY2Vzc2libGVUYXJnZXQgPSBhY2Nlc3NpYmxlVGFyZ2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzaWJsZVRhcmdldC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIEFjY2Vzc2liaWxpdHlNYW5hZ2VyID0gcmVxdWlyZShcIi4vQWNjZXNzaWJpbGl0eU1hbmFnZXIuanNcIiksIGFjY2Vzc2libGVUYXJnZXQgPSByZXF1aXJlKFwiLi9hY2Nlc3NpYmxlVGFyZ2V0LmpzXCIpO1xuZXhwb3J0cy5BY2Nlc3NpYmlsaXR5TWFuYWdlciA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuZXhwb3J0cy5hY2Nlc3NpYmxlVGFyZ2V0ID0gYWNjZXNzaWJsZVRhcmdldC5hY2Nlc3NpYmxlVGFyZ2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIGRpc3BsYXkgPSByZXF1aXJlKFwiQHBpeGkvZGlzcGxheVwiKTtcbmNvbnN0IF9BcHBsaWNhdGlvbiA9IGNsYXNzIF9BcHBsaWNhdGlvbjIge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9uYWwgYXBwbGljYXRpb24gYW5kIHJlbmRlcmVyIHBhcmFtZXRlcnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5zdGFnZSA9IG5ldyBkaXNwbGF5LkNvbnRhaW5lcigpLCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBmb3JjZUNhbnZhczogITFcbiAgICB9LCBvcHRpb25zKSwgdGhpcy5yZW5kZXJlciA9IGNvcmUuYXV0b0RldGVjdFJlbmRlcmVyKG9wdGlvbnMpLCBfQXBwbGljYXRpb24yLl9wbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgcGx1Z2luLmluaXQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICAvKiogUmVuZGVyIHRoZSBjdXJyZW50IHN0YWdlLiAqL1xuICByZW5kZXIoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zdGFnZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIncyBjYW52YXMgZWxlbWVudC5cbiAgICogQG1lbWJlciB7UElYSS5JQ2FudmFzfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB2aWV3KCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyPy52aWV3O1xuICB9XG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHJlbmRlcmVyJ3Mgc2NyZWVuIHJlY3RhbmdsZS4gSXRzIHNhZmUgdG8gdXNlIGFzIGBmaWx0ZXJBcmVhYCBvciBgaGl0QXJlYWAgZm9yIHRoZSB3aG9sZSBzY3JlZW4uXG4gICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBzY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXI/LnNjcmVlbjtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveSBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZVZpZXc9ZmFsc2VdIC0gQXV0b21hdGljYWxseSByZW1vdmUgY2FudmFzIGZyb20gRE9NLlxuICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbc3RhZ2VPcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFnZU9wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyIGRlc3Ryb3lcbiAgICogIG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ3N0YWdlT3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0YWdlT3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBzdGFnZU9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0XG4gICAqICB0byB0cnVlLiBTaG91bGQgaXQgZGVzdHJveSB0aGUgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0YWdlT3B0aW9ucy5iYXNlVGV4dHVyZT1mYWxzZV0gLSBPbmx5IHVzZWQgZm9yIGNoaWxkIFNwcml0ZXMgaWYgc3RhZ2VPcHRpb25zLmNoaWxkcmVuIGlzIHNldFxuICAgKiAgdG8gdHJ1ZS4gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXG4gICAqL1xuICBkZXN0cm95KHJlbW92ZVZpZXcsIHN0YWdlT3B0aW9ucykge1xuICAgIGNvbnN0IHBsdWdpbnMgPSBfQXBwbGljYXRpb24yLl9wbHVnaW5zLnNsaWNlKDApO1xuICAgIHBsdWdpbnMucmV2ZXJzZSgpLCBwbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgcGx1Z2luLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9KSwgdGhpcy5zdGFnZS5kZXN0cm95KHN0YWdlT3B0aW9ucyksIHRoaXMuc3RhZ2UgPSBudWxsLCB0aGlzLnJlbmRlcmVyLmRlc3Ryb3kocmVtb3ZlVmlldyksIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59O1xuX0FwcGxpY2F0aW9uLl9wbHVnaW5zID0gW107XG5sZXQgQXBwbGljYXRpb24gPSBfQXBwbGljYXRpb247XG5jb3JlLmV4dGVuc2lvbnMuaGFuZGxlQnlMaXN0KGNvcmUuRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbiwgQXBwbGljYXRpb24uX3BsdWdpbnMpO1xuZXhwb3J0cy5BcHBsaWNhdGlvbiA9IEFwcGxpY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwbGljYXRpb24uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIik7XG5jbGFzcyBSZXNpemVQbHVnaW4ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgcGx1Z2luIHdpdGggc2NvcGUgb2YgYXBwbGljYXRpb24gaW5zdGFuY2VcbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gU2VlIGFwcGxpY2F0aW9uIG9wdGlvbnNcbiAgICovXG4gIHN0YXRpYyBpbml0KG9wdGlvbnMpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgXCJyZXNpemVUb1wiLFxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSFRNTCBlbGVtZW50IG9yIHdpbmRvdyB0byBhdXRvbWF0aWNhbGx5IHJlc2l6ZSB0aGVcbiAgICAgICAqIHJlbmRlcmVyJ3MgdmlldyBlbGVtZW50IHRvIG1hdGNoIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgKiBAbWVtYmVyIHtXaW5kb3d8SFRNTEVsZW1lbnR9XG4gICAgICAgKiBAbmFtZSByZXNpemVUb1xuICAgICAgICogQG1lbWJlcm9mIFBJWEkuQXBwbGljYXRpb24jXG4gICAgICAgKi9cbiAgICAgIHtcbiAgICAgICAgc2V0KGRvbSkge1xuICAgICAgICAgIGdsb2JhbFRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnF1ZXVlUmVzaXplKSwgdGhpcy5fcmVzaXplVG8gPSBkb20sIGRvbSAmJiAoZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucXVldWVSZXNpemUpLCB0aGlzLnJlc2l6ZSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNpemVUbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICksIHRoaXMucXVldWVSZXNpemUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9yZXNpemVUbyAmJiAodGhpcy5jYW5jZWxSZXNpemUoKSwgdGhpcy5fcmVzaXplSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5yZXNpemUoKSkpO1xuICAgIH0sIHRoaXMuY2FuY2VsUmVzaXplID0gKCkgPT4ge1xuICAgICAgdGhpcy5fcmVzaXplSWQgJiYgKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3Jlc2l6ZUlkKSwgdGhpcy5fcmVzaXplSWQgPSBudWxsKTtcbiAgICB9LCB0aGlzLnJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fcmVzaXplVG8pXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuY2FuY2VsUmVzaXplKCk7XG4gICAgICBsZXQgd2lkdGgsIGhlaWdodDtcbiAgICAgIGlmICh0aGlzLl9yZXNpemVUbyA9PT0gZ2xvYmFsVGhpcy53aW5kb3cpXG4gICAgICAgIHdpZHRoID0gZ2xvYmFsVGhpcy5pbm5lcldpZHRoLCBoZWlnaHQgPSBnbG9iYWxUaGlzLmlubmVySGVpZ2h0O1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCB9ID0gdGhpcy5fcmVzaXplVG87XG4gICAgICAgIHdpZHRoID0gY2xpZW50V2lkdGgsIGhlaWdodCA9IGNsaWVudEhlaWdodDtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpLCB0aGlzLnJlbmRlcigpO1xuICAgIH0sIHRoaXMuX3Jlc2l6ZUlkID0gbnVsbCwgdGhpcy5fcmVzaXplVG8gPSBudWxsLCB0aGlzLnJlc2l6ZVRvID0gb3B0aW9ucy5yZXNpemVUbyB8fCBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhbiB1cCB0aGUgdGlja2VyLCBzY29wZWQgdG8gYXBwbGljYXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGRlc3Ryb3koKSB7XG4gICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucXVldWVSZXNpemUpLCB0aGlzLmNhbmNlbFJlc2l6ZSgpLCB0aGlzLmNhbmNlbFJlc2l6ZSA9IG51bGwsIHRoaXMucXVldWVSZXNpemUgPSBudWxsLCB0aGlzLnJlc2l6ZVRvID0gbnVsbCwgdGhpcy5yZXNpemUgPSBudWxsO1xuICB9XG59XG5SZXNpemVQbHVnaW4uZXh0ZW5zaW9uID0gY29yZS5FeHRlbnNpb25UeXBlLkFwcGxpY2F0aW9uO1xuY29yZS5leHRlbnNpb25zLmFkZChSZXNpemVQbHVnaW4pO1xuZXhwb3J0cy5SZXNpemVQbHVnaW4gPSBSZXNpemVQbHVnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNpemVQbHVnaW4uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBBcHBsaWNhdGlvbiA9IHJlcXVpcmUoXCIuL0FwcGxpY2F0aW9uLmpzXCIpLCBSZXNpemVQbHVnaW4gPSByZXF1aXJlKFwiLi9SZXNpemVQbHVnaW4uanNcIik7XG5leHBvcnRzLkFwcGxpY2F0aW9uID0gQXBwbGljYXRpb24uQXBwbGljYXRpb247XG5leHBvcnRzLlJlc2l6ZVBsdWdpbiA9IFJlc2l6ZVBsdWdpbi5SZXNpemVQbHVnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKTtcbmNvbnN0IGFzc2V0S2V5TWFwID0ge1xuICBsb2FkZXI6IGNvcmUuRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICByZXNvbHZlcjogY29yZS5FeHRlbnNpb25UeXBlLlJlc29sdmVQYXJzZXIsXG4gIGNhY2hlOiBjb3JlLkV4dGVuc2lvblR5cGUuQ2FjaGVQYXJzZXIsXG4gIGRldGVjdGlvbjogY29yZS5FeHRlbnNpb25UeXBlLkRldGVjdGlvblBhcnNlclxufTtcbmNvcmUuZXh0ZW5zaW9ucy5oYW5kbGUoY29yZS5FeHRlbnNpb25UeXBlLkFzc2V0LCAoZXh0ZW5zaW9uKSA9PiB7XG4gIGNvbnN0IHJlZiA9IGV4dGVuc2lvbi5yZWY7XG4gIE9iamVjdC5lbnRyaWVzKGFzc2V0S2V5TWFwKS5maWx0ZXIoKFtrZXldKSA9PiAhIXJlZltrZXldKS5mb3JFYWNoKChba2V5LCB0eXBlXSkgPT4gY29yZS5leHRlbnNpb25zLmFkZChPYmplY3QuYXNzaWduKFxuICAgIHJlZltrZXldLFxuICAgIC8vIEFsbG93IHRoZSBmdW5jdGlvbiB0byBvcHRpb25hbGx5IGRlZmluZSBpdCdzIG93blxuICAgIC8vIEV4dGVuc2lvbk1ldGFkYXRhLCB0aGUgdXNlIGNhc2VzIGhlcmUgaXMgcHJpb3JpdHkgZm9yIExvYWRlclBhcnNlcnNcbiAgICB7IGV4dGVuc2lvbjogcmVmW2tleV0uZXh0ZW5zaW9uID8/IHR5cGUgfVxuICApKSk7XG59LCAoZXh0ZW5zaW9uKSA9PiB7XG4gIGNvbnN0IHJlZiA9IGV4dGVuc2lvbi5yZWY7XG4gIE9iamVjdC5rZXlzKGFzc2V0S2V5TWFwKS5maWx0ZXIoKGtleSkgPT4gISFyZWZba2V5XSkuZm9yRWFjaCgoa2V5KSA9PiBjb3JlLmV4dGVuc2lvbnMucmVtb3ZlKHJlZltrZXldKSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzc2V0RXh0ZW5zaW9uLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCBCYWNrZ3JvdW5kTG9hZGVyID0gcmVxdWlyZShcIi4vQmFja2dyb3VuZExvYWRlci5qc1wiKSwgQ2FjaGUgPSByZXF1aXJlKFwiLi9jYWNoZS9DYWNoZS5qc1wiKSwgTG9hZGVyID0gcmVxdWlyZShcIi4vbG9hZGVyL0xvYWRlci5qc1wiKTtcbnJlcXVpcmUoXCIuL2xvYWRlci9wYXJzZXJzL2luZGV4LmpzXCIpO1xudmFyIFJlc29sdmVyID0gcmVxdWlyZShcIi4vcmVzb2x2ZXIvUmVzb2x2ZXIuanNcIiksIGNvbnZlcnRUb0xpc3QgPSByZXF1aXJlKFwiLi91dGlscy9jb252ZXJ0VG9MaXN0LmpzXCIpLCBpc1NpbmdsZUl0ZW0gPSByZXF1aXJlKFwiLi91dGlscy9pc1NpbmdsZUl0ZW0uanNcIiksIGxvYWRUZXh0dXJlcyA9IHJlcXVpcmUoXCIuL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRUZXh0dXJlcy5qc1wiKTtcbmNsYXNzIEFzc2V0c0NsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZGV0ZWN0aW9ucyA9IFtdLCB0aGlzLl9pbml0aWFsaXplZCA9ICExLCB0aGlzLnJlc29sdmVyID0gbmV3IFJlc29sdmVyLlJlc29sdmVyKCksIHRoaXMubG9hZGVyID0gbmV3IExvYWRlci5Mb2FkZXIoKSwgdGhpcy5jYWNoZSA9IENhY2hlLkNhY2hlLCB0aGlzLl9iYWNrZ3JvdW5kTG9hZGVyID0gbmV3IEJhY2tncm91bmRMb2FkZXIuQmFja2dyb3VuZExvYWRlcih0aGlzLmxvYWRlciksIHRoaXMuX2JhY2tncm91bmRMb2FkZXIuYWN0aXZlID0gITAsIHRoaXMucmVzZXQoKTtcbiAgfVxuICAvKipcbiAgICogQmVzdCBwcmFjdGljZSBpcyB0byBjYWxsIHRoaXMgZnVuY3Rpb24gYmVmb3JlIGFueSBsb2FkaW5nIGNvbW1lbmNlc1xuICAgKiBJbml0aWF0aW5nIGlzIHRoZSBiZXN0IHRpbWUgdG8gYWRkIGFueSBjdXN0b21pemF0aW9uIHRvIHRoZSB3YXkgdGhpbmdzIGFyZSBsb2FkZWQuXG4gICAqXG4gICAqIHlvdSBkbyBub3QgbmVlZCB0byBjYWxsIHRoaXMgZm9yIHRoZSBBc3NldCBjbGFzcyB0byB3b3JrLCBvbmx5IGlmIHlvdSB3YW50IHRvIHNldCBhbnkgaW5pdGlhbCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyB0byBpbml0aWFsaXplIHRoZSBBc3NldCBtYW5hZ2VyIHdpdGhcbiAgICovXG4gIGFzeW5jIGluaXQob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbQXNzZXRzXUFzc2V0TWFuYWdlciBhbHJlYWR5IGluaXRpYWxpemVkLCBkaWQgeW91IGxvYWQgYmVmb3JlIGNhbGxpbmcgdGhpcyBBc3NldC5pbml0KCk/XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQgPSAhMCwgb3B0aW9ucy5kZWZhdWx0U2VhcmNoUGFyYW1zICYmIHRoaXMucmVzb2x2ZXIuc2V0RGVmYXVsdFNlYXJjaFBhcmFtcyhvcHRpb25zLmRlZmF1bHRTZWFyY2hQYXJhbXMpLCBvcHRpb25zLmJhc2VQYXRoICYmICh0aGlzLnJlc29sdmVyLmJhc2VQYXRoID0gb3B0aW9ucy5iYXNlUGF0aCksIG9wdGlvbnMuYnVuZGxlSWRlbnRpZmllciAmJiB0aGlzLnJlc29sdmVyLnNldEJ1bmRsZUlkZW50aWZpZXIob3B0aW9ucy5idW5kbGVJZGVudGlmaWVyKSwgb3B0aW9ucy5tYW5pZmVzdCkge1xuICAgICAgbGV0IG1hbmlmZXN0ID0gb3B0aW9ucy5tYW5pZmVzdDtcbiAgICAgIHR5cGVvZiBtYW5pZmVzdCA9PSBcInN0cmluZ1wiICYmIChtYW5pZmVzdCA9IGF3YWl0IHRoaXMubG9hZChtYW5pZmVzdCkpLCB0aGlzLnJlc29sdmVyLmFkZE1hbmlmZXN0KG1hbmlmZXN0KTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x1dGlvblByZWYgPSBvcHRpb25zLnRleHR1cmVQcmVmZXJlbmNlPy5yZXNvbHV0aW9uID8/IDEsIHJlc29sdXRpb24gPSB0eXBlb2YgcmVzb2x1dGlvblByZWYgPT0gXCJudW1iZXJcIiA/IFtyZXNvbHV0aW9uUHJlZl0gOiByZXNvbHV0aW9uUHJlZiwgZm9ybWF0cyA9IGF3YWl0IHRoaXMuX2RldGVjdEZvcm1hdHMoe1xuICAgICAgcHJlZmVycmVkRm9ybWF0czogb3B0aW9ucy50ZXh0dXJlUHJlZmVyZW5jZT8uZm9ybWF0LFxuICAgICAgc2tpcERldGVjdGlvbnM6IG9wdGlvbnMuc2tpcERldGVjdGlvbnMsXG4gICAgICBkZXRlY3Rpb25zOiB0aGlzLl9kZXRlY3Rpb25zXG4gICAgfSk7XG4gICAgdGhpcy5yZXNvbHZlci5wcmVmZXIoe1xuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGZvcm1hdDogZm9ybWF0cyxcbiAgICAgICAgcmVzb2x1dGlvblxuICAgICAgfVxuICAgIH0pLCBvcHRpb25zLnByZWZlcmVuY2VzICYmIHRoaXMuc2V0UHJlZmVyZW5jZXMob3B0aW9ucy5wcmVmZXJlbmNlcyk7XG4gIH1cbiAgYWRkKGFsaWFzZXMsIHNyY3MsIGRhdGEsIGZvcm1hdCwgbG9hZFBhcnNlcikge1xuICAgIHRoaXMucmVzb2x2ZXIuYWRkKGFsaWFzZXMsIHNyY3MsIGRhdGEsIGZvcm1hdCwgbG9hZFBhcnNlcik7XG4gIH1cbiAgYXN5bmMgbG9hZCh1cmxzLCBvblByb2dyZXNzKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgfHwgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgY29uc3Qgc2luZ2xlQXNzZXQgPSBpc1NpbmdsZUl0ZW0uaXNTaW5nbGVJdGVtKHVybHMpLCB1cmxBcnJheSA9IGNvbnZlcnRUb0xpc3QuY29udmVydFRvTGlzdCh1cmxzKS5tYXAoKHVybCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB1cmwgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBhbGlhc2VzID0gdGhpcy5yZXNvbHZlci5nZXRBbGlhcyh1cmwpO1xuICAgICAgICByZXR1cm4gYWxpYXNlcy5zb21lKChhbGlhcykgPT4gIXRoaXMucmVzb2x2ZXIuaGFzS2V5KGFsaWFzKSkgJiYgdGhpcy5hZGQodXJsKSwgQXJyYXkuaXNBcnJheShhbGlhc2VzKSA/IGFsaWFzZXNbMF0gOiBhbGlhc2VzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXIuaGFzS2V5KHVybCkgfHwgdGhpcy5hZGQoeyBhbGlhczogdXJsLCBzcmM6IHVybCB9KSwgdXJsO1xuICAgIH0pLCByZXNvbHZlUmVzdWx0cyA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZSh1cmxBcnJheSksIG91dCA9IGF3YWl0IHRoaXMuX21hcExvYWRUb1Jlc29sdmUocmVzb2x2ZVJlc3VsdHMsIG9uUHJvZ3Jlc3MpO1xuICAgIHJldHVybiBzaW5nbGVBc3NldCA/IG91dFt1cmxBcnJheVswXV0gOiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgYWRkcyBhIGJ1bmRsZSBvZiBhc3NldHMgaW4gb25lIGdvIHNvIHRoYXQgeW91IGNhbiBsb2FkIHRoZW0gYXMgYSBncm91cC5cbiAgICogRm9yIGV4YW1wbGUgeW91IGNvdWxkIGFkZCBhIGJ1bmRsZSBmb3IgZWFjaCBzY3JlZW4gaW4geW91IHBpeGkgYXBwXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEFzc2V0cyB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBBc3NldHMuYWRkQnVuZGxlKCdhbmltYWxzJywge1xuICAgKiAgICAgYnVubnk6ICdidW5ueS5wbmcnLFxuICAgKiAgICAgY2hpY2tlbjogJ2NoaWNrZW4ucG5nJyxcbiAgICogICAgIHRodW1wZXI6ICd0aHVtcGVyLnBuZycsXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCBhc3NldHMgPSBhd2FpdCBBc3NldHMubG9hZEJ1bmRsZSgnYW5pbWFscycpO1xuICAgKiBAcGFyYW0gYnVuZGxlSWQgLSB0aGUgaWQgb2YgdGhlIGJ1bmRsZSB0byBhZGRcbiAgICogQHBhcmFtIGFzc2V0cyAtIGEgcmVjb3JkIG9mIHRoZSBhc3NldCBvciBhc3NldHMgdGhhdCB3aWxsIGJlIGNob3NlbiBmcm9tIHdoZW4gbG9hZGluZyB2aWEgdGhlIHNwZWNpZmllZCBrZXlcbiAgICovXG4gIGFkZEJ1bmRsZShidW5kbGVJZCwgYXNzZXRzKSB7XG4gICAgdGhpcy5yZXNvbHZlci5hZGRCdW5kbGUoYnVuZGxlSWQsIGFzc2V0cyk7XG4gIH1cbiAgLyoqXG4gICAqIEJ1bmRsZXMgYXJlIGEgd2F5IHRvIGxvYWQgbXVsdGlwbGUgYXNzZXRzIGF0IG9uY2UuXG4gICAqIElmIGEgbWFuaWZlc3QgaGFzIGJlZW4gcHJvdmlkZWQgdG8gdGhlIGluaXQgZnVuY3Rpb24gdGhlbiB5b3UgY2FuIGxvYWQgYSBidW5kbGUsIG9yIGJ1bmRsZXMuXG4gICAqIHlvdSBjYW4gYWxzbyBhZGQgYnVuZGxlcyB2aWEgYGFkZEJ1bmRsZWBcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQXNzZXRzIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIC8vIE1hbmlmZXN0IEV4YW1wbGVcbiAgICogY29uc3QgbWFuaWZlc3QgPSB7XG4gICAqICAgICBidW5kbGVzOiBbXG4gICAqICAgICAgICAge1xuICAgKiAgICAgICAgICAgICBuYW1lOiAnbG9hZC1zY3JlZW4nLFxuICAgKiAgICAgICAgICAgICBhc3NldHM6IFtcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2JhY2tncm91bmQnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHNyYzogJ3N1bnNldC5wbmcnLFxuICAgKiAgICAgICAgICAgICAgICAgfSxcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2JhcicsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAnbG9hZC1iYXIue3BuZyx3ZWJwfScsXG4gICAqICAgICAgICAgICAgICAgICB9LFxuICAgKiAgICAgICAgICAgICBdLFxuICAgKiAgICAgICAgIH0sXG4gICAqICAgICAgICAge1xuICAgKiAgICAgICAgICAgICBuYW1lOiAnZ2FtZS1zY3JlZW4nLFxuICAgKiAgICAgICAgICAgICBhc3NldHM6IFtcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2NoYXJhY3RlcicsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAncm9ib3QucG5nJyxcbiAgICogICAgICAgICAgICAgICAgIH0sXG4gICAqICAgICAgICAgICAgICAgICB7XG4gICAqICAgICAgICAgICAgICAgICAgICAgYWxpYXM6ICdlbmVteScsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAnYmFkLWd1eS5wbmcnLFxuICAgKiAgICAgICAgICAgICAgICAgfSxcbiAgICogICAgICAgICAgICAgXSxcbiAgICogICAgICAgICB9LFxuICAgKiAgICAgXVxuICAgKiB9O1xuICAgKlxuICAgKiBhd2FpdCBBc3NldC5pbml0KHsgbWFuaWZlc3QgfSk7XG4gICAqXG4gICAqIC8vIExvYWQgYSBidW5kbGUuLi5cbiAgICogbG9hZFNjcmVlbkFzc2V0cyA9IGF3YWl0IEFzc2V0cy5sb2FkQnVuZGxlKCdsb2FkLXNjcmVlbicpO1xuICAgKiAvLyBMb2FkIGFub3RoZXIgYnVuZGxlLi4uXG4gICAqIGdhbWVTY3JlZW5Bc3NldHMgPSBhd2FpdCBBc3NldHMubG9hZEJ1bmRsZSgnZ2FtZS1zY3JlZW4nKTtcbiAgICogQHBhcmFtIGJ1bmRsZUlkcyAtIHRoZSBidW5kbGUgaWQgb3IgaWRzIHRvIGxvYWRcbiAgICogQHBhcmFtIG9uUHJvZ3Jlc3MgLSBPcHRpb25hbCBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHByb2dyZXNzIG9uIGFzc2V0IGxvYWRpbmcgaXMgbWFkZS5cbiAgICogVGhlIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIHNpbmdsZSBwYXJhbWV0ZXIsIGBwcm9ncmVzc2AsIHdoaWNoIHJlcHJlc2VudHMgdGhlIHBlcmNlbnRhZ2UgKDAuMCAtIDEuMClcbiAgICogb2YgdGhlIGFzc2V0cyBsb2FkZWQuIERvIG5vdCB1c2UgdGhpcyBmdW5jdGlvbiB0byBkZXRlY3Qgd2hlbiBhc3NldHMgYXJlIGNvbXBsZXRlIGFuZCBhdmFpbGFibGUsXG4gICAqIGluc3RlYWQgdXNlIHRoZSBQcm9taXNlIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24uXG4gICAqIEByZXR1cm5zIGFsbCB0aGUgYnVuZGxlcyBhc3NldHMgb3IgYSBoYXNoIG9mIGFzc2V0cyBmb3IgZWFjaCBidW5kbGUgc3BlY2lmaWVkXG4gICAqL1xuICBhc3luYyBsb2FkQnVuZGxlKGJ1bmRsZUlkcywgb25Qcm9ncmVzcykge1xuICAgIHRoaXMuX2luaXRpYWxpemVkIHx8IGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGxldCBzaW5nbGVBc3NldCA9ICExO1xuICAgIHR5cGVvZiBidW5kbGVJZHMgPT0gXCJzdHJpbmdcIiAmJiAoc2luZ2xlQXNzZXQgPSAhMCwgYnVuZGxlSWRzID0gW2J1bmRsZUlkc10pO1xuICAgIGNvbnN0IHJlc29sdmVSZXN1bHRzID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlQnVuZGxlKGJ1bmRsZUlkcyksIG91dCA9IHt9LCBrZXlzID0gT2JqZWN0LmtleXMocmVzb2x2ZVJlc3VsdHMpO1xuICAgIGxldCBjb3VudCA9IDAsIHRvdGFsID0gMDtcbiAgICBjb25zdCBfb25Qcm9ncmVzcyA9ICgpID0+IHtcbiAgICAgIG9uUHJvZ3Jlc3M/LigrK2NvdW50IC8gdG90YWwpO1xuICAgIH0sIHByb21pc2VzID0ga2V5cy5tYXAoKGJ1bmRsZUlkKSA9PiB7XG4gICAgICBjb25zdCByZXNvbHZlUmVzdWx0ID0gcmVzb2x2ZVJlc3VsdHNbYnVuZGxlSWRdO1xuICAgICAgcmV0dXJuIHRvdGFsICs9IE9iamVjdC5rZXlzKHJlc29sdmVSZXN1bHQpLmxlbmd0aCwgdGhpcy5fbWFwTG9hZFRvUmVzb2x2ZShyZXNvbHZlUmVzdWx0LCBfb25Qcm9ncmVzcykudGhlbigocmVzb2x2ZVJlc3VsdDIpID0+IHtcbiAgICAgICAgb3V0W2J1bmRsZUlkXSA9IHJlc29sdmVSZXN1bHQyO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKSwgc2luZ2xlQXNzZXQgPyBvdXRbYnVuZGxlSWRzWzBdXSA6IG91dDtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGUgYSBiYWNrZ3JvdW5kIGxvYWQgb2Ygc29tZSBhc3NldHMuIEl0IHdpbGwgcGFzc2l2ZWx5IGJlZ2luIHRvIGxvYWQgdGhlc2UgYXNzZXRzIGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgKiBTbyB3aGVuIHlvdSBhY3R1YWxseSBjb21lIHRvIGxvYWRpbmcgdGhlbSB5b3Ugd2lsbCBnZXQgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGxvYWRlZCBhc3NldHMgaW1tZWRpYXRlbHlcbiAgICpcbiAgICogQW4gZXhhbXBsZSBvZiB0aGlzIG1pZ2h0IGJlIHRoYXQgeW91IHdvdWxkIGJhY2tncm91bmQgbG9hZCBnYW1lIGFzc2V0cyBhZnRlciB5b3VyIGluaXRhbCBsb2FkLlxuICAgKiB0aGVuIHdoZW4geW91IGdvdCB0byBhY3R1YWxseSBsb2FkIHlvdXIgZ2FtZSBzY3JlZW4gYXNzZXRzIHdoZW4gYSBwbGF5ZXIgZ29lcyB0byB0aGUgZ2FtZSAtIHRoZSBsb2FkaW5nXG4gICAqIHdvdWxkIGFscmVhZHkgaGF2ZSBzdGFyZWQgb3IgbWF5IGV2ZW4gYmUgY29tcGxldGUsIHNhdmluZyB5b3UgaGF2aW5nIHRvIHNob3cgYW4gaW50ZXJpbSBsb2FkIGJhci5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQXNzZXRzIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIEFzc2V0cy5iYWNrZ3JvdW5kTG9hZCgnYnVubnkucG5nJyk7XG4gICAqXG4gICAqIC8vIGxhdGVyIG9uIGluIHlvdXIgYXBwLi4uXG4gICAqIGF3YWl0IEFzc2V0cy5sb2FkQnVuZGxlKCdidW5ueS5wbmcnKTsgLy8gV2lsbCByZXNvbHZlIHF1aWNrZXIgYXMgbG9hZGluZyBtYXkgaGF2ZSBjb21wbGV0ZWQhXG4gICAqIEBwYXJhbSB1cmxzIC0gdGhlIHVybCAvIHVybHMgeW91IHdhbnQgdG8gYmFja2dyb3VuZCBsb2FkXG4gICAqL1xuICBhc3luYyBiYWNrZ3JvdW5kTG9hZCh1cmxzKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgfHwgYXdhaXQgdGhpcy5pbml0KCksIHR5cGVvZiB1cmxzID09IFwic3RyaW5nXCIgJiYgKHVybHMgPSBbdXJsc10pO1xuICAgIGNvbnN0IHJlc29sdmVSZXN1bHRzID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlKHVybHMpO1xuICAgIHRoaXMuX2JhY2tncm91bmRMb2FkZXIuYWRkKE9iamVjdC52YWx1ZXMocmVzb2x2ZVJlc3VsdHMpKTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGUgYSBiYWNrZ3JvdW5kIG9mIGEgYnVuZGxlLCB3b3JrcyBleGFjdGx5IGxpa2UgYmFja2dyb3VuZExvYWQgYnV0IGZvciBidW5kbGVzLlxuICAgKiB0aGlzIGNhbiBvbmx5IGJlIHVzZWQgaWYgdGhlIGxvYWRlciBoYXMgYmVlbiBpbml0aWF0ZWQgd2l0aCBhIG1hbmlmZXN0XG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEFzc2V0cyB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBhd2FpdCBBc3NldHMuaW5pdCh7XG4gICAqICAgICBtYW5pZmVzdDoge1xuICAgKiAgICAgICAgIGJ1bmRsZXM6IFtcbiAgICogICAgICAgICAgICAge1xuICAgKiAgICAgICAgICAgICAgICAgbmFtZTogJ2xvYWQtc2NyZWVuJyxcbiAgICogICAgICAgICAgICAgICAgIGFzc2V0czogWy4uLl0sXG4gICAqICAgICAgICAgICAgIH0sXG4gICAqICAgICAgICAgICAgIC4uLlxuICAgKiAgICAgICAgIF0sXG4gICAqICAgICB9LFxuICAgKiB9KTtcbiAgICpcbiAgICogQXNzZXRzLmJhY2tncm91bmRMb2FkQnVuZGxlKCdsb2FkLXNjcmVlbicpO1xuICAgKlxuICAgKiAvLyBMYXRlciBvbiBpbiB5b3VyIGFwcC4uLlxuICAgKiBhd2FpdCBBc3NldHMubG9hZEJ1bmRsZSgnbG9hZC1zY3JlZW4nKTsgLy8gV2lsbCByZXNvbHZlIHF1aWNrZXIgYXMgbG9hZGluZyBtYXkgaGF2ZSBjb21wbGV0ZWQhXG4gICAqIEBwYXJhbSBidW5kbGVJZHMgLSB0aGUgYnVuZGxlSWQgLyBidW5kbGVJZHMgeW91IHdhbnQgdG8gYmFja2dyb3VuZCBsb2FkXG4gICAqL1xuICBhc3luYyBiYWNrZ3JvdW5kTG9hZEJ1bmRsZShidW5kbGVJZHMpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCB8fCBhd2FpdCB0aGlzLmluaXQoKSwgdHlwZW9mIGJ1bmRsZUlkcyA9PSBcInN0cmluZ1wiICYmIChidW5kbGVJZHMgPSBbYnVuZGxlSWRzXSk7XG4gICAgY29uc3QgcmVzb2x2ZVJlc3VsdHMgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVCdW5kbGUoYnVuZGxlSWRzKTtcbiAgICBPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHRzKS5mb3JFYWNoKChyZXNvbHZlUmVzdWx0KSA9PiB7XG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kTG9hZGVyLmFkZChPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHQpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogT25seSBpbnRlbmRlZCBmb3IgZGV2ZWxvcG1lbnQgcHVycG9zZXMuXG4gICAqIFRoaXMgd2lsbCB3aXBlIHRoZSByZXNvbHZlciBhbmQgY2FjaGVzLlxuICAgKiBZb3Ugd2lsbCBuZWVkIHRvIHJlaW5pdGlhbGl6ZSB0aGUgQXNzZXRcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMucmVzb2x2ZXIucmVzZXQoKSwgdGhpcy5sb2FkZXIucmVzZXQoKSwgdGhpcy5jYWNoZS5yZXNldCgpLCB0aGlzLl9pbml0aWFsaXplZCA9ICExO1xuICB9XG4gIGdldChrZXlzKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlzID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gQ2FjaGUuQ2FjaGUuZ2V0KGtleXMpO1xuICAgIGNvbnN0IGFzc2V0cyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcbiAgICAgIGFzc2V0c1tpXSA9IENhY2hlLkNhY2hlLmdldChrZXlzW2ldKTtcbiAgICByZXR1cm4gYXNzZXRzO1xuICB9XG4gIC8qKlxuICAgKiBoZWxwZXIgZnVuY3Rpb24gdG8gbWFwIHJlc29sdmVkIGFzc2V0cyBiYWNrIHRvIGxvYWRlZCBhc3NldHNcbiAgICogQHBhcmFtIHJlc29sdmVSZXN1bHRzIC0gdGhlIHJlc29sdmUgcmVzdWx0cyBmcm9tIHRoZSByZXNvbHZlclxuICAgKiBAcGFyYW0gb25Qcm9ncmVzcyAtIHRoZSBwcm9ncmVzcyBjYWxsYmFja1xuICAgKi9cbiAgYXN5bmMgX21hcExvYWRUb1Jlc29sdmUocmVzb2x2ZVJlc3VsdHMsIG9uUHJvZ3Jlc3MpIHtcbiAgICBjb25zdCByZXNvbHZlQXJyYXkgPSBPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHRzKSwgcmVzb2x2ZUtleXMgPSBPYmplY3Qua2V5cyhyZXNvbHZlUmVzdWx0cyk7XG4gICAgdGhpcy5fYmFja2dyb3VuZExvYWRlci5hY3RpdmUgPSAhMTtcbiAgICBjb25zdCBsb2FkZWRBc3NldHMgPSBhd2FpdCB0aGlzLmxvYWRlci5sb2FkKHJlc29sdmVBcnJheSwgb25Qcm9ncmVzcyk7XG4gICAgdGhpcy5fYmFja2dyb3VuZExvYWRlci5hY3RpdmUgPSAhMDtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICByZXR1cm4gcmVzb2x2ZUFycmF5LmZvckVhY2goKHJlc29sdmVSZXN1bHQsIGkpID0+IHtcbiAgICAgIGNvbnN0IGFzc2V0ID0gbG9hZGVkQXNzZXRzW3Jlc29sdmVSZXN1bHQuc3JjXSwga2V5cyA9IFtyZXNvbHZlUmVzdWx0LnNyY107XG4gICAgICByZXNvbHZlUmVzdWx0LmFsaWFzICYmIGtleXMucHVzaCguLi5yZXNvbHZlUmVzdWx0LmFsaWFzKSwgb3V0W3Jlc29sdmVLZXlzW2ldXSA9IGFzc2V0LCBDYWNoZS5DYWNoZS5zZXQoa2V5cywgYXNzZXQpO1xuICAgIH0pLCBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFVubG9hZCBhbiBhc3NldCBvciBhc3NldHMuIEFzIHRoZSBBc3NldHMgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoZSBhc3NldHMgdmlhIHRoZSBgbG9hZGAgZnVuY3Rpb25cbiAgICogdGhpcyB3aWxsIG1ha2Ugc3VyZSB0byBkZXN0cm95IGFueSBhc3NldHMgYW5kIHJlbGVhc2UgdGhlbSBmcm9tIG1lbW9yeS5cbiAgICogT25jZSB1bmxvYWRlZCwgeW91IHdpbGwgbmVlZCB0byBsb2FkIHRoZSBhc3NldCBhZ2Fpbi5cbiAgICpcbiAgICogVXNlIHRoaXMgdG8gaGVscCBtYW5hZ2UgYXNzZXRzIGlmIHlvdSBmaW5kIHRoYXQgeW91IGhhdmUgYSBsYXJnZSBhcHAgYW5kIHlvdSB3YW50IHRvIGZyZWUgdXAgbWVtb3J5LlxuICAgKlxuICAgKiAtIGl0J3MgdXAgdG8geW91IGFzIHRoZSBkZXZlbG9wZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGV4dHVyZXMgYXJlIG5vdCBhY3RpdmVseSBiZWluZyB1c2VkIHdoZW4geW91IHVubG9hZCB0aGVtLFxuICAgKiBQaXhpIHdvbid0IGJyZWFrIGJ1dCB5b3Ugd2lsbCBlbmQgdXAgd2l0aCBtaXNzaW5nIGFzc2V0cy4gTm90IGEgZ29vZCBsb29rIGZvciB0aGUgdXNlciFcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQXNzZXRzIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIC8vIExvYWQgYSBVUkw6XG4gICAqIGNvbnN0IG15SW1hZ2VUZXh0dXJlID0gYXdhaXQgQXNzZXRzLmxvYWQoJ2h0dHA6Ly9zb21lLnVybC5jb20vaW1hZ2UucG5nJyk7IC8vID0+IHJldHVybnMgYSB0ZXh0dXJlXG4gICAqXG4gICAqIGF3YWl0IEFzc2V0cy51bmxvYWQoJ2h0dHA6Ly9zb21lLnVybC5jb20vaW1hZ2UucG5nJylcbiAgICpcbiAgICogLy8gbXlJbWFnZVRleHR1cmUgd2lsbCBiZSBkZXN0cm95ZWQgbm93LlxuICAgKlxuICAgKiAvLyBVbmxvYWQgbXVsdGlwbGUgYXNzZXRzOlxuICAgKiBjb25zdCB0ZXh0dXJlcyA9IGF3YWl0IEFzc2V0cy51bmxvYWQoWyd0aHVtcGVyJywgJ2NoaWNrbyddKTtcbiAgICogQHBhcmFtIHVybHMgLSB0aGUgdXJscyB0byB1bmxvYWRcbiAgICovXG4gIGFzeW5jIHVubG9hZCh1cmxzKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgfHwgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgY29uc3QgdXJsQXJyYXkgPSBjb252ZXJ0VG9MaXN0LmNvbnZlcnRUb0xpc3QodXJscykubWFwKCh1cmwpID0+IHR5cGVvZiB1cmwgIT0gXCJzdHJpbmdcIiA/IHVybC5zcmMgOiB1cmwpLCByZXNvbHZlUmVzdWx0cyA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZSh1cmxBcnJheSk7XG4gICAgYXdhaXQgdGhpcy5fdW5sb2FkRnJvbVJlc29sdmVkKHJlc29sdmVSZXN1bHRzKTtcbiAgfVxuICAvKipcbiAgICogQnVuZGxlcyBhcmUgYSB3YXkgdG8gbWFuYWdlIG11bHRpcGxlIGFzc2V0cyBhdCBvbmNlLlxuICAgKiB0aGlzIHdpbGwgdW5sb2FkIGFsbCBmaWxlcyBpbiBhIGJ1bmRsZS5cbiAgICpcbiAgICogb25jZSBhIGJ1bmRsZSBoYXMgYmVlbiB1bmxvYWRlZCwgeW91IG5lZWQgdG8gbG9hZCBpdCBhZ2FpbiB0byBoYXZlIGFjY2VzcyB0byB0aGUgYXNzZXRzLlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBBc3NldHMgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogQXNzZXRzLmFkZEJ1bmRsZSh7XG4gICAqICAgICAndGh1bXBlcic6ICdodHRwOi8vc29tZS51cmwuY29tL3RodW1wZXIucG5nJyxcbiAgICogfSlcbiAgICpcbiAgICogY29uc3QgYXNzZXRzID0gYXdhaXQgQXNzZXRzLmxvYWRCdW5kbGUoJ3RodW1wZXInKTtcbiAgICpcbiAgICogLy8gTm93IHRvIHVubG9hZC4uLlxuICAgKlxuICAgKiBhd2FpdCBBc3NldHMudW5sb2FkQnVuZGxlKCd0aHVtcGVyJyk7XG4gICAqXG4gICAqIC8vIEFsbCBhc3NldHMgaW4gdGhlIGFzc2V0cyBvYmplY3Qgd2lsbCBub3cgaGF2ZSBiZWVuIGRlc3Ryb3llZCBhbmQgcHVyZ2VkIGZyb20gdGhlIGNhY2hlXG4gICAqIEBwYXJhbSBidW5kbGVJZHMgLSB0aGUgYnVuZGxlIGlkIG9yIGlkcyB0byB1bmxvYWRcbiAgICovXG4gIGFzeW5jIHVubG9hZEJ1bmRsZShidW5kbGVJZHMpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCB8fCBhd2FpdCB0aGlzLmluaXQoKSwgYnVuZGxlSWRzID0gY29udmVydFRvTGlzdC5jb252ZXJ0VG9MaXN0KGJ1bmRsZUlkcyk7XG4gICAgY29uc3QgcmVzb2x2ZVJlc3VsdHMgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVCdW5kbGUoYnVuZGxlSWRzKSwgcHJvbWlzZXMgPSBPYmplY3Qua2V5cyhyZXNvbHZlUmVzdWx0cykubWFwKChidW5kbGVJZCkgPT4gdGhpcy5fdW5sb2FkRnJvbVJlc29sdmVkKHJlc29sdmVSZXN1bHRzW2J1bmRsZUlkXSkpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxuICBhc3luYyBfdW5sb2FkRnJvbVJlc29sdmVkKHJlc29sdmVSZXN1bHQpIHtcbiAgICBjb25zdCByZXNvbHZlQXJyYXkgPSBPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHQpO1xuICAgIHJlc29sdmVBcnJheS5mb3JFYWNoKChyZXNvbHZlUmVzdWx0MikgPT4ge1xuICAgICAgQ2FjaGUuQ2FjaGUucmVtb3ZlKHJlc29sdmVSZXN1bHQyLnNyYyk7XG4gICAgfSksIGF3YWl0IHRoaXMubG9hZGVyLnVubG9hZChyZXNvbHZlQXJyYXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlY3RzIHRoZSBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgdGhlIGJyb3dzZXIsIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHN1cHBvcnRlZCBmb3JtYXRzLCByZXNwZWN0aW5nXG4gICAqIHRoZSB1c2VycyBwcmVmZXJyZWQgZm9ybWF0cyBvcmRlci5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBkZXRlY3RpbmcgZm9ybWF0c1xuICAgKiBAcGFyYW0gb3B0aW9ucy5wcmVmZXJyZWRGb3JtYXRzIC0gdGhlIHByZWZlcnJlZCBmb3JtYXRzIHRvIHVzZVxuICAgKiBAcGFyYW0gb3B0aW9ucy5za2lwRGV0ZWN0aW9ucyAtIGlmIHdlIHNob3VsZCBza2lwIHRoZSBkZXRlY3Rpb25zIGFsdG9nZXRoZXJcbiAgICogQHBhcmFtIG9wdGlvbnMuZGV0ZWN0aW9ucyAtIHRoZSBkZXRlY3Rpb25zIHRvIHVzZVxuICAgKiBAcmV0dXJucyAtIHRoZSBkZXRlY3RlZCBmb3JtYXRzXG4gICAqL1xuICBhc3luYyBfZGV0ZWN0Rm9ybWF0cyhvcHRpb25zKSB7XG4gICAgbGV0IGZvcm1hdHMgPSBbXTtcbiAgICBvcHRpb25zLnByZWZlcnJlZEZvcm1hdHMgJiYgKGZvcm1hdHMgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMucHJlZmVycmVkRm9ybWF0cykgPyBvcHRpb25zLnByZWZlcnJlZEZvcm1hdHMgOiBbb3B0aW9ucy5wcmVmZXJyZWRGb3JtYXRzXSk7XG4gICAgZm9yIChjb25zdCBkZXRlY3Rpb24gb2Ygb3B0aW9ucy5kZXRlY3Rpb25zKVxuICAgICAgb3B0aW9ucy5za2lwRGV0ZWN0aW9ucyB8fCBhd2FpdCBkZXRlY3Rpb24udGVzdCgpID8gZm9ybWF0cyA9IGF3YWl0IGRldGVjdGlvbi5hZGQoZm9ybWF0cykgOiBvcHRpb25zLnNraXBEZXRlY3Rpb25zIHx8IChmb3JtYXRzID0gYXdhaXQgZGV0ZWN0aW9uLnJlbW92ZShmb3JtYXRzKSk7XG4gICAgcmV0dXJuIGZvcm1hdHMgPSBmb3JtYXRzLmZpbHRlcigoZm9ybWF0LCBpbmRleCkgPT4gZm9ybWF0cy5pbmRleE9mKGZvcm1hdCkgPT09IGluZGV4KSwgZm9ybWF0cztcbiAgfVxuICAvKiogQWxsIHRoZSBkZXRlY3Rpb24gcGFyc2VycyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIEFzc2V0cyBjbGFzcy4gKi9cbiAgZ2V0IGRldGVjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RldGVjdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMi4wXG4gICAqIEBzZWUge0BsaW5rIEFzc2V0cy5zZXRQcmVmZXJlbmNlc31cbiAgICovXG4gIGdldCBwcmVmZXJXb3JrZXJzKCkge1xuICAgIHJldHVybiBsb2FkVGV4dHVyZXMubG9hZFRleHR1cmVzLmNvbmZpZy5wcmVmZXJXb3JrZXJzO1xuICB9XG4gIHNldCBwcmVmZXJXb3JrZXJzKHZhbHVlKSB7XG4gICAgY29yZS51dGlscy5kZXByZWNhdGlvbihcIjcuMi4wXCIsIFwiQXNzZXRzLnByZWZlcnNXb3JrZXJzIGlzIGRlcHJlY2F0ZWQsIHVzZSBBc3NldHMuc2V0UHJlZmVyZW5jZXMoeyBwcmVmZXJXb3JrZXJzOiB0cnVlIH0pIGluc3RlYWQuXCIpLCB0aGlzLnNldFByZWZlcmVuY2VzKHsgcHJlZmVyV29ya2VyczogdmFsdWUgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYWwgc2V0dGVyIGZvciBwcmVmZXJlbmNlcy4gVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiB0byBzZXQgcHJlZmVyZW5jZXMgb24gYWxsIHBhcnNlcnMuXG4gICAqIEBwYXJhbSBwcmVmZXJlbmNlcyAtIHRoZSBwcmVmZXJlbmNlcyB0byBzZXRcbiAgICovXG4gIHNldFByZWZlcmVuY2VzKHByZWZlcmVuY2VzKSB7XG4gICAgdGhpcy5sb2FkZXIucGFyc2Vycy5mb3JFYWNoKChwYXJzZXIpID0+IHtcbiAgICAgIHBhcnNlci5jb25maWcgJiYgT2JqZWN0LmtleXMocGFyc2VyLmNvbmZpZykuZmlsdGVyKChrZXkpID0+IGtleSBpbiBwcmVmZXJlbmNlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIHBhcnNlci5jb25maWdba2V5XSA9IHByZWZlcmVuY2VzW2tleV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgQXNzZXRzID0gbmV3IEFzc2V0c0NsYXNzKCk7XG5jb3JlLmV4dGVuc2lvbnMuaGFuZGxlQnlMaXN0KGNvcmUuRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLCBBc3NldHMubG9hZGVyLnBhcnNlcnMpLmhhbmRsZUJ5TGlzdChjb3JlLkV4dGVuc2lvblR5cGUuUmVzb2x2ZVBhcnNlciwgQXNzZXRzLnJlc29sdmVyLnBhcnNlcnMpLmhhbmRsZUJ5TGlzdChjb3JlLkV4dGVuc2lvblR5cGUuQ2FjaGVQYXJzZXIsIEFzc2V0cy5jYWNoZS5wYXJzZXJzKS5oYW5kbGVCeUxpc3QoY29yZS5FeHRlbnNpb25UeXBlLkRldGVjdGlvblBhcnNlciwgQXNzZXRzLmRldGVjdGlvbnMpO1xuZXhwb3J0cy5Bc3NldHMgPSBBc3NldHM7XG5leHBvcnRzLkFzc2V0c0NsYXNzID0gQXNzZXRzQ2xhc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3NldHMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJhY2tncm91bmRMb2FkZXIge1xuICAvKipcbiAgICogQHBhcmFtIGxvYWRlclxuICAgKiBAcGFyYW0gdmVyYm9zZSAtIHNob3VsZCB0aGUgbG9hZGVyIGxvZyB0byB0aGUgY29uc29sZVxuICAgKi9cbiAgY29uc3RydWN0b3IobG9hZGVyLCB2ZXJib3NlID0gITEpIHtcbiAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXIsIHRoaXMuX2Fzc2V0TGlzdCA9IFtdLCB0aGlzLl9pc0xvYWRpbmcgPSAhMSwgdGhpcy5fbWF4Q29uY3VycmVudCA9IDEsIHRoaXMudmVyYm9zZSA9IHZlcmJvc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gYXJyYXkgb2YgYXNzZXRzIHRvIGxvYWQuXG4gICAqIEBwYXJhbSBhc3NldFVybHMgLSBhc3NldHMgdG8gbG9hZFxuICAgKi9cbiAgYWRkKGFzc2V0VXJscykge1xuICAgIGFzc2V0VXJscy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICB0aGlzLl9hc3NldExpc3QucHVzaChhKTtcbiAgICB9KSwgdGhpcy52ZXJib3NlICYmIGNvbnNvbGUubG9nKFwiW0JhY2tncm91bmRMb2FkZXJdIGFzc2V0czogXCIsIHRoaXMuX2Fzc2V0TGlzdCksIHRoaXMuX2lzQWN0aXZlICYmICF0aGlzLl9pc0xvYWRpbmcgJiYgdGhpcy5fbmV4dCgpO1xuICB9XG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgbmV4dCBzZXQgb2YgYXNzZXRzLiBXaWxsIHRyeSB0byBsb2FkIGFzIG1hbnkgYXNzZXRzIGFzIGl0IGNhbiBhdCB0aGUgc2FtZSB0aW1lLlxuICAgKlxuICAgKiBUaGUgbWF4IGFzc2V0cyBpdCB3aWxsIHRyeSB0byBsb2FkIGF0IG9uZSB0aW1lIHdpbGwgYmUgNC5cbiAgICovXG4gIGFzeW5jIF9uZXh0KCkge1xuICAgIGlmICh0aGlzLl9hc3NldExpc3QubGVuZ3RoICYmIHRoaXMuX2lzQWN0aXZlKSB7XG4gICAgICB0aGlzLl9pc0xvYWRpbmcgPSAhMDtcbiAgICAgIGNvbnN0IHRvTG9hZCA9IFtdLCB0b0xvYWRBbW91bnQgPSBNYXRoLm1pbih0aGlzLl9hc3NldExpc3QubGVuZ3RoLCB0aGlzLl9tYXhDb25jdXJyZW50KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9Mb2FkQW1vdW50OyBpKyspXG4gICAgICAgIHRvTG9hZC5wdXNoKHRoaXMuX2Fzc2V0TGlzdC5wb3AoKSk7XG4gICAgICBhd2FpdCB0aGlzLl9sb2FkZXIubG9hZCh0b0xvYWQpLCB0aGlzLl9pc0xvYWRpbmcgPSAhMSwgdGhpcy5fbmV4dCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGUvRGVhY3RpdmF0ZSB0aGUgbG9hZGluZy4gSWYgc2V0IHRvIHRydWUgdGhlbiBpdCB3aWxsIGltbWVkaWF0ZWx5IGNvbnRpbnVlIHRvIGxvYWQgdGhlIG5leHQgYXNzZXQuXG4gICAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGNsYXNzIGlzIGFjdGl2ZVxuICAgKi9cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNBY3RpdmU7XG4gIH1cbiAgc2V0IGFjdGl2ZSh2YWx1ZSkge1xuICAgIHRoaXMuX2lzQWN0aXZlICE9PSB2YWx1ZSAmJiAodGhpcy5faXNBY3RpdmUgPSB2YWx1ZSwgdmFsdWUgJiYgIXRoaXMuX2lzTG9hZGluZyAmJiB0aGlzLl9uZXh0KCkpO1xuICB9XG59XG5leHBvcnRzLkJhY2tncm91bmRMb2FkZXIgPSBCYWNrZ3JvdW5kTG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFja2dyb3VuZExvYWRlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKTtcbnJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbnZhciBjb252ZXJ0VG9MaXN0ID0gcmVxdWlyZShcIi4uL3V0aWxzL2NvbnZlcnRUb0xpc3QuanNcIik7XG5jbGFzcyBDYWNoZUNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcGFyc2VycyA9IFtdLCB0aGlzLl9jYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuX2NhY2hlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAvKiogQ2xlYXIgYWxsIGVudHJpZXMuICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX2NhY2hlTWFwLmNsZWFyKCksIHRoaXMuX2NhY2hlLmNsZWFyKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBrZXkgZXhpc3RzXG4gICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIGNoZWNrXG4gICAqL1xuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLmhhcyhrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBlbnRyeSBieSBrZXlcbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGdldFxuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NhY2hlLmdldChrZXkpO1xuICAgIHJldHVybiByZXN1bHQgfHwgY29uc29sZS53YXJuKGBbQXNzZXRzXSBBc3NldCBpZCAke2tleX0gd2FzIG5vdCBmb3VuZCBpbiB0aGUgQ2FjaGVgKSwgcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSB2YWx1ZSBieSBrZXkgb3Iga2V5cyBuYW1lXG4gICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9yIGtleXMgdG8gc2V0XG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzdG9yZSBpbiB0aGUgY2FjaGUgb3IgZnJvbSB3aGljaCBjYWNoZWFibGUgYXNzZXRzIHdpbGwgYmUgZGVyaXZlZC5cbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qga2V5cyA9IGNvbnZlcnRUb0xpc3QuY29udmVydFRvTGlzdChrZXkpO1xuICAgIGxldCBjYWNoZWFibGVBc3NldHM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcnNlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2Vyc1tpXTtcbiAgICAgIGlmIChwYXJzZXIudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgY2FjaGVhYmxlQXNzZXRzID0gcGFyc2VyLmdldENhY2hlYWJsZUFzc2V0cyhrZXlzLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjYWNoZWFibGVBc3NldHMgfHwgKGNhY2hlYWJsZUFzc2V0cyA9IHt9LCBrZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIGNhY2hlYWJsZUFzc2V0c1trZXkyXSA9IHZhbHVlO1xuICAgIH0pKTtcbiAgICBjb25zdCBjYWNoZUtleXMgPSBPYmplY3Qua2V5cyhjYWNoZWFibGVBc3NldHMpLCBjYWNoZWRBc3NldHMgPSB7XG4gICAgICBjYWNoZUtleXMsXG4gICAgICBrZXlzXG4gICAgfTtcbiAgICBpZiAoa2V5cy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICB0aGlzLl9jYWNoZU1hcC5zZXQoa2V5MiwgY2FjaGVkQXNzZXRzKTtcbiAgICB9KSwgY2FjaGVLZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIHRoaXMuX2NhY2hlLmhhcyhrZXkyKSAmJiB0aGlzLl9jYWNoZS5nZXQoa2V5MikgIT09IHZhbHVlICYmIGNvbnNvbGUud2FybihcIltDYWNoZV0gYWxyZWFkeSBoYXMga2V5OlwiLCBrZXkyKSwgdGhpcy5fY2FjaGUuc2V0KGtleTIsIGNhY2hlYWJsZUFzc2V0c1trZXkyXSk7XG4gICAgfSksIHZhbHVlIGluc3RhbmNlb2YgY29yZS5UZXh0dXJlKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gdmFsdWU7XG4gICAgICBrZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZSAhPT0gY29yZS5UZXh0dXJlLkVNUFRZLmJhc2VUZXh0dXJlICYmIGNvcmUuQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBrZXkyKSwgY29yZS5UZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwga2V5Mik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBlbnRyeSBieSBrZXlcbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGFsc28gcmVtb3ZlIGFueSBhc3NvY2lhdGVkIGFsaWFzIGZyb20gdGhlIGNhY2hlIGFsc28uXG4gICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZShrZXkpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlTWFwLmhhcyhrZXkpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFtBc3NldHNdIEFzc2V0IGlkICR7a2V5fSB3YXMgbm90IGZvdW5kIGluIHRoZSBDYWNoZWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZU1hcCA9IHRoaXMuX2NhY2hlTWFwLmdldChrZXkpO1xuICAgIGNhY2hlTWFwLmNhY2hlS2V5cy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICB0aGlzLl9jYWNoZS5kZWxldGUoa2V5Mik7XG4gICAgfSksIGNhY2hlTWFwLmtleXMuZm9yRWFjaCgoa2V5MikgPT4ge1xuICAgICAgdGhpcy5fY2FjaGVNYXAuZGVsZXRlKGtleTIpO1xuICAgIH0pO1xuICB9XG4gIC8qKiBBbGwgbG9hZGVyIHBhcnNlcnMgcmVnaXN0ZXJlZCAqL1xuICBnZXQgcGFyc2VycygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VycztcbiAgfVxufVxuY29uc3QgQ2FjaGUgPSBuZXcgQ2FjaGVDbGFzcygpO1xuZXhwb3J0cy5DYWNoZSA9IENhY2hlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FjaGUuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhY2hlUGFyc2VyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQ2FjaGUgPSByZXF1aXJlKFwiLi9DYWNoZS5qc1wiKTtcbnJlcXVpcmUoXCIuL0NhY2hlUGFyc2VyLmpzXCIpO1xucmVxdWlyZShcIi4vcGFyc2Vycy9pbmRleC5qc1wiKTtcbmV4cG9ydHMuQ2FjaGUgPSBDYWNoZS5DYWNoZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpO1xuY29uc3QgY2FjaGVUZXh0dXJlQXJyYXkgPSB7XG4gIGV4dGVuc2lvbjogY29yZS5FeHRlbnNpb25UeXBlLkNhY2hlUGFyc2VyLFxuICB0ZXN0OiAoYXNzZXQpID0+IEFycmF5LmlzQXJyYXkoYXNzZXQpICYmIGFzc2V0LmV2ZXJ5KCh0KSA9PiB0IGluc3RhbmNlb2YgY29yZS5UZXh0dXJlKSxcbiAgZ2V0Q2FjaGVhYmxlQXNzZXRzOiAoa2V5cywgYXNzZXQpID0+IHtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICByZXR1cm4ga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGFzc2V0LmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgb3V0W2tleSArIChpID09PSAwID8gXCJcIiA6IGkgKyAxKV0gPSBpdGVtO1xuICAgICAgfSk7XG4gICAgfSksIG91dDtcbiAgfVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQoY2FjaGVUZXh0dXJlQXJyYXkpO1xuZXhwb3J0cy5jYWNoZVRleHR1cmVBcnJheSA9IGNhY2hlVGV4dHVyZUFycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FjaGVUZXh0dXJlQXJyYXkuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjYWNoZVRleHR1cmVBcnJheSA9IHJlcXVpcmUoXCIuL2NhY2hlVGV4dHVyZUFycmF5LmpzXCIpO1xuZXhwb3J0cy5jYWNoZVRleHR1cmVBcnJheSA9IGNhY2hlVGV4dHVyZUFycmF5LmNhY2hlVGV4dHVyZUFycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnJlcXVpcmUoXCIuL3BhcnNlcnMvaW5kZXguanNcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgdGVzdEltYWdlRm9ybWF0ID0gcmVxdWlyZShcIi4uL3V0aWxzL3Rlc3RJbWFnZUZvcm1hdC5qc1wiKTtcbmNvbnN0IGRldGVjdEF2aWYgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IGNvcmUuRXh0ZW5zaW9uVHlwZS5EZXRlY3Rpb25QYXJzZXIsXG4gICAgcHJpb3JpdHk6IDFcbiAgfSxcbiAgdGVzdDogYXN5bmMgKCkgPT4gdGVzdEltYWdlRm9ybWF0LnRlc3RJbWFnZUZvcm1hdChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIFwiZGF0YTppbWFnZS9hdmlmO2Jhc2U2NCxBQUFBSUdaMGVYQmhkbWxtQUFBQUFHRjJhV1p0YVdZeGJXbGhaazFCTVVJQUFBRHliV1YwWVFBQUFBQUFBQUFvYUdSc2NnQUFBQUFBQUFBQWNHbGpkQUFBQUFBQUFBQUFBQUFBQUd4cFltRjJhV1lBQUFBQURuQnBkRzBBQUFBQUFBRUFBQUFlYVd4dll3QUFBQUJFQUFBQkFBRUFBQUFCQUFBQkdnQUFBQjBBQUFBb2FXbHVaZ0FBQUFBQUFRQUFBQnBwYm1abEFnQUFBQUFCQUFCaGRqQXhRMjlzYjNJQUFBQUFhbWx3Y25BQUFBQkxhWEJqYndBQUFCUnBjM0JsQUFBQUFBQUFBQUlBQUFBQ0FBQUFFSEJwZUdrQUFBQUFBd2dJQ0FBQUFBeGhkakZEZ1EwTUFBQUFBQk5qYjJ4eWJtTnNlQUFDQUFJQUFZQUFBQUFYYVhCdFlRQUFBQUFBQUFBQkFBRUVBUUtEQkFBQUFDVnRaR0YwRWdBS0NCZ0FOb2dRRUF3Z01nOGY4RC8vLzhXZmh3QjgrRXJLNDJBPVwiXG4gICksXG4gIGFkZDogYXN5bmMgKGZvcm1hdHMpID0+IFsuLi5mb3JtYXRzLCBcImF2aWZcIl0sXG4gIHJlbW92ZTogYXN5bmMgKGZvcm1hdHMpID0+IGZvcm1hdHMuZmlsdGVyKChmKSA9PiBmICE9PSBcImF2aWZcIilcbn07XG5jb3JlLmV4dGVuc2lvbnMuYWRkKGRldGVjdEF2aWYpO1xuZXhwb3J0cy5kZXRlY3RBdmlmID0gZGV0ZWN0QXZpZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdEF2aWYuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIik7XG5jb25zdCBpbWFnZUZvcm1hdHMgPSBbXCJwbmdcIiwgXCJqcGdcIiwgXCJqcGVnXCJdLCBkZXRlY3REZWZhdWx0cyA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLkRldGVjdGlvblBhcnNlcixcbiAgICBwcmlvcml0eTogLTFcbiAgfSxcbiAgdGVzdDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCEwKSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4gWy4uLmZvcm1hdHMsIC4uLmltYWdlRm9ybWF0c10sXG4gIHJlbW92ZTogYXN5bmMgKGZvcm1hdHMpID0+IGZvcm1hdHMuZmlsdGVyKChmKSA9PiAhaW1hZ2VGb3JtYXRzLmluY2x1ZGVzKGYpKVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQoZGV0ZWN0RGVmYXVsdHMpO1xuZXhwb3J0cy5kZXRlY3REZWZhdWx0cyA9IGRldGVjdERlZmF1bHRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZWN0RGVmYXVsdHMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIHRlc3RWaWRlb0Zvcm1hdCA9IHJlcXVpcmUoXCIuLi91dGlscy90ZXN0VmlkZW9Gb3JtYXQuanNcIik7XG5jb25zdCBkZXRlY3RNcDQgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IGNvcmUuRXh0ZW5zaW9uVHlwZS5EZXRlY3Rpb25QYXJzZXIsXG4gICAgcHJpb3JpdHk6IDBcbiAgfSxcbiAgdGVzdDogYXN5bmMgKCkgPT4gdGVzdFZpZGVvRm9ybWF0LnRlc3RWaWRlb0Zvcm1hdChcInZpZGVvL21wNFwiKSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4gWy4uLmZvcm1hdHMsIFwibXA0XCIsIFwibTR2XCJdLFxuICByZW1vdmU6IGFzeW5jIChmb3JtYXRzKSA9PiBmb3JtYXRzLmZpbHRlcigoZikgPT4gZiAhPT0gXCJtcDRcIiAmJiBmICE9PSBcIm00dlwiKVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQoZGV0ZWN0TXA0KTtcbmV4cG9ydHMuZGV0ZWN0TXA0ID0gZGV0ZWN0TXA0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZWN0TXA0LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCB0ZXN0VmlkZW9Gb3JtYXQgPSByZXF1aXJlKFwiLi4vdXRpbHMvdGVzdFZpZGVvRm9ybWF0LmpzXCIpO1xuY29uc3QgZGV0ZWN0T2d2ID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBjb3JlLkV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAwXG4gIH0sXG4gIHRlc3Q6IGFzeW5jICgpID0+IHRlc3RWaWRlb0Zvcm1hdC50ZXN0VmlkZW9Gb3JtYXQoXCJ2aWRlby9vZ2dcIiksXG4gIGFkZDogYXN5bmMgKGZvcm1hdHMpID0+IFsuLi5mb3JtYXRzLCBcIm9ndlwiXSxcbiAgcmVtb3ZlOiBhc3luYyAoZm9ybWF0cykgPT4gZm9ybWF0cy5maWx0ZXIoKGYpID0+IGYgIT09IFwib2d2XCIpXG59O1xuY29yZS5leHRlbnNpb25zLmFkZChkZXRlY3RPZ3YpO1xuZXhwb3J0cy5kZXRlY3RPZ3YgPSBkZXRlY3RPZ3Y7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3RPZ3YuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIHRlc3RWaWRlb0Zvcm1hdCA9IHJlcXVpcmUoXCIuLi91dGlscy90ZXN0VmlkZW9Gb3JtYXQuanNcIik7XG5jb25zdCBkZXRlY3RXZWJtID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBjb3JlLkV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAwXG4gIH0sXG4gIHRlc3Q6IGFzeW5jICgpID0+IHRlc3RWaWRlb0Zvcm1hdC50ZXN0VmlkZW9Gb3JtYXQoXCJ2aWRlby93ZWJtXCIpLFxuICBhZGQ6IGFzeW5jIChmb3JtYXRzKSA9PiBbLi4uZm9ybWF0cywgXCJ3ZWJtXCJdLFxuICByZW1vdmU6IGFzeW5jIChmb3JtYXRzKSA9PiBmb3JtYXRzLmZpbHRlcigoZikgPT4gZiAhPT0gXCJ3ZWJtXCIpXG59O1xuY29yZS5leHRlbnNpb25zLmFkZChkZXRlY3RXZWJtKTtcbmV4cG9ydHMuZGV0ZWN0V2VibSA9IGRldGVjdFdlYm07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3RXZWJtLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCB0ZXN0SW1hZ2VGb3JtYXQgPSByZXF1aXJlKFwiLi4vdXRpbHMvdGVzdEltYWdlRm9ybWF0LmpzXCIpO1xuY29uc3QgZGV0ZWN0V2VicCA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLkRldGVjdGlvblBhcnNlcixcbiAgICBwcmlvcml0eTogMFxuICB9LFxuICB0ZXN0OiBhc3luYyAoKSA9PiB0ZXN0SW1hZ2VGb3JtYXQudGVzdEltYWdlRm9ybWF0KFxuICAgIFwiZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmg0QUFBQlhSVUpRVmxBNFRCRUFBQUF2QUFBQUFBZlEvLzczdi8rQmlPaC9BQUE9XCJcbiAgKSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4gWy4uLmZvcm1hdHMsIFwid2VicFwiXSxcbiAgcmVtb3ZlOiBhc3luYyAoZm9ybWF0cykgPT4gZm9ybWF0cy5maWx0ZXIoKGYpID0+IGYgIT09IFwid2VicFwiKVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQoZGV0ZWN0V2VicCk7XG5leHBvcnRzLmRldGVjdFdlYnAgPSBkZXRlY3RXZWJwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZWN0V2VicC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGRldGVjdEF2aWYgPSByZXF1aXJlKFwiLi9kZXRlY3RBdmlmLmpzXCIpLCBkZXRlY3RXZWJwID0gcmVxdWlyZShcIi4vZGV0ZWN0V2VicC5qc1wiKSwgZGV0ZWN0RGVmYXVsdHMgPSByZXF1aXJlKFwiLi9kZXRlY3REZWZhdWx0cy5qc1wiKSwgZGV0ZWN0V2VibSA9IHJlcXVpcmUoXCIuL2RldGVjdFdlYm0uanNcIiksIGRldGVjdE1wNCA9IHJlcXVpcmUoXCIuL2RldGVjdE1wNC5qc1wiKSwgZGV0ZWN0T2d2ID0gcmVxdWlyZShcIi4vZGV0ZWN0T2d2LmpzXCIpO1xuZXhwb3J0cy5kZXRlY3RBdmlmID0gZGV0ZWN0QXZpZi5kZXRlY3RBdmlmO1xuZXhwb3J0cy5kZXRlY3RXZWJwID0gZGV0ZWN0V2VicC5kZXRlY3RXZWJwO1xuZXhwb3J0cy5kZXRlY3REZWZhdWx0cyA9IGRldGVjdERlZmF1bHRzLmRldGVjdERlZmF1bHRzO1xuZXhwb3J0cy5kZXRlY3RXZWJtID0gZGV0ZWN0V2VibS5kZXRlY3RXZWJtO1xuZXhwb3J0cy5kZXRlY3RNcDQgPSBkZXRlY3RNcDQuZGV0ZWN0TXA0O1xuZXhwb3J0cy5kZXRlY3RPZ3YgPSBkZXRlY3RPZ3YuZGV0ZWN0T2d2O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmFzeW5jIGZ1bmN0aW9uIHRlc3RJbWFnZUZvcm1hdChpbWFnZURhdGEpIHtcbiAgaWYgKFwiSW1hZ2VcIiBpbiBnbG9iYWxUaGlzKVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSghMCk7XG4gICAgICB9LCBpbWFnZS5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICByZXNvbHZlKCExKTtcbiAgICAgIH0sIGltYWdlLnNyYyA9IGltYWdlRGF0YTtcbiAgICB9KTtcbiAgaWYgKFwiY3JlYXRlSW1hZ2VCaXRtYXBcIiBpbiBnbG9iYWxUaGlzICYmIFwiZmV0Y2hcIiBpbiBnbG9iYWxUaGlzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCAoYXdhaXQgZmV0Y2goaW1hZ2VEYXRhKSkuYmxvYigpO1xuICAgICAgYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYik7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIHJldHVybiAhMDtcbiAgfVxuICByZXR1cm4gITE7XG59XG5leHBvcnRzLnRlc3RJbWFnZUZvcm1hdCA9IHRlc3RJbWFnZUZvcm1hdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlc3RJbWFnZUZvcm1hdC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgaW5Xb3JrZXIgPSBcIldvcmtlckdsb2JhbFNjb3BlXCIgaW4gZ2xvYmFsVGhpcyAmJiBnbG9iYWxUaGlzIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5Xb3JrZXJHbG9iYWxTY29wZTtcbmZ1bmN0aW9uIHRlc3RWaWRlb0Zvcm1hdChtaW1lVHlwZSkge1xuICByZXR1cm4gaW5Xb3JrZXIgPyAhMSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKS5jYW5QbGF5VHlwZShtaW1lVHlwZSkgIT09IFwiXCI7XG59XG5leHBvcnRzLnRlc3RWaWRlb0Zvcm1hdCA9IHRlc3RWaWRlb0Zvcm1hdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlc3RWaWRlb0Zvcm1hdC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xucmVxdWlyZShcIi4vQXNzZXRFeHRlbnNpb24uanNcIik7XG52YXIgQXNzZXRzID0gcmVxdWlyZShcIi4vQXNzZXRzLmpzXCIpO1xucmVxdWlyZShcIi4vY2FjaGUvaW5kZXguanNcIik7XG5yZXF1aXJlKFwiLi9kZXRlY3Rpb25zL2luZGV4LmpzXCIpO1xucmVxdWlyZShcIi4vbG9hZGVyL2luZGV4LmpzXCIpO1xucmVxdWlyZShcIi4vcmVzb2x2ZXIvaW5kZXguanNcIik7XG5yZXF1aXJlKFwiLi90eXBlcy5qc1wiKTtcbnJlcXVpcmUoXCIuL3V0aWxzL2luZGV4LmpzXCIpO1xudmFyIENhY2hlID0gcmVxdWlyZShcIi4vY2FjaGUvQ2FjaGUuanNcIiksIGNhY2hlVGV4dHVyZUFycmF5ID0gcmVxdWlyZShcIi4vY2FjaGUvcGFyc2Vycy9jYWNoZVRleHR1cmVBcnJheS5qc1wiKSwgZGV0ZWN0QXZpZiA9IHJlcXVpcmUoXCIuL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RBdmlmLmpzXCIpLCBkZXRlY3RXZWJwID0gcmVxdWlyZShcIi4vZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdFdlYnAuanNcIiksIGRldGVjdERlZmF1bHRzID0gcmVxdWlyZShcIi4vZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdERlZmF1bHRzLmpzXCIpLCBkZXRlY3RXZWJtID0gcmVxdWlyZShcIi4vZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdFdlYm0uanNcIiksIGRldGVjdE1wNCA9IHJlcXVpcmUoXCIuL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RNcDQuanNcIiksIGRldGVjdE9ndiA9IHJlcXVpcmUoXCIuL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RPZ3YuanNcIiksIExvYWRlclBhcnNlciA9IHJlcXVpcmUoXCIuL2xvYWRlci9wYXJzZXJzL0xvYWRlclBhcnNlci5qc1wiKSwgbG9hZEpzb24gPSByZXF1aXJlKFwiLi9sb2FkZXIvcGFyc2Vycy9sb2FkSnNvbi5qc1wiKSwgbG9hZFR4dCA9IHJlcXVpcmUoXCIuL2xvYWRlci9wYXJzZXJzL2xvYWRUeHQuanNcIiksIGxvYWRXZWJGb250ID0gcmVxdWlyZShcIi4vbG9hZGVyL3BhcnNlcnMvbG9hZFdlYkZvbnQuanNcIiksIGxvYWRTVkcgPSByZXF1aXJlKFwiLi9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy9sb2FkU1ZHLmpzXCIpLCBsb2FkVGV4dHVyZXMgPSByZXF1aXJlKFwiLi9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy9sb2FkVGV4dHVyZXMuanNcIiksIGxvYWRWaWRlbyA9IHJlcXVpcmUoXCIuL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRWaWRlby5qc1wiKSwgY3JlYXRlVGV4dHVyZSA9IHJlcXVpcmUoXCIuL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL3V0aWxzL2NyZWF0ZVRleHR1cmUuanNcIiksIHJlc29sdmVUZXh0dXJlVXJsID0gcmVxdWlyZShcIi4vcmVzb2x2ZXIvcGFyc2Vycy9yZXNvbHZlVGV4dHVyZVVybC5qc1wiKSwgY2hlY2tEYXRhVXJsID0gcmVxdWlyZShcIi4vdXRpbHMvY2hlY2tEYXRhVXJsLmpzXCIpLCBjaGVja0V4dGVuc2lvbiA9IHJlcXVpcmUoXCIuL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLmpzXCIpLCBjb252ZXJ0VG9MaXN0ID0gcmVxdWlyZShcIi4vdXRpbHMvY29udmVydFRvTGlzdC5qc1wiKSwgY29weVNlYXJjaFBhcmFtcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2NvcHlTZWFyY2hQYXJhbXMuanNcIiksIGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMgPSByZXF1aXJlKFwiLi91dGlscy9jcmVhdGVTdHJpbmdWYXJpYXRpb25zLmpzXCIpLCBpc1NpbmdsZUl0ZW0gPSByZXF1aXJlKFwiLi91dGlscy9pc1NpbmdsZUl0ZW0uanNcIik7XG5leHBvcnRzLkFzc2V0cyA9IEFzc2V0cy5Bc3NldHM7XG5leHBvcnRzLkFzc2V0c0NsYXNzID0gQXNzZXRzLkFzc2V0c0NsYXNzO1xuZXhwb3J0cy5DYWNoZSA9IENhY2hlLkNhY2hlO1xuZXhwb3J0cy5jYWNoZVRleHR1cmVBcnJheSA9IGNhY2hlVGV4dHVyZUFycmF5LmNhY2hlVGV4dHVyZUFycmF5O1xuZXhwb3J0cy5kZXRlY3RBdmlmID0gZGV0ZWN0QXZpZi5kZXRlY3RBdmlmO1xuZXhwb3J0cy5kZXRlY3RXZWJwID0gZGV0ZWN0V2VicC5kZXRlY3RXZWJwO1xuZXhwb3J0cy5kZXRlY3REZWZhdWx0cyA9IGRldGVjdERlZmF1bHRzLmRldGVjdERlZmF1bHRzO1xuZXhwb3J0cy5kZXRlY3RXZWJtID0gZGV0ZWN0V2VibS5kZXRlY3RXZWJtO1xuZXhwb3J0cy5kZXRlY3RNcDQgPSBkZXRlY3RNcDQuZGV0ZWN0TXA0O1xuZXhwb3J0cy5kZXRlY3RPZ3YgPSBkZXRlY3RPZ3YuZGV0ZWN0T2d2O1xuZXhwb3J0cy5Mb2FkZXJQYXJzZXJQcmlvcml0eSA9IExvYWRlclBhcnNlci5Mb2FkZXJQYXJzZXJQcmlvcml0eTtcbmV4cG9ydHMubG9hZEpzb24gPSBsb2FkSnNvbi5sb2FkSnNvbjtcbmV4cG9ydHMubG9hZFR4dCA9IGxvYWRUeHQubG9hZFR4dDtcbmV4cG9ydHMuZ2V0Rm9udEZhbWlseU5hbWUgPSBsb2FkV2ViRm9udC5nZXRGb250RmFtaWx5TmFtZTtcbmV4cG9ydHMubG9hZFdlYkZvbnQgPSBsb2FkV2ViRm9udC5sb2FkV2ViRm9udDtcbmV4cG9ydHMubG9hZFNWRyA9IGxvYWRTVkcubG9hZFNWRztcbmV4cG9ydHMubG9hZEltYWdlQml0bWFwID0gbG9hZFRleHR1cmVzLmxvYWRJbWFnZUJpdG1hcDtcbmV4cG9ydHMubG9hZFRleHR1cmVzID0gbG9hZFRleHR1cmVzLmxvYWRUZXh0dXJlcztcbmV4cG9ydHMubG9hZFZpZGVvID0gbG9hZFZpZGVvLmxvYWRWaWRlbztcbmV4cG9ydHMuY3JlYXRlVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUuY3JlYXRlVGV4dHVyZTtcbmV4cG9ydHMucmVzb2x2ZVRleHR1cmVVcmwgPSByZXNvbHZlVGV4dHVyZVVybC5yZXNvbHZlVGV4dHVyZVVybDtcbmV4cG9ydHMuY2hlY2tEYXRhVXJsID0gY2hlY2tEYXRhVXJsLmNoZWNrRGF0YVVybDtcbmV4cG9ydHMuY2hlY2tFeHRlbnNpb24gPSBjaGVja0V4dGVuc2lvbi5jaGVja0V4dGVuc2lvbjtcbmV4cG9ydHMuY29udmVydFRvTGlzdCA9IGNvbnZlcnRUb0xpc3QuY29udmVydFRvTGlzdDtcbmV4cG9ydHMuY29weVNlYXJjaFBhcmFtcyA9IGNvcHlTZWFyY2hQYXJhbXMuY29weVNlYXJjaFBhcmFtcztcbmV4cG9ydHMuY3JlYXRlU3RyaW5nVmFyaWF0aW9ucyA9IGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMuY3JlYXRlU3RyaW5nVmFyaWF0aW9ucztcbmV4cG9ydHMuaXNTaW5nbGVJdGVtID0gaXNTaW5nbGVJdGVtLmlzU2luZ2xlSXRlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpO1xucmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xudmFyIGlzU2luZ2xlSXRlbSA9IHJlcXVpcmUoXCIuLi91dGlscy9pc1NpbmdsZUl0ZW0uanNcIiksIGNvbnZlcnRUb0xpc3QgPSByZXF1aXJlKFwiLi4vdXRpbHMvY29udmVydFRvTGlzdC5qc1wiKTtcbmNsYXNzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3BhcnNlcnMgPSBbXSwgdGhpcy5fcGFyc2Vyc1ZhbGlkYXRlZCA9ICExLCB0aGlzLnBhcnNlcnMgPSBuZXcgUHJveHkodGhpcy5fcGFyc2Vycywge1xuICAgICAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlKSA9PiAodGhpcy5fcGFyc2Vyc1ZhbGlkYXRlZCA9ICExLCB0YXJnZXRba2V5XSA9IHZhbHVlLCAhMClcbiAgICB9KSwgdGhpcy5wcm9taXNlQ2FjaGUgPSB7fTtcbiAgfVxuICAvKiogZnVuY3Rpb24gdXNlZCBmb3IgdGVzdGluZyAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLl9wYXJzZXJzVmFsaWRhdGVkID0gITEsIHRoaXMucHJvbWlzZUNhY2hlID0ge307XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgaW50ZXJuYWxseSB0byBnZW5lcmF0ZSBhIHByb21pc2UgZm9yIHRoZSBhc3NldCB0byBiZSBsb2FkZWQuXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIGJlIGxvYWRlZFxuICAgKiBAcGFyYW0gZGF0YSAtIGFueSBjdXN0b20gYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWxldmFudCB0byB0aGUgYXNzZXQgYmVpbmcgbG9hZGVkXG4gICAqIEByZXR1cm5zIC0gYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHRvIGFuIEFzc2V0IGZvciBleGFtcGxlIGEgVGV4dHVyZSBvZiBhIEpTT04gb2JqZWN0XG4gICAqL1xuICBfZ2V0TG9hZFByb21pc2VBbmRQYXJzZXIodXJsLCBkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcHJvbWlzZTogbnVsbCxcbiAgICAgIHBhcnNlcjogbnVsbFxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdC5wcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBhc3NldCA9IG51bGwsIHBhcnNlciA9IG51bGw7XG4gICAgICBpZiAoZGF0YS5sb2FkUGFyc2VyICYmIChwYXJzZXIgPSB0aGlzLl9wYXJzZXJIYXNoW2RhdGEubG9hZFBhcnNlcl0sIHBhcnNlciB8fCBjb25zb2xlLndhcm4oYFtBc3NldHNdIHNwZWNpZmllZCBsb2FkIHBhcnNlciBcIiR7ZGF0YS5sb2FkUGFyc2VyfVwiIG5vdCBmb3VuZCB3aGlsZSBsb2FkaW5nICR7dXJsfWApKSwgIXBhcnNlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBhcnNlclggPSB0aGlzLnBhcnNlcnNbaV07XG4gICAgICAgICAgaWYgKHBhcnNlclgubG9hZCAmJiBwYXJzZXJYLnRlc3Q/Lih1cmwsIGRhdGEsIHRoaXMpKSB7XG4gICAgICAgICAgICBwYXJzZXIgPSBwYXJzZXJYO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyc2VyKVxuICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYFtBc3NldHNdICR7dXJsfSBjb3VsZCBub3QgYmUgbG9hZGVkIGFzIHdlIGRvbid0IGtub3cgaG93IHRvIHBhcnNlIGl0LCBlbnN1cmUgdGhlIGNvcnJlY3QgcGFyc2VyIGhhcyBiZWVuIGFkZGVkYCksIG51bGw7XG4gICAgICB9XG4gICAgICBhc3NldCA9IGF3YWl0IHBhcnNlci5sb2FkKHVybCwgZGF0YSwgdGhpcyksIHJlc3VsdC5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJzZXIyID0gdGhpcy5wYXJzZXJzW2ldO1xuICAgICAgICBwYXJzZXIyLnBhcnNlICYmIHBhcnNlcjIucGFyc2UgJiYgYXdhaXQgcGFyc2VyMi50ZXN0UGFyc2U/Lihhc3NldCwgZGF0YSwgdGhpcykgJiYgKGFzc2V0ID0gYXdhaXQgcGFyc2VyMi5wYXJzZShhc3NldCwgZGF0YSwgdGhpcykgfHwgYXNzZXQsIHJlc3VsdC5wYXJzZXIgPSBwYXJzZXIyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhc3NldDtcbiAgICB9KSgpLCByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgbG9hZChhc3NldHNUb0xvYWRJbiwgb25Qcm9ncmVzcykge1xuICAgIHRoaXMuX3BhcnNlcnNWYWxpZGF0ZWQgfHwgdGhpcy5fdmFsaWRhdGVQYXJzZXJzKCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCBhc3NldHMgPSB7fSwgc2luZ2xlQXNzZXQgPSBpc1NpbmdsZUl0ZW0uaXNTaW5nbGVJdGVtKGFzc2V0c1RvTG9hZEluKSwgYXNzZXRzVG9Mb2FkID0gY29udmVydFRvTGlzdC5jb252ZXJ0VG9MaXN0KGFzc2V0c1RvTG9hZEluLCAoaXRlbSkgPT4gKHtcbiAgICAgIGFsaWFzOiBbaXRlbV0sXG4gICAgICBzcmM6IGl0ZW1cbiAgICB9KSksIHRvdGFsID0gYXNzZXRzVG9Mb2FkLmxlbmd0aCwgcHJvbWlzZXMgPSBhc3NldHNUb0xvYWQubWFwKGFzeW5jIChhc3NldCkgPT4ge1xuICAgICAgY29uc3QgdXJsID0gY29yZS51dGlscy5wYXRoLnRvQWJzb2x1dGUoYXNzZXQuc3JjKTtcbiAgICAgIGlmICghYXNzZXRzW2Fzc2V0LnNyY10pXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5wcm9taXNlQ2FjaGVbdXJsXSB8fCAodGhpcy5wcm9taXNlQ2FjaGVbdXJsXSA9IHRoaXMuX2dldExvYWRQcm9taXNlQW5kUGFyc2VyKHVybCwgYXNzZXQpKSwgYXNzZXRzW2Fzc2V0LnNyY10gPSBhd2FpdCB0aGlzLnByb21pc2VDYWNoZVt1cmxdLnByb21pc2UsIG9uUHJvZ3Jlc3MgJiYgb25Qcm9ncmVzcygrK2NvdW50IC8gdG90YWwpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZGVsZXRlIHRoaXMucHJvbWlzZUNhY2hlW3VybF0sIGRlbGV0ZSBhc3NldHNbYXNzZXQuc3JjXSwgbmV3IEVycm9yKGBbTG9hZGVyLmxvYWRdIEZhaWxlZCB0byBsb2FkICR7dXJsfS5cbiR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyksIHNpbmdsZUFzc2V0ID8gYXNzZXRzW2Fzc2V0c1RvTG9hZFswXS5zcmNdIDogYXNzZXRzO1xuICB9XG4gIC8qKlxuICAgKiBVbmxvYWRzIG9uZSBvciBtb3JlIGFzc2V0cy4gQW55IHVubG9hZGVkIGFzc2V0cyB3aWxsIGJlIGRlc3Ryb3llZCwgZnJlZWluZyB1cCBtZW1vcnkgZm9yIHlvdXIgYXBwLlxuICAgKiBUaGUgcGFyc2VyIHRoYXQgY3JlYXRlZCB0aGUgYXNzZXQsIHdpbGwgYmUgdGhlIG9uZSB0aGF0IHVubG9hZHMgaXQuXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNpbmdsZSBhc3NldDpcbiAgICogY29uc3QgYXNzZXQgPSBhd2FpdCBMb2FkZXIubG9hZCgnY29vbC5wbmcnKTtcbiAgICpcbiAgICogYXdhaXQgTG9hZGVyLnVubG9hZCgnY29vbC5wbmcnKTtcbiAgICpcbiAgICogY29uc29sZS5sb2coYXNzZXQuZGVzdHJveWVkKTsgLy8gdHJ1ZVxuICAgKiBAcGFyYW0gYXNzZXRzVG9VbmxvYWRJbiAtIHVybHMgdGhhdCB5b3Ugd2FudCB0byB1bmxvYWQsIG9yIGEgc2luZ2xlIG9uZSFcbiAgICovXG4gIGFzeW5jIHVubG9hZChhc3NldHNUb1VubG9hZEluKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBjb252ZXJ0VG9MaXN0LmNvbnZlcnRUb0xpc3QoYXNzZXRzVG9VbmxvYWRJbiwgKGl0ZW0pID0+ICh7XG4gICAgICBhbGlhczogW2l0ZW1dLFxuICAgICAgc3JjOiBpdGVtXG4gICAgfSkpLm1hcChhc3luYyAoYXNzZXQpID0+IHtcbiAgICAgIGNvbnN0IHVybCA9IGNvcmUudXRpbHMucGF0aC50b0Fic29sdXRlKGFzc2V0LnNyYyksIGxvYWRQcm9taXNlID0gdGhpcy5wcm9taXNlQ2FjaGVbdXJsXTtcbiAgICAgIGlmIChsb2FkUHJvbWlzZSkge1xuICAgICAgICBjb25zdCBsb2FkZWRBc3NldCA9IGF3YWl0IGxvYWRQcm9taXNlLnByb21pc2U7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnByb21pc2VDYWNoZVt1cmxdLCBsb2FkUHJvbWlzZS5wYXJzZXI/LnVubG9hZD8uKGxvYWRlZEFzc2V0LCBhc3NldCwgdGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG4gIC8qKiB2YWxpZGF0ZXMgb3VyIHBhcnNlcnMsIHJpZ2h0IG5vdyBpdCBvbmx5IGNoZWNrcyBmb3IgbmFtZSBjb25mbGljdHMgYnV0IHdlIGNhbiBhZGQgbW9yZSBoZXJlIGFzIHJlcXVpcmVkISAqL1xuICBfdmFsaWRhdGVQYXJzZXJzKCkge1xuICAgIHRoaXMuX3BhcnNlcnNWYWxpZGF0ZWQgPSAhMCwgdGhpcy5fcGFyc2VySGFzaCA9IHRoaXMuX3BhcnNlcnMuZmlsdGVyKChwYXJzZXIpID0+IHBhcnNlci5uYW1lKS5yZWR1Y2UoKGhhc2gsIHBhcnNlcikgPT4gKGhhc2hbcGFyc2VyLm5hbWVdICYmIGNvbnNvbGUud2FybihgW0Fzc2V0c10gbG9hZFBhcnNlciBuYW1lIGNvbmZsaWN0IFwiJHtwYXJzZXIubmFtZX1cImApLCB7IC4uLmhhc2gsIFtwYXJzZXIubmFtZV06IHBhcnNlciB9KSwge30pO1xuICB9XG59XG5leHBvcnRzLkxvYWRlciA9IExvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvYWRlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xucmVxdWlyZShcIi4vcGFyc2Vycy9pbmRleC5qc1wiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgTG9hZGVyUGFyc2VyUHJpb3JpdHkgPSAvKiBAX19QVVJFX18gKi8gKChMb2FkZXJQYXJzZXJQcmlvcml0eTIpID0+IChMb2FkZXJQYXJzZXJQcmlvcml0eTJbTG9hZGVyUGFyc2VyUHJpb3JpdHkyLkxvdyA9IDBdID0gXCJMb3dcIiwgTG9hZGVyUGFyc2VyUHJpb3JpdHkyW0xvYWRlclBhcnNlclByaW9yaXR5Mi5Ob3JtYWwgPSAxXSA9IFwiTm9ybWFsXCIsIExvYWRlclBhcnNlclByaW9yaXR5MltMb2FkZXJQYXJzZXJQcmlvcml0eTIuSGlnaCA9IDJdID0gXCJIaWdoXCIsIExvYWRlclBhcnNlclByaW9yaXR5MikpKExvYWRlclBhcnNlclByaW9yaXR5IHx8IHt9KTtcbmV4cG9ydHMuTG9hZGVyUGFyc2VyUHJpb3JpdHkgPSBMb2FkZXJQYXJzZXJQcmlvcml0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvYWRlclBhcnNlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xubGV0IFVVSUQgPSAwLCBNQVhfV09SS0VSUztcbmNvbnN0IFdISVRFX1BORyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FRQUFBQzFIQXdDQUFBQUMwbEVRVlI0Mm1QOC94OEFBd01DQU8raXAxc0FBQUFBU1VWT1JLNUNZSUk9XCIsIGNoZWNrSW1hZ2VCaXRtYXBDb2RlID0ge1xuICBpZDogXCJjaGVja0ltYWdlQml0bWFwXCIsXG4gIGNvZGU6IGBcbiAgICBhc3luYyBmdW5jdGlvbiBjaGVja0ltYWdlQml0bWFwKClcbiAgICB7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJyR7V0hJVEVfUE5HfScpO1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VCbG9iID0gIGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlQml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2VCbG9iKTtcblxuICAgICAgICAgICAgcmV0dXJuIGltYWdlQml0bWFwLndpZHRoID09PSAxICYmIGltYWdlQml0bWFwLmhlaWdodCA9PT0gMTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrSW1hZ2VCaXRtYXAoKS50aGVuKChyZXN1bHQpID0+IHsgc2VsZi5wb3N0TWVzc2FnZShyZXN1bHQpOyB9KTtcbiAgICBgXG59LCB3b3JrZXJDb2RlID0ge1xuICBpZDogXCJsb2FkSW1hZ2VCaXRtYXBcIixcbiAgY29kZTogYFxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRJbWFnZUJpdG1hcCh1cmwpXG4gICAge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcYFtXb3JrZXJNYW5hZ2VyLmxvYWRJbWFnZUJpdG1hcF0gRmFpbGVkIHRvIGZldGNoIFxcJHt1cmx9OiBcXGBcbiAgICAgICAgICAgICAgICArIFxcYFxcJHtyZXNwb25zZS5zdGF0dXN9IFxcJHtyZXNwb25zZS5zdGF0dXNUZXh0fVxcYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbWFnZUJsb2IgPSAgYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlQmxvYik7XG5cbiAgICAgICAgcmV0dXJuIGltYWdlQml0bWFwO1xuICAgIH1cbiAgICBzZWxmLm9ubWVzc2FnZSA9IGFzeW5jIChldmVudCkgPT5cbiAgICB7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGxvYWRJbWFnZUJpdG1hcChldmVudC5kYXRhLmRhdGFbMF0pO1xuXG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBpbWFnZUJpdG1hcCxcbiAgICAgICAgICAgICAgICB1dWlkOiBldmVudC5kYXRhLnV1aWQsXG4gICAgICAgICAgICAgICAgaWQ6IGV2ZW50LmRhdGEuaWQsXG4gICAgICAgICAgICB9LCBbaW1hZ2VCaXRtYXBdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKVxuICAgICAgICB7XG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICB1dWlkOiBldmVudC5kYXRhLnV1aWQsXG4gICAgICAgICAgICAgICAgaWQ6IGV2ZW50LmRhdGEuaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07YFxufTtcbmxldCB3b3JrZXJVUkw7XG5jbGFzcyBXb3JrZXJNYW5hZ2VyQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9ICExLCB0aGlzLl9jcmVhdGVkV29ya2VycyA9IDAsIHRoaXMud29ya2VyUG9vbCA9IFtdLCB0aGlzLnF1ZXVlID0gW10sIHRoaXMucmVzb2x2ZUhhc2ggPSB7fTtcbiAgfVxuICBpc0ltYWdlQml0bWFwU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0ltYWdlQml0bWFwU3VwcG9ydGVkICE9PSB2b2lkIDAgPyB0aGlzLl9pc0ltYWdlQml0bWFwU3VwcG9ydGVkIDogKHRoaXMuX2lzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3Qgd29ya2VyVVJMMiA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoXG4gICAgICAgIFtjaGVja0ltYWdlQml0bWFwQ29kZS5jb2RlXSxcbiAgICAgICAgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiB9XG4gICAgICApKSwgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVUkwyKTtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpLCBVUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlclVSTDIpLCByZXNvbHZlKGV2ZW50LmRhdGEpO1xuICAgICAgfSk7XG4gICAgfSksIHRoaXMuX2lzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQpO1xuICB9XG4gIGxvYWRJbWFnZUJpdG1hcChzcmMpIHtcbiAgICByZXR1cm4gdGhpcy5fcnVuKFwibG9hZEltYWdlQml0bWFwXCIsIFtzcmNdKTtcbiAgfVxuICBhc3luYyBfaW5pdFdvcmtlcnMoKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgfHwgKHRoaXMuX2luaXRpYWxpemVkID0gITApO1xuICB9XG4gIGdldFdvcmtlcigpIHtcbiAgICBNQVhfV09SS0VSUyA9PT0gdm9pZCAwICYmIChNQVhfV09SS0VSUyA9IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5IHx8IDQpO1xuICAgIGxldCB3b3JrZXIgPSB0aGlzLndvcmtlclBvb2wucG9wKCk7XG4gICAgcmV0dXJuICF3b3JrZXIgJiYgdGhpcy5fY3JlYXRlZFdvcmtlcnMgPCBNQVhfV09SS0VSUyAmJiAod29ya2VyVVJMIHx8ICh3b3JrZXJVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt3b3JrZXJDb2RlLmNvZGVdLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiIH0pKSksIHRoaXMuX2NyZWF0ZWRXb3JrZXJzKyssIHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVVJMKSwgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5jb21wbGV0ZShldmVudC5kYXRhKSwgdGhpcy5yZXR1cm5Xb3JrZXIoZXZlbnQudGFyZ2V0KSwgdGhpcy5uZXh0KCk7XG4gICAgfSkpLCB3b3JrZXI7XG4gIH1cbiAgcmV0dXJuV29ya2VyKHdvcmtlcikge1xuICAgIHRoaXMud29ya2VyUG9vbC5wdXNoKHdvcmtlcik7XG4gIH1cbiAgY29tcGxldGUoZGF0YSkge1xuICAgIGRhdGEuZXJyb3IgIT09IHZvaWQgMCA/IHRoaXMucmVzb2x2ZUhhc2hbZGF0YS51dWlkXS5yZWplY3QoZGF0YS5lcnJvcikgOiB0aGlzLnJlc29sdmVIYXNoW2RhdGEudXVpZF0ucmVzb2x2ZShkYXRhLmRhdGEpLCB0aGlzLnJlc29sdmVIYXNoW2RhdGEudXVpZF0gPSBudWxsO1xuICB9XG4gIGFzeW5jIF9ydW4oaWQsIGFyZ3MpIHtcbiAgICBhd2FpdCB0aGlzLl9pbml0V29ya2VycygpO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goeyBpZCwgYXJndW1lbnRzOiBhcmdzLCByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMubmV4dCgpLCBwcm9taXNlO1xuICB9XG4gIG5leHQoKSB7XG4gICAgaWYgKCF0aGlzLnF1ZXVlLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB3b3JrZXIgPSB0aGlzLmdldFdvcmtlcigpO1xuICAgIGlmICghd29ya2VyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHRvRG8gPSB0aGlzLnF1ZXVlLnBvcCgpLCBpZCA9IHRvRG8uaWQ7XG4gICAgdGhpcy5yZXNvbHZlSGFzaFtVVUlEXSA9IHsgcmVzb2x2ZTogdG9Eby5yZXNvbHZlLCByZWplY3Q6IHRvRG8ucmVqZWN0IH0sIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICBkYXRhOiB0b0RvLmFyZ3VtZW50cyxcbiAgICAgIHV1aWQ6IFVVSUQrKyxcbiAgICAgIGlkXG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFdvcmtlck1hbmFnZXIgPSBuZXcgV29ya2VyTWFuYWdlckNsYXNzKCk7XG5leHBvcnRzLldvcmtlck1hbmFnZXIgPSBXb3JrZXJNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V29ya2VyTWFuYWdlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIExvYWRlclBhcnNlciA9IHJlcXVpcmUoXCIuL0xvYWRlclBhcnNlci5qc1wiKSwgbG9hZEpzb24gPSByZXF1aXJlKFwiLi9sb2FkSnNvbi5qc1wiKSwgbG9hZFR4dCA9IHJlcXVpcmUoXCIuL2xvYWRUeHQuanNcIiksIGxvYWRXZWJGb250ID0gcmVxdWlyZShcIi4vbG9hZFdlYkZvbnQuanNcIik7XG5yZXF1aXJlKFwiLi90ZXh0dXJlcy9pbmRleC5qc1wiKTtcbmV4cG9ydHMuTG9hZGVyUGFyc2VyUHJpb3JpdHkgPSBMb2FkZXJQYXJzZXIuTG9hZGVyUGFyc2VyUHJpb3JpdHk7XG5leHBvcnRzLmxvYWRKc29uID0gbG9hZEpzb24ubG9hZEpzb247XG5leHBvcnRzLmxvYWRUeHQgPSBsb2FkVHh0LmxvYWRUeHQ7XG5leHBvcnRzLmdldEZvbnRGYW1pbHlOYW1lID0gbG9hZFdlYkZvbnQuZ2V0Rm9udEZhbWlseU5hbWU7XG5leHBvcnRzLmxvYWRXZWJGb250ID0gbG9hZFdlYkZvbnQubG9hZFdlYkZvbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgY2hlY2tEYXRhVXJsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2NoZWNrRGF0YVVybC5qc1wiKSwgY2hlY2tFeHRlbnNpb24gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvY2hlY2tFeHRlbnNpb24uanNcIiksIExvYWRlclBhcnNlciA9IHJlcXVpcmUoXCIuL0xvYWRlclBhcnNlci5qc1wiKTtcbmNvbnN0IHZhbGlkSlNPTkV4dGVuc2lvbiA9IFwiLmpzb25cIiwgdmFsaWRKU09OTUlNRSA9IFwiYXBwbGljYXRpb24vanNvblwiLCBsb2FkSnNvbiA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlci5Mb2FkZXJQYXJzZXJQcmlvcml0eS5Mb3dcbiAgfSxcbiAgbmFtZTogXCJsb2FkSnNvblwiLFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiBjaGVja0RhdGFVcmwuY2hlY2tEYXRhVXJsKHVybCwgdmFsaWRKU09OTUlNRSkgfHwgY2hlY2tFeHRlbnNpb24uY2hlY2tFeHRlbnNpb24odXJsLCB2YWxpZEpTT05FeHRlbnNpb24pO1xuICB9LFxuICBhc3luYyBsb2FkKHVybCkge1xuICAgIHJldHVybiBhd2FpdCAoYXdhaXQgY29yZS5zZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCkpLmpzb24oKTtcbiAgfVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQobG9hZEpzb24pO1xuZXhwb3J0cy5sb2FkSnNvbiA9IGxvYWRKc29uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZEpzb24uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIGNoZWNrRGF0YVVybCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9jaGVja0RhdGFVcmwuanNcIiksIGNoZWNrRXh0ZW5zaW9uID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLmpzXCIpLCBMb2FkZXJQYXJzZXIgPSByZXF1aXJlKFwiLi9Mb2FkZXJQYXJzZXIuanNcIik7XG5jb25zdCB2YWxpZFRYVEV4dGVuc2lvbiA9IFwiLnR4dFwiLCB2YWxpZFRYVE1JTUUgPSBcInRleHQvcGxhaW5cIiwgbG9hZFR4dCA9IHtcbiAgbmFtZTogXCJsb2FkVHh0XCIsXG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IGNvcmUuRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXIuTG9hZGVyUGFyc2VyUHJpb3JpdHkuTG93XG4gIH0sXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIGNoZWNrRGF0YVVybC5jaGVja0RhdGFVcmwodXJsLCB2YWxpZFRYVE1JTUUpIHx8IGNoZWNrRXh0ZW5zaW9uLmNoZWNrRXh0ZW5zaW9uKHVybCwgdmFsaWRUWFRFeHRlbnNpb24pO1xuICB9LFxuICBhc3luYyBsb2FkKHVybCkge1xuICAgIHJldHVybiBhd2FpdCAoYXdhaXQgY29yZS5zZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCkpLnRleHQoKTtcbiAgfVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQobG9hZFR4dCk7XG5leHBvcnRzLmxvYWRUeHQgPSBsb2FkVHh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZFR4dC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgY2hlY2tEYXRhVXJsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2NoZWNrRGF0YVVybC5qc1wiKSwgY2hlY2tFeHRlbnNpb24gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvY2hlY2tFeHRlbnNpb24uanNcIiksIExvYWRlclBhcnNlciA9IHJlcXVpcmUoXCIuL0xvYWRlclBhcnNlci5qc1wiKTtcbmNvbnN0IHZhbGlkV2VpZ2h0cyA9IFtcbiAgXCJub3JtYWxcIixcbiAgXCJib2xkXCIsXG4gIFwiMTAwXCIsXG4gIFwiMjAwXCIsXG4gIFwiMzAwXCIsXG4gIFwiNDAwXCIsXG4gIFwiNTAwXCIsXG4gIFwiNjAwXCIsXG4gIFwiNzAwXCIsXG4gIFwiODAwXCIsXG4gIFwiOTAwXCJcbl0sIHZhbGlkRm9udEV4dGVuc2lvbnMgPSBbXCIudHRmXCIsIFwiLm90ZlwiLCBcIi53b2ZmXCIsIFwiLndvZmYyXCJdLCB2YWxpZEZvbnRNSU1FcyA9IFtcbiAgXCJmb250L3R0ZlwiLFxuICBcImZvbnQvb3RmXCIsXG4gIFwiZm9udC93b2ZmXCIsXG4gIFwiZm9udC93b2ZmMlwiXG5dLCBDU1NfSURFTlRfVE9LRU5fUkVHRVggPSAvXigtLXwtP1tBLVpfXSlbMC05QS1aXy1dKiQvaTtcbmZ1bmN0aW9uIGdldEZvbnRGYW1pbHlOYW1lKHVybCkge1xuICBjb25zdCBleHQgPSBjb3JlLnV0aWxzLnBhdGguZXh0bmFtZSh1cmwpLCBuYW1lVG9rZW5zID0gY29yZS51dGlscy5wYXRoLmJhc2VuYW1lKHVybCwgZXh0KS5yZXBsYWNlKC8oLXxfKS9nLCBcIiBcIikudG9Mb3dlckNhc2UoKS5zcGxpdChcIiBcIikubWFwKCh3b3JkKSA9PiB3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSk7XG4gIGxldCB2YWxpZCA9IG5hbWVUb2tlbnMubGVuZ3RoID4gMDtcbiAgZm9yIChjb25zdCB0b2tlbiBvZiBuYW1lVG9rZW5zKVxuICAgIGlmICghdG9rZW4ubWF0Y2goQ1NTX0lERU5UX1RPS0VOX1JFR0VYKSkge1xuICAgICAgdmFsaWQgPSAhMTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgbGV0IGZvbnRGYW1pbHlOYW1lID0gbmFtZVRva2Vucy5qb2luKFwiIFwiKTtcbiAgcmV0dXJuIHZhbGlkIHx8IChmb250RmFtaWx5TmFtZSA9IGBcIiR7Zm9udEZhbWlseU5hbWUucmVwbGFjZSgvW1xcXFxcIl0vZywgXCJcXFxcJCZcIil9XCJgKSwgZm9udEZhbWlseU5hbWU7XG59XG5jb25zdCB2YWxpZFVSSUNoYXJhY3RlcnNSZWdleCA9IC9eWzAtOUEtWmEteiU6Lz8jXFxbXFxdQCFcXCQmJygpXFwqXFwrLDs9XFwtLl9+XSokLztcbmZ1bmN0aW9uIGVuY29kZVVSSVdoZW5OZWVkZWQodXJpKSB7XG4gIHJldHVybiB2YWxpZFVSSUNoYXJhY3RlcnNSZWdleC50ZXN0KHVyaSkgPyB1cmkgOiBlbmNvZGVVUkkodXJpKTtcbn1cbmNvbnN0IGxvYWRXZWJGb250ID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBjb3JlLkV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgICBwcmlvcml0eTogTG9hZGVyUGFyc2VyLkxvYWRlclBhcnNlclByaW9yaXR5Lkxvd1xuICB9LFxuICBuYW1lOiBcImxvYWRXZWJGb250XCIsXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIGNoZWNrRGF0YVVybC5jaGVja0RhdGFVcmwodXJsLCB2YWxpZEZvbnRNSU1FcykgfHwgY2hlY2tFeHRlbnNpb24uY2hlY2tFeHRlbnNpb24odXJsLCB2YWxpZEZvbnRFeHRlbnNpb25zKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb250cyA9IGNvcmUuc2V0dGluZ3MuQURBUFRFUi5nZXRGb250RmFjZVNldCgpO1xuICAgIGlmIChmb250cykge1xuICAgICAgY29uc3QgZm9udEZhY2VzID0gW10sIG5hbWUgPSBvcHRpb25zLmRhdGE/LmZhbWlseSA/PyBnZXRGb250RmFtaWx5TmFtZSh1cmwpLCB3ZWlnaHRzID0gb3B0aW9ucy5kYXRhPy53ZWlnaHRzPy5maWx0ZXIoKHdlaWdodCkgPT4gdmFsaWRXZWlnaHRzLmluY2x1ZGVzKHdlaWdodCkpID8/IFtcIm5vcm1hbFwiXSwgZGF0YSA9IG9wdGlvbnMuZGF0YSA/PyB7fTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2VpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB3ZWlnaHQgPSB3ZWlnaHRzW2ldLCBmb250ID0gbmV3IEZvbnRGYWNlKG5hbWUsIGB1cmwoJHtlbmNvZGVVUklXaGVuTmVlZGVkKHVybCl9KWAsIHtcbiAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIHdlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgZm9udC5sb2FkKCksIGZvbnRzLmFkZChmb250KSwgZm9udEZhY2VzLnB1c2goZm9udCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9udEZhY2VzLmxlbmd0aCA9PT0gMSA/IGZvbnRGYWNlc1swXSA6IGZvbnRGYWNlcztcbiAgICB9XG4gICAgcmV0dXJuIGNvbnNvbGUud2FybihcIltsb2FkV2ViRm9udF0gRm9udEZhY2UgQVBJIGlzIG5vdCBzdXBwb3J0ZWQuIFNraXBwaW5nIGxvYWRpbmcgZm9udFwiKSwgbnVsbDtcbiAgfSxcbiAgdW5sb2FkKGZvbnQpIHtcbiAgICAoQXJyYXkuaXNBcnJheShmb250KSA/IGZvbnQgOiBbZm9udF0pLmZvckVhY2goKHQpID0+IGNvcmUuc2V0dGluZ3MuQURBUFRFUi5nZXRGb250RmFjZVNldCgpLmRlbGV0ZSh0KSk7XG4gIH1cbn07XG5jb3JlLmV4dGVuc2lvbnMuYWRkKGxvYWRXZWJGb250KTtcbmV4cG9ydHMuZ2V0Rm9udEZhbWlseU5hbWUgPSBnZXRGb250RmFtaWx5TmFtZTtcbmV4cG9ydHMubG9hZFdlYkZvbnQgPSBsb2FkV2ViRm9udDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRXZWJGb250LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbG9hZFNWRyA9IHJlcXVpcmUoXCIuL2xvYWRTVkcuanNcIiksIGxvYWRUZXh0dXJlcyA9IHJlcXVpcmUoXCIuL2xvYWRUZXh0dXJlcy5qc1wiKSwgbG9hZFZpZGVvID0gcmVxdWlyZShcIi4vbG9hZFZpZGVvLmpzXCIpO1xucmVxdWlyZShcIi4vdXRpbHMvaW5kZXguanNcIik7XG5leHBvcnRzLmxvYWRTVkcgPSBsb2FkU1ZHLmxvYWRTVkc7XG5leHBvcnRzLmxvYWRJbWFnZUJpdG1hcCA9IGxvYWRUZXh0dXJlcy5sb2FkSW1hZ2VCaXRtYXA7XG5leHBvcnRzLmxvYWRUZXh0dXJlcyA9IGxvYWRUZXh0dXJlcy5sb2FkVGV4dHVyZXM7XG5leHBvcnRzLmxvYWRWaWRlbyA9IGxvYWRWaWRlby5sb2FkVmlkZW87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgY2hlY2tEYXRhVXJsID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL2NoZWNrRGF0YVVybC5qc1wiKSwgY2hlY2tFeHRlbnNpb24gPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvY2hlY2tFeHRlbnNpb24uanNcIiksIExvYWRlclBhcnNlciA9IHJlcXVpcmUoXCIuLi9Mb2FkZXJQYXJzZXIuanNcIiksIGxvYWRUZXh0dXJlcyA9IHJlcXVpcmUoXCIuL2xvYWRUZXh0dXJlcy5qc1wiKSwgY3JlYXRlVGV4dHVyZSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NyZWF0ZVRleHR1cmUuanNcIik7XG5jb25zdCB2YWxpZFNWR0V4dGVuc2lvbiA9IFwiLnN2Z1wiLCB2YWxpZFNWR01JTUUgPSBcImltYWdlL3N2Zyt4bWxcIiwgbG9hZFNWRyA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlci5Mb2FkZXJQYXJzZXJQcmlvcml0eS5IaWdoXG4gIH0sXG4gIG5hbWU6IFwibG9hZFNWR1wiLFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiBjaGVja0RhdGFVcmwuY2hlY2tEYXRhVXJsKHVybCwgdmFsaWRTVkdNSU1FKSB8fCBjaGVja0V4dGVuc2lvbi5jaGVja0V4dGVuc2lvbih1cmwsIHZhbGlkU1ZHRXh0ZW5zaW9uKTtcbiAgfSxcbiAgYXN5bmMgdGVzdFBhcnNlKGRhdGEpIHtcbiAgICByZXR1cm4gY29yZS5TVkdSZXNvdXJjZS50ZXN0KGRhdGEpO1xuICB9LFxuICBhc3luYyBwYXJzZShhc3NldCwgZGF0YSwgbG9hZGVyKSB7XG4gICAgY29uc3Qgc3JjID0gbmV3IGNvcmUuU1ZHUmVzb3VyY2UoYXNzZXQsIGRhdGE/LmRhdGE/LnJlc291cmNlT3B0aW9ucyk7XG4gICAgYXdhaXQgc3JjLmxvYWQoKTtcbiAgICBjb25zdCBiYXNlID0gbmV3IGNvcmUuQmFzZVRleHR1cmUoc3JjLCB7XG4gICAgICByZXNvbHV0aW9uOiBjb3JlLnV0aWxzLmdldFJlc29sdXRpb25PZlVybChhc3NldCksXG4gICAgICAuLi5kYXRhPy5kYXRhXG4gICAgfSk7XG4gICAgcmV0dXJuIGJhc2UucmVzb3VyY2Uuc3JjID0gZGF0YS5zcmMsIGNyZWF0ZVRleHR1cmUuY3JlYXRlVGV4dHVyZShiYXNlLCBsb2FkZXIsIGRhdGEuc3JjKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwsIF9vcHRpb25zKSB7XG4gICAgcmV0dXJuIChhd2FpdCBjb3JlLnNldHRpbmdzLkFEQVBURVIuZmV0Y2godXJsKSkudGV4dCgpO1xuICB9LFxuICB1bmxvYWQ6IGxvYWRUZXh0dXJlcy5sb2FkVGV4dHVyZXMudW5sb2FkXG59O1xuY29yZS5leHRlbnNpb25zLmFkZChsb2FkU1ZHKTtcbmV4cG9ydHMubG9hZFNWRyA9IGxvYWRTVkc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkU1ZHLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCBjaGVja0RhdGFVcmwgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvY2hlY2tEYXRhVXJsLmpzXCIpLCBjaGVja0V4dGVuc2lvbiA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9jaGVja0V4dGVuc2lvbi5qc1wiKSwgTG9hZGVyUGFyc2VyID0gcmVxdWlyZShcIi4uL0xvYWRlclBhcnNlci5qc1wiKSwgV29ya2VyTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9Xb3JrZXJNYW5hZ2VyLmpzXCIpLCBjcmVhdGVUZXh0dXJlID0gcmVxdWlyZShcIi4vdXRpbHMvY3JlYXRlVGV4dHVyZS5qc1wiKTtcbmNvbnN0IHZhbGlkSW1hZ2VFeHRlbnNpb25zID0gW1wiLmpwZWdcIiwgXCIuanBnXCIsIFwiLnBuZ1wiLCBcIi53ZWJwXCIsIFwiLmF2aWZcIl0sIHZhbGlkSW1hZ2VNSU1FcyA9IFtcbiAgXCJpbWFnZS9qcGVnXCIsXG4gIFwiaW1hZ2UvcG5nXCIsXG4gIFwiaW1hZ2Uvd2VicFwiLFxuICBcImltYWdlL2F2aWZcIlxuXTtcbmFzeW5jIGZ1bmN0aW9uIGxvYWRJbWFnZUJpdG1hcCh1cmwpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb3JlLnNldHRpbmdzLkFEQVBURVIuZmV0Y2godXJsKTtcbiAgaWYgKCFyZXNwb25zZS5vaylcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFtsb2FkSW1hZ2VCaXRtYXBdIEZhaWxlZCB0byBmZXRjaCAke3VybH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gIGNvbnN0IGltYWdlQmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgcmV0dXJuIGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlQmxvYik7XG59XG5jb25zdCBsb2FkVGV4dHVyZXMgPSB7XG4gIG5hbWU6IFwibG9hZFRleHR1cmVzXCIsXG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IGNvcmUuRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXIuTG9hZGVyUGFyc2VyUHJpb3JpdHkuSGlnaFxuICB9LFxuICBjb25maWc6IHtcbiAgICBwcmVmZXJXb3JrZXJzOiAhMCxcbiAgICBwcmVmZXJDcmVhdGVJbWFnZUJpdG1hcDogITAsXG4gICAgY3Jvc3NPcmlnaW46IFwiYW5vbnltb3VzXCJcbiAgfSxcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gY2hlY2tEYXRhVXJsLmNoZWNrRGF0YVVybCh1cmwsIHZhbGlkSW1hZ2VNSU1FcykgfHwgY2hlY2tFeHRlbnNpb24uY2hlY2tFeHRlbnNpb24odXJsLCB2YWxpZEltYWdlRXh0ZW5zaW9ucyk7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBhc3NldCwgbG9hZGVyKSB7XG4gICAgY29uc3QgdXNlSW1hZ2VCaXRtYXAgPSBnbG9iYWxUaGlzLmNyZWF0ZUltYWdlQml0bWFwICYmIHRoaXMuY29uZmlnLnByZWZlckNyZWF0ZUltYWdlQml0bWFwO1xuICAgIGxldCBzcmM7XG4gICAgdXNlSW1hZ2VCaXRtYXAgPyB0aGlzLmNvbmZpZy5wcmVmZXJXb3JrZXJzICYmIGF3YWl0IFdvcmtlck1hbmFnZXIuV29ya2VyTWFuYWdlci5pc0ltYWdlQml0bWFwU3VwcG9ydGVkKCkgPyBzcmMgPSBhd2FpdCBXb3JrZXJNYW5hZ2VyLldvcmtlck1hbmFnZXIubG9hZEltYWdlQml0bWFwKHVybCkgOiBzcmMgPSBhd2FpdCBsb2FkSW1hZ2VCaXRtYXAodXJsKSA6IHNyYyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHNyYzIgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIHNyYzIuY3Jvc3NPcmlnaW4gPSB0aGlzLmNvbmZpZy5jcm9zc09yaWdpbiwgc3JjMi5zcmMgPSB1cmwsIHNyYzIuY29tcGxldGUgPyByZXNvbHZlKHNyYzIpIDogKHNyYzIub25sb2FkID0gKCkgPT4gcmVzb2x2ZShzcmMyKSwgc3JjMi5vbmVycm9yID0gKGUpID0+IHJlamVjdChlKSk7XG4gICAgfSk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgLi4uYXNzZXQuZGF0YSB9O1xuICAgIG9wdGlvbnMucmVzb2x1dGlvbiA/PyAob3B0aW9ucy5yZXNvbHV0aW9uID0gY29yZS51dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwodXJsKSksIHVzZUltYWdlQml0bWFwICYmIG9wdGlvbnMucmVzb3VyY2VPcHRpb25zPy5vd25zSW1hZ2VCaXRtYXAgPT09IHZvaWQgMCAmJiAob3B0aW9ucy5yZXNvdXJjZU9wdGlvbnMgPSB7IC4uLm9wdGlvbnMucmVzb3VyY2VPcHRpb25zIH0sIG9wdGlvbnMucmVzb3VyY2VPcHRpb25zLm93bnNJbWFnZUJpdG1hcCA9ICEwKTtcbiAgICBjb25zdCBiYXNlID0gbmV3IGNvcmUuQmFzZVRleHR1cmUoc3JjLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYmFzZS5yZXNvdXJjZS5zcmMgPSB1cmwsIGNyZWF0ZVRleHR1cmUuY3JlYXRlVGV4dHVyZShiYXNlLCBsb2FkZXIsIHVybCk7XG4gIH0sXG4gIHVubG9hZCh0ZXh0dXJlKSB7XG4gICAgdGV4dHVyZS5kZXN0cm95KCEwKTtcbiAgfVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQobG9hZFRleHR1cmVzKTtcbmV4cG9ydHMubG9hZEltYWdlQml0bWFwID0gbG9hZEltYWdlQml0bWFwO1xuZXhwb3J0cy5sb2FkVGV4dHVyZXMgPSBsb2FkVGV4dHVyZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkVGV4dHVyZXMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIGNoZWNrRGF0YVVybCA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9jaGVja0RhdGFVcmwuanNcIiksIGNoZWNrRXh0ZW5zaW9uID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLmpzXCIpLCBMb2FkZXJQYXJzZXIgPSByZXF1aXJlKFwiLi4vTG9hZGVyUGFyc2VyLmpzXCIpLCBjcmVhdGVUZXh0dXJlID0gcmVxdWlyZShcIi4vdXRpbHMvY3JlYXRlVGV4dHVyZS5qc1wiKTtcbmNvbnN0IHZhbGlkVmlkZW9FeHRlbnNpb25zID0gW1wiLm1wNFwiLCBcIi5tNHZcIiwgXCIud2VibVwiLCBcIi5vZ3ZcIl0sIHZhbGlkVmlkZW9NSU1FcyA9IFtcbiAgXCJ2aWRlby9tcDRcIixcbiAgXCJ2aWRlby93ZWJtXCIsXG4gIFwidmlkZW8vb2dnXCJcbl0sIGxvYWRWaWRlbyA9IHtcbiAgbmFtZTogXCJsb2FkVmlkZW9cIixcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlci5Mb2FkZXJQYXJzZXJQcmlvcml0eS5IaWdoXG4gIH0sXG4gIGNvbmZpZzoge1xuICAgIGRlZmF1bHRBdXRvUGxheTogITBcbiAgfSxcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gY2hlY2tEYXRhVXJsLmNoZWNrRGF0YVVybCh1cmwsIHZhbGlkVmlkZW9NSU1FcykgfHwgY2hlY2tFeHRlbnNpb24uY2hlY2tFeHRlbnNpb24odXJsLCB2YWxpZFZpZGVvRXh0ZW5zaW9ucyk7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBsb2FkQXNzZXQsIGxvYWRlcikge1xuICAgIGxldCB0ZXh0dXJlO1xuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCAoYXdhaXQgY29yZS5zZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCkpLmJsb2IoKSwgYmxvYlVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGF1dG9QbGF5OiB0aGlzLmNvbmZpZy5kZWZhdWx0QXV0b1BsYXksXG4gICAgICAgIC4uLmxvYWRBc3NldD8uZGF0YT8ucmVzb3VyY2VPcHRpb25zXG4gICAgICB9LCBzcmMgPSBuZXcgY29yZS5WaWRlb1Jlc291cmNlKGJsb2JVUkwsIG9wdGlvbnMpO1xuICAgICAgYXdhaXQgc3JjLmxvYWQoKTtcbiAgICAgIGNvbnN0IGJhc2UgPSBuZXcgY29yZS5CYXNlVGV4dHVyZShzcmMsIHtcbiAgICAgICAgYWxwaGFNb2RlOiBhd2FpdCBjb3JlLnV0aWxzLmRldGVjdFZpZGVvQWxwaGFNb2RlKCksXG4gICAgICAgIHJlc29sdXRpb246IGNvcmUudXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKHVybCksXG4gICAgICAgIC4uLmxvYWRBc3NldD8uZGF0YVxuICAgICAgfSk7XG4gICAgICBiYXNlLnJlc291cmNlLnNyYyA9IHVybCwgdGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUuY3JlYXRlVGV4dHVyZShiYXNlLCBsb2FkZXIsIHVybCksIHRleHR1cmUuYmFzZVRleHR1cmUub25jZShcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVSTCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVUkwpLCBlO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfSxcbiAgdW5sb2FkKHRleHR1cmUpIHtcbiAgICB0ZXh0dXJlLmRlc3Ryb3koITApO1xuICB9XG59O1xuY29yZS5leHRlbnNpb25zLmFkZChsb2FkVmlkZW8pO1xuZXhwb3J0cy5sb2FkVmlkZW8gPSBsb2FkVmlkZW87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkVmlkZW8uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIENhY2hlID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2NhY2hlL0NhY2hlLmpzXCIpO1xuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShiYXNlLCBsb2FkZXIsIHVybCkge1xuICBiYXNlLnJlc291cmNlLmludGVybmFsID0gITA7XG4gIGNvbnN0IHRleHR1cmUgPSBuZXcgY29yZS5UZXh0dXJlKGJhc2UpLCB1bmxvYWQgPSAoKSA9PiB7XG4gICAgZGVsZXRlIGxvYWRlci5wcm9taXNlQ2FjaGVbdXJsXSwgQ2FjaGUuQ2FjaGUuaGFzKHVybCkgJiYgQ2FjaGUuQ2FjaGUucmVtb3ZlKHVybCk7XG4gIH07XG4gIHJldHVybiB0ZXh0dXJlLmJhc2VUZXh0dXJlLm9uY2UoXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgIHVybCBpbiBsb2FkZXIucHJvbWlzZUNhY2hlICYmIChjb25zb2xlLndhcm4oXCJbQXNzZXRzXSBBIEJhc2VUZXh0dXJlIG1hbmFnZWQgYnkgQXNzZXRzIHdhcyBkZXN0cm95ZWQgaW5zdGVhZCBvZiB1bmxvYWRlZCEgVXNlIEFzc2V0cy51bmxvYWQoKSBpbnN0ZWFkIG9mIGRlc3Ryb3lpbmcgdGhlIEJhc2VUZXh0dXJlLlwiKSwgdW5sb2FkKCkpO1xuICB9KSwgdGV4dHVyZS5vbmNlKFwiZGVzdHJveWVkXCIsICgpID0+IHtcbiAgICBiYXNlLmRlc3Ryb3llZCB8fCAoY29uc29sZS53YXJuKFwiW0Fzc2V0c10gQSBUZXh0dXJlIG1hbmFnZWQgYnkgQXNzZXRzIHdhcyBkZXN0cm95ZWQgaW5zdGVhZCBvZiB1bmxvYWRlZCEgVXNlIEFzc2V0cy51bmxvYWQoKSBpbnN0ZWFkIG9mIGRlc3Ryb3lpbmcgdGhlIFRleHR1cmUuXCIpLCB1bmxvYWQoKSk7XG4gIH0pLCB0ZXh0dXJlO1xufVxuZXhwb3J0cy5jcmVhdGVUZXh0dXJlID0gY3JlYXRlVGV4dHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVRleHR1cmUuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjcmVhdGVUZXh0dXJlID0gcmVxdWlyZShcIi4vY3JlYXRlVGV4dHVyZS5qc1wiKTtcbmV4cG9ydHMuY3JlYXRlVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUuY3JlYXRlVGV4dHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCBjb252ZXJ0VG9MaXN0ID0gcmVxdWlyZShcIi4uL3V0aWxzL2NvbnZlcnRUb0xpc3QuanNcIiksIGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMgPSByZXF1aXJlKFwiLi4vdXRpbHMvY3JlYXRlU3RyaW5nVmFyaWF0aW9ucy5qc1wiKSwgaXNTaW5nbGVJdGVtID0gcmVxdWlyZShcIi4uL3V0aWxzL2lzU2luZ2xlSXRlbS5qc1wiKTtcbmNsYXNzIFJlc29sdmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZGVmYXVsdEJ1bmRsZUlkZW50aWZpZXJPcHRpb25zID0ge1xuICAgICAgY29ubmVjdG9yOiBcIi1cIixcbiAgICAgIGNyZWF0ZUJ1bmRsZUFzc2V0SWQ6IChidW5kbGVJZCwgYXNzZXRJZCkgPT4gYCR7YnVuZGxlSWR9JHt0aGlzLl9idW5kbGVJZENvbm5lY3Rvcn0ke2Fzc2V0SWR9YCxcbiAgICAgIGV4dHJhY3RBc3NldElkRnJvbUJ1bmRsZTogKGJ1bmRsZUlkLCBhc3NldEJ1bmRsZUlkKSA9PiBhc3NldEJ1bmRsZUlkLnJlcGxhY2UoYCR7YnVuZGxlSWR9JHt0aGlzLl9idW5kbGVJZENvbm5lY3Rvcn1gLCBcIlwiKVxuICAgIH0sIHRoaXMuX2J1bmRsZUlkQ29ubmVjdG9yID0gdGhpcy5fZGVmYXVsdEJ1bmRsZUlkZW50aWZpZXJPcHRpb25zLmNvbm5lY3RvciwgdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZCA9IHRoaXMuX2RlZmF1bHRCdW5kbGVJZGVudGlmaWVyT3B0aW9ucy5jcmVhdGVCdW5kbGVBc3NldElkLCB0aGlzLl9leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUgPSB0aGlzLl9kZWZhdWx0QnVuZGxlSWRlbnRpZmllck9wdGlvbnMuZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlLCB0aGlzLl9hc3NldE1hcCA9IHt9LCB0aGlzLl9wcmVmZXJyZWRPcmRlciA9IFtdLCB0aGlzLl9wYXJzZXJzID0gW10sIHRoaXMuX3Jlc29sdmVySGFzaCA9IHt9LCB0aGlzLl9idW5kbGVzID0ge307XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRlIGhvdyB0aGUgcmVzb2x2ZXIgZGVhbHMgd2l0aCBnZW5lcmF0aW5nIGJ1bmRsZSBpZHMuXG4gICAqIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBhbnkgYnVuZGxlcyBhcmUgYWRkZWRcbiAgICogQHBhcmFtIGJ1bmRsZUlkZW50aWZpZXIgLSB0aGUgYnVuZGxlIGlkZW50aWZpZXIgb3B0aW9uc1xuICAgKi9cbiAgc2V0QnVuZGxlSWRlbnRpZmllcihidW5kbGVJZGVudGlmaWVyKSB7XG4gICAgaWYgKHRoaXMuX2J1bmRsZUlkQ29ubmVjdG9yID0gYnVuZGxlSWRlbnRpZmllci5jb25uZWN0b3IgPz8gdGhpcy5fYnVuZGxlSWRDb25uZWN0b3IsIHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQgPSBidW5kbGVJZGVudGlmaWVyLmNyZWF0ZUJ1bmRsZUFzc2V0SWQgPz8gdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZCwgdGhpcy5fZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlID0gYnVuZGxlSWRlbnRpZmllci5leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUgPz8gdGhpcy5fZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlLCB0aGlzLl9leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUoXCJmb29cIiwgdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZChcImZvb1wiLCBcImJhclwiKSkgIT09IFwiYmFyXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbUmVzb2x2ZXJdIEdlbmVyYXRlQnVuZGxlQXNzZXRJZCBhcmUgbm90IHdvcmtpbmcgY29ycmVjdGx5XCIpO1xuICB9XG4gIC8qKlxuICAgKiBMZXQgdGhlIHJlc29sdmVyIGtub3cgd2hpY2ggYXNzZXRzIHlvdSBwcmVmZXIgdG8gdXNlIHdoZW4gcmVzb2x2aW5nIGFzc2V0cy5cbiAgICogTXVsdGlwbGUgcHJlZmVyIHVzZXIgZGVmaW5lZCBydWxlcyBjYW4gYmUgYWRkZWQuXG4gICAqIEBleGFtcGxlXG4gICAqIHJlc29sdmVyLnByZWZlcih7XG4gICAqICAgICAvLyBmaXJzdCBsb29rIGZvciBzb21ldGhpbmcgd2l0aCB0aGUgY29ycmVjdCBmb3JtYXQsIGFuZCB0aGVuIHRoZW4gY29ycmVjdCByZXNvbHV0aW9uXG4gICAqICAgICBwcmlvcml0eTogWydmb3JtYXQnLCAncmVzb2x1dGlvbiddLFxuICAgKiAgICAgcGFyYW1zOntcbiAgICogICAgICAgICBmb3JtYXQ6J3dlYnAnLCAvLyBwcmVmZXIgd2VicCBpbWFnZXNcbiAgICogICAgICAgICByZXNvbHV0aW9uOiAyLCAvLyBwcmVmZXIgYSByZXNvbHV0aW9uIG9mIDJcbiAgICogICAgIH1cbiAgICogfSlcbiAgICogcmVzb2x2ZXIuYWRkKCdmb28nLCBbJ2JhckAyeC53ZWJwJywgJ2JhckAyeC5wbmcnLCAnYmFyLndlYnAnLCAnYmFyLnBuZyddKTtcbiAgICogcmVzb2x2ZXIucmVzb2x2ZVVybCgnZm9vJykgLy8gPT4gJ2JhckAyeC53ZWJwJ1xuICAgKiBAcGFyYW0gcHJlZmVyT3JkZXJzIC0gdGhlIHByZWZlciBvcHRpb25zXG4gICAqL1xuICBwcmVmZXIoLi4ucHJlZmVyT3JkZXJzKSB7XG4gICAgcHJlZmVyT3JkZXJzLmZvckVhY2goKHByZWZlcikgPT4ge1xuICAgICAgdGhpcy5fcHJlZmVycmVkT3JkZXIucHVzaChwcmVmZXIpLCBwcmVmZXIucHJpb3JpdHkgfHwgKHByZWZlci5wcmlvcml0eSA9IE9iamVjdC5rZXlzKHByZWZlci5wYXJhbXMpKTtcbiAgICB9KSwgdGhpcy5fcmVzb2x2ZXJIYXNoID0ge307XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgYmFzZSBwYXRoIHRvIHByZXBlbmQgdG8gYWxsIHVybHMgd2hlbiByZXNvbHZpbmdcbiAgICogQGV4YW1wbGVcbiAgICogcmVzb2x2ZXIuYmFzZVBhdGggPSAnaHR0cHM6Ly9ob21lLmNvbS8nO1xuICAgKiByZXNvbHZlci5hZGQoJ2ZvbycsICdiYXIub25nJyk7XG4gICAqIHJlc29sdmVyLnJlc29sdmVVcmwoJ2ZvbycsICdiYXIucG5nJyk7IC8vID0+ICdodHRwczovL2hvbWUuY29tL2Jhci5wbmcnXG4gICAqIEBwYXJhbSBiYXNlUGF0aCAtIHRoZSBiYXNlIHBhdGggdG8gdXNlXG4gICAqL1xuICBzZXQgYmFzZVBhdGgoYmFzZVBhdGgpIHtcbiAgICB0aGlzLl9iYXNlUGF0aCA9IGJhc2VQYXRoO1xuICB9XG4gIGdldCBiYXNlUGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZVBhdGg7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgcm9vdCBwYXRoIGZvciByb290LXJlbGF0aXZlIFVSTHMuIEJ5IGRlZmF1bHQgdGhlIGBiYXNlUGF0aGAncyByb290IGlzIHVzZWQuIElmIG5vIGBiYXNlUGF0aGAgaXMgc2V0LCB0aGVuIHRoZVxuICAgKiBkZWZhdWx0IHZhbHVlIGZvciBicm93c2VycyBpcyBgd2luZG93LmxvY2F0aW9uLm9yaWdpbmBcbiAgICogQGV4YW1wbGVcbiAgICogLy8gQXBwbGljYXRpb24gaG9zdGVkIG9uIGh0dHBzOi8vaG9tZS5jb20vc29tZS1wYXRoL2luZGV4Lmh0bWxcbiAgICogcmVzb2x2ZXIuYmFzZVBhdGggPSAnaHR0cHM6Ly9ob21lLmNvbS9zb21lLXBhdGgvJztcbiAgICogcmVzb2x2ZXIucm9vdFBhdGggPSAnaHR0cHM6Ly9ob21lLmNvbS8nO1xuICAgKiByZXNvbHZlci5hZGQoJ2ZvbycsICcvYmFyLnBuZycpO1xuICAgKiByZXNvbHZlci5yZXNvbHZlVXJsKCdmb28nLCAnL2Jhci5wbmcnKTsgLy8gPT4gJ2h0dHBzOi8vaG9tZS5jb20vYmFyLnBuZydcbiAgICogQHBhcmFtIHJvb3RQYXRoIC0gdGhlIHJvb3QgcGF0aCB0byB1c2VcbiAgICovXG4gIHNldCByb290UGF0aChyb290UGF0aCkge1xuICAgIHRoaXMuX3Jvb3RQYXRoID0gcm9vdFBhdGg7XG4gIH1cbiAgZ2V0IHJvb3RQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9yb290UGF0aDtcbiAgfVxuICAvKipcbiAgICogQWxsIHRoZSBhY3RpdmUgVVJMIHBhcnNlcnMgdGhhdCBoZWxwIHRoZSBwYXJzZXIgdG8gZXh0cmFjdCBpbmZvcm1hdGlvbiBhbmQgY3JlYXRlXG4gICAqIGFuIGFzc2V0IG9iamVjdC1iYXNlZCBvbiBwYXJzaW5nIHRoZSBVUkwgaXRzZWxmLlxuICAgKlxuICAgKiBDYW4gYmUgYWRkZWQgdXNpbmcgdGhlIGV4dGVuc2lvbnMgQVBJXG4gICAqIEBleGFtcGxlXG4gICAqIHJlc29sdmVyLmFkZCgnZm9vJywgW1xuICAgKiAgICAge1xuICAgKiAgICAgICAgIHJlc29sdXRpb246IDIsXG4gICAqICAgICAgICAgZm9ybWF0OiAncG5nJyxcbiAgICogICAgICAgICBzcmM6ICdpbWFnZUAyeC5wbmcnLFxuICAgKiAgICAgfSxcbiAgICogICAgIHtcbiAgICogICAgICAgICByZXNvbHV0aW9uOjEsXG4gICAqICAgICAgICAgZm9ybWF0OidwbmcnLFxuICAgKiAgICAgICAgIHNyYzogJ2ltYWdlLnBuZycsXG4gICAqICAgICB9LFxuICAgKiBdKTtcbiAgICpcbiAgICogLy8gV2l0aCBhIHVybCBwYXJzZXIgdGhlIGluZm9ybWF0aW9uIHN1Y2ggYXMgcmVzb2x1dGlvbiBhbmQgZmlsZSBmb3JtYXQgY291bGQgZXh0cmFjdGVkIGZyb20gdGhlIHVybCBpdHNlbGY6XG4gICAqIGV4dGVuc2lvbnMuYWRkKHtcbiAgICogICAgIGV4dGVuc2lvbjogRXh0ZW5zaW9uVHlwZS5SZXNvbHZlUGFyc2VyLFxuICAgKiAgICAgdGVzdDogbG9hZFRleHR1cmVzLnRlc3QsIC8vIHRlc3QgaWYgdXJsIGVuZHMgaW4gYW4gaW1hZ2VcbiAgICogICAgIHBhcnNlOiAodmFsdWU6IHN0cmluZykgPT5cbiAgICogICAgICh7XG4gICAqICAgICAgICAgcmVzb2x1dGlvbjogcGFyc2VGbG9hdChzZXR0aW5ncy5SRVRJTkFfUFJFRklYLmV4ZWModmFsdWUpPy5bMV0gPz8gJzEnKSxcbiAgICogICAgICAgICBmb3JtYXQ6IHZhbHVlLnNwbGl0KCcuJykucG9wKCksXG4gICAqICAgICAgICAgc3JjOiB2YWx1ZSxcbiAgICogICAgIH0pLFxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gTm93IHJlc29sdXRpb24gYW5kIGZvcm1hdCBjYW4gYmUgZXh0cmFjdGVkIGZyb20gdGhlIHVybFxuICAgKiByZXNvbHZlci5hZGQoJ2ZvbycsIFtcbiAgICogICAgICdpbWFnZUAyeC5wbmcnLFxuICAgKiAgICAgJ2ltYWdlLnBuZycsXG4gICAqIF0pO1xuICAgKi9cbiAgZ2V0IHBhcnNlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlcnM7XG4gIH1cbiAgLyoqIFVzZWQgZm9yIHRlc3RpbmcsIHRoaXMgcmVzZXRzIHRoZSByZXNvbHZlciB0byBpdHMgaW5pdGlhbCBzdGF0ZSAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnNldEJ1bmRsZUlkZW50aWZpZXIodGhpcy5fZGVmYXVsdEJ1bmRsZUlkZW50aWZpZXJPcHRpb25zKSwgdGhpcy5fYXNzZXRNYXAgPSB7fSwgdGhpcy5fcHJlZmVycmVkT3JkZXIgPSBbXSwgdGhpcy5fcmVzb2x2ZXJIYXNoID0ge30sIHRoaXMuX3Jvb3RQYXRoID0gbnVsbCwgdGhpcy5fYmFzZVBhdGggPSBudWxsLCB0aGlzLl9tYW5pZmVzdCA9IG51bGwsIHRoaXMuX2J1bmRsZXMgPSB7fSwgdGhpcy5fZGVmYXVsdFNlYXJjaFBhcmFtcyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlZmF1bHQgVVJMIHNlYXJjaCBwYXJhbWV0ZXJzIGZvciB0aGUgVVJMIHJlc29sdmVyLiBUaGUgdXJscyBjYW4gYmUgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIG9yIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHNlYXJjaFBhcmFtcyAtIHRoZSBkZWZhdWx0IHVybCBwYXJhbWV0ZXJzIHRvIGFwcGVuZCB3aGVuIHJlc29sdmluZyB1cmxzXG4gICAqL1xuICBzZXREZWZhdWx0U2VhcmNoUGFyYW1zKHNlYXJjaFBhcmFtcykge1xuICAgIGlmICh0eXBlb2Ygc2VhcmNoUGFyYW1zID09IFwic3RyaW5nXCIpXG4gICAgICB0aGlzLl9kZWZhdWx0U2VhcmNoUGFyYW1zID0gc2VhcmNoUGFyYW1zO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgcXVlcnlWYWx1ZXMgPSBzZWFyY2hQYXJhbXM7XG4gICAgICB0aGlzLl9kZWZhdWx0U2VhcmNoUGFyYW1zID0gT2JqZWN0LmtleXMocXVlcnlWYWx1ZXMpLm1hcCgoa2V5KSA9PiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQocXVlcnlWYWx1ZXNba2V5XSl9YCkuam9pbihcIiZcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhbGlhc2VzIGZvciBhIGdpdmVuIGFzc2V0XG4gICAqIEBwYXJhbSBhc3NldCAtIHRoZSBhc3NldCB0byBnZXQgdGhlIGFsaWFzZXMgZm9yXG4gICAqL1xuICBnZXRBbGlhcyhhc3NldCkge1xuICAgIGNvbnN0IHsgYWxpYXMsIG5hbWUsIHNyYywgc3JjcyB9ID0gYXNzZXQ7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0xpc3QuY29udmVydFRvTGlzdChcbiAgICAgIGFsaWFzIHx8IG5hbWUgfHwgc3JjIHx8IHNyY3MsXG4gICAgICAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiID8gdmFsdWUgOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCgodikgPT4gdj8uc3JjID8/IHY/LnNyY3MgPz8gdikgOiB2YWx1ZT8uc3JjIHx8IHZhbHVlPy5zcmNzID8gdmFsdWUuc3JjID8/IHZhbHVlLnNyY3MgOiB2YWx1ZSxcbiAgICAgICEwXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgbWFuaWZlc3QgdG8gdGhlIGFzc2V0IHJlc29sdmVyLiBUaGlzIGlzIGEgbmljZSB3YXkgdG8gYWRkIGFsbCB0aGUgYXNzZXQgaW5mb3JtYXRpb24gaW4gb25lIGdvLlxuICAgKiBnZW5lcmFsbHkgYSBtYW5pZmVzdCB3b3VsZCBiZSBidWlsdCB1c2luZyBhIHRvb2wuXG4gICAqIEBwYXJhbSBtYW5pZmVzdCAtIHRoZSBtYW5pZmVzdCB0byBhZGQgdG8gdGhlIHJlc29sdmVyXG4gICAqL1xuICBhZGRNYW5pZmVzdChtYW5pZmVzdCkge1xuICAgIHRoaXMuX21hbmlmZXN0ICYmIGNvbnNvbGUud2FybihcIltSZXNvbHZlcl0gTWFuaWZlc3QgYWxyZWFkeSBleGlzdHMsIHRoaXMgd2lsbCBiZSBvdmVyd3JpdHRlblwiKSwgdGhpcy5fbWFuaWZlc3QgPSBtYW5pZmVzdCwgbWFuaWZlc3QuYnVuZGxlcy5mb3JFYWNoKChidW5kbGUpID0+IHtcbiAgICAgIHRoaXMuYWRkQnVuZGxlKGJ1bmRsZS5uYW1lLCBidW5kbGUuYXNzZXRzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBhZGRzIGEgYnVuZGxlIG9mIGFzc2V0cyBpbiBvbmUgZ28gc28gdGhhdCB5b3UgY2FuIHJlc29sdmUgdGhlbSBhcyBhIGdyb3VwLlxuICAgKiBGb3IgZXhhbXBsZSB5b3UgY291bGQgYWRkIGEgYnVuZGxlIGZvciBlYWNoIHNjcmVlbiBpbiB5b3UgcGl4aSBhcHBcbiAgICogQGV4YW1wbGVcbiAgICogcmVzb2x2ZXIuYWRkQnVuZGxlKCdhbmltYWxzJywge1xuICAgKiAgICAgYnVubnk6ICdidW5ueS5wbmcnLFxuICAgKiAgICAgY2hpY2tlbjogJ2NoaWNrZW4ucG5nJyxcbiAgICogICAgIHRodW1wZXI6ICd0aHVtcGVyLnBuZycsXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCByZXNvbHZlZEFzc2V0cyA9IGF3YWl0IHJlc29sdmVyLnJlc29sdmVCdW5kbGUoJ2FuaW1hbHMnKTtcbiAgICogQHBhcmFtIGJ1bmRsZUlkIC0gVGhlIGlkIG9mIHRoZSBidW5kbGUgdG8gYWRkXG4gICAqIEBwYXJhbSBhc3NldHMgLSBBIHJlY29yZCBvZiB0aGUgYXNzZXQgb3IgYXNzZXRzIHRoYXQgd2lsbCBiZSBjaG9zZW4gZnJvbSB3aGVuIGxvYWRpbmcgdmlhIHRoZSBzcGVjaWZpZWQga2V5XG4gICAqL1xuICBhZGRCdW5kbGUoYnVuZGxlSWQsIGFzc2V0cykge1xuICAgIGNvbnN0IGFzc2V0TmFtZXMgPSBbXTtcbiAgICBBcnJheS5pc0FycmF5KGFzc2V0cykgPyBhc3NldHMuZm9yRWFjaCgoYXNzZXQpID0+IHtcbiAgICAgIGNvbnN0IHNyY3MgPSBhc3NldC5zcmMgPz8gYXNzZXQuc3JjcywgYWxpYXNlcyA9IGFzc2V0LmFsaWFzID8/IGFzc2V0Lm5hbWU7XG4gICAgICBsZXQgaWRzO1xuICAgICAgaWYgKHR5cGVvZiBhbGlhc2VzID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgYnVuZGxlQXNzZXRJZCA9IHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQoYnVuZGxlSWQsIGFsaWFzZXMpO1xuICAgICAgICBhc3NldE5hbWVzLnB1c2goYnVuZGxlQXNzZXRJZCksIGlkcyA9IFthbGlhc2VzLCBidW5kbGVBc3NldElkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ1bmRsZUlkcyA9IGFsaWFzZXMubWFwKChuYW1lKSA9PiB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkKGJ1bmRsZUlkLCBuYW1lKSk7XG4gICAgICAgIGFzc2V0TmFtZXMucHVzaCguLi5idW5kbGVJZHMpLCBpZHMgPSBbLi4uYWxpYXNlcywgLi4uYnVuZGxlSWRzXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkKHtcbiAgICAgICAgLi4uYXNzZXQsXG4gICAgICAgIGFsaWFzOiBpZHMsXG4gICAgICAgIHNyYzogc3Jjc1xuICAgICAgfSk7XG4gICAgfSkgOiBPYmplY3Qua2V5cyhhc3NldHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgYWxpYXNlcyA9IFtrZXksIHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQoYnVuZGxlSWQsIGtleSldO1xuICAgICAgaWYgKHR5cGVvZiBhc3NldHNba2V5XSA9PSBcInN0cmluZ1wiKVxuICAgICAgICB0aGlzLmFkZCh7XG4gICAgICAgICAgYWxpYXM6IGFsaWFzZXMsXG4gICAgICAgICAgc3JjOiBhc3NldHNba2V5XVxuICAgICAgICB9KTtcbiAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXNzZXRzW2tleV0pKVxuICAgICAgICB0aGlzLmFkZCh7XG4gICAgICAgICAgYWxpYXM6IGFsaWFzZXMsXG4gICAgICAgICAgc3JjOiBhc3NldHNba2V5XVxuICAgICAgICB9KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBhc3NldCA9IGFzc2V0c1trZXldLCBhc3NldFNyYyA9IGFzc2V0LnNyYyA/PyBhc3NldC5zcmNzO1xuICAgICAgICB0aGlzLmFkZCh7XG4gICAgICAgICAgLi4uYXNzZXQsXG4gICAgICAgICAgYWxpYXM6IGFsaWFzZXMsXG4gICAgICAgICAgc3JjOiBBcnJheS5pc0FycmF5KGFzc2V0U3JjKSA/IGFzc2V0U3JjIDogW2Fzc2V0U3JjXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFzc2V0TmFtZXMucHVzaCguLi5hbGlhc2VzKTtcbiAgICB9KSwgdGhpcy5fYnVuZGxlc1tidW5kbGVJZF0gPSBhc3NldE5hbWVzO1xuICB9XG4gIGFkZChhbGlhc2VzLCBzcmNzLCBkYXRhLCBmb3JtYXQsIGxvYWRQYXJzZXIpIHtcbiAgICBjb25zdCBhc3NldHMgPSBbXTtcbiAgICB0eXBlb2YgYWxpYXNlcyA9PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoYWxpYXNlcykgJiYgdHlwZW9mIGFsaWFzZXNbMF0gPT0gXCJzdHJpbmdcIiA/IChjb3JlLnV0aWxzLmRlcHJlY2F0aW9uKFwiNy4yLjBcIiwgYEFzc2V0cy5hZGQgbm93IHVzZXMgYW4gb2JqZWN0IGluc3RlYWQgb2YgaW5kaXZpZHVhbCBwYXJhbWV0ZXJzLlxuUGxlYXNlIHVzZSBBc3NldHMuYWRkKHsgYWxpYXMsIHNyYywgZGF0YSwgZm9ybWF0LCBsb2FkUGFyc2VyIH0pIGluc3RlYWQuYCksIGFzc2V0cy5wdXNoKHsgYWxpYXM6IGFsaWFzZXMsIHNyYzogc3JjcywgZGF0YSwgZm9ybWF0LCBsb2FkUGFyc2VyIH0pKSA6IEFycmF5LmlzQXJyYXkoYWxpYXNlcykgPyBhc3NldHMucHVzaCguLi5hbGlhc2VzKSA6IGFzc2V0cy5wdXNoKGFsaWFzZXMpO1xuICAgIGxldCBrZXlDaGVjaztcbiAgICBrZXlDaGVjayA9IChrZXkpID0+IHtcbiAgICAgIHRoaXMuaGFzS2V5KGtleSkgJiYgY29uc29sZS53YXJuKGBbUmVzb2x2ZXJdIGFscmVhZHkgaGFzIGtleTogJHtrZXl9IG92ZXJ3cml0aW5nYCk7XG4gICAgfSwgY29udmVydFRvTGlzdC5jb252ZXJ0VG9MaXN0KGFzc2V0cykuZm9yRWFjaCgoYXNzZXQpID0+IHtcbiAgICAgIGNvbnN0IHsgc3JjLCBzcmNzOiBzcmNzMiB9ID0gYXNzZXQ7XG4gICAgICBsZXQgeyBkYXRhOiBkYXRhMiwgZm9ybWF0OiBmb3JtYXQyLCBsb2FkUGFyc2VyOiBsb2FkUGFyc2VyMiB9ID0gYXNzZXQ7XG4gICAgICBjb25zdCBzcmNzVG9Vc2UgPSBjb252ZXJ0VG9MaXN0LmNvbnZlcnRUb0xpc3Qoc3JjIHx8IHNyY3MyKS5tYXAoKHNyYzIpID0+IHR5cGVvZiBzcmMyID09IFwic3RyaW5nXCIgPyBjcmVhdGVTdHJpbmdWYXJpYXRpb25zLmNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMoc3JjMikgOiBBcnJheS5pc0FycmF5KHNyYzIpID8gc3JjMiA6IFtzcmMyXSksIGFsaWFzZXNUb1VzZSA9IHRoaXMuZ2V0QWxpYXMoYXNzZXQpO1xuICAgICAgQXJyYXkuaXNBcnJheShhbGlhc2VzVG9Vc2UpID8gYWxpYXNlc1RvVXNlLmZvckVhY2goa2V5Q2hlY2spIDoga2V5Q2hlY2soYWxpYXNlc1RvVXNlKTtcbiAgICAgIGNvbnN0IHJlc29sdmVkQXNzZXRzID0gW107XG4gICAgICBzcmNzVG9Vc2UuZm9yRWFjaCgoc3JjczMpID0+IHtcbiAgICAgICAgc3JjczMuZm9yRWFjaCgoc3JjMikgPT4ge1xuICAgICAgICAgIGxldCBmb3JtYXR0ZWRBc3NldCA9IHt9O1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3JjMiAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRBc3NldC5zcmMgPSBzcmMyO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wYXJzZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9IHRoaXMuX3BhcnNlcnNbaV07XG4gICAgICAgICAgICAgIGlmIChwYXJzZXIudGVzdChzcmMyKSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZEFzc2V0ID0gcGFyc2VyLnBhcnNlKHNyYzIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBkYXRhMiA9IHNyYzIuZGF0YSA/PyBkYXRhMiwgZm9ybWF0MiA9IHNyYzIuZm9ybWF0ID8/IGZvcm1hdDIsIGxvYWRQYXJzZXIyID0gc3JjMi5sb2FkUGFyc2VyID8/IGxvYWRQYXJzZXIyLCBmb3JtYXR0ZWRBc3NldCA9IHtcbiAgICAgICAgICAgICAgLi4uZm9ybWF0dGVkQXNzZXQsXG4gICAgICAgICAgICAgIC4uLnNyYzJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKCFhbGlhc2VzVG9Vc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtSZXNvbHZlcl0gYWxpYXMgaXMgdW5kZWZpbmVkIGZvciB0aGlzIGFzc2V0OiAke2Zvcm1hdHRlZEFzc2V0LnNyY31gKTtcbiAgICAgICAgICBmb3JtYXR0ZWRBc3NldCA9IHRoaXMuYnVpbGRSZXNvbHZlZEFzc2V0KGZvcm1hdHRlZEFzc2V0LCB7XG4gICAgICAgICAgICBhbGlhc2VzOiBhbGlhc2VzVG9Vc2UsXG4gICAgICAgICAgICBkYXRhOiBkYXRhMixcbiAgICAgICAgICAgIGZvcm1hdDogZm9ybWF0MixcbiAgICAgICAgICAgIGxvYWRQYXJzZXI6IGxvYWRQYXJzZXIyXG4gICAgICAgICAgfSksIHJlc29sdmVkQXNzZXRzLnB1c2goZm9ybWF0dGVkQXNzZXQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLCBhbGlhc2VzVG9Vc2UuZm9yRWFjaCgoYWxpYXMpID0+IHtcbiAgICAgICAgdGhpcy5fYXNzZXRNYXBbYWxpYXNdID0gcmVzb2x2ZWRBc3NldHM7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvLyBUT0RPOiB0aGlzIG5lZWRzIGFuIG92ZXJsb2FkIGxpa2UgbG9hZCBkaWQgaW4gQXNzZXRzXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVzb2x2ZXIgaGFzIGhhZCBhIG1hbmlmZXN0IHNldCB2aWEgc2V0TWFuaWZlc3QsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGFzc2V0cyB1cmxzIGZvclxuICAgKiBhIGdpdmVuIGJ1bmRsZUlkIG9yIGJ1bmRsZUlkcy5cbiAgICogQGV4YW1wbGVcbiAgICogLy8gTWFuaWZlc3QgRXhhbXBsZVxuICAgKiBjb25zdCBtYW5pZmVzdCA9IHtcbiAgICogICAgIGJ1bmRsZXM6IFtcbiAgICogICAgICAgICB7XG4gICAqICAgICAgICAgICAgIG5hbWU6ICdsb2FkLXNjcmVlbicsXG4gICAqICAgICAgICAgICAgIGFzc2V0czogW1xuICAgKiAgICAgICAgICAgICAgICAge1xuICAgKiAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiAnYmFja2dyb3VuZCcsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAnc3Vuc2V0LnBuZycsXG4gICAqICAgICAgICAgICAgICAgICB9LFxuICAgKiAgICAgICAgICAgICAgICAge1xuICAgKiAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiAnYmFyJyxcbiAgICogICAgICAgICAgICAgICAgICAgICBzcmM6ICdsb2FkLWJhci57cG5nLHdlYnB9JyxcbiAgICogICAgICAgICAgICAgICAgIH0sXG4gICAqICAgICAgICAgICAgIF0sXG4gICAqICAgICAgICAgfSxcbiAgICogICAgICAgICB7XG4gICAqICAgICAgICAgICAgIG5hbWU6ICdnYW1lLXNjcmVlbicsXG4gICAqICAgICAgICAgICAgIGFzc2V0czogW1xuICAgKiAgICAgICAgICAgICAgICAge1xuICAgKiAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiAnY2hhcmFjdGVyJyxcbiAgICogICAgICAgICAgICAgICAgICAgICBzcmM6ICdyb2JvdC5wbmcnLFxuICAgKiAgICAgICAgICAgICAgICAgfSxcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2VuZW15JyxcbiAgICogICAgICAgICAgICAgICAgICAgICBzcmM6ICdiYWQtZ3V5LnBuZycsXG4gICAqICAgICAgICAgICAgICAgICB9LFxuICAgKiAgICAgICAgICAgICBdLFxuICAgKiAgICAgICAgIH0sXG4gICAqICAgICBdXG4gICAqIH07XG4gICAqXG4gICAqIHJlc29sdmVyLnNldE1hbmlmZXN0KG1hbmlmZXN0KTtcbiAgICogY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlci5yZXNvbHZlQnVuZGxlKCdsb2FkLXNjcmVlbicpO1xuICAgKiBAcGFyYW0gYnVuZGxlSWRzIC0gVGhlIGJ1bmRsZSBpZHMgdG8gcmVzb2x2ZVxuICAgKiBAcmV0dXJucyBBbGwgdGhlIGJ1bmRsZXMgYXNzZXRzIG9yIGEgaGFzaCBvZiBhc3NldHMgZm9yIGVhY2ggYnVuZGxlIHNwZWNpZmllZFxuICAgKi9cbiAgcmVzb2x2ZUJ1bmRsZShidW5kbGVJZHMpIHtcbiAgICBjb25zdCBzaW5nbGVBc3NldCA9IGlzU2luZ2xlSXRlbS5pc1NpbmdsZUl0ZW0oYnVuZGxlSWRzKTtcbiAgICBidW5kbGVJZHMgPSBjb252ZXJ0VG9MaXN0LmNvbnZlcnRUb0xpc3QoYnVuZGxlSWRzKTtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICByZXR1cm4gYnVuZGxlSWRzLmZvckVhY2goKGJ1bmRsZUlkKSA9PiB7XG4gICAgICBjb25zdCBhc3NldE5hbWVzID0gdGhpcy5fYnVuZGxlc1tidW5kbGVJZF07XG4gICAgICBpZiAoYXNzZXROYW1lcykge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gdGhpcy5yZXNvbHZlKGFzc2V0TmFtZXMpLCBhc3NldHMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0cykge1xuICAgICAgICAgIGNvbnN0IGFzc2V0ID0gcmVzdWx0c1trZXldO1xuICAgICAgICAgIGFzc2V0c1t0aGlzLl9leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUoYnVuZGxlSWQsIGtleSldID0gYXNzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgb3V0W2J1bmRsZUlkXSA9IGFzc2V0cztcbiAgICAgIH1cbiAgICB9KSwgc2luZ2xlQXNzZXQgPyBvdXRbYnVuZGxlSWRzWzBdXSA6IG91dDtcbiAgfVxuICAvKipcbiAgICogRG9lcyBleGFjdGx5IHdoYXQgcmVzb2x2ZSBkb2VzLCBidXQgcmV0dXJucyBqdXN0IHRoZSBVUkwgcmF0aGVyIHRoYW4gdGhlIHdob2xlIGFzc2V0IG9iamVjdFxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvciBrZXlzIHRvIHJlc29sdmVcbiAgICogQHJldHVybnMgLSBUaGUgVVJMcyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleShzKVxuICAgKi9cbiAgcmVzb2x2ZVVybChrZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc29sdmUoa2V5KTtcbiAgICBpZiAodHlwZW9mIGtleSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBvdXQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgaSBpbiByZXN1bHQpXG4gICAgICAgIG91dFtpXSA9IHJlc3VsdFtpXS5zcmM7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnNyYztcbiAgfVxuICByZXNvbHZlKGtleXMpIHtcbiAgICBjb25zdCBzaW5nbGVBc3NldCA9IGlzU2luZ2xlSXRlbS5pc1NpbmdsZUl0ZW0oa2V5cyk7XG4gICAga2V5cyA9IGNvbnZlcnRUb0xpc3QuY29udmVydFRvTGlzdChrZXlzKTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICByZXR1cm4ga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmICghdGhpcy5fcmVzb2x2ZXJIYXNoW2tleV0pXG4gICAgICAgIGlmICh0aGlzLl9hc3NldE1hcFtrZXldKSB7XG4gICAgICAgICAgbGV0IGFzc2V0cyA9IHRoaXMuX2Fzc2V0TWFwW2tleV07XG4gICAgICAgICAgY29uc3QgYmVzdEFzc2V0ID0gYXNzZXRzWzBdLCBwcmVmZXJyZWRPcmRlciA9IHRoaXMuX2dldFByZWZlcnJlZE9yZGVyKGFzc2V0cyk7XG4gICAgICAgICAgcHJlZmVycmVkT3JkZXI/LnByaW9yaXR5LmZvckVhY2goKHByaW9yaXR5S2V5KSA9PiB7XG4gICAgICAgICAgICBwcmVmZXJyZWRPcmRlci5wYXJhbXNbcHJpb3JpdHlLZXldLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQXNzZXRzID0gYXNzZXRzLmZpbHRlcigoYXNzZXQpID0+IGFzc2V0W3ByaW9yaXR5S2V5XSA/IGFzc2V0W3ByaW9yaXR5S2V5XSA9PT0gdmFsdWUgOiAhMSk7XG4gICAgICAgICAgICAgIGZpbHRlcmVkQXNzZXRzLmxlbmd0aCAmJiAoYXNzZXRzID0gZmlsdGVyZWRBc3NldHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSksIHRoaXMuX3Jlc29sdmVySGFzaFtrZXldID0gYXNzZXRzWzBdID8/IGJlc3RBc3NldDtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZXJIYXNoW2tleV0gPSB0aGlzLmJ1aWxkUmVzb2x2ZWRBc3NldCh7XG4gICAgICAgICAgICBhbGlhczogW2tleV0sXG4gICAgICAgICAgICBzcmM6IGtleVxuICAgICAgICAgIH0sIHt9KTtcbiAgICAgIHJlc3VsdFtrZXldID0gdGhpcy5fcmVzb2x2ZXJIYXNoW2tleV07XG4gICAgfSksIHNpbmdsZUFzc2V0ID8gcmVzdWx0W2tleXNbMF1dIDogcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYW4gYXNzZXQgd2l0aCBhIGdpdmVuIGtleSBleGlzdHMgaW4gdGhlIHJlc29sdmVyXG4gICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBhc3NldFxuICAgKi9cbiAgaGFzS2V5KGtleSkge1xuICAgIHJldHVybiAhIXRoaXMuX2Fzc2V0TWFwW2tleV07XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGJ1bmRsZSB3aXRoIHRoZSBnaXZlbiBrZXkgZXhpc3RzIGluIHRoZSByZXNvbHZlclxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgYnVuZGxlXG4gICAqL1xuICBoYXNCdW5kbGUoa2V5KSB7XG4gICAgcmV0dXJuICEhdGhpcy5fYnVuZGxlc1trZXldO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm5hbCBmdW5jdGlvbiBmb3IgZmlndXJpbmcgb3V0IHdoYXQgcHJlZmVyIGNyaXRlcmlhIGFuIGFzc2V0IHNob3VsZCB1c2UuXG4gICAqIEBwYXJhbSBhc3NldHNcbiAgICovXG4gIF9nZXRQcmVmZXJyZWRPcmRlcihhc3NldHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXNzZXQgPSBhc3NldHNbMF0sIHByZWZlcnJlZCA9IHRoaXMuX3ByZWZlcnJlZE9yZGVyLmZpbmQoKHByZWZlcmVuY2UpID0+IHByZWZlcmVuY2UucGFyYW1zLmZvcm1hdC5pbmNsdWRlcyhhc3NldC5mb3JtYXQpKTtcbiAgICAgIGlmIChwcmVmZXJyZWQpXG4gICAgICAgIHJldHVybiBwcmVmZXJyZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcmVmZXJyZWRPcmRlclswXTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZGVmYXVsdCB1cmwgcGFyYW1ldGVycyB0byB0aGUgdXJsXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgdXJsIHRvIGFwcGVuZCB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzIHRvXG4gICAqIEByZXR1cm5zIC0gVGhlIHVybCB3aXRoIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnMgYXBwZW5kZWRcbiAgICovXG4gIF9hcHBlbmREZWZhdWx0U2VhcmNoUGFyYW1zKHVybCkge1xuICAgIGlmICghdGhpcy5fZGVmYXVsdFNlYXJjaFBhcmFtcylcbiAgICAgIHJldHVybiB1cmw7XG4gICAgY29uc3QgcGFyYW1Db25uZWN0b3IgPSAvXFw/Ly50ZXN0KHVybCkgPyBcIiZcIiA6IFwiP1wiO1xuICAgIHJldHVybiBgJHt1cmx9JHtwYXJhbUNvbm5lY3Rvcn0ke3RoaXMuX2RlZmF1bHRTZWFyY2hQYXJhbXN9YDtcbiAgfVxuICBidWlsZFJlc29sdmVkQXNzZXQoZm9ybWF0dGVkQXNzZXQsIGRhdGEpIHtcbiAgICBjb25zdCB7IGFsaWFzZXMsIGRhdGE6IGFzc2V0RGF0YSwgbG9hZFBhcnNlciwgZm9ybWF0IH0gPSBkYXRhO1xuICAgIHJldHVybiAodGhpcy5fYmFzZVBhdGggfHwgdGhpcy5fcm9vdFBhdGgpICYmIChmb3JtYXR0ZWRBc3NldC5zcmMgPSBjb3JlLnV0aWxzLnBhdGgudG9BYnNvbHV0ZShmb3JtYXR0ZWRBc3NldC5zcmMsIHRoaXMuX2Jhc2VQYXRoLCB0aGlzLl9yb290UGF0aCkpLCBmb3JtYXR0ZWRBc3NldC5hbGlhcyA9IGFsaWFzZXMgPz8gZm9ybWF0dGVkQXNzZXQuYWxpYXMgPz8gW2Zvcm1hdHRlZEFzc2V0LnNyY10sIGZvcm1hdHRlZEFzc2V0LnNyYyA9IHRoaXMuX2FwcGVuZERlZmF1bHRTZWFyY2hQYXJhbXMoZm9ybWF0dGVkQXNzZXQuc3JjKSwgZm9ybWF0dGVkQXNzZXQuZGF0YSA9IHsgLi4uYXNzZXREYXRhIHx8IHt9LCAuLi5mb3JtYXR0ZWRBc3NldC5kYXRhIH0sIGZvcm1hdHRlZEFzc2V0LmxvYWRQYXJzZXIgPSBsb2FkUGFyc2VyID8/IGZvcm1hdHRlZEFzc2V0LmxvYWRQYXJzZXIsIGZvcm1hdHRlZEFzc2V0LmZvcm1hdCA9IGZvcm1hdCA/PyBjb3JlLnV0aWxzLnBhdGguZXh0bmFtZShmb3JtYXR0ZWRBc3NldC5zcmMpLnNsaWNlKDEpLCBmb3JtYXR0ZWRBc3NldC5zcmNzID0gZm9ybWF0dGVkQXNzZXQuc3JjLCBmb3JtYXR0ZWRBc3NldC5uYW1lID0gZm9ybWF0dGVkQXNzZXQuYWxpYXMsIGZvcm1hdHRlZEFzc2V0O1xuICB9XG59XG5leHBvcnRzLlJlc29sdmVyID0gUmVzb2x2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNvbHZlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xucmVxdWlyZShcIi4vcGFyc2Vycy9pbmRleC5qc1wiKTtcbnJlcXVpcmUoXCIuL3R5cGVzLmpzXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciByZXNvbHZlVGV4dHVyZVVybCA9IHJlcXVpcmUoXCIuL3Jlc29sdmVUZXh0dXJlVXJsLmpzXCIpO1xuZXhwb3J0cy5yZXNvbHZlVGV4dHVyZVVybCA9IHJlc29sdmVUZXh0dXJlVXJsLnJlc29sdmVUZXh0dXJlVXJsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIik7XG5yZXF1aXJlKFwiLi4vLi4vbG9hZGVyL2luZGV4LmpzXCIpO1xudmFyIGxvYWRUZXh0dXJlcyA9IHJlcXVpcmUoXCIuLi8uLi9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy9sb2FkVGV4dHVyZXMuanNcIik7XG5jb25zdCByZXNvbHZlVGV4dHVyZVVybCA9IHtcbiAgZXh0ZW5zaW9uOiBjb3JlLkV4dGVuc2lvblR5cGUuUmVzb2x2ZVBhcnNlcixcbiAgdGVzdDogbG9hZFRleHR1cmVzLmxvYWRUZXh0dXJlcy50ZXN0LFxuICBwYXJzZTogKHZhbHVlKSA9PiAoe1xuICAgIHJlc29sdXRpb246IHBhcnNlRmxvYXQoY29yZS5zZXR0aW5ncy5SRVRJTkFfUFJFRklYLmV4ZWModmFsdWUpPy5bMV0gPz8gXCIxXCIpLFxuICAgIGZvcm1hdDogY29yZS51dGlscy5wYXRoLmV4dG5hbWUodmFsdWUpLnNsaWNlKDEpLFxuICAgIHNyYzogdmFsdWVcbiAgfSlcbn07XG5jb3JlLmV4dGVuc2lvbnMuYWRkKHJlc29sdmVUZXh0dXJlVXJsKTtcbmV4cG9ydHMucmVzb2x2ZVRleHR1cmVVcmwgPSByZXNvbHZlVGV4dHVyZVVybDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVUZXh0dXJlVXJsLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGNoZWNrRGF0YVVybCh1cmwsIG1pbWVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1pbWVzKSkge1xuICAgIGZvciAoY29uc3QgbWltZSBvZiBtaW1lcylcbiAgICAgIGlmICh1cmwuc3RhcnRzV2l0aChgZGF0YToke21pbWV9YCkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuIHVybC5zdGFydHNXaXRoKGBkYXRhOiR7bWltZXN9YCk7XG59XG5leHBvcnRzLmNoZWNrRGF0YVVybCA9IGNoZWNrRGF0YVVybDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrRGF0YVVybC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKTtcbmZ1bmN0aW9uIGNoZWNrRXh0ZW5zaW9uKHVybCwgZXh0ZW5zaW9uKSB7XG4gIGNvbnN0IHRlbXBVUkwgPSB1cmwuc3BsaXQoXCI/XCIpWzBdLCBleHQgPSBjb3JlLnV0aWxzLnBhdGguZXh0bmFtZSh0ZW1wVVJMKS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShleHRlbnNpb24pID8gZXh0ZW5zaW9uLmluY2x1ZGVzKGV4dCkgOiBleHQgPT09IGV4dGVuc2lvbjtcbn1cbmV4cG9ydHMuY2hlY2tFeHRlbnNpb24gPSBjaGVja0V4dGVuc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrRXh0ZW5zaW9uLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBjb252ZXJ0VG9MaXN0ID0gKGlucHV0LCB0cmFuc2Zvcm0sIGZvcmNlVHJhbnNmb3JtID0gITEpID0+IChBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQgPSBbaW5wdXRdKSwgdHJhbnNmb3JtID8gaW5wdXQubWFwKChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PSBcInN0cmluZ1wiIHx8IGZvcmNlVHJhbnNmb3JtID8gdHJhbnNmb3JtKGl0ZW0pIDogaXRlbSkgOiBpbnB1dCk7XG5leHBvcnRzLmNvbnZlcnRUb0xpc3QgPSBjb252ZXJ0VG9MaXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udmVydFRvTGlzdC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgY29weVNlYXJjaFBhcmFtcyA9ICh0YXJnZXRVcmwsIHNvdXJjZVVybCkgPT4ge1xuICBjb25zdCBzZWFyY2hQYXJhbXMgPSBzb3VyY2VVcmwuc3BsaXQoXCI/XCIpWzFdO1xuICByZXR1cm4gc2VhcmNoUGFyYW1zICYmICh0YXJnZXRVcmwgKz0gYD8ke3NlYXJjaFBhcmFtc31gKSwgdGFyZ2V0VXJsO1xufTtcbmV4cG9ydHMuY29weVNlYXJjaFBhcmFtcyA9IGNvcHlTZWFyY2hQYXJhbXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3B5U2VhcmNoUGFyYW1zLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBwcm9jZXNzWChiYXNlLCBpZHMsIGRlcHRoLCByZXN1bHQsIHRhZ3MpIHtcbiAgY29uc3QgaWQgPSBpZHNbZGVwdGhdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdmFsdWUgPSBpZFtpXTtcbiAgICBkZXB0aCA8IGlkcy5sZW5ndGggLSAxID8gcHJvY2Vzc1goYmFzZS5yZXBsYWNlKHJlc3VsdFtkZXB0aF0sIHZhbHVlKSwgaWRzLCBkZXB0aCArIDEsIHJlc3VsdCwgdGFncykgOiB0YWdzLnB1c2goYmFzZS5yZXBsYWNlKHJlc3VsdFtkZXB0aF0sIHZhbHVlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMoc3RyaW5nKSB7XG4gIGNvbnN0IHJlZ2V4ID0gL1xceyguKj8pXFx9L2csIHJlc3VsdCA9IHN0cmluZy5tYXRjaChyZWdleCksIHRhZ3MgPSBbXTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIGNvbnN0IGlkcyA9IFtdO1xuICAgIHJlc3VsdC5mb3JFYWNoKCh2YXJzKSA9PiB7XG4gICAgICBjb25zdCBzcGxpdCA9IHZhcnMuc3Vic3RyaW5nKDEsIHZhcnMubGVuZ3RoIC0gMSkuc3BsaXQoXCIsXCIpO1xuICAgICAgaWRzLnB1c2goc3BsaXQpO1xuICAgIH0pLCBwcm9jZXNzWChzdHJpbmcsIGlkcywgMCwgcmVzdWx0LCB0YWdzKTtcbiAgfSBlbHNlXG4gICAgdGFncy5wdXNoKHN0cmluZyk7XG4gIHJldHVybiB0YWdzO1xufVxuZXhwb3J0cy5jcmVhdGVTdHJpbmdWYXJpYXRpb25zID0gY3JlYXRlU3RyaW5nVmFyaWF0aW9ucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjaGVja0RhdGFVcmwgPSByZXF1aXJlKFwiLi9jaGVja0RhdGFVcmwuanNcIiksIGNoZWNrRXh0ZW5zaW9uID0gcmVxdWlyZShcIi4vY2hlY2tFeHRlbnNpb24uanNcIiksIGNvbnZlcnRUb0xpc3QgPSByZXF1aXJlKFwiLi9jb252ZXJ0VG9MaXN0LmpzXCIpLCBjb3B5U2VhcmNoUGFyYW1zID0gcmVxdWlyZShcIi4vY29weVNlYXJjaFBhcmFtcy5qc1wiKSwgY3JlYXRlU3RyaW5nVmFyaWF0aW9ucyA9IHJlcXVpcmUoXCIuL2NyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMuanNcIiksIGlzU2luZ2xlSXRlbSA9IHJlcXVpcmUoXCIuL2lzU2luZ2xlSXRlbS5qc1wiKTtcbmV4cG9ydHMuY2hlY2tEYXRhVXJsID0gY2hlY2tEYXRhVXJsLmNoZWNrRGF0YVVybDtcbmV4cG9ydHMuY2hlY2tFeHRlbnNpb24gPSBjaGVja0V4dGVuc2lvbi5jaGVja0V4dGVuc2lvbjtcbmV4cG9ydHMuY29udmVydFRvTGlzdCA9IGNvbnZlcnRUb0xpc3QuY29udmVydFRvTGlzdDtcbmV4cG9ydHMuY29weVNlYXJjaFBhcmFtcyA9IGNvcHlTZWFyY2hQYXJhbXMuY29weVNlYXJjaFBhcmFtcztcbmV4cG9ydHMuY3JlYXRlU3RyaW5nVmFyaWF0aW9ucyA9IGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMuY3JlYXRlU3RyaW5nVmFyaWF0aW9ucztcbmV4cG9ydHMuaXNTaW5nbGVJdGVtID0gaXNTaW5nbGVJdGVtLmlzU2luZ2xlSXRlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpc1NpbmdsZUl0ZW0gPSAoaXRlbSkgPT4gIUFycmF5LmlzQXJyYXkoaXRlbSk7XG5leHBvcnRzLmlzU2luZ2xlSXRlbSA9IGlzU2luZ2xlSXRlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzU2luZ2xlSXRlbS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbG9yZCA9IHJlcXVpcmUoXCJAcGl4aS9jb2xvcmRcIiksIG5hbWVzUGx1Z2luID0gcmVxdWlyZShcIkBwaXhpL2NvbG9yZC9wbHVnaW5zL25hbWVzXCIpO1xuY29sb3JkLmV4dGVuZChbbmFtZXNQbHVnaW5dKTtcbmNvbnN0IF9Db2xvciA9IGNsYXNzIF9Db2xvcjIge1xuICAvKipcbiAgICogQHBhcmFtIHtQSVhJLkNvbG9yU291cmNlfSB2YWx1ZSAtIE9wdGlvbmFsIHZhbHVlIHRvIHVzZSwgaWYgbm90IHByb3ZpZGVkLCB3aGl0ZSBpcyB1c2VkLlxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWUgPSAxNjc3NzIxNSkge1xuICAgIHRoaXMuX3ZhbHVlID0gbnVsbCwgdGhpcy5fY29tcG9uZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoNCksIHRoaXMuX2NvbXBvbmVudHMuZmlsbCgxKSwgdGhpcy5faW50ID0gMTY3NzcyMTUsIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKiogR2V0IHJlZCBjb21wb25lbnQgKDAgLSAxKSAqL1xuICBnZXQgcmVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzBdO1xuICB9XG4gIC8qKiBHZXQgZ3JlZW4gY29tcG9uZW50ICgwIC0gMSkgKi9cbiAgZ2V0IGdyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzFdO1xuICB9XG4gIC8qKiBHZXQgYmx1ZSBjb21wb25lbnQgKDAgLSAxKSAqL1xuICBnZXQgYmx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1syXTtcbiAgfVxuICAvKiogR2V0IGFscGhhIGNvbXBvbmVudCAoMCAtIDEpICovXG4gIGdldCBhbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1szXTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZSwgc3VpdGFibGUgZm9yIGNoYWluaW5nXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAc2VlIFBJWEkuQ29sb3IudmFsdWVcbiAgICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPSB2YWx1ZSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgY29sb3Igc291cmNlLlxuICAgKlxuICAgKiBXaGVuIHNldHRpbmc6XG4gICAqIC0gU2V0dGluZyB0byBhbiBpbnN0YW5jZSBvZiBgQ29sb3JgIHdpbGwgY29weSBpdHMgY29sb3Igc291cmNlIGFuZCBjb21wb25lbnRzLlxuICAgKiAtIE90aGVyd2lzZSwgYENvbG9yYCB3aWxsIHRyeSB0byBub3JtYWxpemUgdGhlIGNvbG9yIHNvdXJjZSBhbmQgc2V0IHRoZSBjb21wb25lbnRzLlxuICAgKiAgIElmIHRoZSBjb2xvciBzb3VyY2UgaXMgaW52YWxpZCwgYW4gYEVycm9yYCB3aWxsIGJlIHRocm93biBhbmQgdGhlIGBDb2xvcmAgd2lsbCBsZWZ0IHVuY2hhbmdlZC5cbiAgICpcbiAgICogTm90ZTogVGhlIGBudWxsYCBpbiB0aGUgc2V0dGVyJ3MgcGFyYW1ldGVyIHR5cGUgaXMgYWRkZWQgdG8gbWF0Y2ggdGhlIFR5cGVTY3JpcHQgcnVsZTogcmV0dXJuIHR5cGUgb2YgZ2V0dGVyXG4gICAqIG11c3QgYmUgYXNzaWduYWJsZSB0byBpdHMgc2V0dGVyJ3MgcGFyYW1ldGVyIHR5cGUuIFNldHRpbmcgYHZhbHVlYCB0byBgbnVsbGAgd2lsbCB0aHJvdyBhbiBgRXJyb3JgLlxuICAgKlxuICAgKiBXaGVuIGdldHRpbmc6XG4gICAqIC0gQSByZXR1cm4gdmFsdWUgb2YgYG51bGxgIG1lYW5zIHRoZSBwcmV2aW91cyB2YWx1ZSB3YXMgb3ZlcnJpZGRlbiAoZS5nLiwge0BsaW5rIFBJWEkuQ29sb3IubXVsdGlwbHkgbXVsdGlwbHl9LFxuICAgKiAgIHtAbGluayBQSVhJLkNvbG9yLnByZW11bHRpcGx5IHByZW11bHRpcGx5fSBvciB7QGxpbmsgUElYSS5Db2xvci5yb3VuZCByb3VuZH0pLlxuICAgKiAtIE90aGVyd2lzZSwgdGhlIGNvbG9yIHNvdXJjZSB1c2VkIHdoZW4gc2V0dGluZyBpcyByZXR1cm5lZC5cbiAgICogQHR5cGUge1BJWEkuQ29sb3JTb3VyY2V9XG4gICAqL1xuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfQ29sb3IyKVxuICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLmNsb25lU291cmNlKHZhbHVlLl92YWx1ZSksIHRoaXMuX2ludCA9IHZhbHVlLl9pbnQsIHRoaXMuX2NvbXBvbmVudHMuc2V0KHZhbHVlLl9jb21wb25lbnRzKTtcbiAgICBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBQSVhJLkNvbG9yI3ZhbHVlIHRvIG51bGxcIik7XG4gICAgICAodGhpcy5fdmFsdWUgPT09IG51bGwgfHwgIXRoaXMuaXNTb3VyY2VFcXVhbCh0aGlzLl92YWx1ZSwgdmFsdWUpKSAmJiAodGhpcy5ub3JtYWxpemUodmFsdWUpLCB0aGlzLl92YWx1ZSA9IHRoaXMuY2xvbmVTb3VyY2UodmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ29weSBhIGNvbG9yIHNvdXJjZSBpbnRlcm5hbGx5LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBDb2xvciBzb3VyY2VcbiAgICovXG4gIGNsb25lU291cmNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHZhbHVlID09PSBudWxsID8gdmFsdWUgOiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpID8gdmFsdWUuc2xpY2UoMCkgOiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCA/IHsgLi4udmFsdWUgfSA6IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBFcXVhbGl0eSBjaGVjayBmb3IgY29sb3Igc291cmNlcy5cbiAgICogQHBhcmFtIHZhbHVlMSAtIEZpcnN0IGNvbG9yIHNvdXJjZVxuICAgKiBAcGFyYW0gdmFsdWUyIC0gU2Vjb25kIGNvbG9yIHNvdXJjZVxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbG9yIHNvdXJjZXMgYXJlIGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICovXG4gIGlzU291cmNlRXF1YWwodmFsdWUxLCB2YWx1ZTIpIHtcbiAgICBjb25zdCB0eXBlMSA9IHR5cGVvZiB2YWx1ZTE7XG4gICAgaWYgKHR5cGUxICE9PSB0eXBlb2YgdmFsdWUyKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmICh0eXBlMSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlMSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZTEgaW5zdGFuY2VvZiBOdW1iZXIpXG4gICAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUxKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlMikgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlMSkgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlMikpXG4gICAgICByZXR1cm4gdmFsdWUxLmxlbmd0aCAhPT0gdmFsdWUyLmxlbmd0aCA/ICExIDogdmFsdWUxLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSB2YWx1ZTJbaV0pO1xuICAgIGlmICh2YWx1ZTEgIT09IG51bGwgJiYgdmFsdWUyICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKHZhbHVlMSksIGtleXMyID0gT2JqZWN0LmtleXModmFsdWUyKTtcbiAgICAgIHJldHVybiBrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCA/ICExIDoga2V5czEuZXZlcnkoKGtleSkgPT4gdmFsdWUxW2tleV0gPT09IHZhbHVlMltrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlMSA9PT0gdmFsdWUyO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHRvIGEgUkdCQSBjb2xvciBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIG5ldyBDb2xvcignd2hpdGUnKS50b1JnYigpOyAvLyByZXR1cm5zIHsgcjogMSwgZzogMSwgYjogMSwgYTogMSB9XG4gICAqL1xuICB0b1JnYmEoKSB7XG4gICAgY29uc3QgW3IsIGcsIGIsIGFdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICByZXR1cm4geyByLCBnLCBiLCBhIH07XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBSR0IgY29sb3Igb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3BpeGkuanMnO1xuICAgKiBuZXcgQ29sb3IoJ3doaXRlJykudG9SZ2IoKTsgLy8gcmV0dXJucyB7IHI6IDEsIGc6IDEsIGI6IDEgfVxuICAgKi9cbiAgdG9SZ2IoKSB7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICByZXR1cm4geyByLCBnLCBiIH07XG4gIH1cbiAgLyoqIENvbnZlcnQgdG8gYSBDU1Mtc3R5bGUgcmdiYSBzdHJpbmc6IGByZ2JhKDI1NSwyNTUsMjU1LDEuMClgLiAqL1xuICB0b1JnYmFTdHJpbmcoKSB7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy50b1VpbnQ4UmdiQXJyYXkoKTtcbiAgICByZXR1cm4gYHJnYmEoJHtyfSwke2d9LCR7Yn0sJHt0aGlzLmFscGhhfSlgO1xuICB9XG4gIHRvVWludDhSZ2JBcnJheShvdXQpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHJldHVybiBvdXQgPSBvdXQgPz8gW10sIG91dFswXSA9IE1hdGgucm91bmQociAqIDI1NSksIG91dFsxXSA9IE1hdGgucm91bmQoZyAqIDI1NSksIG91dFsyXSA9IE1hdGgucm91bmQoYiAqIDI1NSksIG91dDtcbiAgfVxuICB0b1JnYkFycmF5KG91dCkge1xuICAgIG91dCA9IG91dCA/PyBbXTtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHJldHVybiBvdXRbMF0gPSByLCBvdXRbMV0gPSBnLCBvdXRbMl0gPSBiLCBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBudW1iZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIG5ldyBDb2xvcignd2hpdGUnKS50b051bWJlcigpOyAvLyByZXR1cm5zIDE2Nzc3MjE1XG4gICAqL1xuICB0b051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5faW50O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgbnVtYmVyIGluIGxpdHRsZSBlbmRpYW4gZm9ybWF0IChlLmcuLCBCQkdHUlIpLlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3BpeGkuanMnO1xuICAgKiBuZXcgQ29sb3IoMHhmZmNjOTkpLnRvTGl0dGxlRW5kaWFuTnVtYmVyKCk7IC8vIHJldHVybnMgMHg5OWNjZmZcbiAgICogQHJldHVybnMge251bWJlcn0gLSBUaGUgY29sb3IgYXMgYSBudW1iZXIgaW4gbGl0dGxlIGVuZGlhbiBmb3JtYXQuXG4gICAqL1xuICB0b0xpdHRsZUVuZGlhbk51bWJlcigpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2ludDtcbiAgICByZXR1cm4gKHZhbHVlID4+IDE2KSArICh2YWx1ZSAmIDY1MjgwKSArICgodmFsdWUgJiAyNTUpIDw8IDE2KTtcbiAgfVxuICAvKipcbiAgICogTXVsdGlwbHkgd2l0aCBhbm90aGVyIGNvbG9yLiBUaGlzIGFjdGlvbiBpcyBkZXN0cnVjdGl2ZSwgYW5kIHdpbGxcbiAgICogb3ZlcnJpZGUgdGhlIHByZXZpb3VzIGB2YWx1ZWAgcHJvcGVydHkgdG8gYmUgYG51bGxgLlxuICAgKiBAcGFyYW0ge1BJWEkuQ29sb3JTb3VyY2V9IHZhbHVlIC0gVGhlIGNvbG9yIHRvIG11bHRpcGx5IGJ5LlxuICAgKi9cbiAgbXVsdGlwbHkodmFsdWUpIHtcbiAgICBjb25zdCBbciwgZywgYiwgYV0gPSBfQ29sb3IyLnRlbXAuc2V0VmFsdWUodmFsdWUpLl9jb21wb25lbnRzO1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzBdICo9IHIsIHRoaXMuX2NvbXBvbmVudHNbMV0gKj0gZywgdGhpcy5fY29tcG9uZW50c1syXSAqPSBiLCB0aGlzLl9jb21wb25lbnRzWzNdICo9IGEsIHRoaXMucmVmcmVzaEludCgpLCB0aGlzLl92YWx1ZSA9IG51bGwsIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGNvbG9yIHRvIGEgcHJlbXVsdGlwbGllZCBhbHBoYSBmb3JtYXQuIFRoaXMgYWN0aW9uIGlzIGRlc3RydWN0aXZlLCBhbmQgd2lsbFxuICAgKiBvdmVycmlkZSB0aGUgcHJldmlvdXMgYHZhbHVlYCBwcm9wZXJ0eSB0byBiZSBgbnVsbGAuXG4gICAqIEBwYXJhbSBhbHBoYSAtIFRoZSBhbHBoYSB0byBtdWx0aXBseSBieS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbYXBwbHlUb1JHQj10cnVlXSAtIFdoZXRoZXIgdG8gcHJlbXVsdGlwbHkgUkdCIGNoYW5uZWxzLlxuICAgKiBAcmV0dXJucyB7UElYSS5Db2xvcn0gLSBJdHNlbGYuXG4gICAqL1xuICBwcmVtdWx0aXBseShhbHBoYSwgYXBwbHlUb1JHQiA9ICEwKSB7XG4gICAgcmV0dXJuIGFwcGx5VG9SR0IgJiYgKHRoaXMuX2NvbXBvbmVudHNbMF0gKj0gYWxwaGEsIHRoaXMuX2NvbXBvbmVudHNbMV0gKj0gYWxwaGEsIHRoaXMuX2NvbXBvbmVudHNbMl0gKj0gYWxwaGEpLCB0aGlzLl9jb21wb25lbnRzWzNdID0gYWxwaGEsIHRoaXMucmVmcmVzaEludCgpLCB0aGlzLl92YWx1ZSA9IG51bGwsIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFByZW11bHRpcGxpZXMgYWxwaGEgd2l0aCBjdXJyZW50IGNvbG9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYWxwaGEgLSBUaGUgYWxwaGEgdG8gbXVsdGlwbHkgYnkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FwcGx5VG9SR0I9dHJ1ZV0gLSBXaGV0aGVyIHRvIHByZW11bHRpcGx5IFJHQiBjaGFubmVscy5cbiAgICogQHJldHVybnMge251bWJlcn0gdGludCBtdWx0aXBsaWVkIGJ5IGFscGhhXG4gICAqL1xuICB0b1ByZW11bHRpcGxpZWQoYWxwaGEsIGFwcGx5VG9SR0IgPSAhMCkge1xuICAgIGlmIChhbHBoYSA9PT0gMSlcbiAgICAgIHJldHVybiAoMjU1IDw8IDI0KSArIHRoaXMuX2ludDtcbiAgICBpZiAoYWxwaGEgPT09IDApXG4gICAgICByZXR1cm4gYXBwbHlUb1JHQiA/IDAgOiB0aGlzLl9pbnQ7XG4gICAgbGV0IHIgPSB0aGlzLl9pbnQgPj4gMTYgJiAyNTUsIGcgPSB0aGlzLl9pbnQgPj4gOCAmIDI1NSwgYiA9IHRoaXMuX2ludCAmIDI1NTtcbiAgICByZXR1cm4gYXBwbHlUb1JHQiAmJiAociA9IHIgKiBhbHBoYSArIDAuNSB8IDAsIGcgPSBnICogYWxwaGEgKyAwLjUgfCAwLCBiID0gYiAqIGFscGhhICsgMC41IHwgMCksIChhbHBoYSAqIDI1NSA8PCAyNCkgKyAociA8PCAxNikgKyAoZyA8PCA4KSArIGI7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBoZXhpZGVjaW1hbCBzdHJpbmcuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIG5ldyBDb2xvcignd2hpdGUnKS50b0hleCgpOyAvLyByZXR1cm5zIFwiI2ZmZmZmZlwiXG4gICAqL1xuICB0b0hleCgpIHtcbiAgICBjb25zdCBoZXhTdHJpbmcgPSB0aGlzLl9pbnQudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBgIyR7XCIwMDAwMDBcIi5zdWJzdHJpbmcoMCwgNiAtIGhleFN0cmluZy5sZW5ndGgpICsgaGV4U3RyaW5nfWA7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBoZXhpZGVjaW1hbCBzdHJpbmcgd2l0aCBhbHBoYS5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAgICogbmV3IENvbG9yKCd3aGl0ZScpLnRvSGV4YSgpOyAvLyByZXR1cm5zIFwiI2ZmZmZmZmZmXCJcbiAgICovXG4gIHRvSGV4YSgpIHtcbiAgICBjb25zdCBhbHBoYVN0cmluZyA9IE1hdGgucm91bmQodGhpcy5fY29tcG9uZW50c1szXSAqIDI1NSkudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiB0aGlzLnRvSGV4KCkgKyBcIjAwXCIuc3Vic3RyaW5nKDAsIDIgLSBhbHBoYVN0cmluZy5sZW5ndGgpICsgYWxwaGFTdHJpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhbHBoYSwgc3VpdGFibGUgZm9yIGNoYWluaW5nLlxuICAgKiBAcGFyYW0gYWxwaGFcbiAgICovXG4gIHNldEFscGhhKGFscGhhKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbM10gPSB0aGlzLl9jbGFtcChhbHBoYSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJvdW5kcyB0aGUgc3BlY2lmaWVkIGNvbG9yIGFjY29yZGluZyB0byB0aGUgc3RlcC4gVGhpcyBhY3Rpb24gaXMgZGVzdHJ1Y3RpdmUsIGFuZCB3aWxsXG4gICAqIG92ZXJyaWRlIHRoZSBwcmV2aW91cyBgdmFsdWVgIHByb3BlcnR5IHRvIGJlIGBudWxsYC4gVGhlIGFscGhhIGNvbXBvbmVudCBpcyBub3Qgcm91bmRlZC5cbiAgICogQHBhcmFtIHN0ZXBzIC0gTnVtYmVyIG9mIHN0ZXBzIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhIGNhcCB3aGVuIHJvdW5kaW5nIGNvbG9yc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjMuMFxuICAgKi9cbiAgcm91bmQoc3RlcHMpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzBdID0gTWF0aC5yb3VuZChyICogc3RlcHMpIC8gc3RlcHMsIHRoaXMuX2NvbXBvbmVudHNbMV0gPSBNYXRoLnJvdW5kKGcgKiBzdGVwcykgLyBzdGVwcywgdGhpcy5fY29tcG9uZW50c1syXSA9IE1hdGgucm91bmQoYiAqIHN0ZXBzKSAvIHN0ZXBzLCB0aGlzLnJlZnJlc2hJbnQoKSwgdGhpcy5fdmFsdWUgPSBudWxsLCB0aGlzO1xuICB9XG4gIHRvQXJyYXkob3V0KSB7XG4gICAgb3V0ID0gb3V0ID8/IFtdO1xuICAgIGNvbnN0IFtyLCBnLCBiLCBhXSA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgcmV0dXJuIG91dFswXSA9IHIsIG91dFsxXSA9IGcsIG91dFsyXSA9IGIsIG91dFszXSA9IGEsIG91dDtcbiAgfVxuICAvKipcbiAgICogTm9ybWFsaXplIHRoZSBpbnB1dCB2YWx1ZSBpbnRvIHJnYmFcbiAgICogQHBhcmFtIHZhbHVlIC0gSW5wdXQgdmFsdWVcbiAgICovXG4gIG5vcm1hbGl6ZSh2YWx1ZSkge1xuICAgIGxldCByLCBnLCBiLCBhO1xuICAgIGlmICgodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTY3NzcyMTUpIHtcbiAgICAgIGNvbnN0IGludCA9IHZhbHVlO1xuICAgICAgciA9IChpbnQgPj4gMTYgJiAyNTUpIC8gMjU1LCBnID0gKGludCA+PiA4ICYgMjU1KSAvIDI1NSwgYiA9IChpbnQgJiAyNTUpIC8gMjU1LCBhID0gMTtcbiAgICB9IGVsc2UgaWYgKChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkgJiYgdmFsdWUubGVuZ3RoID49IDMgJiYgdmFsdWUubGVuZ3RoIDw9IDQpXG4gICAgICB2YWx1ZSA9IHRoaXMuX2NsYW1wKHZhbHVlKSwgW3IsIGcsIGIsIGEgPSAxXSA9IHZhbHVlO1xuICAgIGVsc2UgaWYgKCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkgJiYgdmFsdWUubGVuZ3RoID49IDMgJiYgdmFsdWUubGVuZ3RoIDw9IDQpXG4gICAgICB2YWx1ZSA9IHRoaXMuX2NsYW1wKHZhbHVlLCAwLCAyNTUpLCBbciwgZywgYiwgYSA9IDI1NV0gPSB2YWx1ZSwgciAvPSAyNTUsIGcgLz0gMjU1LCBiIC89IDI1NSwgYSAvPSAyNTU7XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBtYXRjaCA9IF9Db2xvcjIuSEVYX1BBVFRFUk4uZXhlYyh2YWx1ZSk7XG4gICAgICAgIG1hdGNoICYmICh2YWx1ZSA9IGAjJHttYXRjaFsyXX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbG9yID0gY29sb3JkLmNvbG9yZCh2YWx1ZSk7XG4gICAgICBjb2xvci5pc1ZhbGlkKCkgJiYgKHsgciwgZywgYiwgYSB9ID0gY29sb3IucmdiYSwgciAvPSAyNTUsIGcgLz0gMjU1LCBiIC89IDI1NSk7XG4gICAgfVxuICAgIGlmIChyICE9PSB2b2lkIDApXG4gICAgICB0aGlzLl9jb21wb25lbnRzWzBdID0gciwgdGhpcy5fY29tcG9uZW50c1sxXSA9IGcsIHRoaXMuX2NvbXBvbmVudHNbMl0gPSBiLCB0aGlzLl9jb21wb25lbnRzWzNdID0gYSwgdGhpcy5yZWZyZXNoSW50KCk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY29udmVydCBjb2xvciAke3ZhbHVlfWApO1xuICB9XG4gIC8qKiBSZWZyZXNoIHRoZSBpbnRlcm5hbCBjb2xvciByZ2IgbnVtYmVyICovXG4gIHJlZnJlc2hJbnQoKSB7XG4gICAgdGhpcy5fY2xhbXAodGhpcy5fY29tcG9uZW50cyk7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB0aGlzLl9pbnQgPSAociAqIDI1NSA8PCAxNikgKyAoZyAqIDI1NSA8PCA4KSArIChiICogMjU1IHwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIENsYW1wcyB2YWx1ZXMgdG8gYSByYW5nZS4gV2lsbCBvdmVycmlkZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUocykgdG8gY2xhbXBcbiAgICogQHBhcmFtIG1pbiAtIE1pbmltdW0gdmFsdWVcbiAgICogQHBhcmFtIG1heCAtIE1heGltdW0gdmFsdWVcbiAgICovXG4gIF9jbGFtcCh2YWx1ZSwgbWluID0gMCwgbWF4ID0gMSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpIDogKHZhbHVlLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgIHZhbHVlW2ldID0gTWF0aC5taW4oTWF0aC5tYXgodiwgbWluKSwgbWF4KTtcbiAgICB9KSwgdmFsdWUpO1xuICB9XG59O1xuX0NvbG9yLnNoYXJlZCA9IG5ldyBfQ29sb3IoKSwgLyoqXG4qIFRlbXBvcmFyeSBDb2xvciBvYmplY3QgZm9yIHN0YXRpYyB1c2VzIGludGVybmFsbHkuXG4qIEFzIHRvIG5vdCBjb25mbGljdCB3aXRoIENvbG9yLnNoYXJlZC5cbiogQGlnbm9yZVxuKi9cbl9Db2xvci50ZW1wID0gbmV3IF9Db2xvcigpLCAvKiogUGF0dGVybiBmb3IgaGV4IHN0cmluZ3MgKi9cbl9Db2xvci5IRVhfUEFUVEVSTiA9IC9eKCN8MHgpPygoW2EtZjAtOV17M30pezEsMn0oW2EtZjAtOV17Mn0pPykkL2k7XG5sZXQgQ29sb3IgPSBfQ29sb3I7XG5leHBvcnRzLkNvbG9yID0gQ29sb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIENvbG9yID0gcmVxdWlyZShcIi4vQ29sb3IuanNcIik7XG5leHBvcnRzLkNvbG9yID0gQ29sb3IuQ29sb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPXtncmFkOi45LHR1cm46MzYwLHJhZDozNjAvKDIqTWF0aC5QSSl9LHQ9ZnVuY3Rpb24ocil7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHI/ci5sZW5ndGg+MDpcIm51bWJlclwiPT10eXBlb2Ygcn0sbj1mdW5jdGlvbihyLHQsbil7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLHZvaWQgMD09PW4mJihuPU1hdGgucG93KDEwLHQpKSxNYXRoLnJvdW5kKG4qcikvbiswfSxlPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09biYmKG49MSkscj5uP246cj50P3I6dH0sdT1mdW5jdGlvbihyKXtyZXR1cm4ocj1pc0Zpbml0ZShyKT9yJTM2MDowKT4wP3I6ciszNjB9LG89ZnVuY3Rpb24ocil7cmV0dXJue3I6ZShyLnIsMCwyNTUpLGc6ZShyLmcsMCwyNTUpLGI6ZShyLmIsMCwyNTUpLGE6ZShyLmEpfX0sYT1mdW5jdGlvbihyKXtyZXR1cm57cjpuKHIuciksZzpuKHIuZyksYjpuKHIuYiksYTpuKHIuYSwzKX19LHM9L14jKFswLTlhLWZdezMsOH0pJC9pLGk9ZnVuY3Rpb24ocil7dmFyIHQ9ci50b1N0cmluZygxNik7cmV0dXJuIHQubGVuZ3RoPDI/XCIwXCIrdDp0fSxoPWZ1bmN0aW9uKHIpe3ZhciB0PXIucixuPXIuZyxlPXIuYix1PXIuYSxvPU1hdGgubWF4KHQsbixlKSxhPW8tTWF0aC5taW4odCxuLGUpLHM9YT9vPT09dD8obi1lKS9hOm89PT1uPzIrKGUtdCkvYTo0Kyh0LW4pL2E6MDtyZXR1cm57aDo2MCooczwwP3MrNjpzKSxzOm8/YS9vKjEwMDowLHY6by8yNTUqMTAwLGE6dX19LGI9ZnVuY3Rpb24ocil7dmFyIHQ9ci5oLG49ci5zLGU9ci52LHU9ci5hO3Q9dC8zNjAqNixuLz0xMDAsZS89MTAwO3ZhciBvPU1hdGguZmxvb3IodCksYT1lKigxLW4pLHM9ZSooMS0odC1vKSpuKSxpPWUqKDEtKDEtdCtvKSpuKSxoPW8lNjtyZXR1cm57cjoyNTUqW2UscyxhLGEsaSxlXVtoXSxnOjI1NSpbaSxlLGUscyxhLGFdW2hdLGI6MjU1KlthLGEsaSxlLGUsc11baF0sYTp1fX0sZD1mdW5jdGlvbihyKXtyZXR1cm57aDp1KHIuaCksczplKHIucywwLDEwMCksbDplKHIubCwwLDEwMCksYTplKHIuYSl9fSxnPWZ1bmN0aW9uKHIpe3JldHVybntoOm4oci5oKSxzOm4oci5zKSxsOm4oci5sKSxhOm4oci5hLDMpfX0sZj1mdW5jdGlvbihyKXtyZXR1cm4gYigobj0odD1yKS5zLHtoOnQuaCxzOihuKj0oKGU9dC5sKTw1MD9lOjEwMC1lKS8xMDApPjA/MipuLyhlK24pKjEwMDowLHY6ZStuLGE6dC5hfSkpO3ZhciB0LG4sZX0scD1mdW5jdGlvbihyKXtyZXR1cm57aDoodD1oKHIpKS5oLHM6KHU9KDIwMC0obj10LnMpKSooZT10LnYpLzEwMCk+MCYmdTwyMDA/biplLzEwMC8odTw9MTAwP3U6MjAwLXUpKjEwMDowLGw6dS8yLGE6dC5hfTt2YXIgdCxuLGUsdX0sbD0vXmhzbGE/XFwoXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoZGVnfHJhZHxncmFkfHR1cm4pP1xccyosXFxzKihbKy1dP1xcZCpcXC4/XFxkKyklXFxzKixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMqKD86LFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyopP1xcKSQvaSxjPS9eaHNsYT9cXChcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKShkZWd8cmFkfGdyYWR8dHVybik/XFxzKyhbKy1dP1xcZCpcXC4/XFxkKyklXFxzKyhbKy1dP1xcZCpcXC4/XFxkKyklXFxzKig/OlxcL1xccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyopP1xcKSQvaSx2PS9ecmdiYT9cXChcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqLFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyosXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKig/OixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKT9cXCkkL2ksbT0vXnJnYmE/XFwoXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKyhbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKyhbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKig/OlxcL1xccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyopP1xcKSQvaSx5PXtzdHJpbmc6W1tmdW5jdGlvbihyKXt2YXIgdD1zLmV4ZWMocik7cmV0dXJuIHQ/KHI9dFsxXSkubGVuZ3RoPD00P3tyOnBhcnNlSW50KHJbMF0rclswXSwxNiksZzpwYXJzZUludChyWzFdK3JbMV0sMTYpLGI6cGFyc2VJbnQoclsyXStyWzJdLDE2KSxhOjQ9PT1yLmxlbmd0aD9uKHBhcnNlSW50KHJbM10rclszXSwxNikvMjU1LDIpOjF9OjY9PT1yLmxlbmd0aHx8OD09PXIubGVuZ3RoP3tyOnBhcnNlSW50KHIuc3Vic3RyKDAsMiksMTYpLGc6cGFyc2VJbnQoci5zdWJzdHIoMiwyKSwxNiksYjpwYXJzZUludChyLnN1YnN0cig0LDIpLDE2KSxhOjg9PT1yLmxlbmd0aD9uKHBhcnNlSW50KHIuc3Vic3RyKDYsMiksMTYpLzI1NSwyKToxfTpudWxsOm51bGx9LFwiaGV4XCJdLFtmdW5jdGlvbihyKXt2YXIgdD12LmV4ZWMocil8fG0uZXhlYyhyKTtyZXR1cm4gdD90WzJdIT09dFs0XXx8dFs0XSE9PXRbNl0/bnVsbDpvKHtyOk51bWJlcih0WzFdKS8odFsyXT8xMDAvMjU1OjEpLGc6TnVtYmVyKHRbM10pLyh0WzRdPzEwMC8yNTU6MSksYjpOdW1iZXIodFs1XSkvKHRbNl0/MTAwLzI1NToxKSxhOnZvaWQgMD09PXRbN10/MTpOdW1iZXIodFs3XSkvKHRbOF0/MTAwOjEpfSk6bnVsbH0sXCJyZ2JcIl0sW2Z1bmN0aW9uKHQpe3ZhciBuPWwuZXhlYyh0KXx8Yy5leGVjKHQpO2lmKCFuKXJldHVybiBudWxsO3ZhciBlLHUsbz1kKHtoOihlPW5bMV0sdT1uWzJdLHZvaWQgMD09PXUmJih1PVwiZGVnXCIpLE51bWJlcihlKSooclt1XXx8MSkpLHM6TnVtYmVyKG5bM10pLGw6TnVtYmVyKG5bNF0pLGE6dm9pZCAwPT09bls1XT8xOk51bWJlcihuWzVdKS8obls2XT8xMDA6MSl9KTtyZXR1cm4gZihvKX0sXCJoc2xcIl1dLG9iamVjdDpbW2Z1bmN0aW9uKHIpe3ZhciBuPXIucixlPXIuZyx1PXIuYixhPXIuYSxzPXZvaWQgMD09PWE/MTphO3JldHVybiB0KG4pJiZ0KGUpJiZ0KHUpP28oe3I6TnVtYmVyKG4pLGc6TnVtYmVyKGUpLGI6TnVtYmVyKHUpLGE6TnVtYmVyKHMpfSk6bnVsbH0sXCJyZ2JcIl0sW2Z1bmN0aW9uKHIpe3ZhciBuPXIuaCxlPXIucyx1PXIubCxvPXIuYSxhPXZvaWQgMD09PW8/MTpvO2lmKCF0KG4pfHwhdChlKXx8IXQodSkpcmV0dXJuIG51bGw7dmFyIHM9ZCh7aDpOdW1iZXIobiksczpOdW1iZXIoZSksbDpOdW1iZXIodSksYTpOdW1iZXIoYSl9KTtyZXR1cm4gZihzKX0sXCJoc2xcIl0sW2Z1bmN0aW9uKHIpe3ZhciBuPXIuaCxvPXIucyxhPXIudixzPXIuYSxpPXZvaWQgMD09PXM/MTpzO2lmKCF0KG4pfHwhdChvKXx8IXQoYSkpcmV0dXJuIG51bGw7dmFyIGg9ZnVuY3Rpb24ocil7cmV0dXJue2g6dShyLmgpLHM6ZShyLnMsMCwxMDApLHY6ZShyLnYsMCwxMDApLGE6ZShyLmEpfX0oe2g6TnVtYmVyKG4pLHM6TnVtYmVyKG8pLHY6TnVtYmVyKGEpLGE6TnVtYmVyKGkpfSk7cmV0dXJuIGIoaCl9LFwiaHN2XCJdXX0sTj1mdW5jdGlvbihyLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgZT10W25dWzBdKHIpO2lmKGUpcmV0dXJuW2UsdFtuXVsxXV19cmV0dXJuW251bGwsdm9pZCAwXX0seD1mdW5jdGlvbihyKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2Ygcj9OKHIudHJpbSgpLHkuc3RyaW5nKTpcIm9iamVjdFwiPT10eXBlb2YgciYmbnVsbCE9PXI/TihyLHkub2JqZWN0KTpbbnVsbCx2b2lkIDBdfSxNPWZ1bmN0aW9uKHIsdCl7dmFyIG49cChyKTtyZXR1cm57aDpuLmgsczplKG4ucysxMDAqdCwwLDEwMCksbDpuLmwsYTpuLmF9fSxJPWZ1bmN0aW9uKHIpe3JldHVybigyOTkqci5yKzU4NypyLmcrMTE0KnIuYikvMWUzLzI1NX0sSD1mdW5jdGlvbihyLHQpe3ZhciBuPXAocik7cmV0dXJue2g6bi5oLHM6bi5zLGw6ZShuLmwrMTAwKnQsMCwxMDApLGE6bi5hfX0sJD1mdW5jdGlvbigpe2Z1bmN0aW9uIHIocil7dGhpcy5wYXJzZWQ9eChyKVswXSx0aGlzLnJnYmE9dGhpcy5wYXJzZWR8fHtyOjAsZzowLGI6MCxhOjF9fXJldHVybiByLnByb3RvdHlwZS5pc1ZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnBhcnNlZH0sci5wcm90b3R5cGUuYnJpZ2h0bmVzcz1mdW5jdGlvbigpe3JldHVybiBuKEkodGhpcy5yZ2JhKSwyKX0sci5wcm90b3R5cGUuaXNEYXJrPWZ1bmN0aW9uKCl7cmV0dXJuIEkodGhpcy5yZ2JhKTwuNX0sci5wcm90b3R5cGUuaXNMaWdodD1mdW5jdGlvbigpe3JldHVybiBJKHRoaXMucmdiYSk+PS41fSxyLnByb3RvdHlwZS50b0hleD1mdW5jdGlvbigpe3JldHVybiByPWEodGhpcy5yZ2JhKSx0PXIucixlPXIuZyx1PXIuYixzPShvPXIuYSk8MT9pKG4oMjU1Km8pKTpcIlwiLFwiI1wiK2kodCkraShlKStpKHUpK3M7dmFyIHIsdCxlLHUsbyxzfSxyLnByb3RvdHlwZS50b1JnYj1mdW5jdGlvbigpe3JldHVybiBhKHRoaXMucmdiYSl9LHIucHJvdG90eXBlLnRvUmdiU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHI9YSh0aGlzLnJnYmEpLHQ9ci5yLG49ci5nLGU9ci5iLCh1PXIuYSk8MT9cInJnYmEoXCIrdCtcIiwgXCIrbitcIiwgXCIrZStcIiwgXCIrdStcIilcIjpcInJnYihcIit0K1wiLCBcIituK1wiLCBcIitlK1wiKVwiO3ZhciByLHQsbixlLHV9LHIucHJvdG90eXBlLnRvSHNsPWZ1bmN0aW9uKCl7cmV0dXJuIGcocCh0aGlzLnJnYmEpKX0sci5wcm90b3R5cGUudG9Ic2xTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gcj1nKHAodGhpcy5yZ2JhKSksdD1yLmgsbj1yLnMsZT1yLmwsKHU9ci5hKTwxP1wiaHNsYShcIit0K1wiLCBcIituK1wiJSwgXCIrZStcIiUsIFwiK3UrXCIpXCI6XCJoc2woXCIrdCtcIiwgXCIrbitcIiUsIFwiK2UrXCIlKVwiO3ZhciByLHQsbixlLHV9LHIucHJvdG90eXBlLnRvSHN2PWZ1bmN0aW9uKCl7cmV0dXJuIHI9aCh0aGlzLnJnYmEpLHtoOm4oci5oKSxzOm4oci5zKSx2Om4oci52KSxhOm4oci5hLDMpfTt2YXIgcn0sci5wcm90b3R5cGUuaW52ZXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIGooe3I6MjU1LShyPXRoaXMucmdiYSkucixnOjI1NS1yLmcsYjoyNTUtci5iLGE6ci5hfSk7dmFyIHJ9LHIucHJvdG90eXBlLnNhdHVyYXRlPWZ1bmN0aW9uKHIpe3JldHVybiB2b2lkIDA9PT1yJiYocj0uMSksaihNKHRoaXMucmdiYSxyKSl9LHIucHJvdG90eXBlLmRlc2F0dXJhdGU9ZnVuY3Rpb24ocil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4xKSxqKE0odGhpcy5yZ2JhLC1yKSl9LHIucHJvdG90eXBlLmdyYXlzY2FsZT1mdW5jdGlvbigpe3JldHVybiBqKE0odGhpcy5yZ2JhLC0xKSl9LHIucHJvdG90eXBlLmxpZ2h0ZW49ZnVuY3Rpb24ocil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4xKSxqKEgodGhpcy5yZ2JhLHIpKX0sci5wcm90b3R5cGUuZGFya2VuPWZ1bmN0aW9uKHIpe3JldHVybiB2b2lkIDA9PT1yJiYocj0uMSksaihIKHRoaXMucmdiYSwtcikpfSxyLnByb3RvdHlwZS5yb3RhdGU9ZnVuY3Rpb24ocil7cmV0dXJuIHZvaWQgMD09PXImJihyPTE1KSx0aGlzLmh1ZSh0aGlzLmh1ZSgpK3IpfSxyLnByb3RvdHlwZS5hbHBoYT1mdW5jdGlvbihyKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2Ygcj9qKHtyOih0PXRoaXMucmdiYSkucixnOnQuZyxiOnQuYixhOnJ9KTpuKHRoaXMucmdiYS5hLDMpO3ZhciB0fSxyLnByb3RvdHlwZS5odWU9ZnVuY3Rpb24ocil7dmFyIHQ9cCh0aGlzLnJnYmEpO3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiByP2ooe2g6cixzOnQucyxsOnQubCxhOnQuYX0pOm4odC5oKX0sci5wcm90b3R5cGUuaXNFcXVhbD1mdW5jdGlvbihyKXtyZXR1cm4gdGhpcy50b0hleCgpPT09aihyKS50b0hleCgpfSxyfSgpLGo9ZnVuY3Rpb24ocil7cmV0dXJuIHIgaW5zdGFuY2VvZiAkP3I6bmV3ICQocil9LHc9W107ZXhwb3J0cy5Db2xvcmQ9JCxleHBvcnRzLmNvbG9yZD1qLGV4cG9ydHMuZXh0ZW5kPWZ1bmN0aW9uKHIpe3IuZm9yRWFjaChmdW5jdGlvbihyKXt3LmluZGV4T2Yocik8MCYmKHIoJCx5KSx3LnB1c2gocikpfSl9LGV4cG9ydHMuZ2V0Rm9ybWF0PWZ1bmN0aW9uKHIpe3JldHVybiB4KHIpWzFdfSxleHBvcnRzLnJhbmRvbT1mdW5jdGlvbigpe3JldHVybiBuZXcgJCh7cjoyNTUqTWF0aC5yYW5kb20oKSxnOjI1NSpNYXRoLnJhbmRvbSgpLGI6MjU1Kk1hdGgucmFuZG9tKCl9KX07XG4iLCJtb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihlLGYpe3ZhciBhPXt3aGl0ZTpcIiNmZmZmZmZcIixiaXNxdWU6XCIjZmZlNGM0XCIsYmx1ZTpcIiMwMDAwZmZcIixjYWRldGJsdWU6XCIjNWY5ZWEwXCIsY2hhcnRyZXVzZTpcIiM3ZmZmMDBcIixjaG9jb2xhdGU6XCIjZDI2OTFlXCIsY29yYWw6XCIjZmY3ZjUwXCIsYW50aXF1ZXdoaXRlOlwiI2ZhZWJkN1wiLGFxdWE6XCIjMDBmZmZmXCIsYXp1cmU6XCIjZjBmZmZmXCIsd2hpdGVzbW9rZTpcIiNmNWY1ZjVcIixwYXBheWF3aGlwOlwiI2ZmZWZkNVwiLHBsdW06XCIjZGRhMGRkXCIsYmxhbmNoZWRhbG1vbmQ6XCIjZmZlYmNkXCIsYmxhY2s6XCIjMDAwMDAwXCIsZ29sZDpcIiNmZmQ3MDBcIixnb2xkZW5yb2Q6XCIjZGFhNTIwXCIsZ2FpbnNib3JvOlwiI2RjZGNkY1wiLGNvcm5zaWxrOlwiI2ZmZjhkY1wiLGNvcm5mbG93ZXJibHVlOlwiIzY0OTVlZFwiLGJ1cmx5d29vZDpcIiNkZWI4ODdcIixhcXVhbWFyaW5lOlwiIzdmZmZkNFwiLGJlaWdlOlwiI2Y1ZjVkY1wiLGNyaW1zb246XCIjZGMxNDNjXCIsY3lhbjpcIiMwMGZmZmZcIixkYXJrYmx1ZTpcIiMwMDAwOGJcIixkYXJrY3lhbjpcIiMwMDhiOGJcIixkYXJrZ29sZGVucm9kOlwiI2I4ODYwYlwiLGRhcmtraGFraTpcIiNiZGI3NmJcIixkYXJrZ3JheTpcIiNhOWE5YTlcIixkYXJrZ3JlZW46XCIjMDA2NDAwXCIsZGFya2dyZXk6XCIjYTlhOWE5XCIscGVhY2hwdWZmOlwiI2ZmZGFiOVwiLGRhcmttYWdlbnRhOlwiIzhiMDA4YlwiLGRhcmtyZWQ6XCIjOGIwMDAwXCIsZGFya29yY2hpZDpcIiM5OTMyY2NcIixkYXJrb3JhbmdlOlwiI2ZmOGMwMFwiLGRhcmtzbGF0ZWJsdWU6XCIjNDgzZDhiXCIsZ3JheTpcIiM4MDgwODBcIixkYXJrc2xhdGVncmF5OlwiIzJmNGY0ZlwiLGRhcmtzbGF0ZWdyZXk6XCIjMmY0ZjRmXCIsZGVlcHBpbms6XCIjZmYxNDkzXCIsZGVlcHNreWJsdWU6XCIjMDBiZmZmXCIsd2hlYXQ6XCIjZjVkZWIzXCIsZmlyZWJyaWNrOlwiI2IyMjIyMlwiLGZsb3JhbHdoaXRlOlwiI2ZmZmFmMFwiLGdob3N0d2hpdGU6XCIjZjhmOGZmXCIsZGFya3Zpb2xldDpcIiM5NDAwZDNcIixtYWdlbnRhOlwiI2ZmMDBmZlwiLGdyZWVuOlwiIzAwODAwMFwiLGRvZGdlcmJsdWU6XCIjMWU5MGZmXCIsZ3JleTpcIiM4MDgwODBcIixob25leWRldzpcIiNmMGZmZjBcIixob3RwaW5rOlwiI2ZmNjliNFwiLGJsdWV2aW9sZXQ6XCIjOGEyYmUyXCIsZm9yZXN0Z3JlZW46XCIjMjI4YjIyXCIsbGF3bmdyZWVuOlwiIzdjZmMwMFwiLGluZGlhbnJlZDpcIiNjZDVjNWNcIixpbmRpZ286XCIjNGIwMDgyXCIsZnVjaHNpYTpcIiNmZjAwZmZcIixicm93bjpcIiNhNTJhMmFcIixtYXJvb246XCIjODAwMDAwXCIsbWVkaXVtYmx1ZTpcIiMwMDAwY2RcIixsaWdodGNvcmFsOlwiI2YwODA4MFwiLGRhcmt0dXJxdW9pc2U6XCIjMDBjZWQxXCIsbGlnaHRjeWFuOlwiI2UwZmZmZlwiLGl2b3J5OlwiI2ZmZmZmMFwiLGxpZ2h0eWVsbG93OlwiI2ZmZmZlMFwiLGxpZ2h0c2FsbW9uOlwiI2ZmYTA3YVwiLGxpZ2h0c2VhZ3JlZW46XCIjMjBiMmFhXCIsbGluZW46XCIjZmFmMGU2XCIsbWVkaXVtYXF1YW1hcmluZTpcIiM2NmNkYWFcIixsZW1vbmNoaWZmb246XCIjZmZmYWNkXCIsbGltZTpcIiMwMGZmMDBcIixraGFraTpcIiNmMGU2OGNcIixtZWRpdW1zZWFncmVlbjpcIiMzY2IzNzFcIixsaW1lZ3JlZW46XCIjMzJjZDMyXCIsbWVkaXVtc3ByaW5nZ3JlZW46XCIjMDBmYTlhXCIsbGlnaHRza3libHVlOlwiIzg3Y2VmYVwiLGxpZ2h0Ymx1ZTpcIiNhZGQ4ZTZcIixtaWRuaWdodGJsdWU6XCIjMTkxOTcwXCIsbGlnaHRwaW5rOlwiI2ZmYjZjMVwiLG1pc3R5cm9zZTpcIiNmZmU0ZTFcIixtb2NjYXNpbjpcIiNmZmU0YjVcIixtaW50Y3JlYW06XCIjZjVmZmZhXCIsbGlnaHRzbGF0ZWdyYXk6XCIjNzc4ODk5XCIsbGlnaHRzbGF0ZWdyZXk6XCIjNzc4ODk5XCIsbmF2YWpvd2hpdGU6XCIjZmZkZWFkXCIsbmF2eTpcIiMwMDAwODBcIixtZWRpdW12aW9sZXRyZWQ6XCIjYzcxNTg1XCIscG93ZGVyYmx1ZTpcIiNiMGUwZTZcIixwYWxlZ29sZGVucm9kOlwiI2VlZThhYVwiLG9sZGxhY2U6XCIjZmRmNWU2XCIscGFsZXR1cnF1b2lzZTpcIiNhZmVlZWVcIixtZWRpdW10dXJxdW9pc2U6XCIjNDhkMWNjXCIsbWVkaXVtb3JjaGlkOlwiI2JhNTVkM1wiLHJlYmVjY2FwdXJwbGU6XCIjNjYzMzk5XCIsbGlnaHRzdGVlbGJsdWU6XCIjYjBjNGRlXCIsbWVkaXVtc2xhdGVibHVlOlwiIzdiNjhlZVwiLHRoaXN0bGU6XCIjZDhiZmQ4XCIsdGFuOlwiI2QyYjQ4Y1wiLG9yY2hpZDpcIiNkYTcwZDZcIixtZWRpdW1wdXJwbGU6XCIjOTM3MGRiXCIscHVycGxlOlwiIzgwMDA4MFwiLHBpbms6XCIjZmZjMGNiXCIsc2t5Ymx1ZTpcIiM4N2NlZWJcIixzcHJpbmdncmVlbjpcIiMwMGZmN2ZcIixwYWxlZ3JlZW46XCIjOThmYjk4XCIscmVkOlwiI2ZmMDAwMFwiLHllbGxvdzpcIiNmZmZmMDBcIixzbGF0ZWJsdWU6XCIjNmE1YWNkXCIsbGF2ZW5kZXJibHVzaDpcIiNmZmYwZjVcIixwZXJ1OlwiI2NkODUzZlwiLHBhbGV2aW9sZXRyZWQ6XCIjZGI3MDkzXCIsdmlvbGV0OlwiI2VlODJlZVwiLHRlYWw6XCIjMDA4MDgwXCIsc2xhdGVncmF5OlwiIzcwODA5MFwiLHNsYXRlZ3JleTpcIiM3MDgwOTBcIixhbGljZWJsdWU6XCIjZjBmOGZmXCIsZGFya3NlYWdyZWVuOlwiIzhmYmM4ZlwiLGRhcmtvbGl2ZWdyZWVuOlwiIzU1NmIyZlwiLGdyZWVueWVsbG93OlwiI2FkZmYyZlwiLHNlYWdyZWVuOlwiIzJlOGI1N1wiLHNlYXNoZWxsOlwiI2ZmZjVlZVwiLHRvbWF0bzpcIiNmZjYzNDdcIixzaWx2ZXI6XCIjYzBjMGMwXCIsc2llbm5hOlwiI2EwNTIyZFwiLGxhdmVuZGVyOlwiI2U2ZTZmYVwiLGxpZ2h0Z3JlZW46XCIjOTBlZTkwXCIsb3JhbmdlOlwiI2ZmYTUwMFwiLG9yYW5nZXJlZDpcIiNmZjQ1MDBcIixzdGVlbGJsdWU6XCIjNDY4MmI0XCIscm95YWxibHVlOlwiIzQxNjllMVwiLHR1cnF1b2lzZTpcIiM0MGUwZDBcIix5ZWxsb3dncmVlbjpcIiM5YWNkMzJcIixzYWxtb246XCIjZmE4MDcyXCIsc2FkZGxlYnJvd246XCIjOGI0NTEzXCIsc2FuZHlicm93bjpcIiNmNGE0NjBcIixyb3N5YnJvd246XCIjYmM4ZjhmXCIsZGFya3NhbG1vbjpcIiNlOTk2N2FcIixsaWdodGdvbGRlbnJvZHllbGxvdzpcIiNmYWZhZDJcIixzbm93OlwiI2ZmZmFmYVwiLGxpZ2h0Z3JleTpcIiNkM2QzZDNcIixsaWdodGdyYXk6XCIjZDNkM2QzXCIsZGltZ3JheTpcIiM2OTY5NjlcIixkaW1ncmV5OlwiIzY5Njk2OVwiLG9saXZlZHJhYjpcIiM2YjhlMjNcIixvbGl2ZTpcIiM4MDgwMDBcIn0scj17fTtmb3IodmFyIGQgaW4gYSlyW2FbZF1dPWQ7dmFyIGw9e307ZS5wcm90b3R5cGUudG9OYW1lPWZ1bmN0aW9uKGYpe2lmKCEodGhpcy5yZ2JhLmF8fHRoaXMucmdiYS5yfHx0aGlzLnJnYmEuZ3x8dGhpcy5yZ2JhLmIpKXJldHVyblwidHJhbnNwYXJlbnRcIjt2YXIgZCxpLG89clt0aGlzLnRvSGV4KCldO2lmKG8pcmV0dXJuIG87aWYobnVsbD09Zj92b2lkIDA6Zi5jbG9zZXN0KXt2YXIgbj10aGlzLnRvUmdiKCksdD0xLzAsYj1cImJsYWNrXCI7aWYoIWwubGVuZ3RoKWZvcih2YXIgYyBpbiBhKWxbY109bmV3IGUoYVtjXSkudG9SZ2IoKTtmb3IodmFyIGcgaW4gYSl7dmFyIHU9KGQ9bixpPWxbZ10sTWF0aC5wb3coZC5yLWkuciwyKStNYXRoLnBvdyhkLmctaS5nLDIpK01hdGgucG93KGQuYi1pLmIsMikpO3U8dCYmKHQ9dSxiPWcpfXJldHVybiBifX07Zi5zdHJpbmcucHVzaChbZnVuY3Rpb24oZil7dmFyIHI9Zi50b0xvd2VyQ2FzZSgpLGQ9XCJ0cmFuc3BhcmVudFwiPT09cj9cIiMwMDAwXCI6YVtyXTtyZXR1cm4gZD9uZXcgZShkKS50b1JnYigpOm51bGx9LFwibmFtZVwiXSl9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgSU5URVJOQUxfRk9STUFUUyA9IC8qIEBfX1BVUkVfXyAqLyAoKElOVEVSTkFMX0ZPUk1BVFMyKSA9PiAoSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVCA9IDMzNzc2XSA9IFwiQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVFwiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVCA9IDMzNzc3XSA9IFwiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFRcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQgPSAzMzc3OF0gPSBcIkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUXCIsIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUID0gMzM3NzldID0gXCJDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVFwiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQxX0VYVCA9IDM1OTE3XSA9IFwiQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUMV9FWFRcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUM19FWFQgPSAzNTkxOF0gPSBcIkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDNfRVhUXCIsIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDVfRVhUID0gMzU5MTldID0gXCJDT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQ1X0VYVFwiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1NSR0JfUzNUQ19EWFQxX0VYVCA9IDM1OTE2XSA9IFwiQ09NUFJFU1NFRF9TUkdCX1MzVENfRFhUMV9FWFRcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SMTFfRUFDID0gMzc0ODhdID0gXCJDT01QUkVTU0VEX1IxMV9FQUNcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9TSUdORURfUjExX0VBQyA9IDM3NDg5XSA9IFwiQ09NUFJFU1NFRF9TSUdORURfUjExX0VBQ1wiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1JHMTFfRUFDID0gMzc0OTBdID0gXCJDT01QUkVTU0VEX1JHMTFfRUFDXCIsIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyLkNPTVBSRVNTRURfU0lHTkVEX1JHMTFfRUFDID0gMzc0OTFdID0gXCJDT01QUkVTU0VEX1NJR05FRF9SRzExX0VBQ1wiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1JHQjhfRVRDMiA9IDM3NDkyXSA9IFwiQ09NUFJFU1NFRF9SR0I4X0VUQzJcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQyA9IDM3NDk2XSA9IFwiQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQ1wiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1NSR0I4X0VUQzIgPSAzNzQ5M10gPSBcIkNPTVBSRVNTRURfU1JHQjhfRVRDMlwiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9FVEMyX0VBQyA9IDM3NDk3XSA9IFwiQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfRVRDMl9FQUNcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMiA9IDM3NDk0XSA9IFwiQ09NUFJFU1NFRF9SR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMlwiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1NSR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMiA9IDM3NDk1XSA9IFwiQ09NUFJFU1NFRF9TUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzJcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRyA9IDM1ODQwXSA9IFwiQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNR1wiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRyA9IDM1ODQyXSA9IFwiQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUdcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRyA9IDM1ODQxXSA9IFwiQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNR1wiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNRyA9IDM1ODQzXSA9IFwiQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUdcIiwgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzIuQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTCA9IDM2MTk2XSA9IFwiQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTFwiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1JHQl9BVENfV0VCR0wgPSAzNTk4Nl0gPSBcIkNPTVBSRVNTRURfUkdCX0FUQ19XRUJHTFwiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1JHQkFfQVRDX0VYUExJQ0lUX0FMUEhBX1dFQkdMID0gMzU5ODZdID0gXCJDT01QUkVTU0VEX1JHQkFfQVRDX0VYUExJQ0lUX0FMUEhBX1dFQkdMXCIsIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyLkNPTVBSRVNTRURfUkdCQV9BVENfSU5URVJQT0xBVEVEX0FMUEhBX1dFQkdMID0gMzQ3OThdID0gXCJDT01QUkVTU0VEX1JHQkFfQVRDX0lOVEVSUE9MQVRFRF9BTFBIQV9XRUJHTFwiLCBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMi5DT01QUkVTU0VEX1JHQkFfQVNUQ180eDRfS0hSID0gMzc4MDhdID0gXCJDT01QUkVTU0VEX1JHQkFfQVNUQ180eDRfS0hSXCIsIElOVEVSTkFMX0ZPUk1BVFMyKSkoSU5URVJOQUxfRk9STUFUUyB8fCB7fSk7XG5jb25zdCBJTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMID0ge1xuICAvLyBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xuICAzMzc3NjogMC41LFxuICAzMzc3NzogMC41LFxuICAzMzc3ODogMSxcbiAgMzM3Nzk6IDEsXG4gIC8vIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXG4gIDM1OTE2OiAwLjUsXG4gIDM1OTE3OiAwLjUsXG4gIDM1OTE4OiAxLFxuICAzNTkxOTogMSxcbiAgLy8gV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0Y1xuICAzNzQ4ODogMC41LFxuICAzNzQ4OTogMC41LFxuICAzNzQ5MDogMSxcbiAgMzc0OTE6IDEsXG4gIDM3NDkyOiAwLjUsXG4gIDM3NDk2OiAxLFxuICAzNzQ5MzogMC41LFxuICAzNzQ5NzogMSxcbiAgMzc0OTQ6IDAuNSxcbiAgLy8gfn5cbiAgMzc0OTU6IDAuNSxcbiAgLy8gfn5cbiAgLy8gV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXG4gIDM1ODQwOiAwLjUsXG4gIDM1ODQyOiAwLjUsXG4gIDM1ODQxOiAwLjI1LFxuICAzNTg0MzogMC4yNSxcbiAgLy8gV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzFcbiAgMzYxOTY6IDAuNSxcbiAgLy8gQHNlZSBodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS9PcGVuR0wvZXh0ZW5zaW9ucy9BTUQvQU1EX2NvbXByZXNzZWRfQVRDX3RleHR1cmUudHh0XG4gIC8vIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hdGNcbiAgMzU5ODY6IDAuNSxcbiAgMzU5ODY6IDEsXG4gIDM0Nzk4OiAxLFxuICAvLyBAc2VlIGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvT3BlbkdML2V4dGVuc2lvbnMvS0hSL0tIUl90ZXh0dXJlX2NvbXByZXNzaW9uX2FzdGNfaGRyLnR4dFxuICAvLyBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXN0Y1xuICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlICovXG4gIDM3ODA4OiAxXG59O1xuZXhwb3J0cy5JTlRFUk5BTF9GT1JNQVRTID0gSU5URVJOQUxfRk9STUFUUztcbmV4cG9ydHMuSU5URVJOQUxfRk9STUFUX1RPX0JZVEVTX1BFUl9QSVhFTCA9IElOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9jb25zdCA9IHJlcXVpcmUoXCIuL2NvbnN0LmpzXCIpO1xucmVxdWlyZShcIi4vbG9hZGVycy9pbmRleC5qc1wiKTtcbnJlcXVpcmUoXCIuL3BhcnNlcnMvaW5kZXguanNcIik7XG5yZXF1aXJlKFwiLi9yZXNvdXJjZXMvaW5kZXguanNcIik7XG52YXIgZGV0ZWN0Q29tcHJlc3NlZFRleHR1cmVzID0gcmVxdWlyZShcIi4vbG9hZGVycy9kZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMuanNcIiksIGxvYWRERFMgPSByZXF1aXJlKFwiLi9sb2FkZXJzL2xvYWRERFMuanNcIiksIGxvYWRLVFggPSByZXF1aXJlKFwiLi9sb2FkZXJzL2xvYWRLVFguanNcIiksIHJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybCA9IHJlcXVpcmUoXCIuL2xvYWRlcnMvcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsLmpzXCIpLCBwYXJzZUREUyA9IHJlcXVpcmUoXCIuL3BhcnNlcnMvcGFyc2VERFMuanNcIiksIHBhcnNlS1RYID0gcmVxdWlyZShcIi4vcGFyc2Vycy9wYXJzZUtUWC5qc1wiKSwgQmxvYlJlc291cmNlID0gcmVxdWlyZShcIi4vcmVzb3VyY2VzL0Jsb2JSZXNvdXJjZS5qc1wiKSwgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSA9IHJlcXVpcmUoXCIuL3Jlc291cmNlcy9Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlLmpzXCIpO1xuZXhwb3J0cy5JTlRFUk5BTF9GT1JNQVRTID0gX2NvbnN0LklOVEVSTkFMX0ZPUk1BVFM7XG5leHBvcnRzLklOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUwgPSBfY29uc3QuSU5URVJOQUxfRk9STUFUX1RPX0JZVEVTX1BFUl9QSVhFTDtcbmV4cG9ydHMuZGV0ZWN0Q29tcHJlc3NlZFRleHR1cmVzID0gZGV0ZWN0Q29tcHJlc3NlZFRleHR1cmVzLmRldGVjdENvbXByZXNzZWRUZXh0dXJlcztcbmV4cG9ydHMubG9hZEREUyA9IGxvYWRERFMubG9hZEREUztcbmV4cG9ydHMubG9hZEtUWCA9IGxvYWRLVFgubG9hZEtUWDtcbmV4cG9ydHMucmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsID0gcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsLnJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybDtcbmV4cG9ydHMucGFyc2VERFMgPSBwYXJzZUREUy5wYXJzZUREUztcbmV4cG9ydHMuRk9STUFUU19UT19DT01QT05FTlRTID0gcGFyc2VLVFguRk9STUFUU19UT19DT01QT05FTlRTO1xuZXhwb3J0cy5UWVBFU19UT19CWVRFU19QRVJfQ09NUE9ORU5UID0gcGFyc2VLVFguVFlQRVNfVE9fQllURVNfUEVSX0NPTVBPTkVOVDtcbmV4cG9ydHMuVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMID0gcGFyc2VLVFguVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMO1xuZXhwb3J0cy5wYXJzZUtUWCA9IHBhcnNlS1RYLnBhcnNlS1RYO1xuZXhwb3J0cy5CbG9iUmVzb3VyY2UgPSBCbG9iUmVzb3VyY2UuQmxvYlJlc291cmNlO1xuZXhwb3J0cy5Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlID0gQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKTtcbmxldCBzdG9yZWRHbCwgZXh0ZW5zaW9ucztcbmZ1bmN0aW9uIGdldENvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucygpIHtcbiAgZXh0ZW5zaW9ucyA9IHtcbiAgICBzM3RjOiBzdG9yZWRHbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKSxcbiAgICBzM3RjX3NSR0I6IHN0b3JlZEdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2JcIiksXG4gICAgLyogZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2UgKi9cbiAgICBldGM6IHN0b3JlZEdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGNcIiksXG4gICAgZXRjMTogc3RvcmVkR2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzFcIiksXG4gICAgcHZydGM6IHN0b3JlZEdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1wiKSB8fCBzdG9yZWRHbC5nZXRFeHRlbnNpb24oXCJXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXCIpLFxuICAgIGF0Yzogc3RvcmVkR2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2F0Y1wiKSxcbiAgICBhc3RjOiBzdG9yZWRHbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXN0Y1wiKVxuICB9O1xufVxuY29uc3QgZGV0ZWN0Q29tcHJlc3NlZFRleHR1cmVzID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBjb3JlLkV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAyXG4gIH0sXG4gIHRlc3Q6IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBnbCA9IGNvcmUuc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoKS5nZXRDb250ZXh0KFwid2ViZ2xcIik7XG4gICAgcmV0dXJuIGdsID8gKHN0b3JlZEdsID0gZ2wsICEwKSA6IChjb25zb2xlLndhcm4oXCJXZWJHTCBub3QgYXZhaWxhYmxlIGZvciBjb21wcmVzc2VkIHRleHR1cmVzLlwiKSwgITEpO1xuICB9LFxuICBhZGQ6IGFzeW5jIChmb3JtYXRzKSA9PiB7XG4gICAgZXh0ZW5zaW9ucyB8fCBnZXRDb21wcmVzc2VkVGV4dHVyZUV4dGVuc2lvbnMoKTtcbiAgICBjb25zdCB0ZXh0dXJlRm9ybWF0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgZXh0ZW5zaW9uTmFtZSBpbiBleHRlbnNpb25zKVxuICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSAmJiB0ZXh0dXJlRm9ybWF0cy5wdXNoKGV4dGVuc2lvbk5hbWUpO1xuICAgIHJldHVybiBbLi4udGV4dHVyZUZvcm1hdHMsIC4uLmZvcm1hdHNdO1xuICB9LFxuICByZW1vdmU6IGFzeW5jIChmb3JtYXRzKSA9PiAoZXh0ZW5zaW9ucyB8fCBnZXRDb21wcmVzc2VkVGV4dHVyZUV4dGVuc2lvbnMoKSwgZm9ybWF0cy5maWx0ZXIoKGYpID0+ICEoZiBpbiBleHRlbnNpb25zKSkpXG59O1xuY29yZS5leHRlbnNpb25zLmFkZChkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMpO1xuZXhwb3J0cy5kZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMgPSBkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnJlcXVpcmUoXCIuL2NvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucy5qc1wiKTtcbnZhciBkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMgPSByZXF1aXJlKFwiLi9kZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMuanNcIiksIGxvYWRERFMgPSByZXF1aXJlKFwiLi9sb2FkRERTLmpzXCIpLCBsb2FkS1RYID0gcmVxdWlyZShcIi4vbG9hZEtUWC5qc1wiKSwgcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsID0gcmVxdWlyZShcIi4vcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsLmpzXCIpO1xuZXhwb3J0cy5kZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMgPSBkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMuZGV0ZWN0Q29tcHJlc3NlZFRleHR1cmVzO1xuZXhwb3J0cy5sb2FkRERTID0gbG9hZEREUy5sb2FkRERTO1xuZXhwb3J0cy5sb2FkS1RYID0gbG9hZEtUWC5sb2FkS1RYO1xuZXhwb3J0cy5yZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwgPSByZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwucmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBhc3NldHMgPSByZXF1aXJlKFwiQHBpeGkvYXNzZXRzXCIpLCBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIik7XG5yZXF1aXJlKFwiLi4vcGFyc2Vycy9pbmRleC5qc1wiKTtcbnZhciBwYXJzZUREUyA9IHJlcXVpcmUoXCIuLi9wYXJzZXJzL3BhcnNlRERTLmpzXCIpO1xuY29uc3QgbG9hZEREUyA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IGFzc2V0cy5Mb2FkZXJQYXJzZXJQcmlvcml0eS5IaWdoXG4gIH0sXG4gIG5hbWU6IFwibG9hZEREU1wiLFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiBhc3NldHMuY2hlY2tFeHRlbnNpb24odXJsLCBcIi5kZHNcIik7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBhc3NldCwgbG9hZGVyKSB7XG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCAoYXdhaXQgY29yZS5zZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCkpLmFycmF5QnVmZmVyKCksIHRleHR1cmVzID0gcGFyc2VERFMucGFyc2VERFMoYXJyYXlCdWZmZXIpLm1hcCgocmVzb3VyY2UpID0+IHtcbiAgICAgIGNvbnN0IGJhc2UgPSBuZXcgY29yZS5CYXNlVGV4dHVyZShyZXNvdXJjZSwge1xuICAgICAgICBtaXBtYXA6IGNvcmUuTUlQTUFQX01PREVTLk9GRixcbiAgICAgICAgYWxwaGFNb2RlOiBjb3JlLkFMUEhBX01PREVTLk5PX1BSRU1VTFRJUExJRURfQUxQSEEsXG4gICAgICAgIHJlc29sdXRpb246IGNvcmUudXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKHVybCksXG4gICAgICAgIC4uLmFzc2V0LmRhdGFcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFzc2V0cy5jcmVhdGVUZXh0dXJlKGJhc2UsIGxvYWRlciwgdXJsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGV4dHVyZXMubGVuZ3RoID09PSAxID8gdGV4dHVyZXNbMF0gOiB0ZXh0dXJlcztcbiAgfSxcbiAgdW5sb2FkKHRleHR1cmUpIHtcbiAgICBBcnJheS5pc0FycmF5KHRleHR1cmUpID8gdGV4dHVyZS5mb3JFYWNoKCh0KSA9PiB0LmRlc3Ryb3koITApKSA6IHRleHR1cmUuZGVzdHJveSghMCk7XG4gIH1cbn07XG5jb3JlLmV4dGVuc2lvbnMuYWRkKGxvYWRERFMpO1xuZXhwb3J0cy5sb2FkRERTID0gbG9hZEREUztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRERFMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBhc3NldHMgPSByZXF1aXJlKFwiQHBpeGkvYXNzZXRzXCIpLCBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIik7XG5yZXF1aXJlKFwiLi4vcGFyc2Vycy9pbmRleC5qc1wiKTtcbnZhciBwYXJzZUtUWCA9IHJlcXVpcmUoXCIuLi9wYXJzZXJzL3BhcnNlS1RYLmpzXCIpO1xuY29uc3QgbG9hZEtUWCA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IGFzc2V0cy5Mb2FkZXJQYXJzZXJQcmlvcml0eS5IaWdoXG4gIH0sXG4gIG5hbWU6IFwibG9hZEtUWFwiLFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiBhc3NldHMuY2hlY2tFeHRlbnNpb24odXJsLCBcIi5rdHhcIik7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBhc3NldCwgbG9hZGVyKSB7XG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCAoYXdhaXQgY29yZS5zZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCkpLmFycmF5QnVmZmVyKCksIHsgY29tcHJlc3NlZCwgdW5jb21wcmVzc2VkLCBrdkRhdGEgfSA9IHBhcnNlS1RYLnBhcnNlS1RYKHVybCwgYXJyYXlCdWZmZXIpLCByZXNvdXJjZXMgPSBjb21wcmVzc2VkID8/IHVuY29tcHJlc3NlZCwgb3B0aW9ucyA9IHtcbiAgICAgIG1pcG1hcDogY29yZS5NSVBNQVBfTU9ERVMuT0ZGLFxuICAgICAgYWxwaGFNb2RlOiBjb3JlLkFMUEhBX01PREVTLk5PX1BSRU1VTFRJUExJRURfQUxQSEEsXG4gICAgICByZXNvbHV0aW9uOiBjb3JlLnV0aWxzLmdldFJlc29sdXRpb25PZlVybCh1cmwpLFxuICAgICAgLi4uYXNzZXQuZGF0YVxuICAgIH0sIHRleHR1cmVzID0gcmVzb3VyY2VzLm1hcCgocmVzb3VyY2UpID0+IHtcbiAgICAgIHJlc291cmNlcyA9PT0gdW5jb21wcmVzc2VkICYmIE9iamVjdC5hc3NpZ24ob3B0aW9ucywge1xuICAgICAgICB0eXBlOiByZXNvdXJjZS50eXBlLFxuICAgICAgICBmb3JtYXQ6IHJlc291cmNlLmZvcm1hdFxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXMgPSByZXNvdXJjZS5yZXNvdXJjZSA/PyByZXNvdXJjZSwgYmFzZSA9IG5ldyBjb3JlLkJhc2VUZXh0dXJlKHJlcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gYmFzZS5rdHhLZXlWYWx1ZURhdGEgPSBrdkRhdGEsIGFzc2V0cy5jcmVhdGVUZXh0dXJlKGJhc2UsIGxvYWRlciwgdXJsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGV4dHVyZXMubGVuZ3RoID09PSAxID8gdGV4dHVyZXNbMF0gOiB0ZXh0dXJlcztcbiAgfSxcbiAgdW5sb2FkKHRleHR1cmUpIHtcbiAgICBBcnJheS5pc0FycmF5KHRleHR1cmUpID8gdGV4dHVyZS5mb3JFYWNoKCh0KSA9PiB0LmRlc3Ryb3koITApKSA6IHRleHR1cmUuZGVzdHJveSghMCk7XG4gIH1cbn07XG5jb3JlLmV4dGVuc2lvbnMuYWRkKGxvYWRLVFgpO1xuZXhwb3J0cy5sb2FkS1RYID0gbG9hZEtUWDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRLVFguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIik7XG5jb25zdCByZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwgPSB7XG4gIGV4dGVuc2lvbjogY29yZS5FeHRlbnNpb25UeXBlLlJlc29sdmVQYXJzZXIsXG4gIHRlc3Q6ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IGNvcmUudXRpbHMucGF0aC5leHRuYW1lKHZhbHVlKS5zbGljZSgxKTtcbiAgICByZXR1cm4gW1wiYmFzaXNcIiwgXCJrdHhcIiwgXCJkZHNcIl0uaW5jbHVkZXMoZXh0ZW5zaW9uKTtcbiAgfSxcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IGNvcmUudXRpbHMucGF0aC5leHRuYW1lKHZhbHVlKS5zbGljZSgxKTtcbiAgICBpZiAoZXh0ZW5zaW9uID09PSBcImt0eFwiKSB7XG4gICAgICBjb25zdCBleHRlbnNpb25zMiA9IFtcbiAgICAgICAgXCIuczN0Yy5rdHhcIixcbiAgICAgICAgXCIuczN0Y19zUkdCLmt0eFwiLFxuICAgICAgICBcIi5ldGMua3R4XCIsXG4gICAgICAgIFwiLmV0YzEua3R4XCIsXG4gICAgICAgIFwiLnB2cnQua3R4XCIsXG4gICAgICAgIFwiLmF0Yy5rdHhcIixcbiAgICAgICAgXCIuYXN0Yy5rdHhcIlxuICAgICAgXTtcbiAgICAgIGlmIChleHRlbnNpb25zMi5zb21lKChleHQpID0+IHZhbHVlLmVuZHNXaXRoKGV4dCkpKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc29sdXRpb246IHBhcnNlRmxvYXQoY29yZS5zZXR0aW5ncy5SRVRJTkFfUFJFRklYLmV4ZWModmFsdWUpPy5bMV0gPz8gXCIxXCIpLFxuICAgICAgICAgIGZvcm1hdDogZXh0ZW5zaW9uczIuZmluZCgoZXh0KSA9PiB2YWx1ZS5lbmRzV2l0aChleHQpKSxcbiAgICAgICAgICBzcmM6IHZhbHVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZXNvbHV0aW9uOiBwYXJzZUZsb2F0KGNvcmUuc2V0dGluZ3MuUkVUSU5BX1BSRUZJWC5leGVjKHZhbHVlKT8uWzFdID8/IFwiMVwiKSxcbiAgICAgIGZvcm1hdDogZXh0ZW5zaW9uLFxuICAgICAgc3JjOiB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG5jb3JlLmV4dGVuc2lvbnMuYWRkKHJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybCk7XG5leHBvcnRzLnJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybCA9IHJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHBhcnNlRERTID0gcmVxdWlyZShcIi4vcGFyc2VERFMuanNcIiksIHBhcnNlS1RYID0gcmVxdWlyZShcIi4vcGFyc2VLVFguanNcIik7XG5leHBvcnRzLnBhcnNlRERTID0gcGFyc2VERFMucGFyc2VERFM7XG5leHBvcnRzLkZPUk1BVFNfVE9fQ09NUE9ORU5UUyA9IHBhcnNlS1RYLkZPUk1BVFNfVE9fQ09NUE9ORU5UUztcbmV4cG9ydHMuVFlQRVNfVE9fQllURVNfUEVSX0NPTVBPTkVOVCA9IHBhcnNlS1RYLlRZUEVTX1RPX0JZVEVTX1BFUl9DT01QT05FTlQ7XG5leHBvcnRzLlRZUEVTX1RPX0JZVEVTX1BFUl9QSVhFTCA9IHBhcnNlS1RYLlRZUEVTX1RPX0JZVEVTX1BFUl9QSVhFTDtcbmV4cG9ydHMucGFyc2VLVFggPSBwYXJzZUtUWC5wYXJzZUtUWDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2NvbnN0ID0gcmVxdWlyZShcIi4uL2NvbnN0LmpzXCIpO1xucmVxdWlyZShcIi4uL3Jlc291cmNlcy9pbmRleC5qc1wiKTtcbnZhciBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlID0gcmVxdWlyZShcIi4uL3Jlc291cmNlcy9Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlLmpzXCIpO1xuY29uc3QgRERTX01BR0lDX1NJWkUgPSA0LCBERFNfSEVBREVSX1NJWkUgPSAxMjQsIEREU19IRUFERVJfUEZfU0laRSA9IDMyLCBERFNfSEVBREVSX0RYMTBfU0laRSA9IDIwLCBERFNfTUFHSUMgPSA1NDIzMjc4NzYsIEREU19GSUVMRFMgPSB7XG4gIFNJWkU6IDEsXG4gIEZMQUdTOiAyLFxuICBIRUlHSFQ6IDMsXG4gIFdJRFRIOiA0LFxuICBNSVBNQVBfQ09VTlQ6IDcsXG4gIFBJWEVMX0ZPUk1BVDogMTlcbn0sIEREU19QRl9GSUVMRFMgPSB7XG4gIFNJWkU6IDAsXG4gIEZMQUdTOiAxLFxuICBGT1VSQ0M6IDIsXG4gIFJHQl9CSVRDT1VOVDogMyxcbiAgUl9CSVRfTUFTSzogNCxcbiAgR19CSVRfTUFTSzogNSxcbiAgQl9CSVRfTUFTSzogNixcbiAgQV9CSVRfTUFTSzogN1xufSwgRERTX0RYMTBfRklFTERTID0ge1xuICBEWEdJX0ZPUk1BVDogMCxcbiAgUkVTT1VSQ0VfRElNRU5TSU9OOiAxLFxuICBNSVNDX0ZMQUc6IDIsXG4gIEFSUkFZX1NJWkU6IDMsXG4gIE1JU0NfRkxBR1MyOiA0XG59LCBQRl9GTEFHUyA9IDEsIEREUEZfQUxQSEEgPSAyLCBERFBGX0ZPVVJDQyA9IDQsIEREUEZfUkdCID0gNjQsIEREUEZfWVVWID0gNTEyLCBERFBGX0xVTUlOQU5DRSA9IDEzMTA3MiwgRk9VUkNDX0RYVDEgPSA4Mjc2MTEyMDQsIEZPVVJDQ19EWFQzID0gODYxMTY1NjM2LCBGT1VSQ0NfRFhUNSA9IDg5NDcyMDA2OCwgRk9VUkNDX0RYMTAgPSA4MDg1NDAyMjgsIEREU19SRVNPVVJDRV9NSVNDX1RFWFRVUkVDVUJFID0gNCwgRk9VUkNDX1RPX0ZPUk1BVCA9IHtcbiAgW0ZPVVJDQ19EWFQxXTogX2NvbnN0LklOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQsXG4gIFtGT1VSQ0NfRFhUM106IF9jb25zdC5JTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhULFxuICBbRk9VUkNDX0RYVDVdOiBfY29uc3QuSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVFxufSwgRFhHSV9UT19GT1JNQVQgPSB7XG4gIC8vIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXG4gIDcwOiBfY29uc3QuSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVCxcbiAgNzE6IF9jb25zdC5JTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhULFxuICA3MzogX2NvbnN0LklOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQsXG4gIDc0OiBfY29uc3QuSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVCxcbiAgNzY6IF9jb25zdC5JTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhULFxuICA3NzogX2NvbnN0LklOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQsXG4gIC8vIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2JcbiAgNzI6IF9jb25zdC5JTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDFfRVhULFxuICA3NTogX2NvbnN0LklOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUM19FWFQsXG4gIDc4OiBfY29uc3QuSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQ1X0VYVFxufTtcbmZ1bmN0aW9uIHBhcnNlRERTKGFycmF5QnVmZmVyKSB7XG4gIGNvbnN0IGRhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIpO1xuICBpZiAoZGF0YVswXSAhPT0gRERTX01BR0lDKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgRERTIGZpbGUgbWFnaWMgd29yZFwiKTtcbiAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyLCAwLCBERFNfSEVBREVSX1NJWkUgLyBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCksIGhlaWdodCA9IGhlYWRlcltERFNfRklFTERTLkhFSUdIVF0sIHdpZHRoID0gaGVhZGVyW0REU19GSUVMRFMuV0lEVEhdLCBtaXBtYXBDb3VudCA9IGhlYWRlcltERFNfRklFTERTLk1JUE1BUF9DT1VOVF0sIHBpeGVsRm9ybWF0ID0gbmV3IFVpbnQzMkFycmF5KFxuICAgIGFycmF5QnVmZmVyLFxuICAgIEREU19GSUVMRFMuUElYRUxfRk9STUFUICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgRERTX0hFQURFUl9QRl9TSVpFIC8gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlRcbiAgKSwgZm9ybWF0RmxhZ3MgPSBwaXhlbEZvcm1hdFtQRl9GTEFHU107XG4gIGlmIChmb3JtYXRGbGFncyAmIEREUEZfRk9VUkNDKSB7XG4gICAgY29uc3QgZm91ckNDID0gcGl4ZWxGb3JtYXRbRERTX1BGX0ZJRUxEUy5GT1VSQ0NdO1xuICAgIGlmIChmb3VyQ0MgIT09IEZPVVJDQ19EWDEwKSB7XG4gICAgICBjb25zdCBpbnRlcm5hbEZvcm1hdDIgPSBGT1VSQ0NfVE9fRk9STUFUW2ZvdXJDQ10sIGRhdGFPZmZzZXQyID0gRERTX01BR0lDX1NJWkUgKyBERFNfSEVBREVSX1NJWkUsIHRleERhdGEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgZGF0YU9mZnNldDIpO1xuICAgICAgcmV0dXJuIFtuZXcgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlKHRleERhdGEsIHtcbiAgICAgICAgZm9ybWF0OiBpbnRlcm5hbEZvcm1hdDIsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGxldmVsczogbWlwbWFwQ291bnRcbiAgICAgICAgLy8gQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSB3aWxsIHNlcGFyYXRlIHRoZSBsZXZlbEJ1ZmZlcnMgZm9yIHVzIVxuICAgICAgfSldO1xuICAgIH1cbiAgICBjb25zdCBkeDEwT2Zmc2V0ID0gRERTX01BR0lDX1NJWkUgKyBERFNfSEVBREVSX1NJWkUsIGR4MTBIZWFkZXIgPSBuZXcgVWludDMyQXJyYXkoXG4gICAgICBkYXRhLmJ1ZmZlcixcbiAgICAgIGR4MTBPZmZzZXQsXG4gICAgICBERFNfSEVBREVSX0RYMTBfU0laRSAvIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UXG4gICAgKSwgZHhnaUZvcm1hdCA9IGR4MTBIZWFkZXJbRERTX0RYMTBfRklFTERTLkRYR0lfRk9STUFUXSwgcmVzb3VyY2VEaW1lbnNpb24gPSBkeDEwSGVhZGVyW0REU19EWDEwX0ZJRUxEUy5SRVNPVVJDRV9ESU1FTlNJT05dLCBtaXNjRmxhZyA9IGR4MTBIZWFkZXJbRERTX0RYMTBfRklFTERTLk1JU0NfRkxBR10sIGFycmF5U2l6ZSA9IGR4MTBIZWFkZXJbRERTX0RYMTBfRklFTERTLkFSUkFZX1NJWkVdLCBpbnRlcm5hbEZvcm1hdCA9IERYR0lfVE9fRk9STUFUW2R4Z2lGb3JtYXRdO1xuICAgIGlmIChpbnRlcm5hbEZvcm1hdCA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBERFNQYXJzZXIgY2Fubm90IHBhcnNlIHRleHR1cmUgZGF0YSB3aXRoIERYR0kgZm9ybWF0ICR7ZHhnaUZvcm1hdH1gKTtcbiAgICBpZiAobWlzY0ZsYWcgPT09IEREU19SRVNPVVJDRV9NSVNDX1RFWFRVUkVDVUJFKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRERTUGFyc2VyIGRvZXMgbm90IHN1cHBvcnQgY3ViZW1hcCB0ZXh0dXJlc1wiKTtcbiAgICBpZiAocmVzb3VyY2VEaW1lbnNpb24gPT09IDYpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJERFNQYXJzZXIgZG9lcyBub3Qgc3VwcG9ydGVkIDNEIHRleHR1cmUgZGF0YVwiKTtcbiAgICBjb25zdCBpbWFnZUJ1ZmZlcnMgPSBuZXcgQXJyYXkoKSwgZGF0YU9mZnNldCA9IEREU19NQUdJQ19TSVpFICsgRERTX0hFQURFUl9TSVpFICsgRERTX0hFQURFUl9EWDEwX1NJWkU7XG4gICAgaWYgKGFycmF5U2l6ZSA9PT0gMSlcbiAgICAgIGltYWdlQnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0KSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBwaXhlbFNpemUgPSBfY29uc3QuSU5URVJOQUxfRk9STUFUX1RPX0JZVEVTX1BFUl9QSVhFTFtpbnRlcm5hbEZvcm1hdF07XG4gICAgICBsZXQgaW1hZ2VTaXplID0gMCwgbGV2ZWxXaWR0aCA9IHdpZHRoLCBsZXZlbEhlaWdodCA9IGhlaWdodDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWlwbWFwQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBhbGlnbmVkTGV2ZWxXaWR0aCA9IE1hdGgubWF4KDEsIGxldmVsV2lkdGggKyAzICYgLTQpLCBhbGlnbmVkTGV2ZWxIZWlnaHQgPSBNYXRoLm1heCgxLCBsZXZlbEhlaWdodCArIDMgJiAtNCksIGxldmVsU2l6ZSA9IGFsaWduZWRMZXZlbFdpZHRoICogYWxpZ25lZExldmVsSGVpZ2h0ICogcGl4ZWxTaXplO1xuICAgICAgICBpbWFnZVNpemUgKz0gbGV2ZWxTaXplLCBsZXZlbFdpZHRoID0gbGV2ZWxXaWR0aCA+Pj4gMSwgbGV2ZWxIZWlnaHQgPSBsZXZlbEhlaWdodCA+Pj4gMTtcbiAgICAgIH1cbiAgICAgIGxldCBpbWFnZU9mZnNldCA9IGRhdGFPZmZzZXQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5U2l6ZTsgaSsrKVxuICAgICAgICBpbWFnZUJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgaW1hZ2VPZmZzZXQsIGltYWdlU2l6ZSkpLCBpbWFnZU9mZnNldCArPSBpbWFnZVNpemU7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZUJ1ZmZlcnMubWFwKChidWZmZXIpID0+IG5ldyBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLkNvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UoYnVmZmVyLCB7XG4gICAgICBmb3JtYXQ6IGludGVybmFsRm9ybWF0LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsZXZlbHM6IG1pcG1hcENvdW50XG4gICAgfSkpO1xuICB9XG4gIHRocm93IGZvcm1hdEZsYWdzICYgRERQRl9SR0IgPyBuZXcgRXJyb3IoXCJERFNQYXJzZXIgZG9lcyBub3Qgc3VwcG9ydCB1bmNvbXByZXNzZWQgdGV4dHVyZSBkYXRhLlwiKSA6IGZvcm1hdEZsYWdzICYgRERQRl9ZVVYgPyBuZXcgRXJyb3IoXCJERFNQYXJzZXIgZG9lcyBub3Qgc3VwcG9ydGVkIFlVViB1bmNvbXByZXNzZWQgdGV4dHVyZSBkYXRhLlwiKSA6IGZvcm1hdEZsYWdzICYgRERQRl9MVU1JTkFOQ0UgPyBuZXcgRXJyb3IoXCJERFNQYXJzZXIgZG9lcyBub3Qgc3VwcG9ydCBzaW5nbGUtY2hhbm5lbCAobHVtbmluYW5jZSkgdGV4dHVyZSBkYXRhIVwiKSA6IGZvcm1hdEZsYWdzICYgRERQRl9BTFBIQSA/IG5ldyBFcnJvcihcIkREU1BhcnNlciBkb2VzIG5vdCBzdXBwb3J0IHNpbmdsZS1jaGFubmVsIChhbHBoYSkgdGV4dHVyZSBkYXRhIVwiKSA6IG5ldyBFcnJvcihcIkREU1BhcnNlciBmYWlsZWQgdG8gbG9hZCBhIHRleHR1cmUgZmlsZSBkdWUgdG8gYW4gdW5rbm93biByZWFzb24hXCIpO1xufVxuZXhwb3J0cy5wYXJzZUREUyA9IHBhcnNlRERTO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VERFMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIF9jb25zdCA9IHJlcXVpcmUoXCIuLi9jb25zdC5qc1wiKTtcbnJlcXVpcmUoXCIuLi9yZXNvdXJjZXMvaW5kZXguanNcIik7XG52YXIgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSA9IHJlcXVpcmUoXCIuLi9yZXNvdXJjZXMvQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5qc1wiKTtcbmNvbnN0IEZJTEVfSURFTlRJRklFUiA9IFsxNzEsIDc1LCA4NCwgODgsIDMyLCA0OSwgNDksIDE4NywgMTMsIDEwLCAyNiwgMTBdLCBFTkRJQU5ORVNTID0gNjczMDU5ODUsIEtUWF9GSUVMRFMgPSB7XG4gIEZJTEVfSURFTlRJRklFUjogMCxcbiAgRU5ESUFOTkVTUzogMTIsXG4gIEdMX1RZUEU6IDE2LFxuICBHTF9UWVBFX1NJWkU6IDIwLFxuICBHTF9GT1JNQVQ6IDI0LFxuICBHTF9JTlRFUk5BTF9GT1JNQVQ6IDI4LFxuICBHTF9CQVNFX0lOVEVSTkFMX0ZPUk1BVDogMzIsXG4gIFBJWEVMX1dJRFRIOiAzNixcbiAgUElYRUxfSEVJR0hUOiA0MCxcbiAgUElYRUxfREVQVEg6IDQ0LFxuICBOVU1CRVJfT0ZfQVJSQVlfRUxFTUVOVFM6IDQ4LFxuICBOVU1CRVJfT0ZfRkFDRVM6IDUyLFxuICBOVU1CRVJfT0ZfTUlQTUFQX0xFVkVMUzogNTYsXG4gIEJZVEVTX09GX0tFWV9WQUxVRV9EQVRBOiA2MFxufSwgRklMRV9IRUFERVJfU0laRSA9IDY0LCBUWVBFU19UT19CWVRFU19QRVJfQ09NUE9ORU5UID0ge1xuICBbY29yZS5UWVBFUy5VTlNJR05FRF9CWVRFXTogMSxcbiAgW2NvcmUuVFlQRVMuVU5TSUdORURfU0hPUlRdOiAyLFxuICBbY29yZS5UWVBFUy5JTlRdOiA0LFxuICBbY29yZS5UWVBFUy5VTlNJR05FRF9JTlRdOiA0LFxuICBbY29yZS5UWVBFUy5GTE9BVF06IDQsXG4gIFtjb3JlLlRZUEVTLkhBTEZfRkxPQVRdOiA4XG59LCBGT1JNQVRTX1RPX0NPTVBPTkVOVFMgPSB7XG4gIFtjb3JlLkZPUk1BVFMuUkdCQV06IDQsXG4gIFtjb3JlLkZPUk1BVFMuUkdCXTogMyxcbiAgW2NvcmUuRk9STUFUUy5SR106IDIsXG4gIFtjb3JlLkZPUk1BVFMuUkVEXTogMSxcbiAgW2NvcmUuRk9STUFUUy5MVU1JTkFOQ0VdOiAxLFxuICBbY29yZS5GT1JNQVRTLkxVTUlOQU5DRV9BTFBIQV06IDIsXG4gIFtjb3JlLkZPUk1BVFMuQUxQSEFdOiAxXG59LCBUWVBFU19UT19CWVRFU19QRVJfUElYRUwgPSB7XG4gIFtjb3JlLlRZUEVTLlVOU0lHTkVEX1NIT1JUXzRfNF80XzRdOiAyLFxuICBbY29yZS5UWVBFUy5VTlNJR05FRF9TSE9SVF81XzVfNV8xXTogMixcbiAgW2NvcmUuVFlQRVMuVU5TSUdORURfU0hPUlRfNV82XzVdOiAyXG59O1xuZnVuY3Rpb24gcGFyc2VLVFgodXJsLCBhcnJheUJ1ZmZlciwgbG9hZEtleVZhbHVlRGF0YSA9ICExKSB7XG4gIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgaWYgKCF2YWxpZGF0ZSh1cmwsIGRhdGFWaWV3KSlcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgbGl0dGxlRW5kaWFuID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuRU5ESUFOTkVTUywgITApID09PSBFTkRJQU5ORVNTLCBnbFR5cGUgPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5HTF9UWVBFLCBsaXR0bGVFbmRpYW4pLCBnbEZvcm1hdCA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLkdMX0ZPUk1BVCwgbGl0dGxlRW5kaWFuKSwgZ2xJbnRlcm5hbEZvcm1hdCA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLkdMX0lOVEVSTkFMX0ZPUk1BVCwgbGl0dGxlRW5kaWFuKSwgcGl4ZWxXaWR0aCA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLlBJWEVMX1dJRFRILCBsaXR0bGVFbmRpYW4pLCBwaXhlbEhlaWdodCA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLlBJWEVMX0hFSUdIVCwgbGl0dGxlRW5kaWFuKSB8fCAxLCBwaXhlbERlcHRoID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuUElYRUxfREVQVEgsIGxpdHRsZUVuZGlhbikgfHwgMSwgbnVtYmVyT2ZBcnJheUVsZW1lbnRzID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuTlVNQkVSX09GX0FSUkFZX0VMRU1FTlRTLCBsaXR0bGVFbmRpYW4pIHx8IDEsIG51bWJlck9mRmFjZXMgPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5OVU1CRVJfT0ZfRkFDRVMsIGxpdHRsZUVuZGlhbiksIG51bWJlck9mTWlwbWFwTGV2ZWxzID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuTlVNQkVSX09GX01JUE1BUF9MRVZFTFMsIGxpdHRsZUVuZGlhbiksIGJ5dGVzT2ZLZXlWYWx1ZURhdGEgPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5CWVRFU19PRl9LRVlfVkFMVUVfREFUQSwgbGl0dGxlRW5kaWFuKTtcbiAgaWYgKHBpeGVsSGVpZ2h0ID09PSAwIHx8IHBpeGVsRGVwdGggIT09IDEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSAyRCB0ZXh0dXJlcyBhcmUgc3VwcG9ydGVkXCIpO1xuICBpZiAobnVtYmVyT2ZGYWNlcyAhPT0gMSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdWJlVGV4dHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgS1RYTG9hZGVyIHlldCFcIik7XG4gIGlmIChudW1iZXJPZkFycmF5RWxlbWVudHMgIT09IDEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgZG9lcyBub3Qgc3VwcG9ydCBhcnJheSB0ZXh0dXJlc1wiKTtcbiAgY29uc3QgYmxvY2tXaWR0aCA9IDQsIGJsb2NrSGVpZ2h0ID0gNCwgYWxpZ25lZFdpZHRoID0gcGl4ZWxXaWR0aCArIDMgJiAtNCwgYWxpZ25lZEhlaWdodCA9IHBpeGVsSGVpZ2h0ICsgMyAmIC00LCBpbWFnZUJ1ZmZlcnMgPSBuZXcgQXJyYXkobnVtYmVyT2ZBcnJheUVsZW1lbnRzKTtcbiAgbGV0IGltYWdlUGl4ZWxzID0gcGl4ZWxXaWR0aCAqIHBpeGVsSGVpZ2h0O1xuICBnbFR5cGUgPT09IDAgJiYgKGltYWdlUGl4ZWxzID0gYWxpZ25lZFdpZHRoICogYWxpZ25lZEhlaWdodCk7XG4gIGxldCBpbWFnZVBpeGVsQnl0ZVNpemU7XG4gIGlmIChnbFR5cGUgIT09IDAgPyBUWVBFU19UT19CWVRFU19QRVJfQ09NUE9ORU5UW2dsVHlwZV0gPyBpbWFnZVBpeGVsQnl0ZVNpemUgPSBUWVBFU19UT19CWVRFU19QRVJfQ09NUE9ORU5UW2dsVHlwZV0gKiBGT1JNQVRTX1RPX0NPTVBPTkVOVFNbZ2xGb3JtYXRdIDogaW1hZ2VQaXhlbEJ5dGVTaXplID0gVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMW2dsVHlwZV0gOiBpbWFnZVBpeGVsQnl0ZVNpemUgPSBfY29uc3QuSU5URVJOQUxfRk9STUFUX1RPX0JZVEVTX1BFUl9QSVhFTFtnbEludGVybmFsRm9ybWF0XSwgaW1hZ2VQaXhlbEJ5dGVTaXplID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlc29sdmUgdGhlIHBpeGVsIGZvcm1hdCBzdG9yZWQgaW4gdGhlICoua3R4IGZpbGUhXCIpO1xuICBjb25zdCBrdkRhdGEgPSBsb2FkS2V5VmFsdWVEYXRhID8gcGFyc2VLdkRhdGEoZGF0YVZpZXcsIGJ5dGVzT2ZLZXlWYWx1ZURhdGEsIGxpdHRsZUVuZGlhbikgOiBudWxsO1xuICBsZXQgbWlwQnl0ZVNpemUgPSBpbWFnZVBpeGVscyAqIGltYWdlUGl4ZWxCeXRlU2l6ZSwgbWlwV2lkdGggPSBwaXhlbFdpZHRoLCBtaXBIZWlnaHQgPSBwaXhlbEhlaWdodCwgYWxpZ25lZE1pcFdpZHRoID0gYWxpZ25lZFdpZHRoLCBhbGlnbmVkTWlwSGVpZ2h0ID0gYWxpZ25lZEhlaWdodCwgaW1hZ2VPZmZzZXQgPSBGSUxFX0hFQURFUl9TSVpFICsgYnl0ZXNPZktleVZhbHVlRGF0YTtcbiAgZm9yIChsZXQgbWlwbWFwTGV2ZWwgPSAwOyBtaXBtYXBMZXZlbCA8IG51bWJlck9mTWlwbWFwTGV2ZWxzOyBtaXBtYXBMZXZlbCsrKSB7XG4gICAgY29uc3QgaW1hZ2VTaXplID0gZGF0YVZpZXcuZ2V0VWludDMyKGltYWdlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICAgIGxldCBlbGVtZW50T2Zmc2V0ID0gaW1hZ2VPZmZzZXQgKyA0O1xuICAgIGZvciAobGV0IGFycmF5RWxlbWVudCA9IDA7IGFycmF5RWxlbWVudCA8IG51bWJlck9mQXJyYXlFbGVtZW50czsgYXJyYXlFbGVtZW50KyspIHtcbiAgICAgIGxldCBtaXBzID0gaW1hZ2VCdWZmZXJzW2FycmF5RWxlbWVudF07XG4gICAgICBtaXBzIHx8IChtaXBzID0gaW1hZ2VCdWZmZXJzW2FycmF5RWxlbWVudF0gPSBuZXcgQXJyYXkobnVtYmVyT2ZNaXBtYXBMZXZlbHMpKSwgbWlwc1ttaXBtYXBMZXZlbF0gPSB7XG4gICAgICAgIGxldmVsSUQ6IG1pcG1hcExldmVsLFxuICAgICAgICAvLyBkb24ndCBhbGlnbiBtaXBXaWR0aCB3aGVuIHRleHR1cmUgbm90IGNvbXByZXNzZWQhIChnbFR5cGUgbm90IHplcm8pXG4gICAgICAgIGxldmVsV2lkdGg6IG51bWJlck9mTWlwbWFwTGV2ZWxzID4gMSB8fCBnbFR5cGUgIT09IDAgPyBtaXBXaWR0aCA6IGFsaWduZWRNaXBXaWR0aCxcbiAgICAgICAgbGV2ZWxIZWlnaHQ6IG51bWJlck9mTWlwbWFwTGV2ZWxzID4gMSB8fCBnbFR5cGUgIT09IDAgPyBtaXBIZWlnaHQgOiBhbGlnbmVkTWlwSGVpZ2h0LFxuICAgICAgICBsZXZlbEJ1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGVsZW1lbnRPZmZzZXQsIG1pcEJ5dGVTaXplKVxuICAgICAgfSwgZWxlbWVudE9mZnNldCArPSBtaXBCeXRlU2l6ZTtcbiAgICB9XG4gICAgaW1hZ2VPZmZzZXQgKz0gaW1hZ2VTaXplICsgNCwgaW1hZ2VPZmZzZXQgPSBpbWFnZU9mZnNldCAlIDQgIT09IDAgPyBpbWFnZU9mZnNldCArIDQgLSBpbWFnZU9mZnNldCAlIDQgOiBpbWFnZU9mZnNldCwgbWlwV2lkdGggPSBtaXBXaWR0aCA+PiAxIHx8IDEsIG1pcEhlaWdodCA9IG1pcEhlaWdodCA+PiAxIHx8IDEsIGFsaWduZWRNaXBXaWR0aCA9IG1pcFdpZHRoICsgYmxvY2tXaWR0aCAtIDEgJiB+KGJsb2NrV2lkdGggLSAxKSwgYWxpZ25lZE1pcEhlaWdodCA9IG1pcEhlaWdodCArIGJsb2NrSGVpZ2h0IC0gMSAmIH4oYmxvY2tIZWlnaHQgLSAxKSwgbWlwQnl0ZVNpemUgPSBhbGlnbmVkTWlwV2lkdGggKiBhbGlnbmVkTWlwSGVpZ2h0ICogaW1hZ2VQaXhlbEJ5dGVTaXplO1xuICB9XG4gIHJldHVybiBnbFR5cGUgIT09IDAgPyB7XG4gICAgdW5jb21wcmVzc2VkOiBpbWFnZUJ1ZmZlcnMubWFwKChsZXZlbEJ1ZmZlcnMpID0+IHtcbiAgICAgIGxldCBidWZmZXIgPSBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIsIGNvbnZlcnRUb0ludCA9ICExO1xuICAgICAgcmV0dXJuIGdsVHlwZSA9PT0gY29yZS5UWVBFUy5GTE9BVCA/IGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgIGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlci5idWZmZXIsXG4gICAgICAgIGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnl0ZUxlbmd0aCAvIDRcbiAgICAgICkgOiBnbFR5cGUgPT09IGNvcmUuVFlQRVMuVU5TSUdORURfSU5UID8gKGNvbnZlcnRUb0ludCA9ICEwLCBidWZmZXIgPSBuZXcgVWludDMyQXJyYXkoXG4gICAgICAgIGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlci5idWZmZXIsXG4gICAgICAgIGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnl0ZUxlbmd0aCAvIDRcbiAgICAgICkpIDogZ2xUeXBlID09PSBjb3JlLlRZUEVTLklOVCAmJiAoY29udmVydFRvSW50ID0gITAsIGJ1ZmZlciA9IG5ldyBJbnQzMkFycmF5KFxuICAgICAgICBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnVmZmVyLFxuICAgICAgICBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnl0ZU9mZnNldCxcbiAgICAgICAgbGV2ZWxCdWZmZXJzWzBdLmxldmVsQnVmZmVyLmJ5dGVMZW5ndGggLyA0XG4gICAgICApKSwge1xuICAgICAgICByZXNvdXJjZTogbmV3IGNvcmUuQnVmZmVyUmVzb3VyY2UoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdpZHRoOiBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogbGV2ZWxCdWZmZXJzWzBdLmxldmVsSGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB0eXBlOiBnbFR5cGUsXG4gICAgICAgIGZvcm1hdDogY29udmVydFRvSW50ID8gY29udmVydEZvcm1hdFRvSW50ZWdlcihnbEZvcm1hdCkgOiBnbEZvcm1hdFxuICAgICAgfTtcbiAgICB9KSxcbiAgICBrdkRhdGFcbiAgfSA6IHtcbiAgICBjb21wcmVzc2VkOiBpbWFnZUJ1ZmZlcnMubWFwKChsZXZlbEJ1ZmZlcnMpID0+IG5ldyBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLkNvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UobnVsbCwge1xuICAgICAgZm9ybWF0OiBnbEludGVybmFsRm9ybWF0LFxuICAgICAgd2lkdGg6IHBpeGVsV2lkdGgsXG4gICAgICBoZWlnaHQ6IHBpeGVsSGVpZ2h0LFxuICAgICAgbGV2ZWxzOiBudW1iZXJPZk1pcG1hcExldmVscyxcbiAgICAgIGxldmVsQnVmZmVyc1xuICAgIH0pKSxcbiAgICBrdkRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKHVybCwgZGF0YVZpZXcpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBGSUxFX0lERU5USUZJRVIubGVuZ3RoOyBpKyspXG4gICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KGkpICE9PSBGSUxFX0lERU5USUZJRVJbaV0pXG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgJHt1cmx9IGlzIG5vdCBhIHZhbGlkICoua3R4IGZpbGUhYCksICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBjb252ZXJ0Rm9ybWF0VG9JbnRlZ2VyKGZvcm1hdCkge1xuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgY29yZS5GT1JNQVRTLlJHQkE6XG4gICAgICByZXR1cm4gY29yZS5GT1JNQVRTLlJHQkFfSU5URUdFUjtcbiAgICBjYXNlIGNvcmUuRk9STUFUUy5SR0I6XG4gICAgICByZXR1cm4gY29yZS5GT1JNQVRTLlJHQl9JTlRFR0VSO1xuICAgIGNhc2UgY29yZS5GT1JNQVRTLlJHOlxuICAgICAgcmV0dXJuIGNvcmUuRk9STUFUUy5SR19JTlRFR0VSO1xuICAgIGNhc2UgY29yZS5GT1JNQVRTLlJFRDpcbiAgICAgIHJldHVybiBjb3JlLkZPUk1BVFMuUkVEX0lOVEVHRVI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlS3ZEYXRhKGRhdGFWaWV3LCBieXRlc09mS2V5VmFsdWVEYXRhLCBsaXR0bGVFbmRpYW4pIHtcbiAgY29uc3Qga3ZEYXRhID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGJ5dGVzSW50b0tleVZhbHVlRGF0YSA9IDA7XG4gIGZvciAoOyBieXRlc0ludG9LZXlWYWx1ZURhdGEgPCBieXRlc09mS2V5VmFsdWVEYXRhOyApIHtcbiAgICBjb25zdCBrZXlBbmRWYWx1ZUJ5dGVTaXplID0gZGF0YVZpZXcuZ2V0VWludDMyKEZJTEVfSEVBREVSX1NJWkUgKyBieXRlc0ludG9LZXlWYWx1ZURhdGEsIGxpdHRsZUVuZGlhbiksIGtleUFuZFZhbHVlQnl0ZU9mZnNldCA9IEZJTEVfSEVBREVSX1NJWkUgKyBieXRlc0ludG9LZXlWYWx1ZURhdGEgKyA0LCB2YWx1ZVBhZGRpbmcgPSAzIC0gKGtleUFuZFZhbHVlQnl0ZVNpemUgKyAzKSAlIDQ7XG4gICAgaWYgKGtleUFuZFZhbHVlQnl0ZVNpemUgPT09IDAgfHwga2V5QW5kVmFsdWVCeXRlU2l6ZSA+IGJ5dGVzT2ZLZXlWYWx1ZURhdGEgLSBieXRlc0ludG9LZXlWYWx1ZURhdGEpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJLVFhMb2FkZXI6IGtleUFuZFZhbHVlQnl0ZVNpemUgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQga2V5TnVsQnl0ZSA9IDA7XG4gICAgZm9yICg7IGtleU51bEJ5dGUgPCBrZXlBbmRWYWx1ZUJ5dGVTaXplICYmIGRhdGFWaWV3LmdldFVpbnQ4KGtleUFuZFZhbHVlQnl0ZU9mZnNldCArIGtleU51bEJ5dGUpICE9PSAwOyBrZXlOdWxCeXRlKyspXG4gICAgICA7XG4gICAgaWYgKGtleU51bEJ5dGUgPT09IC0xKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiS1RYTG9hZGVyOiBGYWlsZWQgdG8gZmluZCBudWxsIGJ5dGUgdGVybWluYXRpbmcga3ZEYXRhIGtleVwiKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoXG4gICAgICBuZXcgVWludDhBcnJheShkYXRhVmlldy5idWZmZXIsIGtleUFuZFZhbHVlQnl0ZU9mZnNldCwga2V5TnVsQnl0ZSlcbiAgICApLCB2YWx1ZSA9IG5ldyBEYXRhVmlldyhcbiAgICAgIGRhdGFWaWV3LmJ1ZmZlcixcbiAgICAgIGtleUFuZFZhbHVlQnl0ZU9mZnNldCArIGtleU51bEJ5dGUgKyAxLFxuICAgICAga2V5QW5kVmFsdWVCeXRlU2l6ZSAtIGtleU51bEJ5dGUgLSAxXG4gICAgKTtcbiAgICBrdkRhdGEuc2V0KGtleSwgdmFsdWUpLCBieXRlc0ludG9LZXlWYWx1ZURhdGEgKz0gNCArIGtleUFuZFZhbHVlQnl0ZVNpemUgKyB2YWx1ZVBhZGRpbmc7XG4gIH1cbiAgcmV0dXJuIGt2RGF0YTtcbn1cbmV4cG9ydHMuRk9STUFUU19UT19DT01QT05FTlRTID0gRk9STUFUU19UT19DT01QT05FTlRTO1xuZXhwb3J0cy5UWVBFU19UT19CWVRFU19QRVJfQ09NUE9ORU5UID0gVFlQRVNfVE9fQllURVNfUEVSX0NPTVBPTkVOVDtcbmV4cG9ydHMuVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMID0gVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMO1xuZXhwb3J0cy5wYXJzZUtUWCA9IHBhcnNlS1RYO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VLVFguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIik7XG5jbGFzcyBCbG9iUmVzb3VyY2UgZXh0ZW5kcyBjb3JlLkJ1ZmZlclJlc291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgYnVmZmVyL1VSTCBvZiB0aGUgdGV4dHVyZSBmaWxlLlxuICAgKiBAcGFyYW0ge1BJWEkuSUJsb2JSZXNvdXJjZU9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9Mb2FkPWZhbHNlXSAtIFdoZXRoZXIgdG8gZmV0Y2ggdGhlIGRhdGEgaW1tZWRpYXRlbHk7XG4gICAqICB5b3UgY2FuIGZldGNoIGl0IGxhdGVyIHZpYSB7QGxpbmsgUElYSS5CbG9iUmVzb3VyY2UjbG9hZH0uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aD0xXSAtIFRoZSB3aWR0aCBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MV0gLSBUaGUgaGVpZ2h0IGluIHBpeGVscy5cbiAgICogQHBhcmFtIHsxfDJ8NHw4fSBbb3B0aW9ucy51bnBhY2tBbGlnbm1lbnQ9NF0gLSBUaGUgYWxpZ25tZW50IG9mIHRoZSBwaXhlbCByb3dzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zID0geyB3aWR0aDogMSwgaGVpZ2h0OiAxLCBhdXRvTG9hZDogITAgfSkge1xuICAgIGxldCBvcmlnaW4sIGRhdGE7XG4gICAgdHlwZW9mIHNvdXJjZSA9PSBcInN0cmluZ1wiID8gKG9yaWdpbiA9IHNvdXJjZSwgZGF0YSA9IG5ldyBVaW50OEFycmF5KCkpIDogKG9yaWdpbiA9IG51bGwsIGRhdGEgPSBzb3VyY2UpLCBzdXBlcihkYXRhLCBvcHRpb25zKSwgdGhpcy5vcmlnaW4gPSBvcmlnaW4sIHRoaXMuYnVmZmVyID0gZGF0YSA/IG5ldyBjb3JlLlZpZXdhYmxlQnVmZmVyKGRhdGEpIDogbnVsbCwgdGhpcy5fbG9hZCA9IG51bGwsIHRoaXMubG9hZGVkID0gITEsIHRoaXMub3JpZ2luICE9PSBudWxsICYmIG9wdGlvbnMuYXV0b0xvYWQgIT09ICExICYmIHRoaXMubG9hZCgpLCB0aGlzLm9yaWdpbiA9PT0gbnVsbCAmJiB0aGlzLmJ1ZmZlciAmJiAodGhpcy5fbG9hZCA9IFByb21pc2UucmVzb2x2ZSh0aGlzKSwgdGhpcy5sb2FkZWQgPSAhMCwgdGhpcy5vbkJsb2JMb2FkZWQodGhpcy5idWZmZXIucmF3QmluYXJ5RGF0YSkpO1xuICB9XG4gIG9uQmxvYkxvYWRlZChfZGF0YSkge1xuICB9XG4gIC8qKiBMb2FkcyB0aGUgYmxvYiAqL1xuICBsb2FkKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2FkID8gdGhpcy5fbG9hZCA6ICh0aGlzLl9sb2FkID0gZmV0Y2godGhpcy5vcmlnaW4pLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5ibG9iKCkpLnRoZW4oKGJsb2IpID0+IGJsb2IuYXJyYXlCdWZmZXIoKSkudGhlbigoYXJyYXlCdWZmZXIpID0+ICh0aGlzLmRhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIpLCB0aGlzLmJ1ZmZlciA9IG5ldyBjb3JlLlZpZXdhYmxlQnVmZmVyKGFycmF5QnVmZmVyKSwgdGhpcy5sb2FkZWQgPSAhMCwgdGhpcy5vbkJsb2JMb2FkZWQoYXJyYXlCdWZmZXIpLCB0aGlzLnVwZGF0ZSgpLCB0aGlzKSksIHRoaXMuX2xvYWQpO1xuICB9XG59XG5leHBvcnRzLkJsb2JSZXNvdXJjZSA9IEJsb2JSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsb2JSZXNvdXJjZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9jb25zdCA9IHJlcXVpcmUoXCIuLi9jb25zdC5qc1wiKSwgQmxvYlJlc291cmNlID0gcmVxdWlyZShcIi4vQmxvYlJlc291cmNlLmpzXCIpO1xuY2xhc3MgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSBleHRlbmRzIEJsb2JSZXNvdXJjZS5CbG9iUmVzb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHNvdXJjZSAtIHRoZSBidWZmZXIvVVJMIGhvbGRpbmcgdGhlIGNvbXByZXNzZWQgdGV4dHVyZSBkYXRhXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBwYXJhbSB7UElYSS5JTlRFUk5BTF9GT1JNQVRTfSBvcHRpb25zLmZvcm1hdCAtIHRoZSBjb21wcmVzc2lvbiBmb3JtYXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMud2lkdGggLSB0aGUgaW1hZ2Ugd2lkdGggaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5oZWlnaHQgLSB0aGUgaW1hZ2UgaGVpZ2h0IGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxldmVsPTFdIC0gdGhlIG1pcG1hcCBsZXZlbHMgc3RvcmVkIGluIHRoZSBjb21wcmVzc2VkIHRleHR1cmUsIGluY2x1ZGluZyBsZXZlbCAwLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGV2ZWxCdWZmZXJzXSAtIHRoZSBidWZmZXJzIGZvciBlYWNoIG1pcG1hcCBsZXZlbC4gYENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2VgIGNhbiBhbGxvd3MgeW91XG4gICAqICAgICAgdG8gcGFzcyBgbnVsbGAgZm9yIGBzb3VyY2VgLCBmb3IgY2FzZXMgd2hlcmUgZWFjaCBsZXZlbCBpcyBzdG9yZWQgaW4gbm9uLWNvbnRpZ3VvdXMgbWVtb3J5LlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlLCBvcHRpb25zKSwgdGhpcy5mb3JtYXQgPSBvcHRpb25zLmZvcm1hdCwgdGhpcy5sZXZlbHMgPSBvcHRpb25zLmxldmVscyB8fCAxLCB0aGlzLl93aWR0aCA9IG9wdGlvbnMud2lkdGgsIHRoaXMuX2hlaWdodCA9IG9wdGlvbnMuaGVpZ2h0LCB0aGlzLl9leHRlbnNpb24gPSBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLl9mb3JtYXRUb0V4dGVuc2lvbih0aGlzLmZvcm1hdCksIChvcHRpb25zLmxldmVsQnVmZmVycyB8fCB0aGlzLmJ1ZmZlcikgJiYgKHRoaXMuX2xldmVsQnVmZmVycyA9IG9wdGlvbnMubGV2ZWxCdWZmZXJzIHx8IENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UuX2NyZWF0ZUxldmVsQnVmZmVycyhcbiAgICAgIHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBzb3VyY2UgOiB0aGlzLmJ1ZmZlci51aW50OFZpZXcsXG4gICAgICB0aGlzLmZvcm1hdCxcbiAgICAgIHRoaXMubGV2ZWxzLFxuICAgICAgNCxcbiAgICAgIDQsXG4gICAgICAvLyBQVlJUQyBoYXMgOHg0IGJsb2NrcyBpbiAyYnBwIG1vZGVcbiAgICAgIHRoaXMud2lkdGgsXG4gICAgICB0aGlzLmhlaWdodFxuICAgICkpO1xuICB9XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcmVuZGVyZXJcbiAgICogQHBhcmFtIF90ZXh0dXJlIC0gdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIF9nbFRleHR1cmUgLSB0ZXh0dXJlIGluc3RhbmNlIGZvciB0aGlzIHdlYmdsIGNvbnRleHRcbiAgICovXG4gIHVwbG9hZChyZW5kZXJlciwgX3RleHR1cmUsIF9nbFRleHR1cmUpIHtcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdsO1xuICAgIGlmICghcmVuZGVyZXIuY29udGV4dC5leHRlbnNpb25zW3RoaXMuX2V4dGVuc2lvbl0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5fZXh0ZW5zaW9ufSB0ZXh0dXJlcyBhcmUgbm90IHN1cHBvcnRlZCBvbiB0aGUgY3VycmVudCBtYWNoaW5lYCk7XG4gICAgaWYgKCF0aGlzLl9sZXZlbEJ1ZmZlcnMpXG4gICAgICByZXR1cm4gITE7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0FMSUdOTUVOVCwgNCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSB0aGlzLmxldmVsczsgaSA8IGo7IGkrKykge1xuICAgICAgY29uc3QgeyBsZXZlbElELCBsZXZlbFdpZHRoLCBsZXZlbEhlaWdodCwgbGV2ZWxCdWZmZXIgfSA9IHRoaXMuX2xldmVsQnVmZmVyc1tpXTtcbiAgICAgIGdsLmNvbXByZXNzZWRUZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIGxldmVsSUQsIHRoaXMuZm9ybWF0LCBsZXZlbFdpZHRoLCBsZXZlbEhlaWdodCwgMCwgbGV2ZWxCdWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgb25CbG9iTG9hZGVkKCkge1xuICAgIHRoaXMuX2xldmVsQnVmZmVycyA9IENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UuX2NyZWF0ZUxldmVsQnVmZmVycyhcbiAgICAgIHRoaXMuYnVmZmVyLnVpbnQ4VmlldyxcbiAgICAgIHRoaXMuZm9ybWF0LFxuICAgICAgdGhpcy5sZXZlbHMsXG4gICAgICA0LFxuICAgICAgNCxcbiAgICAgIC8vIFBWUlRDIGhhcyA4eDQgYmxvY2tzIGluIDJicHAgbW9kZVxuICAgICAgdGhpcy53aWR0aCxcbiAgICAgIHRoaXMuaGVpZ2h0XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5ICh0byBDb250ZXh0U3lzdGVtI2V4dGVuc2lvbnMpIGZvciB0aGUgV2ViR0wgZXh0ZW5zaW9uIHN1cHBvcnRpbmcgdGhlIGNvbXByZXNzaW9uIGZvcm1hdFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gZm9ybWF0IC0gdGhlIGNvbXByZXNzaW9uIGZvcm1hdCB0byBnZXQgdGhlIGV4dGVuc2lvbiBmb3IuXG4gICAqL1xuICBzdGF0aWMgX2Zvcm1hdFRvRXh0ZW5zaW9uKGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPj0gMzM3NzYgJiYgZm9ybWF0IDw9IDMzNzc5KVxuICAgICAgcmV0dXJuIFwiczN0Y1wiO1xuICAgIGlmIChmb3JtYXQgPj0gMzc0ODggJiYgZm9ybWF0IDw9IDM3NDk3KVxuICAgICAgcmV0dXJuIFwiZXRjXCI7XG4gICAgaWYgKGZvcm1hdCA+PSAzNTg0MCAmJiBmb3JtYXQgPD0gMzU4NDMpXG4gICAgICByZXR1cm4gXCJwdnJ0Y1wiO1xuICAgIGlmIChmb3JtYXQgPj0gMzYxOTYpXG4gICAgICByZXR1cm4gXCJldGMxXCI7XG4gICAgaWYgKGZvcm1hdCA+PSAzNTk4NiAmJiBmb3JtYXQgPD0gMzQ3OTgpXG4gICAgICByZXR1cm4gXCJhdGNcIjtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIChjb21wcmVzc2VkKSB0ZXh0dXJlIGZvcm1hdCBnaXZlbiFcIik7XG4gIH1cbiAgLyoqXG4gICAqIFByZS1jcmVhdGVzIGJ1ZmZlciB2aWV3cyBmb3IgZWFjaCBtaXBtYXAgbGV2ZWxcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGJ1ZmZlciAtXG4gICAqIEBwYXJhbSBmb3JtYXQgLSBjb21wcmVzc2lvbiBmb3JtYXRzXG4gICAqIEBwYXJhbSBsZXZlbHMgLSBtaXBtYXAgbGV2ZWxzXG4gICAqIEBwYXJhbSBibG9ja1dpZHRoIC1cbiAgICogQHBhcmFtIGJsb2NrSGVpZ2h0IC1cbiAgICogQHBhcmFtIGltYWdlV2lkdGggLSB3aWR0aCBvZiB0aGUgaW1hZ2UgaW4gcGl4ZWxzXG4gICAqIEBwYXJhbSBpbWFnZUhlaWdodCAtIGhlaWdodCBvZiB0aGUgaW1hZ2UgaW4gcGl4ZWxzXG4gICAqL1xuICBzdGF0aWMgX2NyZWF0ZUxldmVsQnVmZmVycyhidWZmZXIsIGZvcm1hdCwgbGV2ZWxzLCBibG9ja1dpZHRoLCBibG9ja0hlaWdodCwgaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQpIHtcbiAgICBjb25zdCBidWZmZXJzID0gbmV3IEFycmF5KGxldmVscyk7XG4gICAgbGV0IG9mZnNldCA9IGJ1ZmZlci5ieXRlT2Zmc2V0LCBsZXZlbFdpZHRoID0gaW1hZ2VXaWR0aCwgbGV2ZWxIZWlnaHQgPSBpbWFnZUhlaWdodCwgYWxpZ25lZExldmVsV2lkdGggPSBsZXZlbFdpZHRoICsgYmxvY2tXaWR0aCAtIDEgJiB+KGJsb2NrV2lkdGggLSAxKSwgYWxpZ25lZExldmVsSGVpZ2h0ID0gbGV2ZWxIZWlnaHQgKyBibG9ja0hlaWdodCAtIDEgJiB+KGJsb2NrSGVpZ2h0IC0gMSksIGxldmVsU2l6ZSA9IGFsaWduZWRMZXZlbFdpZHRoICogYWxpZ25lZExldmVsSGVpZ2h0ICogX2NvbnN0LklOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUxbZm9ybWF0XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVsczsgaSsrKVxuICAgICAgYnVmZmVyc1tpXSA9IHtcbiAgICAgICAgbGV2ZWxJRDogaSxcbiAgICAgICAgbGV2ZWxXaWR0aDogbGV2ZWxzID4gMSA/IGxldmVsV2lkdGggOiBhbGlnbmVkTGV2ZWxXaWR0aCxcbiAgICAgICAgbGV2ZWxIZWlnaHQ6IGxldmVscyA+IDEgPyBsZXZlbEhlaWdodCA6IGFsaWduZWRMZXZlbEhlaWdodCxcbiAgICAgICAgbGV2ZWxCdWZmZXI6IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIsIG9mZnNldCwgbGV2ZWxTaXplKVxuICAgICAgfSwgb2Zmc2V0ICs9IGxldmVsU2l6ZSwgbGV2ZWxXaWR0aCA9IGxldmVsV2lkdGggPj4gMSB8fCAxLCBsZXZlbEhlaWdodCA9IGxldmVsSGVpZ2h0ID4+IDEgfHwgMSwgYWxpZ25lZExldmVsV2lkdGggPSBsZXZlbFdpZHRoICsgYmxvY2tXaWR0aCAtIDEgJiB+KGJsb2NrV2lkdGggLSAxKSwgYWxpZ25lZExldmVsSGVpZ2h0ID0gbGV2ZWxIZWlnaHQgKyBibG9ja0hlaWdodCAtIDEgJiB+KGJsb2NrSGVpZ2h0IC0gMSksIGxldmVsU2l6ZSA9IGFsaWduZWRMZXZlbFdpZHRoICogYWxpZ25lZExldmVsSGVpZ2h0ICogX2NvbnN0LklOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUxbZm9ybWF0XTtcbiAgICByZXR1cm4gYnVmZmVycztcbiAgfVxufVxuZXhwb3J0cy5Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlID0gQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBCbG9iUmVzb3VyY2UgPSByZXF1aXJlKFwiLi9CbG9iUmVzb3VyY2UuanNcIiksIENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgPSByZXF1aXJlKFwiLi9Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlLmpzXCIpO1xuZXhwb3J0cy5CbG9iUmVzb3VyY2UgPSBCbG9iUmVzb3VyY2UuQmxvYlJlc291cmNlO1xuZXhwb3J0cy5Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlID0gQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBFTlYgPSAvKiBAX19QVVJFX18gKi8gKChFTlYyKSA9PiAoRU5WMltFTlYyLldFQkdMX0xFR0FDWSA9IDBdID0gXCJXRUJHTF9MRUdBQ1lcIiwgRU5WMltFTlYyLldFQkdMID0gMV0gPSBcIldFQkdMXCIsIEVOVjJbRU5WMi5XRUJHTDIgPSAyXSA9IFwiV0VCR0wyXCIsIEVOVjIpKShFTlYgfHwge30pLCBSRU5ERVJFUl9UWVBFID0gLyogQF9fUFVSRV9fICovICgoUkVOREVSRVJfVFlQRTIpID0+IChSRU5ERVJFUl9UWVBFMltSRU5ERVJFUl9UWVBFMi5VTktOT1dOID0gMF0gPSBcIlVOS05PV05cIiwgUkVOREVSRVJfVFlQRTJbUkVOREVSRVJfVFlQRTIuV0VCR0wgPSAxXSA9IFwiV0VCR0xcIiwgUkVOREVSRVJfVFlQRTJbUkVOREVSRVJfVFlQRTIuQ0FOVkFTID0gMl0gPSBcIkNBTlZBU1wiLCBSRU5ERVJFUl9UWVBFMikpKFJFTkRFUkVSX1RZUEUgfHwge30pLCBCVUZGRVJfQklUUyA9IC8qIEBfX1BVUkVfXyAqLyAoKEJVRkZFUl9CSVRTMikgPT4gKEJVRkZFUl9CSVRTMltCVUZGRVJfQklUUzIuQ09MT1IgPSAxNjM4NF0gPSBcIkNPTE9SXCIsIEJVRkZFUl9CSVRTMltCVUZGRVJfQklUUzIuREVQVEggPSAyNTZdID0gXCJERVBUSFwiLCBCVUZGRVJfQklUUzJbQlVGRkVSX0JJVFMyLlNURU5DSUwgPSAxMDI0XSA9IFwiU1RFTkNJTFwiLCBCVUZGRVJfQklUUzIpKShCVUZGRVJfQklUUyB8fCB7fSksIEJMRU5EX01PREVTID0gLyogQF9fUFVSRV9fICovICgoQkxFTkRfTU9ERVMyKSA9PiAoQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5OT1JNQUwgPSAwXSA9IFwiTk9STUFMXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuQUREID0gMV0gPSBcIkFERFwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLk1VTFRJUExZID0gMl0gPSBcIk1VTFRJUExZXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuU0NSRUVOID0gM10gPSBcIlNDUkVFTlwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLk9WRVJMQVkgPSA0XSA9IFwiT1ZFUkxBWVwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLkRBUktFTiA9IDVdID0gXCJEQVJLRU5cIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5MSUdIVEVOID0gNl0gPSBcIkxJR0hURU5cIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5DT0xPUl9ET0RHRSA9IDddID0gXCJDT0xPUl9ET0RHRVwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLkNPTE9SX0JVUk4gPSA4XSA9IFwiQ09MT1JfQlVSTlwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLkhBUkRfTElHSFQgPSA5XSA9IFwiSEFSRF9MSUdIVFwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLlNPRlRfTElHSFQgPSAxMF0gPSBcIlNPRlRfTElHSFRcIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5ESUZGRVJFTkNFID0gMTFdID0gXCJESUZGRVJFTkNFXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuRVhDTFVTSU9OID0gMTJdID0gXCJFWENMVVNJT05cIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5IVUUgPSAxM10gPSBcIkhVRVwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLlNBVFVSQVRJT04gPSAxNF0gPSBcIlNBVFVSQVRJT05cIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5DT0xPUiA9IDE1XSA9IFwiQ09MT1JcIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5MVU1JTk9TSVRZID0gMTZdID0gXCJMVU1JTk9TSVRZXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuTk9STUFMX05QTSA9IDE3XSA9IFwiTk9STUFMX05QTVwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLkFERF9OUE0gPSAxOF0gPSBcIkFERF9OUE1cIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5TQ1JFRU5fTlBNID0gMTldID0gXCJTQ1JFRU5fTlBNXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuTk9ORSA9IDIwXSA9IFwiTk9ORVwiLCBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyLlNSQ19PVkVSID0gMF0gPSBcIlNSQ19PVkVSXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuU1JDX0lOID0gMjFdID0gXCJTUkNfSU5cIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5TUkNfT1VUID0gMjJdID0gXCJTUkNfT1VUXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuU1JDX0FUT1AgPSAyM10gPSBcIlNSQ19BVE9QXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuRFNUX09WRVIgPSAyNF0gPSBcIkRTVF9PVkVSXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuRFNUX0lOID0gMjVdID0gXCJEU1RfSU5cIiwgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMi5EU1RfT1VUID0gMjZdID0gXCJEU1RfT1VUXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuRFNUX0FUT1AgPSAyN10gPSBcIkRTVF9BVE9QXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuRVJBU0UgPSAyNl0gPSBcIkVSQVNFXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuU1VCVFJBQ1QgPSAyOF0gPSBcIlNVQlRSQUNUXCIsIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzIuWE9SID0gMjldID0gXCJYT1JcIiwgQkxFTkRfTU9ERVMyKSkoQkxFTkRfTU9ERVMgfHwge30pLCBEUkFXX01PREVTID0gLyogQF9fUFVSRV9fICovICgoRFJBV19NT0RFUzIpID0+IChEUkFXX01PREVTMltEUkFXX01PREVTMi5QT0lOVFMgPSAwXSA9IFwiUE9JTlRTXCIsIERSQVdfTU9ERVMyW0RSQVdfTU9ERVMyLkxJTkVTID0gMV0gPSBcIkxJTkVTXCIsIERSQVdfTU9ERVMyW0RSQVdfTU9ERVMyLkxJTkVfTE9PUCA9IDJdID0gXCJMSU5FX0xPT1BcIiwgRFJBV19NT0RFUzJbRFJBV19NT0RFUzIuTElORV9TVFJJUCA9IDNdID0gXCJMSU5FX1NUUklQXCIsIERSQVdfTU9ERVMyW0RSQVdfTU9ERVMyLlRSSUFOR0xFUyA9IDRdID0gXCJUUklBTkdMRVNcIiwgRFJBV19NT0RFUzJbRFJBV19NT0RFUzIuVFJJQU5HTEVfU1RSSVAgPSA1XSA9IFwiVFJJQU5HTEVfU1RSSVBcIiwgRFJBV19NT0RFUzJbRFJBV19NT0RFUzIuVFJJQU5HTEVfRkFOID0gNl0gPSBcIlRSSUFOR0xFX0ZBTlwiLCBEUkFXX01PREVTMikpKERSQVdfTU9ERVMgfHwge30pLCBGT1JNQVRTID0gLyogQF9fUFVSRV9fICovICgoRk9STUFUUzIpID0+IChGT1JNQVRTMltGT1JNQVRTMi5SR0JBID0gNjQwOF0gPSBcIlJHQkFcIiwgRk9STUFUUzJbRk9STUFUUzIuUkdCID0gNjQwN10gPSBcIlJHQlwiLCBGT1JNQVRTMltGT1JNQVRTMi5SRyA9IDMzMzE5XSA9IFwiUkdcIiwgRk9STUFUUzJbRk9STUFUUzIuUkVEID0gNjQwM10gPSBcIlJFRFwiLCBGT1JNQVRTMltGT1JNQVRTMi5SR0JBX0lOVEVHRVIgPSAzNjI0OV0gPSBcIlJHQkFfSU5URUdFUlwiLCBGT1JNQVRTMltGT1JNQVRTMi5SR0JfSU5URUdFUiA9IDM2MjQ4XSA9IFwiUkdCX0lOVEVHRVJcIiwgRk9STUFUUzJbRk9STUFUUzIuUkdfSU5URUdFUiA9IDMzMzIwXSA9IFwiUkdfSU5URUdFUlwiLCBGT1JNQVRTMltGT1JNQVRTMi5SRURfSU5URUdFUiA9IDM2MjQ0XSA9IFwiUkVEX0lOVEVHRVJcIiwgRk9STUFUUzJbRk9STUFUUzIuQUxQSEEgPSA2NDA2XSA9IFwiQUxQSEFcIiwgRk9STUFUUzJbRk9STUFUUzIuTFVNSU5BTkNFID0gNjQwOV0gPSBcIkxVTUlOQU5DRVwiLCBGT1JNQVRTMltGT1JNQVRTMi5MVU1JTkFOQ0VfQUxQSEEgPSA2NDEwXSA9IFwiTFVNSU5BTkNFX0FMUEhBXCIsIEZPUk1BVFMyW0ZPUk1BVFMyLkRFUFRIX0NPTVBPTkVOVCA9IDY0MDJdID0gXCJERVBUSF9DT01QT05FTlRcIiwgRk9STUFUUzJbRk9STUFUUzIuREVQVEhfU1RFTkNJTCA9IDM0MDQxXSA9IFwiREVQVEhfU1RFTkNJTFwiLCBGT1JNQVRTMikpKEZPUk1BVFMgfHwge30pLCBUQVJHRVRTID0gLyogQF9fUFVSRV9fICovICgoVEFSR0VUUzIpID0+IChUQVJHRVRTMltUQVJHRVRTMi5URVhUVVJFXzJEID0gMzU1M10gPSBcIlRFWFRVUkVfMkRcIiwgVEFSR0VUUzJbVEFSR0VUUzIuVEVYVFVSRV9DVUJFX01BUCA9IDM0MDY3XSA9IFwiVEVYVFVSRV9DVUJFX01BUFwiLCBUQVJHRVRTMltUQVJHRVRTMi5URVhUVVJFXzJEX0FSUkFZID0gMzU4NjZdID0gXCJURVhUVVJFXzJEX0FSUkFZXCIsIFRBUkdFVFMyW1RBUkdFVFMyLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCA9IDM0MDY5XSA9IFwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YXCIsIFRBUkdFVFMyW1RBUkdFVFMyLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWCA9IDM0MDcwXSA9IFwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YXCIsIFRBUkdFVFMyW1RBUkdFVFMyLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSA9IDM0MDcxXSA9IFwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZXCIsIFRBUkdFVFMyW1RBUkdFVFMyLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWSA9IDM0MDcyXSA9IFwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZXCIsIFRBUkdFVFMyW1RBUkdFVFMyLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWiA9IDM0MDczXSA9IFwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aXCIsIFRBUkdFVFMyW1RBUkdFVFMyLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWiA9IDM0MDc0XSA9IFwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aXCIsIFRBUkdFVFMyKSkoVEFSR0VUUyB8fCB7fSksIFRZUEVTID0gLyogQF9fUFVSRV9fICovICgoVFlQRVMyKSA9PiAoVFlQRVMyW1RZUEVTMi5VTlNJR05FRF9CWVRFID0gNTEyMV0gPSBcIlVOU0lHTkVEX0JZVEVcIiwgVFlQRVMyW1RZUEVTMi5VTlNJR05FRF9TSE9SVCA9IDUxMjNdID0gXCJVTlNJR05FRF9TSE9SVFwiLCBUWVBFUzJbVFlQRVMyLlVOU0lHTkVEX1NIT1JUXzVfNl81ID0gMzM2MzVdID0gXCJVTlNJR05FRF9TSE9SVF81XzZfNVwiLCBUWVBFUzJbVFlQRVMyLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQgPSAzMjgxOV0gPSBcIlVOU0lHTkVEX1NIT1JUXzRfNF80XzRcIiwgVFlQRVMyW1RZUEVTMi5VTlNJR05FRF9TSE9SVF81XzVfNV8xID0gMzI4MjBdID0gXCJVTlNJR05FRF9TSE9SVF81XzVfNV8xXCIsIFRZUEVTMltUWVBFUzIuVU5TSUdORURfSU5UID0gNTEyNV0gPSBcIlVOU0lHTkVEX0lOVFwiLCBUWVBFUzJbVFlQRVMyLlVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVYgPSAzNTg5OV0gPSBcIlVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVZcIiwgVFlQRVMyW1RZUEVTMi5VTlNJR05FRF9JTlRfMl8xMF8xMF8xMF9SRVYgPSAzMzY0MF0gPSBcIlVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVlwiLCBUWVBFUzJbVFlQRVMyLlVOU0lHTkVEX0lOVF8yNF84ID0gMzQwNDJdID0gXCJVTlNJR05FRF9JTlRfMjRfOFwiLCBUWVBFUzJbVFlQRVMyLlVOU0lHTkVEX0lOVF81XzlfOV85X1JFViA9IDM1OTAyXSA9IFwiVU5TSUdORURfSU5UXzVfOV85XzlfUkVWXCIsIFRZUEVTMltUWVBFUzIuQllURSA9IDUxMjBdID0gXCJCWVRFXCIsIFRZUEVTMltUWVBFUzIuU0hPUlQgPSA1MTIyXSA9IFwiU0hPUlRcIiwgVFlQRVMyW1RZUEVTMi5JTlQgPSA1MTI0XSA9IFwiSU5UXCIsIFRZUEVTMltUWVBFUzIuRkxPQVQgPSA1MTI2XSA9IFwiRkxPQVRcIiwgVFlQRVMyW1RZUEVTMi5GTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVYgPSAzNjI2OV0gPSBcIkZMT0FUXzMyX1VOU0lHTkVEX0lOVF8yNF84X1JFVlwiLCBUWVBFUzJbVFlQRVMyLkhBTEZfRkxPQVQgPSAzNjE5M10gPSBcIkhBTEZfRkxPQVRcIiwgVFlQRVMyKSkoVFlQRVMgfHwge30pLCBTQU1QTEVSX1RZUEVTID0gLyogQF9fUFVSRV9fICovICgoU0FNUExFUl9UWVBFUzIpID0+IChTQU1QTEVSX1RZUEVTMltTQU1QTEVSX1RZUEVTMi5GTE9BVCA9IDBdID0gXCJGTE9BVFwiLCBTQU1QTEVSX1RZUEVTMltTQU1QTEVSX1RZUEVTMi5JTlQgPSAxXSA9IFwiSU5UXCIsIFNBTVBMRVJfVFlQRVMyW1NBTVBMRVJfVFlQRVMyLlVJTlQgPSAyXSA9IFwiVUlOVFwiLCBTQU1QTEVSX1RZUEVTMikpKFNBTVBMRVJfVFlQRVMgfHwge30pLCBTQ0FMRV9NT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKFNDQUxFX01PREVTMikgPT4gKFNDQUxFX01PREVTMltTQ0FMRV9NT0RFUzIuTkVBUkVTVCA9IDBdID0gXCJORUFSRVNUXCIsIFNDQUxFX01PREVTMltTQ0FMRV9NT0RFUzIuTElORUFSID0gMV0gPSBcIkxJTkVBUlwiLCBTQ0FMRV9NT0RFUzIpKShTQ0FMRV9NT0RFUyB8fCB7fSksIFdSQVBfTU9ERVMgPSAvKiBAX19QVVJFX18gKi8gKChXUkFQX01PREVTMikgPT4gKFdSQVBfTU9ERVMyW1dSQVBfTU9ERVMyLkNMQU1QID0gMzMwNzFdID0gXCJDTEFNUFwiLCBXUkFQX01PREVTMltXUkFQX01PREVTMi5SRVBFQVQgPSAxMDQ5N10gPSBcIlJFUEVBVFwiLCBXUkFQX01PREVTMltXUkFQX01PREVTMi5NSVJST1JFRF9SRVBFQVQgPSAzMzY0OF0gPSBcIk1JUlJPUkVEX1JFUEVBVFwiLCBXUkFQX01PREVTMikpKFdSQVBfTU9ERVMgfHwge30pLCBNSVBNQVBfTU9ERVMgPSAvKiBAX19QVVJFX18gKi8gKChNSVBNQVBfTU9ERVMyKSA9PiAoTUlQTUFQX01PREVTMltNSVBNQVBfTU9ERVMyLk9GRiA9IDBdID0gXCJPRkZcIiwgTUlQTUFQX01PREVTMltNSVBNQVBfTU9ERVMyLlBPVzIgPSAxXSA9IFwiUE9XMlwiLCBNSVBNQVBfTU9ERVMyW01JUE1BUF9NT0RFUzIuT04gPSAyXSA9IFwiT05cIiwgTUlQTUFQX01PREVTMltNSVBNQVBfTU9ERVMyLk9OX01BTlVBTCA9IDNdID0gXCJPTl9NQU5VQUxcIiwgTUlQTUFQX01PREVTMikpKE1JUE1BUF9NT0RFUyB8fCB7fSksIEFMUEhBX01PREVTID0gLyogQF9fUFVSRV9fICovICgoQUxQSEFfTU9ERVMyKSA9PiAoQUxQSEFfTU9ERVMyW0FMUEhBX01PREVTMi5OUE0gPSAwXSA9IFwiTlBNXCIsIEFMUEhBX01PREVTMltBTFBIQV9NT0RFUzIuVU5QQUNLID0gMV0gPSBcIlVOUEFDS1wiLCBBTFBIQV9NT0RFUzJbQUxQSEFfTU9ERVMyLlBNQSA9IDJdID0gXCJQTUFcIiwgQUxQSEFfTU9ERVMyW0FMUEhBX01PREVTMi5OT19QUkVNVUxUSVBMSUVEX0FMUEhBID0gMF0gPSBcIk5PX1BSRU1VTFRJUExJRURfQUxQSEFcIiwgQUxQSEFfTU9ERVMyW0FMUEhBX01PREVTMi5QUkVNVUxUSVBMWV9PTl9VUExPQUQgPSAxXSA9IFwiUFJFTVVMVElQTFlfT05fVVBMT0FEXCIsIEFMUEhBX01PREVTMltBTFBIQV9NT0RFUzIuUFJFTVVMVElQTElFRF9BTFBIQSA9IDJdID0gXCJQUkVNVUxUSVBMSUVEX0FMUEhBXCIsIEFMUEhBX01PREVTMikpKEFMUEhBX01PREVTIHx8IHt9KSwgQ0xFQVJfTU9ERVMgPSAvKiBAX19QVVJFX18gKi8gKChDTEVBUl9NT0RFUzIpID0+IChDTEVBUl9NT0RFUzJbQ0xFQVJfTU9ERVMyLk5PID0gMF0gPSBcIk5PXCIsIENMRUFSX01PREVTMltDTEVBUl9NT0RFUzIuWUVTID0gMV0gPSBcIllFU1wiLCBDTEVBUl9NT0RFUzJbQ0xFQVJfTU9ERVMyLkFVVE8gPSAyXSA9IFwiQVVUT1wiLCBDTEVBUl9NT0RFUzJbQ0xFQVJfTU9ERVMyLkJMRU5EID0gMF0gPSBcIkJMRU5EXCIsIENMRUFSX01PREVTMltDTEVBUl9NT0RFUzIuQ0xFQVIgPSAxXSA9IFwiQ0xFQVJcIiwgQ0xFQVJfTU9ERVMyW0NMRUFSX01PREVTMi5CTElUID0gMl0gPSBcIkJMSVRcIiwgQ0xFQVJfTU9ERVMyKSkoQ0xFQVJfTU9ERVMgfHwge30pLCBHQ19NT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKEdDX01PREVTMikgPT4gKEdDX01PREVTMltHQ19NT0RFUzIuQVVUTyA9IDBdID0gXCJBVVRPXCIsIEdDX01PREVTMltHQ19NT0RFUzIuTUFOVUFMID0gMV0gPSBcIk1BTlVBTFwiLCBHQ19NT0RFUzIpKShHQ19NT0RFUyB8fCB7fSksIFBSRUNJU0lPTiA9IC8qIEBfX1BVUkVfXyAqLyAoKFBSRUNJU0lPTjIpID0+IChQUkVDSVNJT04yLkxPVyA9IFwibG93cFwiLCBQUkVDSVNJT04yLk1FRElVTSA9IFwibWVkaXVtcFwiLCBQUkVDSVNJT04yLkhJR0ggPSBcImhpZ2hwXCIsIFBSRUNJU0lPTjIpKShQUkVDSVNJT04gfHwge30pLCBNQVNLX1RZUEVTID0gLyogQF9fUFVSRV9fICovICgoTUFTS19UWVBFUzIpID0+IChNQVNLX1RZUEVTMltNQVNLX1RZUEVTMi5OT05FID0gMF0gPSBcIk5PTkVcIiwgTUFTS19UWVBFUzJbTUFTS19UWVBFUzIuU0NJU1NPUiA9IDFdID0gXCJTQ0lTU09SXCIsIE1BU0tfVFlQRVMyW01BU0tfVFlQRVMyLlNURU5DSUwgPSAyXSA9IFwiU1RFTkNJTFwiLCBNQVNLX1RZUEVTMltNQVNLX1RZUEVTMi5TUFJJVEUgPSAzXSA9IFwiU1BSSVRFXCIsIE1BU0tfVFlQRVMyW01BU0tfVFlQRVMyLkNPTE9SID0gNF0gPSBcIkNPTE9SXCIsIE1BU0tfVFlQRVMyKSkoTUFTS19UWVBFUyB8fCB7fSksIENPTE9SX01BU0tfQklUUyA9IC8qIEBfX1BVUkVfXyAqLyAoKENPTE9SX01BU0tfQklUUzIpID0+IChDT0xPUl9NQVNLX0JJVFMyW0NPTE9SX01BU0tfQklUUzIuUkVEID0gMV0gPSBcIlJFRFwiLCBDT0xPUl9NQVNLX0JJVFMyW0NPTE9SX01BU0tfQklUUzIuR1JFRU4gPSAyXSA9IFwiR1JFRU5cIiwgQ09MT1JfTUFTS19CSVRTMltDT0xPUl9NQVNLX0JJVFMyLkJMVUUgPSA0XSA9IFwiQkxVRVwiLCBDT0xPUl9NQVNLX0JJVFMyW0NPTE9SX01BU0tfQklUUzIuQUxQSEEgPSA4XSA9IFwiQUxQSEFcIiwgQ09MT1JfTUFTS19CSVRTMikpKENPTE9SX01BU0tfQklUUyB8fCB7fSksIE1TQUFfUVVBTElUWSA9IC8qIEBfX1BVUkVfXyAqLyAoKE1TQUFfUVVBTElUWTIpID0+IChNU0FBX1FVQUxJVFkyW01TQUFfUVVBTElUWTIuTk9ORSA9IDBdID0gXCJOT05FXCIsIE1TQUFfUVVBTElUWTJbTVNBQV9RVUFMSVRZMi5MT1cgPSAyXSA9IFwiTE9XXCIsIE1TQUFfUVVBTElUWTJbTVNBQV9RVUFMSVRZMi5NRURJVU0gPSA0XSA9IFwiTUVESVVNXCIsIE1TQUFfUVVBTElUWTJbTVNBQV9RVUFMSVRZMi5ISUdIID0gOF0gPSBcIkhJR0hcIiwgTVNBQV9RVUFMSVRZMikpKE1TQUFfUVVBTElUWSB8fCB7fSksIEJVRkZFUl9UWVBFID0gLyogQF9fUFVSRV9fICovICgoQlVGRkVSX1RZUEUyKSA9PiAoQlVGRkVSX1RZUEUyW0JVRkZFUl9UWVBFMi5FTEVNRU5UX0FSUkFZX0JVRkZFUiA9IDM0OTYzXSA9IFwiRUxFTUVOVF9BUlJBWV9CVUZGRVJcIiwgQlVGRkVSX1RZUEUyW0JVRkZFUl9UWVBFMi5BUlJBWV9CVUZGRVIgPSAzNDk2Ml0gPSBcIkFSUkFZX0JVRkZFUlwiLCBCVUZGRVJfVFlQRTJbQlVGRkVSX1RZUEUyLlVOSUZPUk1fQlVGRkVSID0gMzUzNDVdID0gXCJVTklGT1JNX0JVRkZFUlwiLCBCVUZGRVJfVFlQRTIpKShCVUZGRVJfVFlQRSB8fCB7fSk7XG5leHBvcnRzLkFMUEhBX01PREVTID0gQUxQSEFfTU9ERVM7XG5leHBvcnRzLkJMRU5EX01PREVTID0gQkxFTkRfTU9ERVM7XG5leHBvcnRzLkJVRkZFUl9CSVRTID0gQlVGRkVSX0JJVFM7XG5leHBvcnRzLkJVRkZFUl9UWVBFID0gQlVGRkVSX1RZUEU7XG5leHBvcnRzLkNMRUFSX01PREVTID0gQ0xFQVJfTU9ERVM7XG5leHBvcnRzLkNPTE9SX01BU0tfQklUUyA9IENPTE9SX01BU0tfQklUUztcbmV4cG9ydHMuRFJBV19NT0RFUyA9IERSQVdfTU9ERVM7XG5leHBvcnRzLkVOViA9IEVOVjtcbmV4cG9ydHMuRk9STUFUUyA9IEZPUk1BVFM7XG5leHBvcnRzLkdDX01PREVTID0gR0NfTU9ERVM7XG5leHBvcnRzLk1BU0tfVFlQRVMgPSBNQVNLX1RZUEVTO1xuZXhwb3J0cy5NSVBNQVBfTU9ERVMgPSBNSVBNQVBfTU9ERVM7XG5leHBvcnRzLk1TQUFfUVVBTElUWSA9IE1TQUFfUVVBTElUWTtcbmV4cG9ydHMuUFJFQ0lTSU9OID0gUFJFQ0lTSU9OO1xuZXhwb3J0cy5SRU5ERVJFUl9UWVBFID0gUkVOREVSRVJfVFlQRTtcbmV4cG9ydHMuU0FNUExFUl9UWVBFUyA9IFNBTVBMRVJfVFlQRVM7XG5leHBvcnRzLlNDQUxFX01PREVTID0gU0NBTEVfTU9ERVM7XG5leHBvcnRzLlRBUkdFVFMgPSBUQVJHRVRTO1xuZXhwb3J0cy5UWVBFUyA9IFRZUEVTO1xuZXhwb3J0cy5XUkFQX01PREVTID0gV1JBUF9NT0RFUztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JUmVuZGVyZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiQHBpeGkvY29uc3RhbnRzXCIpLCBleHRlbnNpb25zID0gcmVxdWlyZShcIkBwaXhpL2V4dGVuc2lvbnNcIiksIG1hdGggPSByZXF1aXJlKFwiQHBpeGkvbWF0aFwiKSwgc2V0dGluZ3MgPSByZXF1aXJlKFwiQHBpeGkvc2V0dGluZ3NcIiksIHV0aWxzID0gcmVxdWlyZShcIkBwaXhpL3V0aWxzXCIpLCBVbmlmb3JtR3JvdXAgPSByZXF1aXJlKFwiLi9zaGFkZXIvVW5pZm9ybUdyb3VwLmpzXCIpLCBTeXN0ZW1NYW5hZ2VyID0gcmVxdWlyZShcIi4vc3lzdGVtL1N5c3RlbU1hbmFnZXIuanNcIik7XG5jb25zdCBfUmVuZGVyZXIgPSBjbGFzcyBfUmVuZGVyZXIyIGV4dGVuZHMgU3lzdGVtTWFuYWdlci5TeXN0ZW1NYW5hZ2VyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5JUmVuZGVyZXJPcHRpb25zfSBbb3B0aW9uc10gLSBTZWUge0BsaW5rIFBJWEkuc2V0dGluZ3MuUkVOREVSX09QVElPTlN9IGZvciBkZWZhdWx0cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpLCB0aGlzLnR5cGUgPSBjb25zdGFudHMuUkVOREVSRVJfVFlQRS5XRUJHTCwgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzLnNldHRpbmdzLlJFTkRFUl9PUFRJT05TLCBvcHRpb25zKSwgdGhpcy5nbCA9IG51bGwsIHRoaXMuQ09OVEVYVF9VSUQgPSAwLCB0aGlzLmdsb2JhbFVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cC5Vbmlmb3JtR3JvdXAoe1xuICAgICAgcHJvamVjdGlvbk1hdHJpeDogbmV3IG1hdGguTWF0cml4KClcbiAgICB9LCAhMCk7XG4gICAgY29uc3Qgc3lzdGVtQ29uZmlnID0ge1xuICAgICAgcnVubmVyczogW1xuICAgICAgICBcImluaXRcIixcbiAgICAgICAgXCJkZXN0cm95XCIsXG4gICAgICAgIFwiY29udGV4dENoYW5nZVwiLFxuICAgICAgICBcInJlc29sdXRpb25DaGFuZ2VcIixcbiAgICAgICAgXCJyZXNldFwiLFxuICAgICAgICBcInVwZGF0ZVwiLFxuICAgICAgICBcInBvc3RyZW5kZXJcIixcbiAgICAgICAgXCJwcmVyZW5kZXJcIixcbiAgICAgICAgXCJyZXNpemVcIlxuICAgICAgXSxcbiAgICAgIHN5c3RlbXM6IF9SZW5kZXJlcjIuX19zeXN0ZW1zLFxuICAgICAgcHJpb3JpdHk6IFtcbiAgICAgICAgXCJfdmlld1wiLFxuICAgICAgICBcInRleHR1cmVHZW5lcmF0b3JcIixcbiAgICAgICAgXCJiYWNrZ3JvdW5kXCIsXG4gICAgICAgIFwiX3BsdWdpblwiLFxuICAgICAgICBcInN0YXJ0dXBcIixcbiAgICAgICAgLy8gbG93IGxldmVsIFdlYkdMIHN5c3RlbXNcbiAgICAgICAgXCJjb250ZXh0XCIsXG4gICAgICAgIFwic3RhdGVcIixcbiAgICAgICAgXCJ0ZXh0dXJlXCIsXG4gICAgICAgIFwiYnVmZmVyXCIsXG4gICAgICAgIFwiZ2VvbWV0cnlcIixcbiAgICAgICAgXCJmcmFtZWJ1ZmZlclwiLFxuICAgICAgICBcInRyYW5zZm9ybUZlZWRiYWNrXCIsXG4gICAgICAgIC8vIGhpZ2ggbGV2ZWwgcGl4aSBzcGVjaWZpYyByZW5kZXJpbmdcbiAgICAgICAgXCJtYXNrXCIsXG4gICAgICAgIFwic2Npc3NvclwiLFxuICAgICAgICBcInN0ZW5jaWxcIixcbiAgICAgICAgXCJwcm9qZWN0aW9uXCIsXG4gICAgICAgIFwidGV4dHVyZUdDXCIsXG4gICAgICAgIFwiZmlsdGVyXCIsXG4gICAgICAgIFwicmVuZGVyVGV4dHVyZVwiLFxuICAgICAgICBcImJhdGNoXCIsXG4gICAgICAgIFwib2JqZWN0UmVuZGVyZXJcIixcbiAgICAgICAgXCJfbXVsdGlzYW1wbGVcIlxuICAgICAgXVxuICAgIH07XG4gICAgdGhpcy5zZXR1cChzeXN0ZW1Db25maWcpLCBcInVzZUNvbnRleHRBbHBoYVwiIGluIG9wdGlvbnMgJiYgKHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJvcHRpb25zLnVzZUNvbnRleHRBbHBoYSBpcyBkZXByZWNhdGVkLCB1c2Ugb3B0aW9ucy5wcmVtdWx0aXBsaWVkQWxwaGEgYW5kIG9wdGlvbnMuYmFja2dyb3VuZEFscGhhIGluc3RlYWRcIiksIG9wdGlvbnMucHJlbXVsdGlwbGllZEFscGhhID0gb3B0aW9ucy51c2VDb250ZXh0QWxwaGEgJiYgb3B0aW9ucy51c2VDb250ZXh0QWxwaGEgIT09IFwibm90TXVsdGlwbGllZFwiLCBvcHRpb25zLmJhY2tncm91bmRBbHBoYSA9IG9wdGlvbnMudXNlQ29udGV4dEFscGhhID09PSAhMSA/IDEgOiBvcHRpb25zLmJhY2tncm91bmRBbHBoYSksIHRoaXMuX3BsdWdpbi5yZW5kZXJlclBsdWdpbnMgPSBfUmVuZGVyZXIyLl9fcGx1Z2lucywgdGhpcy5vcHRpb25zID0gb3B0aW9ucywgdGhpcy5zdGFydHVwLnJ1bih0aGlzLm9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgcmVuZGVyZXIgaWYgV2ViR0wgaXMgYXZhaWxhYmxlLiBPdmVycmlkZWFibGVcbiAgICogYnkgdGhlICoqQHBpeGkvY2FudmFzLXJlbmRlcmVyKiogcGFja2FnZSB0byBhbGxvdyBmYWxsYmFjay5cbiAgICogdGhyb3dzIGVycm9yIGlmIFdlYkdMIGlzIG5vdCBhdmFpbGFibGUuXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgdGVzdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnM/LmZvcmNlQ2FudmFzID8gITEgOiB1dGlscy5pc1dlYkdMU3VwcG9ydGVkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBpdHMgV2ViR0wgdmlldy5cbiAgICogQHBhcmFtIGRpc3BsYXlPYmplY3QgLSBUaGUgb2JqZWN0IHRvIGJlIHJlbmRlcmVkLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gT2JqZWN0IHRvIHVzZSBmb3IgcmVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBbb3B0aW9ucy5yZW5kZXJUZXh0dXJlXSAtIFRoZSByZW5kZXIgdGV4dHVyZSB0byByZW5kZXIgdG8uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xlYXI9dHJ1ZV0gLSBTaG91bGQgdGhlIGNhbnZhcyBiZSBjbGVhcmVkIGJlZm9yZSB0aGUgbmV3IHJlbmRlci5cbiAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gW29wdGlvbnMudHJhbnNmb3JtXSAtIEEgdHJhbnNmb3JtIHRvIGFwcGx5IHRvIHRoZSByZW5kZXIgdGV4dHVyZSBiZWZvcmUgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBVcGRhdGVUcmFuc2Zvcm09ZmFsc2VdIC0gU2hvdWxkIHdlIHNraXAgdGhlIHVwZGF0ZSB0cmFuc2Zvcm0gcGFzcz9cbiAgICovXG4gIHJlbmRlcihkaXNwbGF5T2JqZWN0LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vYmplY3RSZW5kZXJlci5yZW5kZXIoZGlzcGxheU9iamVjdCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIFdlYkdMIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gZGVzaXJlZFNjcmVlbldpZHRoIC0gVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIHNjcmVlbi5cbiAgICogQHBhcmFtIGRlc2lyZWRTY3JlZW5IZWlnaHQgLSBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIHNjcmVlbi5cbiAgICovXG4gIHJlc2l6ZShkZXNpcmVkU2NyZWVuV2lkdGgsIGRlc2lyZWRTY3JlZW5IZWlnaHQpIHtcbiAgICB0aGlzLl92aWV3LnJlc2l6ZVZpZXcoZGVzaXJlZFNjcmVlbldpZHRoLCBkZXNpcmVkU2NyZWVuSGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoZSBXZWJHTCBzdGF0ZSBzbyB5b3UgY2FuIHJlbmRlciB0aGluZ3MgaG93ZXZlciB5b3UgZmFuY3khXG4gICAqIEByZXR1cm5zIFJldHVybnMgaXRzZWxmLlxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVubmVycy5yZXNldC5lbWl0KCksIHRoaXM7XG4gIH1cbiAgLyoqIENsZWFyIHRoZSBmcmFtZSBidWZmZXIuICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMucmVuZGVyVGV4dHVyZS5iaW5kKCksIHRoaXMucmVuZGVyVGV4dHVyZS5jbGVhcigpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgcmVuZGVyZXIgKGV2ZW50IGxpc3RlbmVycywgc3ByaXRlYmF0Y2gsIGV0Yy4uLilcbiAgICogQHBhcmFtIFtyZW1vdmVWaWV3PWZhbHNlXSAtIFJlbW92ZXMgdGhlIENhbnZhcyBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAgICogIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpanMvaXNzdWVzLzIyMzNcbiAgICovXG4gIGRlc3Ryb3kocmVtb3ZlVmlldyA9ICExKSB7XG4gICAgdGhpcy5ydW5uZXJzLmRlc3Ryb3kuaXRlbXMucmV2ZXJzZSgpLCB0aGlzLmVtaXRXaXRoQ3VzdG9tT3B0aW9ucyh0aGlzLnJ1bm5lcnMuZGVzdHJveSwge1xuICAgICAgX3ZpZXc6IHJlbW92ZVZpZXdcbiAgICB9KSwgc3VwZXIuZGVzdHJveSgpO1xuICB9XG4gIC8qKiBDb2xsZWN0aW9uIG9mIHBsdWdpbnMgKi9cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdWdpbi5wbHVnaW5zO1xuICB9XG4gIC8qKiBUaGUgbnVtYmVyIG9mIG1zYWEgc2FtcGxlcyBvZiB0aGUgY2FudmFzLiAqL1xuICBnZXQgbXVsdGlzYW1wbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX211bHRpc2FtcGxlLm11bHRpc2FtcGxlO1xuICB9XG4gIC8qKlxuICAgKiBTYW1lIGFzIHZpZXcud2lkdGgsIGFjdHVhbCBudW1iZXIgb2YgcGl4ZWxzIGluIHRoZSBjYW52YXMgYnkgaG9yaXpvbnRhbC5cbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlZmF1bHQgODAwXG4gICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcuZWxlbWVudC53aWR0aDtcbiAgfVxuICAvKipcbiAgICogU2FtZSBhcyB2aWV3LmhlaWdodCwgYWN0dWFsIG51bWJlciBvZiBwaXhlbHMgaW4gdGhlIGNhbnZhcyBieSB2ZXJ0aWNhbC5cbiAgICogQGRlZmF1bHQgNjAwXG4gICAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3LmVsZW1lbnQuaGVpZ2h0O1xuICB9XG4gIC8qKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIuICovXG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3LnJlc29sdXRpb247XG4gIH1cbiAgc2V0IHJlc29sdXRpb24odmFsdWUpIHtcbiAgICB0aGlzLl92aWV3LnJlc29sdXRpb24gPSB2YWx1ZSwgdGhpcy5ydW5uZXJzLnJlc29sdXRpb25DaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gIH1cbiAgLyoqIFdoZXRoZXIgQ1NTIGRpbWVuc2lvbnMgb2YgY2FudmFzIHZpZXcgc2hvdWxkIGJlIHJlc2l6ZWQgdG8gc2NyZWVuIGRpbWVuc2lvbnMgYXV0b21hdGljYWxseS4gKi9cbiAgZ2V0IGF1dG9EZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3LmF1dG9EZW5zaXR5O1xuICB9XG4gIC8qKiBUaGUgY2FudmFzIGVsZW1lbnQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHRvLiovXG4gIGdldCB2aWV3KCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3LmVsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIE1lYXN1cmVtZW50cyBvZiB0aGUgc2NyZWVuLiAoMCwgMCwgc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCkuXG4gICAqXG4gICAqIEl0cyBzYWZlIHRvIHVzZSBhcyBmaWx0ZXJBcmVhIG9yIGhpdEFyZWEgZm9yIHRoZSB3aG9sZSBzdGFnZS5cbiAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAqL1xuICBnZXQgc2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3LnNjcmVlbjtcbiAgfVxuICAvKiogdGhlIGxhc3Qgb2JqZWN0IHJlbmRlcmVkIGJ5IHRoZSByZW5kZXJlci4gVXNlZnVsIGZvciBvdGhlciBwbHVnaW5zIGxpa2UgaW50ZXJhY3Rpb24gbWFuYWdlcnMgKi9cbiAgZ2V0IGxhc3RPYmplY3RSZW5kZXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3RSZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQ7XG4gIH1cbiAgLyoqIEZsYWcgaWYgd2UgYXJlIHJlbmRlcmluZyB0byB0aGUgc2NyZWVuIHZzIHJlbmRlclRleHR1cmUgKi9cbiAgZ2V0IHJlbmRlcmluZ1RvU2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdFJlbmRlcmVyLnJlbmRlcmluZ1RvU2NyZWVuO1xuICB9XG4gIC8qKiBXaGVuIGxvZ2dpbmcgUGl4aSB0byB0aGUgY29uc29sZSwgdGhpcyBpcyB0aGUgbmFtZSB3ZSB3aWxsIHNob3cgKi9cbiAgZ2V0IHJlbmRlcmVyTG9nSWQoKSB7XG4gICAgcmV0dXJuIGBXZWJHTCAke3RoaXMuY29udGV4dC53ZWJHTFZlcnNpb259YDtcbiAgfVxuICAvKipcbiAgICogVGhpcyBzZXRzIHdlYXRoZXIgdGhlIHNjcmVlbiBpcyB0b3RhbGx5IGNsZWFyZWQgYmV0d2VlbiBlYWNoIGZyYW1lIHdpdGh0aGUgYmFja2dyb3VuZCBjb2xvciBhbmQgYWxwaGFcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4wLjBcbiAgICovXG4gIGdldCBjbGVhckJlZm9yZVJlbmRlcigpIHtcbiAgICByZXR1cm4gdXRpbHMuZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLmNsZWFyQmVmb3JlUmVuZGVyIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgcmVuZGVyZXIuYmFja2dyb3VuZC5jbGVhckJlZm9yZVJlbmRlciBpbnN0ZWFkLlwiKSwgdGhpcy5iYWNrZ3JvdW5kLmNsZWFyQmVmb3JlUmVuZGVyO1xuICB9XG4gIC8qKlxuICAgKiBQYXNzLXRocnUgc2V0dGluZyBmb3IgdGhlIGNhbnZhcycgY29udGV4dCBgYWxwaGFgIHByb3BlcnR5LiBUaGlzIGlzIHR5cGljYWxseVxuICAgKiBub3Qgc29tZXRoaW5nIHlvdSBuZWVkIHRvIGZpZGRsZSB3aXRoLiBJZiB5b3Ugd2FudCB0cmFuc3BhcmVuY3ksIHVzZSBgYmFja2dyb3VuZEFscGhhYC5cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4wLjBcbiAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCB1c2VDb250ZXh0QWxwaGEoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci51c2VDb250ZXh0QWxwaGEgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSByZW5kZXJlci5jb250ZXh0LnByZW11bHRpcGxpZWRBbHBoYSBpbnN0ZWFkLlwiKSwgdGhpcy5jb250ZXh0LnVzZUNvbnRleHRBbHBoYTtcbiAgfVxuICAvKipcbiAgICogcmVhZG9ubHkgZHJhd2luZyBidWZmZXIgcHJlc2VydmF0aW9uXG4gICAqIHdlIGNhbiBvbmx5IGtub3cgdGhpcyBpZiBQaXhpIGNyZWF0ZWQgdGhlIGNvbnRleHRcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4wLjBcbiAgICovXG4gIGdldCBwcmVzZXJ2ZURyYXdpbmdCdWZmZXIoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgaGFzIGJlZW4gZGVwcmVjYXRlZCwgd2UgY2Fubm90IHRydWx5IGtub3cgdGhpcyB1bmxlc3MgcGl4aSBjcmVhdGVkIHRoZSBjb250ZXh0XCIpLCB0aGlzLmNvbnRleHQucHJlc2VydmVEcmF3aW5nQnVmZmVyO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFja2dyb3VuZCBjb2xvciB0byBmaWxsIGlmIG5vdCB0cmFuc3BhcmVudFxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMC4wXG4gICAqL1xuICBnZXQgYmFja2dyb3VuZENvbG9yKCkge1xuICAgIHJldHVybiB1dGlscy5kZXByZWNhdGlvbihcIjcuMC4wXCIsIFwicmVuZGVyZXIuYmFja2dyb3VuZENvbG9yIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSByZW5kZXJlci5iYWNrZ3JvdW5kLmNvbG9yIGluc3RlYWQuXCIpLCB0aGlzLmJhY2tncm91bmQuY29sb3I7XG4gIH1cbiAgc2V0IGJhY2tncm91bmRDb2xvcih2YWx1ZSkge1xuICAgIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5iYWNrZ3JvdW5kQ29sb3IgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIHJlbmRlcmVyLmJhY2tncm91bmQuY29sb3IgaW5zdGVhZC5cIiksIHRoaXMuYmFja2dyb3VuZC5jb2xvciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFja2dyb3VuZCBjb2xvciBhbHBoYS4gU2V0dGluZyB0aGlzIHRvIDAgd2lsbCBtYWtlIHRoZSBjYW52YXMgdHJhbnNwYXJlbnQuXG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4wLjBcbiAgICovXG4gIGdldCBiYWNrZ3JvdW5kQWxwaGEoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5iYWNrZ3JvdW5kQWxwaGEgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIHJlbmRlcmVyLmJhY2tncm91bmQuYWxwaGEgaW5zdGVhZC5cIiksIHRoaXMuYmFja2dyb3VuZC5hbHBoYTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4wLjBcbiAgICovXG4gIHNldCBiYWNrZ3JvdW5kQWxwaGEodmFsdWUpIHtcbiAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMC4wXCIsIFwicmVuZGVyZXIuYmFja2dyb3VuZEFscGhhIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSByZW5kZXJlci5iYWNrZ3JvdW5kLmFscGhhIGluc3RlYWQuXCIpLCB0aGlzLmJhY2tncm91bmQuYWxwaGEgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4wLjBcbiAgICovXG4gIGdldCBwb3dlclByZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5wb3dlclByZWZlcmVuY2UgaGFzIGJlZW4gZGVwcmVjYXRlZCwgd2UgY2FuIG9ubHkga25vdyB0aGlzIGlmIHBpeGkgY3JlYXRlcyB0aGUgY29udGV4dFwiKSwgdGhpcy5jb250ZXh0LnBvd2VyUHJlZmVyZW5jZTtcbiAgfVxuICAvKipcbiAgICogVXNlZnVsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRleHR1cmUgb2YgdGhlIGRpc3BsYXkgb2JqZWN0IHRoYXQgY2FuIHRoZW4gYmUgdXNlZCB0byBjcmVhdGUgc3ByaXRlc1xuICAgKiBUaGlzIGNhbiBiZSBxdWl0ZSB1c2VmdWwgaWYgeW91ciBkaXNwbGF5T2JqZWN0IGlzIGNvbXBsaWNhdGVkIGFuZCBuZWVkcyB0byBiZSByZXVzZWQgbXVsdGlwbGUgdGltZXMuXG4gICAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IC0gVGhlIGRpc3BsYXlPYmplY3QgdGhlIG9iamVjdCB3aWxsIGJlIGdlbmVyYXRlZCBmcm9tLlxuICAgKiBAcGFyYW0ge0lHZW5lcmF0ZVRleHR1cmVPcHRpb25zfSBvcHRpb25zIC0gR2VuZXJhdGUgdGV4dHVyZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBvcHRpb25zLnJlZ2lvbiAtIFRoZSByZWdpb24gb2YgdGhlIGRpc3BsYXlPYmplY3QsIHRoYXQgc2hhbGwgYmUgcmVuZGVyZWQsXG4gICAqICAgICAgICBpZiBubyByZWdpb24gaXMgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvbl0gLSBJZiBub3QgZ2l2ZW4sIHRoZSByZW5kZXJlcidzIHJlc29sdXRpb24gaXMgdXNlZC5cbiAgICogQHBhcmFtIHtQSVhJLk1TQUFfUVVBTElUWX0gW29wdGlvbnMubXVsdGlzYW1wbGVdIC0gSWYgbm90IGdpdmVuLCB0aGUgcmVuZGVyZXIncyBtdWx0aXNhbXBsZSBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyBBIHRleHR1cmUgb2YgdGhlIGdyYXBoaWNzIG9iamVjdC5cbiAgICovXG4gIGdlbmVyYXRlVGV4dHVyZShkaXNwbGF5T2JqZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZUdlbmVyYXRvci5nZW5lcmF0ZVRleHR1cmUoZGlzcGxheU9iamVjdCwgb3B0aW9ucyk7XG4gIH1cbn07XG5fUmVuZGVyZXIuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXIsXG4gIHByaW9yaXR5OiAxXG59LCAvKipcbiogQ29sbGVjdGlvbiBvZiBpbnN0YWxsZWQgcGx1Z2lucy4gVGhlc2UgYXJlIGluY2x1ZGVkIGJ5IGRlZmF1bHQgaW4gUElYSSwgYnV0IGNhbiBiZSBleGNsdWRlZFxuKiBieSBjcmVhdGluZyBhIGN1c3RvbSBidWlsZC4gQ29uc3VsdCB0aGUgUkVBRE1FIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGNyZWF0aW5nIGN1c3RvbVxuKiBidWlsZHMgYW5kIGV4Y2x1ZGluZyBwbHVnaW5zLlxuKiBAcHJpdmF0ZVxuKi9cbl9SZW5kZXJlci5fX3BsdWdpbnMgPSB7fSwgLyoqXG4qIFRoZSBjb2xsZWN0aW9uIG9mIGluc3RhbGxlZCBzeXN0ZW1zLlxuKiBAcHJpdmF0ZVxuKi9cbl9SZW5kZXJlci5fX3N5c3RlbXMgPSB7fTtcbmxldCBSZW5kZXJlciA9IF9SZW5kZXJlcjtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5oYW5kbGVCeU1hcChleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJQbHVnaW4sIFJlbmRlcmVyLl9fcGx1Z2lucyk7XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuaGFuZGxlQnlNYXAoZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLCBSZW5kZXJlci5fX3N5c3RlbXMpO1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChSZW5kZXJlcik7XG5leHBvcnRzLlJlbmRlcmVyID0gUmVuZGVyZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4dGVuc2lvbnMgPSByZXF1aXJlKFwiQHBpeGkvZXh0ZW5zaW9uc1wiKTtcbmNvbnN0IHJlbmRlcmVycyA9IFtdO1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmhhbmRsZUJ5TGlzdChleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXIsIHJlbmRlcmVycyk7XG5mdW5jdGlvbiBhdXRvRGV0ZWN0UmVuZGVyZXIob3B0aW9ucykge1xuICBmb3IgKGNvbnN0IFJlbmRlcmVyVHlwZSBvZiByZW5kZXJlcnMpXG4gICAgaWYgKFJlbmRlcmVyVHlwZS50ZXN0KG9wdGlvbnMpKVxuICAgICAgcmV0dXJuIG5ldyBSZW5kZXJlclR5cGUob3B0aW9ucyk7XG4gIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBhdXRvLWRldGVjdCBhIHN1aXRhYmxlIHJlbmRlcmVyLlwiKTtcbn1cbmV4cG9ydHMuYXV0b0RldGVjdFJlbmRlcmVyID0gYXV0b0RldGVjdFJlbmRlcmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0b0RldGVjdFJlbmRlcmVyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29sb3IgPSByZXF1aXJlKFwiQHBpeGkvY29sb3JcIiksIGV4dGVuc2lvbnMgPSByZXF1aXJlKFwiQHBpeGkvZXh0ZW5zaW9uc1wiKTtcbmNsYXNzIEJhY2tncm91bmRTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gITAsIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IG5ldyBjb2xvci5Db2xvcigwKSwgdGhpcy5hbHBoYSA9IDE7XG4gIH1cbiAgLyoqXG4gICAqIGluaXRpYXRlcyB0aGUgYmFja2dyb3VuZCBzeXN0ZW1cbiAgICogQHBhcmFtIHtQSVhJLklSZW5kZXJlck9wdGlvbnN9IG9wdGlvbnMgLSB0aGUgb3B0aW9ucyBmb3IgdGhlIGJhY2tncm91bmQgY29sb3JzXG4gICAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gb3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcjtcbiAgICBjb25zdCB7IGJhY2tncm91bmRDb2xvciwgYmFja2dyb3VuZCwgYmFja2dyb3VuZEFscGhhIH0gPSBvcHRpb25zLCBjb2xvcjIgPSBiYWNrZ3JvdW5kID8/IGJhY2tncm91bmRDb2xvcjtcbiAgICBjb2xvcjIgIT09IHZvaWQgMCAmJiAodGhpcy5jb2xvciA9IGNvbG9yMiksIHRoaXMuYWxwaGEgPSBiYWNrZ3JvdW5kQWxwaGE7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIHRvIGZpbGwgaWYgbm90IHRyYW5zcGFyZW50LlxuICAgKiBAbWVtYmVyIHtQSVhJLkNvbG9yU291cmNlfVxuICAgKi9cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IudmFsdWU7XG4gIH1cbiAgc2V0IGNvbG9yKHZhbHVlKSB7XG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhY2tncm91bmQgY29sb3IgYWxwaGEuIFNldHRpbmcgdGhpcyB0byAwIHdpbGwgbWFrZSB0aGUgY2FudmFzIHRyYW5zcGFyZW50LlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgYWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvci5hbHBoYTtcbiAgfVxuICBzZXQgYWxwaGEodmFsdWUpIHtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3Iuc2V0QWxwaGEodmFsdWUpO1xuICB9XG4gIC8qKiBUaGUgYmFja2dyb3VuZCBjb2xvciBvYmplY3QuICovXG4gIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvcjtcbiAgfVxuICBkZXN0cm95KCkge1xuICB9XG59XG5CYWNrZ3JvdW5kU3lzdGVtLmRlZmF1bHRPcHRpb25zID0ge1xuICAvKipcbiAgICoge0BsaW5rIFBJWEkuSVJlbmRlcmVyT3B0aW9ucy5iYWNrZ3JvdW5kQWxwaGF9XG4gICAqIEBkZWZhdWx0IDFcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3MuUkVOREVSX09QVElPTlNcbiAgICovXG4gIGJhY2tncm91bmRBbHBoYTogMSxcbiAgLyoqXG4gICAqIHtAbGluayBQSVhJLklSZW5kZXJlck9wdGlvbnMuYmFja2dyb3VuZENvbG9yfVxuICAgKiBAZGVmYXVsdCAweDAwMDAwMFxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5ncy5SRU5ERVJfT1BUSU9OU1xuICAgKi9cbiAgYmFja2dyb3VuZENvbG9yOiAwLFxuICAvKipcbiAgICoge0BsaW5rIFBJWEkuSVJlbmRlcmVyT3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5ncy5SRU5ERVJfT1BUSU9OU1xuICAgKi9cbiAgY2xlYXJCZWZvcmVSZW5kZXI6ICEwXG59LCAvKiogQGlnbm9yZSAqL1xuQmFja2dyb3VuZFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gICAgZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLkNhbnZhc1JlbmRlcmVyU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwiYmFja2dyb3VuZFwiXG59O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChCYWNrZ3JvdW5kU3lzdGVtKTtcbmV4cG9ydHMuQmFja2dyb3VuZFN5c3RlbSA9IEJhY2tncm91bmRTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYWNrZ3JvdW5kU3lzdGVtLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKTtcbmNsYXNzIEJhdGNoRHJhd0NhbGwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRleEFycmF5ID0gbnVsbCwgdGhpcy5ibGVuZCA9IDAsIHRoaXMudHlwZSA9IGNvbnN0YW50cy5EUkFXX01PREVTLlRSSUFOR0xFUywgdGhpcy5zdGFydCA9IDAsIHRoaXMuc2l6ZSA9IDAsIHRoaXMuZGF0YSA9IG51bGw7XG4gIH1cbn1cbmV4cG9ydHMuQmF0Y2hEcmF3Q2FsbCA9IEJhdGNoRHJhd0NhbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaERyYXdDYWxsLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKSwgQnVmZmVyID0gcmVxdWlyZShcIi4uL2dlb21ldHJ5L0J1ZmZlci5qc1wiKSwgR2VvbWV0cnkgPSByZXF1aXJlKFwiLi4vZ2VvbWV0cnkvR2VvbWV0cnkuanNcIik7XG5jbGFzcyBCYXRjaEdlb21ldHJ5IGV4dGVuZHMgR2VvbWV0cnkuR2VvbWV0cnkge1xuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBbX3N0YXRpYz1mYWxzZV0gLSBPcHRpbWl6YXRpb24gZmxhZywgd2hlcmUgYGZhbHNlYFxuICAgKiAgICAgICAgaXMgdXBkYXRlZCBldmVyeSBmcmFtZSwgYHRydWVgIGRvZXNuJ3QgY2hhbmdlIGZyYW1lLXRvLWZyYW1lLlxuICAgKi9cbiAgY29uc3RydWN0b3IoX3N0YXRpYyA9ICExKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5fYnVmZmVyID0gbmV3IEJ1ZmZlci5CdWZmZXIobnVsbCwgX3N0YXRpYywgITEpLCB0aGlzLl9pbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXIuQnVmZmVyKG51bGwsIF9zdGF0aWMsICEwKSwgdGhpcy5hZGRBdHRyaWJ1dGUoXCJhVmVydGV4UG9zaXRpb25cIiwgdGhpcy5fYnVmZmVyLCAyLCAhMSwgY29uc3RhbnRzLlRZUEVTLkZMT0FUKS5hZGRBdHRyaWJ1dGUoXCJhVGV4dHVyZUNvb3JkXCIsIHRoaXMuX2J1ZmZlciwgMiwgITEsIGNvbnN0YW50cy5UWVBFUy5GTE9BVCkuYWRkQXR0cmlidXRlKFwiYUNvbG9yXCIsIHRoaXMuX2J1ZmZlciwgNCwgITAsIGNvbnN0YW50cy5UWVBFUy5VTlNJR05FRF9CWVRFKS5hZGRBdHRyaWJ1dGUoXCJhVGV4dHVyZUlkXCIsIHRoaXMuX2J1ZmZlciwgMSwgITAsIGNvbnN0YW50cy5UWVBFUy5GTE9BVCkuYWRkSW5kZXgodGhpcy5faW5kZXhCdWZmZXIpO1xuICB9XG59XG5leHBvcnRzLkJhdGNoR2VvbWV0cnkgPSBCYXRjaEdlb21ldHJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hHZW9tZXRyeS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbG9yID0gcmVxdWlyZShcIkBwaXhpL2NvbG9yXCIpLCBjb25zdGFudHMgPSByZXF1aXJlKFwiQHBpeGkvY29uc3RhbnRzXCIpLCBleHRlbnNpb25zID0gcmVxdWlyZShcIkBwaXhpL2V4dGVuc2lvbnNcIiksIHNldHRpbmdzID0gcmVxdWlyZShcIkBwaXhpL3NldHRpbmdzXCIpLCB1dGlscyA9IHJlcXVpcmUoXCJAcGl4aS91dGlsc1wiKSwgVmlld2FibGVCdWZmZXIgPSByZXF1aXJlKFwiLi4vZ2VvbWV0cnkvVmlld2FibGVCdWZmZXIuanNcIiksIGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIgPSByZXF1aXJlKFwiLi4vc2hhZGVyL3V0aWxzL2NoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIuanNcIiksIFN0YXRlID0gcmVxdWlyZShcIi4uL3N0YXRlL1N0YXRlLmpzXCIpLCBCYXNlVGV4dHVyZSA9IHJlcXVpcmUoXCIuLi90ZXh0dXJlcy9CYXNlVGV4dHVyZS5qc1wiKSwgQmF0Y2hEcmF3Q2FsbCA9IHJlcXVpcmUoXCIuL0JhdGNoRHJhd0NhbGwuanNcIiksIEJhdGNoR2VvbWV0cnkgPSByZXF1aXJlKFwiLi9CYXRjaEdlb21ldHJ5LmpzXCIpLCBCYXRjaFNoYWRlckdlbmVyYXRvciA9IHJlcXVpcmUoXCIuL0JhdGNoU2hhZGVyR2VuZXJhdG9yLmpzXCIpLCBCYXRjaFRleHR1cmVBcnJheSA9IHJlcXVpcmUoXCIuL0JhdGNoVGV4dHVyZUFycmF5LmpzXCIpLCBjYW5VcGxvYWRTYW1lQnVmZmVyID0gcmVxdWlyZShcIi4vY2FuVXBsb2FkU2FtZUJ1ZmZlci5qc1wiKSwgbWF4UmVjb21tZW5kZWRUZXh0dXJlcyA9IHJlcXVpcmUoXCIuL21heFJlY29tbWVuZGVkVGV4dHVyZXMuanNcIiksIE9iamVjdFJlbmRlcmVyID0gcmVxdWlyZShcIi4vT2JqZWN0UmVuZGVyZXIuanNcIiksIHRleHR1cmUkMSA9IHJlcXVpcmUoXCIuL3RleHR1cmUuZnJhZy5qc1wiKSwgdGV4dHVyZSA9IHJlcXVpcmUoXCIuL3RleHR1cmUudmVydC5qc1wiKTtcbmNvbnN0IF9CYXRjaFJlbmRlcmVyID0gY2xhc3MgX0JhdGNoUmVuZGVyZXIyIGV4dGVuZHMgT2JqZWN0UmVuZGVyZXIuT2JqZWN0UmVuZGVyZXIge1xuICAvKipcbiAgICogVGhpcyB3aWxsIGhvb2sgb250byB0aGUgcmVuZGVyZXIncyBgY29udGV4dENoYW5nZWBcbiAgICogYW5kIGBwcmVyZW5kZXJgIHNpZ25hbHMuXG4gICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyB3b3JrcyBmb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKSwgdGhpcy5zZXRTaGFkZXJHZW5lcmF0b3IoKSwgdGhpcy5nZW9tZXRyeUNsYXNzID0gQmF0Y2hHZW9tZXRyeS5CYXRjaEdlb21ldHJ5LCB0aGlzLnZlcnRleFNpemUgPSA2LCB0aGlzLnN0YXRlID0gU3RhdGUuU3RhdGUuZm9yMmQoKSwgdGhpcy5zaXplID0gX0JhdGNoUmVuZGVyZXIyLmRlZmF1bHRCYXRjaFNpemUgKiA0LCB0aGlzLl92ZXJ0ZXhDb3VudCA9IDAsIHRoaXMuX2luZGV4Q291bnQgPSAwLCB0aGlzLl9idWZmZXJlZEVsZW1lbnRzID0gW10sIHRoaXMuX2J1ZmZlcmVkVGV4dHVyZXMgPSBbXSwgdGhpcy5fYnVmZmVyU2l6ZSA9IDAsIHRoaXMuX3NoYWRlciA9IG51bGwsIHRoaXMuX3BhY2tlZEdlb21ldHJpZXMgPSBbXSwgdGhpcy5fcGFja2VkR2VvbWV0cnlQb29sU2l6ZSA9IDIsIHRoaXMuX2ZsdXNoSWQgPSAwLCB0aGlzLl9hQnVmZmVycyA9IHt9LCB0aGlzLl9pQnVmZmVycyA9IHt9LCB0aGlzLm1heFRleHR1cmVzID0gMSwgdGhpcy5yZW5kZXJlci5vbihcInByZXJlbmRlclwiLCB0aGlzLm9uUHJlcmVuZGVyLCB0aGlzKSwgcmVuZGVyZXIucnVubmVycy5jb250ZXh0Q2hhbmdlLmFkZCh0aGlzKSwgdGhpcy5fZGNJbmRleCA9IDAsIHRoaXMuX2FJbmRleCA9IDAsIHRoaXMuX2lJbmRleCA9IDAsIHRoaXMuX2F0dHJpYnV0ZUJ1ZmZlciA9IG51bGwsIHRoaXMuX2luZGV4QnVmZmVyID0gbnVsbCwgdGhpcy5fdGVtcEJvdW5kVGV4dHVyZXMgPSBbXTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heGltdW0gdGV4dHVyZXMgdGhhdCB0aGlzIGRldmljZSBzdXBwb3J0cy5cbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCAzMlxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0TWF4VGV4dHVyZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRNYXhUZXh0dXJlcyA9IHRoaXMuX2RlZmF1bHRNYXhUZXh0dXJlcyA/PyBtYXhSZWNvbW1lbmRlZFRleHR1cmVzLm1heFJlY29tbWVuZGVkVGV4dHVyZXMoMzIpLCB0aGlzLl9kZWZhdWx0TWF4VGV4dHVyZXM7XG4gIH1cbiAgc3RhdGljIHNldCBkZWZhdWx0TWF4VGV4dHVyZXModmFsdWUpIHtcbiAgICB0aGlzLl9kZWZhdWx0TWF4VGV4dHVyZXMgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FuIHdlIHVwbG9hZCB0aGUgc2FtZSBidWZmZXIgaW4gYSBzaW5nbGUgZnJhbWU/XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBnZXQgY2FuVXBsb2FkU2FtZUJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FuVXBsb2FkU2FtZUJ1ZmZlciA9IHRoaXMuX2NhblVwbG9hZFNhbWVCdWZmZXIgPz8gY2FuVXBsb2FkU2FtZUJ1ZmZlci5jYW5VcGxvYWRTYW1lQnVmZmVyKCksIHRoaXMuX2NhblVwbG9hZFNhbWVCdWZmZXI7XG4gIH1cbiAgc3RhdGljIHNldCBjYW5VcGxvYWRTYW1lQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy5fY2FuVXBsb2FkU2FtZUJ1ZmZlciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIFBJWEkuQmF0Y2hSZW5kZXJlciNtYXhUZXh0dXJlc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBNQVhfVEVYVFVSRVMoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJCYXRjaFJlbmRlcmVyI01BWF9URVhUVVJFUyByZW5hbWVkIHRvIEJhdGNoUmVuZGVyZXIjbWF4VGV4dHVyZXNcIiksIHRoaXMubWF4VGV4dHVyZXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHZlcnRleCBzaGFkZXIgc291cmNlXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0VmVydGV4U3JjKCkge1xuICAgIHJldHVybiB0ZXh0dXJlLmRlZmF1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGZyYWdtZW50IHNoYWRlciBzb3VyY2VcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRGcmFnbWVudFRlbXBsYXRlKCkge1xuICAgIHJldHVybiB0ZXh0dXJlJDEuZGVmYXVsdDtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBzaGFkZXIgZ2VuZXJhdG9yLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52ZXJ0ZXg9UElYSS5CYXRjaFJlbmRlcmVyLmRlZmF1bHRWZXJ0ZXhTcmNdIC0gVmVydGV4IHNoYWRlciBzb3VyY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZyYWdtZW50PVBJWEkuQmF0Y2hSZW5kZXJlci5kZWZhdWx0RnJhZ21lbnRUZW1wbGF0ZV0gLSBGcmFnbWVudCBzaGFkZXIgdGVtcGxhdGVcbiAgICovXG4gIHNldFNoYWRlckdlbmVyYXRvcih7XG4gICAgdmVydGV4ID0gX0JhdGNoUmVuZGVyZXIyLmRlZmF1bHRWZXJ0ZXhTcmMsXG4gICAgZnJhZ21lbnQgPSBfQmF0Y2hSZW5kZXJlcjIuZGVmYXVsdEZyYWdtZW50VGVtcGxhdGVcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5zaGFkZXJHZW5lcmF0b3IgPSBuZXcgQmF0Y2hTaGFkZXJHZW5lcmF0b3IuQmF0Y2hTaGFkZXJHZW5lcmF0b3IodmVydGV4LCBmcmFnbWVudCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGBjb250ZXh0Q2hhbmdlYCBzaWduYWwuXG4gICAqXG4gICAqIEl0IGNhbGN1bGF0ZXMgYHRoaXMubWF4VGV4dHVyZXNgIGFuZCBhbGxvY2F0aW5nIHRoZSBwYWNrZWQtZ2VvbWV0cnkgb2JqZWN0IHBvb2wuXG4gICAqL1xuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICBzZXR0aW5ncy5zZXR0aW5ncy5QUkVGRVJfRU5WID09PSBjb25zdGFudHMuRU5WLldFQkdMX0xFR0FDWSA/IHRoaXMubWF4VGV4dHVyZXMgPSAxIDogKHRoaXMubWF4VGV4dHVyZXMgPSBNYXRoLm1pbihcbiAgICAgIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksXG4gICAgICBfQmF0Y2hSZW5kZXJlcjIuZGVmYXVsdE1heFRleHR1cmVzXG4gICAgKSwgdGhpcy5tYXhUZXh0dXJlcyA9IGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIuY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlcihcbiAgICAgIHRoaXMubWF4VGV4dHVyZXMsXG4gICAgICBnbFxuICAgICkpLCB0aGlzLl9zaGFkZXIgPSB0aGlzLnNoYWRlckdlbmVyYXRvci5nZW5lcmF0ZVNoYWRlcih0aGlzLm1heFRleHR1cmVzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BhY2tlZEdlb21ldHJ5UG9vbFNpemU7IGkrKylcbiAgICAgIHRoaXMuX3BhY2tlZEdlb21ldHJpZXNbaV0gPSBuZXcgdGhpcy5nZW9tZXRyeUNsYXNzKCk7XG4gICAgdGhpcy5pbml0Rmx1c2hCdWZmZXJzKCk7XG4gIH1cbiAgLyoqIE1ha2VzIHN1cmUgdGhhdCBzdGF0aWMgYW5kIGR5bmFtaWMgZmx1c2ggcG9vbGVkIG9iamVjdHMgaGF2ZSBjb3JyZWN0IGRpbWVuc2lvbnMuICovXG4gIGluaXRGbHVzaEJ1ZmZlcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdDYWxsUG9vbCxcbiAgICAgIF90ZXh0dXJlQXJyYXlQb29sXG4gICAgfSA9IF9CYXRjaFJlbmRlcmVyMiwgTUFYX1NQUklURVMgPSB0aGlzLnNpemUgLyA0LCBNQVhfVEEgPSBNYXRoLmZsb29yKE1BWF9TUFJJVEVTIC8gdGhpcy5tYXhUZXh0dXJlcykgKyAxO1xuICAgIGZvciAoOyBfZHJhd0NhbGxQb29sLmxlbmd0aCA8IE1BWF9TUFJJVEVTOyApXG4gICAgICBfZHJhd0NhbGxQb29sLnB1c2gobmV3IEJhdGNoRHJhd0NhbGwuQmF0Y2hEcmF3Q2FsbCgpKTtcbiAgICBmb3IgKDsgX3RleHR1cmVBcnJheVBvb2wubGVuZ3RoIDwgTUFYX1RBOyApXG4gICAgICBfdGV4dHVyZUFycmF5UG9vbC5wdXNoKG5ldyBCYXRjaFRleHR1cmVBcnJheS5CYXRjaFRleHR1cmVBcnJheSgpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWF4VGV4dHVyZXM7IGkrKylcbiAgICAgIHRoaXMuX3RlbXBCb3VuZFRleHR1cmVzW2ldID0gbnVsbDtcbiAgfVxuICAvKiogSGFuZGxlcyB0aGUgYHByZXJlbmRlcmAgc2lnbmFsLiBJdCBlbnN1cmVzIHRoYXQgZmx1c2hlcyBzdGFydCBmcm9tIHRoZSBmaXJzdCBnZW9tZXRyeSBvYmplY3QgYWdhaW4uICovXG4gIG9uUHJlcmVuZGVyKCkge1xuICAgIHRoaXMuX2ZsdXNoSWQgPSAwO1xuICB9XG4gIC8qKlxuICAgKiBCdWZmZXJzIHRoZSBcImJhdGNoYWJsZVwiIG9iamVjdC4gSXQgbmVlZCBub3QgYmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkuXG4gICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gcmVuZGVyIHdoZW5cbiAgICogICAgdXNpbmcgdGhpcyByZW5kZXJlclxuICAgKi9cbiAgcmVuZGVyKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50Ll90ZXh0dXJlLnZhbGlkICYmICh0aGlzLl92ZXJ0ZXhDb3VudCArIGVsZW1lbnQudmVydGV4RGF0YS5sZW5ndGggLyAyID4gdGhpcy5zaXplICYmIHRoaXMuZmx1c2goKSwgdGhpcy5fdmVydGV4Q291bnQgKz0gZWxlbWVudC52ZXJ0ZXhEYXRhLmxlbmd0aCAvIDIsIHRoaXMuX2luZGV4Q291bnQgKz0gZWxlbWVudC5pbmRpY2VzLmxlbmd0aCwgdGhpcy5fYnVmZmVyZWRUZXh0dXJlc1t0aGlzLl9idWZmZXJTaXplXSA9IGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmUsIHRoaXMuX2J1ZmZlcmVkRWxlbWVudHNbdGhpcy5fYnVmZmVyU2l6ZSsrXSA9IGVsZW1lbnQpO1xuICB9XG4gIGJ1aWxkVGV4dHVyZXNBbmREcmF3Q2FsbHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX2J1ZmZlcmVkVGV4dHVyZXM6IHRleHR1cmVzLFxuICAgICAgbWF4VGV4dHVyZXNcbiAgICB9ID0gdGhpcywgdGV4dHVyZUFycmF5cyA9IF9CYXRjaFJlbmRlcmVyMi5fdGV4dHVyZUFycmF5UG9vbCwgYmF0Y2ggPSB0aGlzLnJlbmRlcmVyLmJhdGNoLCBib3VuZFRleHR1cmVzID0gdGhpcy5fdGVtcEJvdW5kVGV4dHVyZXMsIHRvdWNoID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlR0MuY291bnQ7XG4gICAgbGV0IFRJQ0sgPSArK0Jhc2VUZXh0dXJlLkJhc2VUZXh0dXJlLl9nbG9iYWxCYXRjaCwgY291bnRUZXhBcnJheXMgPSAwLCB0ZXhBcnJheSA9IHRleHR1cmVBcnJheXNbMF0sIHN0YXJ0ID0gMDtcbiAgICBiYXRjaC5jb3B5Qm91bmRUZXh0dXJlcyhib3VuZFRleHR1cmVzLCBtYXhUZXh0dXJlcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9idWZmZXJTaXplOyArK2kpIHtcbiAgICAgIGNvbnN0IHRleCA9IHRleHR1cmVzW2ldO1xuICAgICAgdGV4dHVyZXNbaV0gPSBudWxsLCB0ZXguX2JhdGNoRW5hYmxlZCAhPT0gVElDSyAmJiAodGV4QXJyYXkuY291bnQgPj0gbWF4VGV4dHVyZXMgJiYgKGJhdGNoLmJvdW5kQXJyYXkodGV4QXJyYXksIGJvdW5kVGV4dHVyZXMsIFRJQ0ssIG1heFRleHR1cmVzKSwgdGhpcy5idWlsZERyYXdDYWxscyh0ZXhBcnJheSwgc3RhcnQsIGkpLCBzdGFydCA9IGksIHRleEFycmF5ID0gdGV4dHVyZUFycmF5c1srK2NvdW50VGV4QXJyYXlzXSwgKytUSUNLKSwgdGV4Ll9iYXRjaEVuYWJsZWQgPSBUSUNLLCB0ZXgudG91Y2hlZCA9IHRvdWNoLCB0ZXhBcnJheS5lbGVtZW50c1t0ZXhBcnJheS5jb3VudCsrXSA9IHRleCk7XG4gICAgfVxuICAgIHRleEFycmF5LmNvdW50ID4gMCAmJiAoYmF0Y2guYm91bmRBcnJheSh0ZXhBcnJheSwgYm91bmRUZXh0dXJlcywgVElDSywgbWF4VGV4dHVyZXMpLCB0aGlzLmJ1aWxkRHJhd0NhbGxzKHRleEFycmF5LCBzdGFydCwgdGhpcy5fYnVmZmVyU2l6ZSksICsrY291bnRUZXhBcnJheXMsICsrVElDSyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZFRleHR1cmVzLmxlbmd0aDsgaSsrKVxuICAgICAgYm91bmRUZXh0dXJlc1tpXSA9IG51bGw7XG4gICAgQmFzZVRleHR1cmUuQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoID0gVElDSztcbiAgfVxuICAvKipcbiAgICogUG9wdWxhdGluZyBkcmF3Y2FsbHMgZm9yIHJlbmRlcmluZ1xuICAgKiBAcGFyYW0gdGV4QXJyYXlcbiAgICogQHBhcmFtIHN0YXJ0XG4gICAqIEBwYXJhbSBmaW5pc2hcbiAgICovXG4gIGJ1aWxkRHJhd0NhbGxzKHRleEFycmF5LCBzdGFydCwgZmluaXNoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX2J1ZmZlcmVkRWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgX2F0dHJpYnV0ZUJ1ZmZlcixcbiAgICAgIF9pbmRleEJ1ZmZlcixcbiAgICAgIHZlcnRleFNpemVcbiAgICB9ID0gdGhpcywgZHJhd0NhbGxzID0gX0JhdGNoUmVuZGVyZXIyLl9kcmF3Q2FsbFBvb2w7XG4gICAgbGV0IGRjSW5kZXggPSB0aGlzLl9kY0luZGV4LCBhSW5kZXggPSB0aGlzLl9hSW5kZXgsIGlJbmRleCA9IHRoaXMuX2lJbmRleCwgZHJhd0NhbGwgPSBkcmF3Q2FsbHNbZGNJbmRleF07XG4gICAgZHJhd0NhbGwuc3RhcnQgPSB0aGlzLl9pSW5kZXgsIGRyYXdDYWxsLnRleEFycmF5ID0gdGV4QXJyYXk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZmluaXNoOyArK2kpIHtcbiAgICAgIGNvbnN0IHNwcml0ZSA9IGVsZW1lbnRzW2ldLCB0ZXggPSBzcHJpdGUuX3RleHR1cmUuYmFzZVRleHR1cmUsIHNwcml0ZUJsZW5kTW9kZSA9IHV0aWxzLnByZW11bHRpcGx5QmxlbmRNb2RlW3RleC5hbHBoYU1vZGUgPyAxIDogMF1bc3ByaXRlLmJsZW5kTW9kZV07XG4gICAgICBlbGVtZW50c1tpXSA9IG51bGwsIHN0YXJ0IDwgaSAmJiBkcmF3Q2FsbC5ibGVuZCAhPT0gc3ByaXRlQmxlbmRNb2RlICYmIChkcmF3Q2FsbC5zaXplID0gaUluZGV4IC0gZHJhd0NhbGwuc3RhcnQsIHN0YXJ0ID0gaSwgZHJhd0NhbGwgPSBkcmF3Q2FsbHNbKytkY0luZGV4XSwgZHJhd0NhbGwudGV4QXJyYXkgPSB0ZXhBcnJheSwgZHJhd0NhbGwuc3RhcnQgPSBpSW5kZXgpLCB0aGlzLnBhY2tJbnRlcmxlYXZlZEdlb21ldHJ5KHNwcml0ZSwgX2F0dHJpYnV0ZUJ1ZmZlciwgX2luZGV4QnVmZmVyLCBhSW5kZXgsIGlJbmRleCksIGFJbmRleCArPSBzcHJpdGUudmVydGV4RGF0YS5sZW5ndGggLyAyICogdmVydGV4U2l6ZSwgaUluZGV4ICs9IHNwcml0ZS5pbmRpY2VzLmxlbmd0aCwgZHJhd0NhbGwuYmxlbmQgPSBzcHJpdGVCbGVuZE1vZGU7XG4gICAgfVxuICAgIHN0YXJ0IDwgZmluaXNoICYmIChkcmF3Q2FsbC5zaXplID0gaUluZGV4IC0gZHJhd0NhbGwuc3RhcnQsICsrZGNJbmRleCksIHRoaXMuX2RjSW5kZXggPSBkY0luZGV4LCB0aGlzLl9hSW5kZXggPSBhSW5kZXgsIHRoaXMuX2lJbmRleCA9IGlJbmRleDtcbiAgfVxuICAvKipcbiAgICogQmluZCB0ZXh0dXJlcyBmb3IgY3VycmVudCByZW5kZXJpbmdcbiAgICogQHBhcmFtIHRleEFycmF5XG4gICAqL1xuICBiaW5kQW5kQ2xlYXJUZXhBcnJheSh0ZXhBcnJheSkge1xuICAgIGNvbnN0IHRleHR1cmVTeXN0ZW0gPSB0aGlzLnJlbmRlcmVyLnRleHR1cmU7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXhBcnJheS5jb3VudDsgaisrKVxuICAgICAgdGV4dHVyZVN5c3RlbS5iaW5kKHRleEFycmF5LmVsZW1lbnRzW2pdLCB0ZXhBcnJheS5pZHNbal0pLCB0ZXhBcnJheS5lbGVtZW50c1tqXSA9IG51bGw7XG4gICAgdGV4QXJyYXkuY291bnQgPSAwO1xuICB9XG4gIHVwZGF0ZUdlb21ldHJ5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9wYWNrZWRHZW9tZXRyaWVzOiBwYWNrZWRHZW9tZXRyaWVzLFxuICAgICAgX2F0dHJpYnV0ZUJ1ZmZlcjogYXR0cmlidXRlQnVmZmVyLFxuICAgICAgX2luZGV4QnVmZmVyOiBpbmRleEJ1ZmZlclxuICAgIH0gPSB0aGlzO1xuICAgIF9CYXRjaFJlbmRlcmVyMi5jYW5VcGxvYWRTYW1lQnVmZmVyID8gKHBhY2tlZEdlb21ldHJpZXNbdGhpcy5fZmx1c2hJZF0uX2J1ZmZlci51cGRhdGUoYXR0cmlidXRlQnVmZmVyLnJhd0JpbmFyeURhdGEpLCBwYWNrZWRHZW9tZXRyaWVzW3RoaXMuX2ZsdXNoSWRdLl9pbmRleEJ1ZmZlci51cGRhdGUoaW5kZXhCdWZmZXIpLCB0aGlzLnJlbmRlcmVyLmdlb21ldHJ5LnVwZGF0ZUJ1ZmZlcnMoKSkgOiAodGhpcy5fcGFja2VkR2VvbWV0cnlQb29sU2l6ZSA8PSB0aGlzLl9mbHVzaElkICYmICh0aGlzLl9wYWNrZWRHZW9tZXRyeVBvb2xTaXplKyssIHBhY2tlZEdlb21ldHJpZXNbdGhpcy5fZmx1c2hJZF0gPSBuZXcgdGhpcy5nZW9tZXRyeUNsYXNzKCkpLCBwYWNrZWRHZW9tZXRyaWVzW3RoaXMuX2ZsdXNoSWRdLl9idWZmZXIudXBkYXRlKGF0dHJpYnV0ZUJ1ZmZlci5yYXdCaW5hcnlEYXRhKSwgcGFja2VkR2VvbWV0cmllc1t0aGlzLl9mbHVzaElkXS5faW5kZXhCdWZmZXIudXBkYXRlKGluZGV4QnVmZmVyKSwgdGhpcy5yZW5kZXJlci5nZW9tZXRyeS5iaW5kKHBhY2tlZEdlb21ldHJpZXNbdGhpcy5fZmx1c2hJZF0pLCB0aGlzLnJlbmRlcmVyLmdlb21ldHJ5LnVwZGF0ZUJ1ZmZlcnMoKSwgdGhpcy5fZmx1c2hJZCsrKTtcbiAgfVxuICBkcmF3QmF0Y2hlcygpIHtcbiAgICBjb25zdCBkY0NvdW50ID0gdGhpcy5fZGNJbmRleCwgeyBnbCwgc3RhdGU6IHN0YXRlU3lzdGVtIH0gPSB0aGlzLnJlbmRlcmVyLCBkcmF3Q2FsbHMgPSBfQmF0Y2hSZW5kZXJlcjIuX2RyYXdDYWxsUG9vbDtcbiAgICBsZXQgY3VyVGV4QXJyYXkgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGNDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB7IHRleEFycmF5LCB0eXBlLCBzaXplLCBzdGFydCwgYmxlbmQgfSA9IGRyYXdDYWxsc1tpXTtcbiAgICAgIGN1clRleEFycmF5ICE9PSB0ZXhBcnJheSAmJiAoY3VyVGV4QXJyYXkgPSB0ZXhBcnJheSwgdGhpcy5iaW5kQW5kQ2xlYXJUZXhBcnJheSh0ZXhBcnJheSkpLCB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IGJsZW5kLCBzdGF0ZVN5c3RlbS5zZXQodGhpcy5zdGF0ZSksIGdsLmRyYXdFbGVtZW50cyh0eXBlLCBzaXplLCBnbC5VTlNJR05FRF9TSE9SVCwgc3RhcnQgKiAyKTtcbiAgICB9XG4gIH1cbiAgLyoqIFJlbmRlcnMgdGhlIGNvbnRlbnQgX25vd18gYW5kIGVtcHRpZXMgdGhlIGN1cnJlbnQgYmF0Y2guICovXG4gIGZsdXNoKCkge1xuICAgIHRoaXMuX3ZlcnRleENvdW50ICE9PSAwICYmICh0aGlzLl9hdHRyaWJ1dGVCdWZmZXIgPSB0aGlzLmdldEF0dHJpYnV0ZUJ1ZmZlcih0aGlzLl92ZXJ0ZXhDb3VudCksIHRoaXMuX2luZGV4QnVmZmVyID0gdGhpcy5nZXRJbmRleEJ1ZmZlcih0aGlzLl9pbmRleENvdW50KSwgdGhpcy5fYUluZGV4ID0gMCwgdGhpcy5faUluZGV4ID0gMCwgdGhpcy5fZGNJbmRleCA9IDAsIHRoaXMuYnVpbGRUZXh0dXJlc0FuZERyYXdDYWxscygpLCB0aGlzLnVwZGF0ZUdlb21ldHJ5KCksIHRoaXMuZHJhd0JhdGNoZXMoKSwgdGhpcy5fYnVmZmVyU2l6ZSA9IDAsIHRoaXMuX3ZlcnRleENvdW50ID0gMCwgdGhpcy5faW5kZXhDb3VudCA9IDApO1xuICB9XG4gIC8qKiBTdGFydHMgYSBuZXcgc3ByaXRlIGJhdGNoLiAqL1xuICBzdGFydCgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnN0YXRlLnNldCh0aGlzLnN0YXRlKSwgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmVuc3VyZVNhbXBsZXJUeXBlKHRoaXMubWF4VGV4dHVyZXMpLCB0aGlzLnJlbmRlcmVyLnNoYWRlci5iaW5kKHRoaXMuX3NoYWRlciksIF9CYXRjaFJlbmRlcmVyMi5jYW5VcGxvYWRTYW1lQnVmZmVyICYmIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLl9wYWNrZWRHZW9tZXRyaWVzW3RoaXMuX2ZsdXNoSWRdKTtcbiAgfVxuICAvKiogU3RvcHMgYW5kIGZsdXNoZXMgdGhlIGN1cnJlbnQgYmF0Y2guICovXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG4gIC8qKiBEZXN0cm95cyB0aGlzIGBCYXRjaFJlbmRlcmVyYC4gSXQgY2Fubm90IGJlIHVzZWQgYWdhaW4uICovXG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wYWNrZWRHZW9tZXRyeVBvb2xTaXplOyBpKyspXG4gICAgICB0aGlzLl9wYWNrZWRHZW9tZXRyaWVzW2ldICYmIHRoaXMuX3BhY2tlZEdlb21ldHJpZXNbaV0uZGVzdHJveSgpO1xuICAgIHRoaXMucmVuZGVyZXIub2ZmKFwicHJlcmVuZGVyXCIsIHRoaXMub25QcmVyZW5kZXIsIHRoaXMpLCB0aGlzLl9hQnVmZmVycyA9IG51bGwsIHRoaXMuX2lCdWZmZXJzID0gbnVsbCwgdGhpcy5fcGFja2VkR2VvbWV0cmllcyA9IG51bGwsIHRoaXMuX2F0dHJpYnV0ZUJ1ZmZlciA9IG51bGwsIHRoaXMuX2luZGV4QnVmZmVyID0gbnVsbCwgdGhpcy5fc2hhZGVyICYmICh0aGlzLl9zaGFkZXIuZGVzdHJveSgpLCB0aGlzLl9zaGFkZXIgPSBudWxsKSwgc3VwZXIuZGVzdHJveSgpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaGVzIGFuIGF0dHJpYnV0ZSBidWZmZXIgZnJvbSBgdGhpcy5fYUJ1ZmZlcnNgIHRoYXQgY2FuIGhvbGQgYXRsZWFzdCBgc2l6ZWAgZmxvYXRzLlxuICAgKiBAcGFyYW0gc2l6ZSAtIG1pbmltdW0gY2FwYWNpdHkgcmVxdWlyZWRcbiAgICogQHJldHVybnMgLSBidWZmZXIgdGhhbiBjYW4gaG9sZCBhdGxlYXN0IGBzaXplYCBmbG9hdHNcbiAgICovXG4gIGdldEF0dHJpYnV0ZUJ1ZmZlcihzaXplKSB7XG4gICAgY29uc3Qgcm91bmRlZFAyID0gdXRpbHMubmV4dFBvdzIoTWF0aC5jZWlsKHNpemUgLyA4KSksIHJvdW5kZWRTaXplSW5kZXggPSB1dGlscy5sb2cyKHJvdW5kZWRQMiksIHJvdW5kZWRTaXplID0gcm91bmRlZFAyICogODtcbiAgICB0aGlzLl9hQnVmZmVycy5sZW5ndGggPD0gcm91bmRlZFNpemVJbmRleCAmJiAodGhpcy5faUJ1ZmZlcnMubGVuZ3RoID0gcm91bmRlZFNpemVJbmRleCArIDEpO1xuICAgIGxldCBidWZmZXIgPSB0aGlzLl9hQnVmZmVyc1tyb3VuZGVkU2l6ZV07XG4gICAgcmV0dXJuIGJ1ZmZlciB8fCAodGhpcy5fYUJ1ZmZlcnNbcm91bmRlZFNpemVdID0gYnVmZmVyID0gbmV3IFZpZXdhYmxlQnVmZmVyLlZpZXdhYmxlQnVmZmVyKHJvdW5kZWRTaXplICogdGhpcy52ZXJ0ZXhTaXplICogNCkpLCBidWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgYW4gaW5kZXggYnVmZmVyIGZyb20gYHRoaXMuX2lCdWZmZXJzYCB0aGF0IGNhblxuICAgKiBoYXZlIGF0IGxlYXN0IGBzaXplYCBjYXBhY2l0eS5cbiAgICogQHBhcmFtIHNpemUgLSBtaW5pbXVtIHJlcXVpcmVkIGNhcGFjaXR5XG4gICAqIEByZXR1cm5zIC0gYnVmZmVyIHRoYXQgY2FuIGZpdCBgc2l6ZWAgaW5kaWNlcy5cbiAgICovXG4gIGdldEluZGV4QnVmZmVyKHNpemUpIHtcbiAgICBjb25zdCByb3VuZGVkUDIgPSB1dGlscy5uZXh0UG93MihNYXRoLmNlaWwoc2l6ZSAvIDEyKSksIHJvdW5kZWRTaXplSW5kZXggPSB1dGlscy5sb2cyKHJvdW5kZWRQMiksIHJvdW5kZWRTaXplID0gcm91bmRlZFAyICogMTI7XG4gICAgdGhpcy5faUJ1ZmZlcnMubGVuZ3RoIDw9IHJvdW5kZWRTaXplSW5kZXggJiYgKHRoaXMuX2lCdWZmZXJzLmxlbmd0aCA9IHJvdW5kZWRTaXplSW5kZXggKyAxKTtcbiAgICBsZXQgYnVmZmVyID0gdGhpcy5faUJ1ZmZlcnNbcm91bmRlZFNpemVJbmRleF07XG4gICAgcmV0dXJuIGJ1ZmZlciB8fCAodGhpcy5faUJ1ZmZlcnNbcm91bmRlZFNpemVJbmRleF0gPSBidWZmZXIgPSBuZXcgVWludDE2QXJyYXkocm91bmRlZFNpemUpKSwgYnVmZmVyO1xuICB9XG4gIC8qKlxuICAgKiBUYWtlcyB0aGUgZm91ciBiYXRjaGluZyBwYXJhbWV0ZXJzIG9mIGBlbGVtZW50YCwgaW50ZXJsZWF2ZXNcbiAgICogYW5kIHB1c2hlcyB0aGVtIGludG8gdGhlIGJhdGNoaW5nIGF0dHJpYnV0ZS9pbmRleCBidWZmZXJzIGdpdmVuLlxuICAgKlxuICAgKiBJdCB1c2VzIHRoZXNlIHByb3BlcnRpZXM6IGB2ZXJ0ZXhEYXRhYCBgdXZzYCwgYHRleHR1cmVJZGAgYW5kXG4gICAqIGBpbmRpY2llc2AuIEl0IGFsc28gdXNlcyB0aGUgXCJ0aW50XCIgb2YgdGhlIGJhc2UtdGV4dHVyZSwgaWZcbiAgICogcHJlc2VudC5cbiAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGVsZW1lbnQgLSBlbGVtZW50IGJlaW5nIHJlbmRlcmVkXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVCdWZmZXIgLSBhdHRyaWJ1dGUgYnVmZmVyLlxuICAgKiBAcGFyYW0gaW5kZXhCdWZmZXIgLSBpbmRleCBidWZmZXJcbiAgICogQHBhcmFtIGFJbmRleCAtIG51bWJlciBvZiBmbG9hdHMgYWxyZWFkeSBpbiB0aGUgYXR0cmlidXRlIGJ1ZmZlclxuICAgKiBAcGFyYW0gaUluZGV4IC0gbnVtYmVyIG9mIGluZGljZXMgYWxyZWFkeSBpbiBgaW5kZXhCdWZmZXJgXG4gICAqL1xuICBwYWNrSW50ZXJsZWF2ZWRHZW9tZXRyeShlbGVtZW50LCBhdHRyaWJ1dGVCdWZmZXIsIGluZGV4QnVmZmVyLCBhSW5kZXgsIGlJbmRleCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHVpbnQzMlZpZXcsXG4gICAgICBmbG9hdDMyVmlld1xuICAgIH0gPSBhdHRyaWJ1dGVCdWZmZXIsIHBhY2tlZFZlcnRpY2VzID0gYUluZGV4IC8gdGhpcy52ZXJ0ZXhTaXplLCB1dnMgPSBlbGVtZW50LnV2cywgaW5kaWNpZXMgPSBlbGVtZW50LmluZGljZXMsIHZlcnRleERhdGEgPSBlbGVtZW50LnZlcnRleERhdGEsIHRleHR1cmVJZCA9IGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmUuX2JhdGNoTG9jYXRpb24sIGFscGhhID0gTWF0aC5taW4oZWxlbWVudC53b3JsZEFscGhhLCAxKSwgYXJnYiA9IGNvbG9yLkNvbG9yLnNoYXJlZC5zZXRWYWx1ZShlbGVtZW50Ll90aW50UkdCKS50b1ByZW11bHRpcGxpZWQoYWxwaGEsIGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmUuYWxwaGFNb2RlID4gMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhEYXRhLmxlbmd0aDsgaSArPSAyKVxuICAgICAgZmxvYXQzMlZpZXdbYUluZGV4KytdID0gdmVydGV4RGF0YVtpXSwgZmxvYXQzMlZpZXdbYUluZGV4KytdID0gdmVydGV4RGF0YVtpICsgMV0sIGZsb2F0MzJWaWV3W2FJbmRleCsrXSA9IHV2c1tpXSwgZmxvYXQzMlZpZXdbYUluZGV4KytdID0gdXZzW2kgKyAxXSwgdWludDMyVmlld1thSW5kZXgrK10gPSBhcmdiLCBmbG9hdDMyVmlld1thSW5kZXgrK10gPSB0ZXh0dXJlSWQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2llcy5sZW5ndGg7IGkrKylcbiAgICAgIGluZGV4QnVmZmVyW2lJbmRleCsrXSA9IHBhY2tlZFZlcnRpY2VzICsgaW5kaWNpZXNbaV07XG4gIH1cbn07XG5fQmF0Y2hSZW5kZXJlci5kZWZhdWx0QmF0Y2hTaXplID0gNDA5NiwgLyoqIEBpZ25vcmUgKi9cbl9CYXRjaFJlbmRlcmVyLmV4dGVuc2lvbiA9IHtcbiAgbmFtZTogXCJiYXRjaFwiLFxuICB0eXBlOiBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJQbHVnaW5cbn0sIC8qKlxuKiBQb29sIG9mIGBCYXRjaERyYXdDYWxsYCBvYmplY3RzIHRoYXQgYGZsdXNoYCB1c2VkXG4qIHRvIGNyZWF0ZSBcImJhdGNoZXNcIiBvZiB0aGUgb2JqZWN0cyBiZWluZyByZW5kZXJlZC5cbipcbiogVGhlc2UgYXJlIG5ldmVyIHJlLWFsbG9jYXRlZCBhZ2Fpbi5cbiogU2hhcmVkIGJldHdlZW4gYWxsIGJhdGNoIHJlbmRlcmVycyBiZWNhdXNlIGl0IGNhbiBiZSBvbmx5IG9uZSBcImZsdXNoXCIgd29ya2luZyBhdCB0aGUgbW9tZW50LlxuKiBAbWVtYmVyIHtQSVhJLkJhdGNoRHJhd0NhbGxbXX1cbiovXG5fQmF0Y2hSZW5kZXJlci5fZHJhd0NhbGxQb29sID0gW10sIC8qKlxuKiBQb29sIG9mIGBCYXRjaERyYXdDYWxsYCBvYmplY3RzIHRoYXQgYGZsdXNoYCB1c2VkXG4qIHRvIGNyZWF0ZSBcImJhdGNoZXNcIiBvZiB0aGUgb2JqZWN0cyBiZWluZyByZW5kZXJlZC5cbipcbiogVGhlc2UgYXJlIG5ldmVyIHJlLWFsbG9jYXRlZCBhZ2Fpbi5cbiogU2hhcmVkIGJldHdlZW4gYWxsIGJhdGNoIHJlbmRlcmVycyBiZWNhdXNlIGl0IGNhbiBiZSBvbmx5IG9uZSBcImZsdXNoXCIgd29ya2luZyBhdCB0aGUgbW9tZW50LlxuKiBAbWVtYmVyIHtQSVhJLkJhdGNoVGV4dHVyZUFycmF5W119XG4qL1xuX0JhdGNoUmVuZGVyZXIuX3RleHR1cmVBcnJheVBvb2wgPSBbXTtcbmxldCBCYXRjaFJlbmRlcmVyID0gX0JhdGNoUmVuZGVyZXI7XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKEJhdGNoUmVuZGVyZXIpO1xuZXhwb3J0cy5CYXRjaFJlbmRlcmVyID0gQmF0Y2hSZW5kZXJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoUmVuZGVyZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtYXRoID0gcmVxdWlyZShcIkBwaXhpL21hdGhcIiksIFByb2dyYW0gPSByZXF1aXJlKFwiLi4vc2hhZGVyL1Byb2dyYW0uanNcIiksIFNoYWRlciA9IHJlcXVpcmUoXCIuLi9zaGFkZXIvU2hhZGVyLmpzXCIpLCBVbmlmb3JtR3JvdXAgPSByZXF1aXJlKFwiLi4vc2hhZGVyL1VuaWZvcm1Hcm91cC5qc1wiKTtcbmNsYXNzIEJhdGNoU2hhZGVyR2VuZXJhdG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB2ZXJ0ZXhTcmMgLSBWZXJ0ZXggc2hhZGVyXG4gICAqIEBwYXJhbSBmcmFnVGVtcGxhdGUgLSBGcmFnbWVudCBzaGFkZXIgdGVtcGxhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZlcnRleFNyYywgZnJhZ1RlbXBsYXRlKSB7XG4gICAgaWYgKHRoaXMudmVydGV4U3JjID0gdmVydGV4U3JjLCB0aGlzLmZyYWdUZW1wbGF0ZSA9IGZyYWdUZW1wbGF0ZSwgdGhpcy5wcm9ncmFtQ2FjaGUgPSB7fSwgdGhpcy5kZWZhdWx0R3JvdXBDYWNoZSA9IHt9LCAhZnJhZ1RlbXBsYXRlLmluY2x1ZGVzKFwiJWNvdW50JVwiKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignRnJhZ21lbnQgdGVtcGxhdGUgbXVzdCBjb250YWluIFwiJWNvdW50JVwiLicpO1xuICAgIGlmICghZnJhZ1RlbXBsYXRlLmluY2x1ZGVzKFwiJWZvcmxvb3AlXCIpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcmFnbWVudCB0ZW1wbGF0ZSBtdXN0IGNvbnRhaW4gXCIlZm9ybG9vcCVcIi4nKTtcbiAgfVxuICBnZW5lcmF0ZVNoYWRlcihtYXhUZXh0dXJlcykge1xuICAgIGlmICghdGhpcy5wcm9ncmFtQ2FjaGVbbWF4VGV4dHVyZXNdKSB7XG4gICAgICBjb25zdCBzYW1wbGVWYWx1ZXMgPSBuZXcgSW50MzJBcnJheShtYXhUZXh0dXJlcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspXG4gICAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGk7XG4gICAgICB0aGlzLmRlZmF1bHRHcm91cENhY2hlW21heFRleHR1cmVzXSA9IFVuaWZvcm1Hcm91cC5Vbmlmb3JtR3JvdXAuZnJvbSh7IHVTYW1wbGVyczogc2FtcGxlVmFsdWVzIH0sICEwKTtcbiAgICAgIGxldCBmcmFnbWVudFNyYyA9IHRoaXMuZnJhZ1RlbXBsYXRlO1xuICAgICAgZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYy5yZXBsYWNlKC8lY291bnQlL2dpLCBgJHttYXhUZXh0dXJlc31gKSwgZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYy5yZXBsYWNlKC8lZm9ybG9vcCUvZ2ksIHRoaXMuZ2VuZXJhdGVTYW1wbGVTcmMobWF4VGV4dHVyZXMpKSwgdGhpcy5wcm9ncmFtQ2FjaGVbbWF4VGV4dHVyZXNdID0gbmV3IFByb2dyYW0uUHJvZ3JhbSh0aGlzLnZlcnRleFNyYywgZnJhZ21lbnRTcmMpO1xuICAgIH1cbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIHRpbnQ6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSxcbiAgICAgIHRyYW5zbGF0aW9uTWF0cml4OiBuZXcgbWF0aC5NYXRyaXgoKSxcbiAgICAgIGRlZmF1bHQ6IHRoaXMuZGVmYXVsdEdyb3VwQ2FjaGVbbWF4VGV4dHVyZXNdXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFNoYWRlci5TaGFkZXIodGhpcy5wcm9ncmFtQ2FjaGVbbWF4VGV4dHVyZXNdLCB1bmlmb3Jtcyk7XG4gIH1cbiAgZ2VuZXJhdGVTYW1wbGVTcmMobWF4VGV4dHVyZXMpIHtcbiAgICBsZXQgc3JjID0gXCJcIjtcbiAgICBzcmMgKz0gYFxuYCwgc3JjICs9IGBcbmA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKVxuICAgICAgaSA+IDAgJiYgKHNyYyArPSBgXG5lbHNlIGApLCBpIDwgbWF4VGV4dHVyZXMgLSAxICYmIChzcmMgKz0gYGlmKHZUZXh0dXJlSWQgPCAke2l9LjUpYCksIHNyYyArPSBgXG57YCwgc3JjICs9IGBcblx0Y29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXJzWyR7aX1dLCB2VGV4dHVyZUNvb3JkKTtgLCBzcmMgKz0gYFxufWA7XG4gICAgcmV0dXJuIHNyYyArPSBgXG5gLCBzcmMgKz0gYFxuYCwgc3JjO1xuICB9XG59XG5leHBvcnRzLkJhdGNoU2hhZGVyR2VuZXJhdG9yID0gQmF0Y2hTaGFkZXJHZW5lcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaFNoYWRlckdlbmVyYXRvci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4dGVuc2lvbnMgPSByZXF1aXJlKFwiQHBpeGkvZXh0ZW5zaW9uc1wiKSwgT2JqZWN0UmVuZGVyZXIgPSByZXF1aXJlKFwiLi9PYmplY3RSZW5kZXJlci5qc1wiKTtcbmNsYXNzIEJhdGNoU3lzdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIFN5c3RlbSB3b3JrcyBmb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlciwgdGhpcy5lbXB0eVJlbmRlcmVyID0gbmV3IE9iamVjdFJlbmRlcmVyLk9iamVjdFJlbmRlcmVyKHJlbmRlcmVyKSwgdGhpcy5jdXJyZW50UmVuZGVyZXIgPSB0aGlzLmVtcHR5UmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgcmVuZGVyZXIgdG8gdGhlIG9uZSBnaXZlbiBpbiBwYXJhbWV0ZXJcbiAgICogQHBhcmFtIG9iamVjdFJlbmRlcmVyIC0gVGhlIG9iamVjdCByZW5kZXJlciB0byB1c2UuXG4gICAqL1xuICBzZXRPYmplY3RSZW5kZXJlcihvYmplY3RSZW5kZXJlcikge1xuICAgIHRoaXMuY3VycmVudFJlbmRlcmVyICE9PSBvYmplY3RSZW5kZXJlciAmJiAodGhpcy5jdXJyZW50UmVuZGVyZXIuc3RvcCgpLCB0aGlzLmN1cnJlbnRSZW5kZXJlciA9IG9iamVjdFJlbmRlcmVyLCB0aGlzLmN1cnJlbnRSZW5kZXJlci5zdGFydCgpKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGlmIHlvdSB3aXNoIHRvIGRvIHNvbWUgY3VzdG9tIHJlbmRlcmluZ1xuICAgKiBJdCB3aWxsIGJhc2ljYWxseSByZW5kZXIgYW55dGhpbmcgdGhhdCBtYXkgYmUgYmF0Y2hlZCB1cCBzdWNoIGFzIHNwcml0ZXNcbiAgICovXG4gIGZsdXNoKCkge1xuICAgIHRoaXMuc2V0T2JqZWN0UmVuZGVyZXIodGhpcy5lbXB0eVJlbmRlcmVyKTtcbiAgfVxuICAvKiogUmVzZXQgdGhlIHN5c3RlbSB0byBhbiBlbXB0eSByZW5kZXJlciAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnNldE9iamVjdFJlbmRlcmVyKHRoaXMuZW1wdHlSZW5kZXJlcik7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmR5IGZ1bmN0aW9uIGZvciBiYXRjaCByZW5kZXJlcnM6IGNvcGllcyBib3VuZCB0ZXh0dXJlcyBpbiBmaXJzdCBtYXhUZXh0dXJlcyBsb2NhdGlvbnMgdG8gYXJyYXlcbiAgICogc2V0cyBhY3R1YWwgX2JhdGNoTG9jYXRpb24gZm9yIHRoZW1cbiAgICogQHBhcmFtIGFyciAtIGFyciBjb3B5IGRlc3RpbmF0aW9uXG4gICAqIEBwYXJhbSBtYXhUZXh0dXJlcyAtIG51bWJlciBvZiBjb3BpZWQgZWxlbWVudHNcbiAgICovXG4gIGNvcHlCb3VuZFRleHR1cmVzKGFyciwgbWF4VGV4dHVyZXMpIHtcbiAgICBjb25zdCB7IGJvdW5kVGV4dHVyZXMgfSA9IHRoaXMucmVuZGVyZXIudGV4dHVyZTtcbiAgICBmb3IgKGxldCBpID0gbWF4VGV4dHVyZXMgLSAxOyBpID49IDA7IC0taSlcbiAgICAgIGFycltpXSA9IGJvdW5kVGV4dHVyZXNbaV0gfHwgbnVsbCwgYXJyW2ldICYmIChhcnJbaV0uX2JhdGNoTG9jYXRpb24gPSBpKTtcbiAgfVxuICAvKipcbiAgICogQXNzaWducyBiYXRjaCBsb2NhdGlvbnMgdG8gdGV4dHVyZXMgaW4gYXJyYXkgYmFzZWQgb24gYm91bmRUZXh0dXJlcyBzdGF0ZS5cbiAgICogQWxsIHRleHR1cmVzIGluIHRleEFycmF5IHNob3VsZCBoYXZlIGBfYmF0Y2hFbmFibGVkID0gX2JhdGNoSWRgLFxuICAgKiBhbmQgdGhlaXIgY291bnQgc2hvdWxkIGJlIGxlc3MgdGhhbiBgbWF4VGV4dHVyZXNgLlxuICAgKiBAcGFyYW0gdGV4QXJyYXkgLSB0ZXh0dXJlcyB0byBib3VuZFxuICAgKiBAcGFyYW0gYm91bmRUZXh0dXJlcyAtIGN1cnJlbnQgc3RhdGUgb2YgYm91bmQgdGV4dHVyZXNcbiAgICogQHBhcmFtIGJhdGNoSWQgLSBtYXJrZXIgZm9yIF9iYXRjaEVuYWJsZWQgcGFyYW0gb2YgdGV4dHVyZXMgaW4gdGV4QXJyYXlcbiAgICogQHBhcmFtIG1heFRleHR1cmVzIC0gbnVtYmVyIG9mIHRleHR1cmUgbG9jYXRpb25zIHRvIG1hbmlwdWxhdGVcbiAgICovXG4gIGJvdW5kQXJyYXkodGV4QXJyYXksIGJvdW5kVGV4dHVyZXMsIGJhdGNoSWQsIG1heFRleHR1cmVzKSB7XG4gICAgY29uc3QgeyBlbGVtZW50cywgaWRzLCBjb3VudCB9ID0gdGV4QXJyYXk7XG4gICAgbGV0IGogPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGV4ID0gZWxlbWVudHNbaV0sIGxvYyA9IHRleC5fYmF0Y2hMb2NhdGlvbjtcbiAgICAgIGlmIChsb2MgPj0gMCAmJiBsb2MgPCBtYXhUZXh0dXJlcyAmJiBib3VuZFRleHR1cmVzW2xvY10gPT09IHRleCkge1xuICAgICAgICBpZHNbaV0gPSBsb2M7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yICg7IGogPCBtYXhUZXh0dXJlczsgKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kID0gYm91bmRUZXh0dXJlc1tqXTtcbiAgICAgICAgaWYgKGJvdW5kICYmIGJvdW5kLl9iYXRjaEVuYWJsZWQgPT09IGJhdGNoSWQgJiYgYm91bmQuX2JhdGNoTG9jYXRpb24gPT09IGopIHtcbiAgICAgICAgICBqKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWRzW2ldID0gaiwgdGV4Ll9iYXRjaExvY2F0aW9uID0gaiwgYm91bmRUZXh0dXJlc1tqXSA9IHRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5CYXRjaFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJiYXRjaFwiXG59O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChCYXRjaFN5c3RlbSk7XG5leHBvcnRzLkJhdGNoU3lzdGVtID0gQmF0Y2hTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaFN5c3RlbS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgQmF0Y2hUZXh0dXJlQXJyYXkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gW10sIHRoaXMuaWRzID0gW10sIHRoaXMuY291bnQgPSAwO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudDsgaSsrKVxuICAgICAgdGhpcy5lbGVtZW50c1tpXSA9IG51bGw7XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cbn1cbmV4cG9ydHMuQmF0Y2hUZXh0dXJlQXJyYXkgPSBCYXRjaFRleHR1cmVBcnJheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoVGV4dHVyZUFycmF5LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBPYmplY3RSZW5kZXJlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBtYW5hZ2VyIHdvcmtzIGZvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIC8qKiBTdHViIG1ldGhvZCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGVtcHR5IHRoZSBjdXJyZW50IGJhdGNoIGJ5IHJlbmRlcmluZyBvYmplY3RzIG5vdy4gKi9cbiAgZmx1c2goKSB7XG4gIH1cbiAgLyoqIEdlbmVyaWMgZGVzdHJ1Y3Rpb24gbWV0aG9kIHRoYXQgZnJlZXMgYWxsIHJlc291cmNlcy4gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJ5IHN1YmNsYXNzZXMuICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFN0dWIgbWV0aG9kIHRoYXQgaW5pdGlhbGl6ZXMgYW55IHN0YXRlIHJlcXVpcmVkIGJlZm9yZVxuICAgKiByZW5kZXJpbmcgc3RhcnRzLiBJdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYHByZXJlbmRlcmBcbiAgICogc2lnbmFsLCB3aGljaCBvY2N1cnMgZXZlcnkgZnJhbWUsIGluIHRoYXQgaXQgaXMgY2FsbGVkXG4gICAqIHdoZW5ldmVyIGFuIG9iamVjdCByZXF1ZXN0cyBfdGhpc18gcmVuZGVyZXIgc3BlY2lmaWNhbGx5LlxuICAgKi9cbiAgc3RhcnQoKSB7XG4gIH1cbiAgLyoqIFN0b3BzIHRoZSByZW5kZXJlci4gSXQgc2hvdWxkIGZyZWUgdXAgYW55IHN0YXRlIGFuZCBiZWNvbWUgZG9ybWFudC4gKi9cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIEtlZXBzIHRoZSBvYmplY3QgdG8gcmVuZGVyLiBJdCBkb2Vzbid0IGhhdmUgdG8gYmVcbiAgICogcmVuZGVyZWQgaW1tZWRpYXRlbHkuXG4gICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBfb2JqZWN0IC0gVGhlIG9iamVjdCB0byByZW5kZXIuXG4gICAqL1xuICByZW5kZXIoX29iamVjdCkge1xuICB9XG59XG5leHBvcnRzLk9iamVjdFJlbmRlcmVyID0gT2JqZWN0UmVuZGVyZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYmplY3RSZW5kZXJlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZShcIkBwaXhpL3NldHRpbmdzXCIpO1xuZnVuY3Rpb24gY2FuVXBsb2FkU2FtZUJ1ZmZlcigpIHtcbiAgcmV0dXJuICFzZXR0aW5ncy5pc01vYmlsZS5hcHBsZS5kZXZpY2U7XG59XG5leHBvcnRzLmNhblVwbG9hZFNhbWVCdWZmZXIgPSBjYW5VcGxvYWRTYW1lQnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FuVXBsb2FkU2FtZUJ1ZmZlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZShcIkBwaXhpL3NldHRpbmdzXCIpO1xuZnVuY3Rpb24gbWF4UmVjb21tZW5kZWRUZXh0dXJlcyhtYXgpIHtcbiAgbGV0IGFsbG93TWF4ID0gITA7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHNldHRpbmdzLnNldHRpbmdzLkFEQVBURVIuZ2V0TmF2aWdhdG9yKCk7XG4gIGlmIChzZXR0aW5ncy5pc01vYmlsZS50YWJsZXQgfHwgc2V0dGluZ3MuaXNNb2JpbGUucGhvbmUpIHtcbiAgICBpZiAoc2V0dGluZ3MuaXNNb2JpbGUuYXBwbGUuZGV2aWNlKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL09TIChcXGQrKV8oXFxkKyk/Lyk7XG4gICAgICBtYXRjaCAmJiBwYXJzZUludChtYXRjaFsxXSwgMTApIDwgMTEgJiYgKGFsbG93TWF4ID0gITEpO1xuICAgIH1cbiAgICBpZiAoc2V0dGluZ3MuaXNNb2JpbGUuYW5kcm9pZC5kZXZpY2UpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZFxccyhbMC05Ll0qKS8pO1xuICAgICAgbWF0Y2ggJiYgcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSA8IDcgJiYgKGFsbG93TWF4ID0gITEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxsb3dNYXggPyBtYXggOiA0O1xufVxuZXhwb3J0cy5tYXhSZWNvbW1lbmRlZFRleHR1cmVzID0gbWF4UmVjb21tZW5kZWRUZXh0dXJlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heFJlY29tbWVuZGVkVGV4dHVyZXMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgZGVmYXVsdEZyYWdtZW50ID0gYHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xudmFyeWluZyB2ZWM0IHZDb2xvcjtcbnZhcnlpbmcgZmxvYXQgdlRleHR1cmVJZDtcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyc1slY291bnQlXTtcblxudm9pZCBtYWluKHZvaWQpe1xuICAgIHZlYzQgY29sb3I7XG4gICAgJWZvcmxvb3AlXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiB2Q29sb3I7XG59XG5gO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdEZyYWdtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZS5mcmFnLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIGRlZmF1bHRWZXJ0ZXggPSBgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbmF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcbmF0dHJpYnV0ZSBmbG9hdCBhVGV4dHVyZUlkO1xuXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcbnVuaWZvcm0gdmVjNCB0aW50O1xuXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG52YXJ5aW5nIGZsb2F0IHZUZXh0dXJlSWQ7XG5cbnZvaWQgbWFpbih2b2lkKXtcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xuXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG4gICAgdlRleHR1cmVJZCA9IGFUZXh0dXJlSWQ7XG4gICAgdkNvbG9yID0gYUNvbG9yICogdGludDtcbn1cbmA7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0VmVydGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZS52ZXJ0LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKSwgZXh0ZW5zaW9ucyA9IHJlcXVpcmUoXCJAcGl4aS9leHRlbnNpb25zXCIpLCBzZXR0aW5ncyA9IHJlcXVpcmUoXCJAcGl4aS9zZXR0aW5nc1wiKTtcbmxldCBDT05URVhUX1VJRF9DT1VOVEVSID0gMDtcbmNsYXNzIENvbnRleHRTeXN0ZW0ge1xuICAvKiogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci4gKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIsIHRoaXMud2ViR0xWZXJzaW9uID0gMSwgdGhpcy5leHRlbnNpb25zID0ge30sIHRoaXMuc3VwcG9ydHMgPSB7XG4gICAgICB1aW50MzJJbmRpY2VzOiAhMVxuICAgIH0sIHRoaXMuaGFuZGxlQ29udGV4dExvc3QgPSB0aGlzLmhhbmRsZUNvbnRleHRMb3N0LmJpbmQodGhpcyksIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkID0gdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQuYmluZCh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogYHRydWVgIGlmIHRoZSBjb250ZXh0IGlzIGxvc3RcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgaXNMb3N0KCkge1xuICAgIHJldHVybiAhdGhpcy5nbCB8fCB0aGlzLmdsLmlzQ29udGV4dExvc3QoKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgY29udGV4dCBjaGFuZ2UgZXZlbnQuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIE5ldyBXZWJHTCBjb250ZXh0LlxuICAgKi9cbiAgY29udGV4dENoYW5nZShnbCkge1xuICAgIHRoaXMuZ2wgPSBnbCwgdGhpcy5yZW5kZXJlci5nbCA9IGdsLCB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEID0gQ09OVEVYVF9VSURfQ09VTlRFUisrO1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmNvbnRleHQpXG4gICAgICB0aGlzLmluaXRGcm9tQ29udGV4dChvcHRpb25zLmNvbnRleHQpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgYWxwaGEgPSB0aGlzLnJlbmRlcmVyLmJhY2tncm91bmQuYWxwaGEgPCAxLCBwcmVtdWx0aXBsaWVkQWxwaGEgPSBvcHRpb25zLnByZW11bHRpcGxpZWRBbHBoYTtcbiAgICAgIHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsIHRoaXMudXNlQ29udGV4dEFscGhhID0gb3B0aW9ucy51c2VDb250ZXh0QWxwaGEsIHRoaXMucG93ZXJQcmVmZXJlbmNlID0gb3B0aW9ucy5wb3dlclByZWZlcmVuY2UsIHRoaXMuaW5pdEZyb21PcHRpb25zKHtcbiAgICAgICAgYWxwaGEsXG4gICAgICAgIHByZW11bHRpcGxpZWRBbHBoYSxcbiAgICAgICAgYW50aWFsaWFzOiBvcHRpb25zLmFudGlhbGlhcyxcbiAgICAgICAgc3RlbmNpbDogITAsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsXG4gICAgICAgIHBvd2VyUHJlZmVyZW5jZTogb3B0aW9ucy5wb3dlclByZWZlcmVuY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbnRleHQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gV2ViR0wgY29udGV4dFxuICAgKi9cbiAgaW5pdEZyb21Db250ZXh0KGdsKSB7XG4gICAgdGhpcy5nbCA9IGdsLCB0aGlzLnZhbGlkYXRlQ29udGV4dChnbCksIHRoaXMucmVuZGVyZXIuZ2wgPSBnbCwgdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRCA9IENPTlRFWFRfVUlEX0NPVU5URVIrKywgdGhpcy5yZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UuZW1pdChnbCk7XG4gICAgY29uc3QgdmlldyA9IHRoaXMucmVuZGVyZXIudmlldztcbiAgICB2aWV3LmFkZEV2ZW50TGlzdGVuZXIgIT09IHZvaWQgMCAmJiAodmlldy5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLCB0aGlzLmhhbmRsZUNvbnRleHRMb3N0LCAhMSksIHZpZXcuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dHJlc3RvcmVkXCIsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLCAhMSkpO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGZyb20gY29udGV4dCBvcHRpb25zXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvZ2V0Q29udGV4dFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGNvbnRleHQgYXR0cmlidXRlc1xuICAgKi9cbiAgaW5pdEZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuY3JlYXRlQ29udGV4dCh0aGlzLnJlbmRlcmVyLnZpZXcsIG9wdGlvbnMpO1xuICAgIHRoaXMuaW5pdEZyb21Db250ZXh0KGdsKTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIFdlYkdMIENvbnRleHRcbiAgICogQHBhcmFtIGNhbnZhcyAtIHRoZSBjYW52YXMgZWxlbWVudCB0aGF0IHdlIHdpbGwgZ2V0IHRoZSBjb250ZXh0IGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0aGF0IGdldHMgcGFzc2VkIGluIHRvIHRoZSBjYW52YXMgZWxlbWVudCBjb250YWluaW5nIHRoZVxuICAgKiAgICBjb250ZXh0IGF0dHJpYnV0ZXNcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvZ2V0Q29udGV4dFxuICAgKiBAcmV0dXJucyB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSB0aGUgV2ViR0wgY29udGV4dFxuICAgKi9cbiAgY3JlYXRlQ29udGV4dChjYW52YXMsIG9wdGlvbnMpIHtcbiAgICBsZXQgZ2w7XG4gICAgaWYgKHNldHRpbmdzLnNldHRpbmdzLlBSRUZFUl9FTlYgPj0gY29uc3RhbnRzLkVOVi5XRUJHTDIgJiYgKGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgb3B0aW9ucykpLCBnbClcbiAgICAgIHRoaXMud2ViR0xWZXJzaW9uID0gMjtcbiAgICBlbHNlIGlmICh0aGlzLndlYkdMVmVyc2lvbiA9IDEsIGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCBvcHRpb25zKSB8fCBjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBvcHRpb25zKSwgIWdsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViR0wuIFRyeSB1c2luZyB0aGUgY2FudmFzIHJlbmRlcmVyXCIpO1xuICAgIHJldHVybiB0aGlzLmdsID0gZ2wsIHRoaXMuZ2V0RXh0ZW5zaW9ucygpLCB0aGlzLmdsO1xuICB9XG4gIC8qKiBBdXRvLXBvcHVsYXRlIHRoZSB7QGxpbmsgUElYSS5Db250ZXh0U3lzdGVtLmV4dGVuc2lvbnMgZXh0ZW5zaW9uc30uICovXG4gIGdldEV4dGVuc2lvbnMoKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcywgY29tbW9uID0ge1xuICAgICAgbG9zZUNvbnRleHQ6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKSxcbiAgICAgIGFuaXNvdHJvcGljRmlsdGVyaW5nOiBnbC5nZXRFeHRlbnNpb24oXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIiksXG4gICAgICBmbG9hdFRleHR1cmVMaW5lYXI6IGdsLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiKSxcbiAgICAgIHMzdGM6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXCIpLFxuICAgICAgczN0Y19zUkdCOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiXCIpLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIGV0YzogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0Y1wiKSxcbiAgICAgIGV0YzE6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxXCIpLFxuICAgICAgcHZydGM6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1wiKSB8fCBnbC5nZXRFeHRlbnNpb24oXCJXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXCIpLFxuICAgICAgYXRjOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXRjXCIpLFxuICAgICAgYXN0YzogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2FzdGNcIilcbiAgICB9O1xuICAgIHRoaXMud2ViR0xWZXJzaW9uID09PSAxID8gT2JqZWN0LmFzc2lnbih0aGlzLmV4dGVuc2lvbnMsIGNvbW1vbiwge1xuICAgICAgZHJhd0J1ZmZlcnM6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2RyYXdfYnVmZmVyc1wiKSxcbiAgICAgIGRlcHRoVGV4dHVyZTogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfZGVwdGhfdGV4dHVyZVwiKSxcbiAgICAgIHZlcnRleEFycmF5T2JqZWN0OiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdmVydGV4X2FycmF5X29iamVjdFwiKSB8fCBnbC5nZXRFeHRlbnNpb24oXCJNT1pfT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIikgfHwgZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XCIpLFxuICAgICAgdWludDMyRWxlbWVudEluZGV4OiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfZWxlbWVudF9pbmRleF91aW50XCIpLFxuICAgICAgLy8gRmxvYXRzIGFuZCBoYWxmLWZsb2F0c1xuICAgICAgZmxvYXRUZXh0dXJlOiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSxcbiAgICAgIGZsb2F0VGV4dHVyZUxpbmVhcjogZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCIpLFxuICAgICAgdGV4dHVyZUhhbGZGbG9hdDogZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSxcbiAgICAgIHRleHR1cmVIYWxmRmxvYXRMaW5lYXI6IGdsLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXCIpXG4gICAgfSkgOiB0aGlzLndlYkdMVmVyc2lvbiA9PT0gMiAmJiBPYmplY3QuYXNzaWduKHRoaXMuZXh0ZW5zaW9ucywgY29tbW9uLCB7XG4gICAgICAvLyBGbG9hdHMgYW5kIGhhbGYtZmxvYXRzXG4gICAgICBjb2xvckJ1ZmZlckZsb2F0OiBnbC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBsb3N0IHdlYmdsIGNvbnRleHRcbiAgICogQHBhcmFtIHtXZWJHTENvbnRleHRFdmVudH0gZXZlbnQgLSBUaGUgY29udGV4dCBsb3N0IGV2ZW50LlxuICAgKi9cbiAgaGFuZGxlQ29udGV4dExvc3QoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZ2wuaXNDb250ZXh0TG9zdCgpICYmIHRoaXMuZXh0ZW5zaW9ucy5sb3NlQ29udGV4dCAmJiB0aGlzLmV4dGVuc2lvbnMubG9zZUNvbnRleHQucmVzdG9yZUNvbnRleHQoKTtcbiAgICB9LCAwKTtcbiAgfVxuICAvKiogSGFuZGxlcyBhIHJlc3RvcmVkIHdlYmdsIGNvbnRleHQuICovXG4gIGhhbmRsZUNvbnRleHRSZXN0b3JlZCgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnJ1bm5lcnMuY29udGV4dENoYW5nZS5lbWl0KHRoaXMuZ2wpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgdmlldyA9IHRoaXMucmVuZGVyZXIudmlldztcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbCwgdmlldy5yZW1vdmVFdmVudExpc3RlbmVyICE9PSB2b2lkIDAgJiYgKHZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGxvc3RcIiwgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCksIHZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dHJlc3RvcmVkXCIsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkKSksIHRoaXMuZ2wudXNlUHJvZ3JhbShudWxsKSwgdGhpcy5leHRlbnNpb25zLmxvc2VDb250ZXh0ICYmIHRoaXMuZXh0ZW5zaW9ucy5sb3NlQ29udGV4dC5sb3NlQ29udGV4dCgpO1xuICB9XG4gIC8qKiBIYW5kbGUgdGhlIHBvc3QtcmVuZGVyIHJ1bm5lciBldmVudC4gKi9cbiAgcG9zdHJlbmRlcigpIHtcbiAgICB0aGlzLnJlbmRlcmVyLm9iamVjdFJlbmRlcmVyLnJlbmRlcmluZ1RvU2NyZWVuICYmIHRoaXMuZ2wuZmx1c2goKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgY29udGV4dC5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gUmVuZGVyIGNvbnRleHQuXG4gICAqL1xuICB2YWxpZGF0ZUNvbnRleHQoZ2wpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKSwgaXNXZWJHbDIgPSBcIldlYkdMMlJlbmRlcmluZ0NvbnRleHRcIiBpbiBnbG9iYWxUaGlzICYmIGdsIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgIGlzV2ViR2wyICYmICh0aGlzLndlYkdMVmVyc2lvbiA9IDIpLCBhdHRyaWJ1dGVzICYmICFhdHRyaWJ1dGVzLnN0ZW5jaWwgJiYgY29uc29sZS53YXJuKFwiUHJvdmlkZWQgV2ViR0wgY29udGV4dCBkb2VzIG5vdCBoYXZlIGEgc3RlbmNpbCBidWZmZXIsIG1hc2tzIG1heSBub3QgcmVuZGVyIGNvcnJlY3RseVwiKTtcbiAgICBjb25zdCBoYXN1aW50MzIgPSBpc1dlYkdsMiB8fCAhIWdsLmdldEV4dGVuc2lvbihcIk9FU19lbGVtZW50X2luZGV4X3VpbnRcIik7XG4gICAgdGhpcy5zdXBwb3J0cy51aW50MzJJbmRpY2VzID0gaGFzdWludDMyLCBoYXN1aW50MzIgfHwgY29uc29sZS53YXJuKFwiUHJvdmlkZWQgV2ViR0wgY29udGV4dCBkb2VzIG5vdCBzdXBwb3J0IDMyIGluZGV4IGJ1ZmZlciwgY29tcGxleCBncmFwaGljcyBtYXkgbm90IHJlbmRlciBjb3JyZWN0bHlcIik7XG4gIH1cbn1cbkNvbnRleHRTeXN0ZW0uZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgUElYSS5JUmVuZGVyZXJPcHRpb25zLmNvbnRleHR9XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3MuUkVOREVSX09QVElPTlNcbiAgICovXG4gIGNvbnRleHQ6IG51bGwsXG4gIC8qKlxuICAgKiB7QGxpbmsgUElYSS5JUmVuZGVyZXJPcHRpb25zLmFudGlhbGlhc31cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3MuUkVOREVSX09QVElPTlNcbiAgICovXG4gIGFudGlhbGlhczogITEsXG4gIC8qKlxuICAgKiB7QGxpbmsgUElYSS5JUmVuZGVyZXJPcHRpb25zLnByZW11bHRpcGxpZWRBbHBoYX1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5ncy5SRU5ERVJfT1BUSU9OU1xuICAgKi9cbiAgcHJlbXVsdGlwbGllZEFscGhhOiAhMCxcbiAgLyoqXG4gICAqIHtAbGluayBQSVhJLklSZW5kZXJlck9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyfVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5ncy5SRU5ERVJfT1BUSU9OU1xuICAgKi9cbiAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiAhMSxcbiAgLyoqXG4gICAqIHtAbGluayBQSVhJLklSZW5kZXJlck9wdGlvbnMucG93ZXJQcmVmZXJlbmNlfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzLlJFTkRFUl9PUFRJT05TXG4gICAqL1xuICBwb3dlclByZWZlcmVuY2U6IFwiZGVmYXVsdFwiXG59LCAvKiogQGlnbm9yZSAqL1xuQ29udGV4dFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJjb250ZXh0XCJcbn07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKENvbnRleHRTeXN0ZW0pO1xuZXhwb3J0cy5Db250ZXh0U3lzdGVtID0gQ29udGV4dFN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRleHRTeXN0ZW0uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiQHBpeGkvY29uc3RhbnRzXCIpLCBQcm9ncmFtID0gcmVxdWlyZShcIi4uL3NoYWRlci9Qcm9ncmFtLmpzXCIpLCBTaGFkZXIgPSByZXF1aXJlKFwiLi4vc2hhZGVyL1NoYWRlci5qc1wiKSwgU3RhdGUgPSByZXF1aXJlKFwiLi4vc3RhdGUvU3RhdGUuanNcIiksIGRlZmF1bHRGaWx0ZXIkMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHRGaWx0ZXIuZnJhZy5qc1wiKSwgZGVmYXVsdEZpbHRlciA9IHJlcXVpcmUoXCIuL2RlZmF1bHRGaWx0ZXIudmVydC5qc1wiKTtcbmNvbnN0IF9GaWx0ZXIgPSBjbGFzcyBfRmlsdGVyMiBleHRlbmRzIFNoYWRlci5TaGFkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHZlcnRleFNyYyAtIFRoZSBzb3VyY2Ugb2YgdGhlIHZlcnRleCBzaGFkZXIuXG4gICAqIEBwYXJhbSBmcmFnbWVudFNyYyAtIFRoZSBzb3VyY2Ugb2YgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICogQHBhcmFtIHVuaWZvcm1zIC0gQ3VzdG9tIHVuaWZvcm1zIHRvIHVzZSB0byBhdWdtZW50IHRoZSBidWlsdC1pbiBvbmVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IodmVydGV4U3JjLCBmcmFnbWVudFNyYywgdW5pZm9ybXMpIHtcbiAgICBjb25zdCBwcm9ncmFtID0gUHJvZ3JhbS5Qcm9ncmFtLmZyb20oXG4gICAgICB2ZXJ0ZXhTcmMgfHwgX0ZpbHRlcjIuZGVmYXVsdFZlcnRleFNyYyxcbiAgICAgIGZyYWdtZW50U3JjIHx8IF9GaWx0ZXIyLmRlZmF1bHRGcmFnbWVudFNyY1xuICAgICk7XG4gICAgc3VwZXIocHJvZ3JhbSwgdW5pZm9ybXMpLCB0aGlzLnBhZGRpbmcgPSAwLCB0aGlzLnJlc29sdXRpb24gPSBfRmlsdGVyMi5kZWZhdWx0UmVzb2x1dGlvbiwgdGhpcy5tdWx0aXNhbXBsZSA9IF9GaWx0ZXIyLmRlZmF1bHRNdWx0aXNhbXBsZSwgdGhpcy5lbmFibGVkID0gITAsIHRoaXMuYXV0b0ZpdCA9ICEwLCB0aGlzLnN0YXRlID0gbmV3IFN0YXRlLlN0YXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0ge1BJWEkuRmlsdGVyU3lzdGVtfSBmaWx0ZXJNYW5hZ2VyIC0gVGhlIHJlbmRlcmVyIHRvIHJldHJpZXZlIHRoZSBmaWx0ZXIgZnJvbVxuICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gaW5wdXQgLSBUaGUgaW5wdXQgcmVuZGVyIHRhcmdldC5cbiAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IG91dHB1dCAtIFRoZSB0YXJnZXQgdG8gb3V0cHV0IHRvLlxuICAgKiBAcGFyYW0ge1BJWEkuQ0xFQVJfTU9ERVN9IFtjbGVhck1vZGVdIC0gU2hvdWxkIHRoZSBvdXRwdXQgYmUgY2xlYXJlZCBiZWZvcmUgcmVuZGVyaW5nIHRvIGl0LlxuICAgKiBAcGFyYW0ge29iamVjdH0gW19jdXJyZW50U3RhdGVdIC0gSXQncyBjdXJyZW50IHN0YXRlIG9mIGZpbHRlci5cbiAgICogICAgICAgIFRoZXJlIGFyZSBzb21lIHVzZWZ1bCBwcm9wZXJ0aWVzIGluIHRoZSBjdXJyZW50U3RhdGUgOlxuICAgKiAgICAgICAgdGFyZ2V0LCBmaWx0ZXJzLCBzb3VyY2VGcmFtZSwgZGVzdGluYXRpb25GcmFtZSwgcmVuZGVyVGFyZ2V0LCByZXNvbHV0aW9uXG4gICAqL1xuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUsIF9jdXJyZW50U3RhdGUpIHtcbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJsZW5kIG1vZGUgb2YgdGhlIGZpbHRlci5cbiAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcbiAgICovXG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuYmxlbmRNb2RlO1xuICB9XG4gIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgZmlsdGVyLiBTZXR0aW5nIHRoaXMgdG8gYmUgbG93ZXIgd2lsbCBsb3dlciB0aGUgcXVhbGl0eSBidXRcbiAgICogaW5jcmVhc2UgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBmaWx0ZXIuXG4gICAqIElmIHNldCB0byBgbnVsbGAgb3IgYDBgLCB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgY3VycmVudCByZW5kZXIgdGFyZ2V0IGlzIHVzZWQuXG4gICAqIEBkZWZhdWx0IFBJWEkuRmlsdGVyLmRlZmF1bHRSZXNvbHV0aW9uXG4gICAqL1xuICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbjtcbiAgfVxuICBzZXQgcmVzb2x1dGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3Jlc29sdXRpb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgdmVydGV4IHNoYWRlciBzb3VyY2VcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRWZXJ0ZXhTcmMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXIuZGVmYXVsdDtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEZyYWdtZW50U3JjKCkge1xuICAgIHJldHVybiBkZWZhdWx0RmlsdGVyJDEuZGVmYXVsdDtcbiAgfVxufTtcbl9GaWx0ZXIuZGVmYXVsdFJlc29sdXRpb24gPSAxLCAvKipcbiogRGVmYXVsdCBmaWx0ZXIgc2FtcGxlcyBmb3IgYW55IGZpbHRlci5cbiogQHN0YXRpY1xuKiBAdHlwZSB7UElYSS5NU0FBX1FVQUxJVFl8bnVsbH1cbiogQGRlZmF1bHQgUElYSS5NU0FBX1FVQUxJVFkuTk9ORVxuKi9cbl9GaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlID0gY29uc3RhbnRzLk1TQUFfUVVBTElUWS5OT05FO1xubGV0IEZpbHRlciA9IF9GaWx0ZXI7XG5leHBvcnRzLkZpbHRlciA9IEZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbHRlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCJAcGl4aS9jb25zdGFudHNcIiksIG1hdGggPSByZXF1aXJlKFwiQHBpeGkvbWF0aFwiKTtcbmNsYXNzIEZpbHRlclN0YXRlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZW5kZXJUZXh0dXJlID0gbnVsbCwgdGhpcy50YXJnZXQgPSBudWxsLCB0aGlzLmxlZ2FjeSA9ICExLCB0aGlzLnJlc29sdXRpb24gPSAxLCB0aGlzLm11bHRpc2FtcGxlID0gY29uc3RhbnRzLk1TQUFfUVVBTElUWS5OT05FLCB0aGlzLnNvdXJjZUZyYW1lID0gbmV3IG1hdGguUmVjdGFuZ2xlKCksIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgpLCB0aGlzLmJpbmRpbmdTb3VyY2VGcmFtZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgpLCB0aGlzLmJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lID0gbmV3IG1hdGguUmVjdGFuZ2xlKCksIHRoaXMuZmlsdGVycyA9IFtdLCB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XG4gIH1cbiAgLyoqIENsZWFycyB0aGUgc3RhdGUgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy50YXJnZXQgPSBudWxsLCB0aGlzLmZpbHRlcnMgPSBudWxsLCB0aGlzLnJlbmRlclRleHR1cmUgPSBudWxsO1xuICB9XG59XG5leHBvcnRzLkZpbHRlclN0YXRlID0gRmlsdGVyU3RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWx0ZXJTdGF0ZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCJAcGl4aS9jb25zdGFudHNcIiksIGV4dGVuc2lvbnMgPSByZXF1aXJlKFwiQHBpeGkvZXh0ZW5zaW9uc1wiKSwgbWF0aCA9IHJlcXVpcmUoXCJAcGl4aS9tYXRoXCIpLCBSZW5kZXJUZXh0dXJlUG9vbCA9IHJlcXVpcmUoXCIuLi9yZW5kZXJUZXh0dXJlL1JlbmRlclRleHR1cmVQb29sLmpzXCIpLCBVbmlmb3JtR3JvdXAgPSByZXF1aXJlKFwiLi4vc2hhZGVyL1VuaWZvcm1Hcm91cC5qc1wiKSwgUXVhZCA9IHJlcXVpcmUoXCIuLi91dGlscy9RdWFkLmpzXCIpLCBRdWFkVXYgPSByZXF1aXJlKFwiLi4vdXRpbHMvUXVhZFV2LmpzXCIpLCBGaWx0ZXJTdGF0ZSA9IHJlcXVpcmUoXCIuL0ZpbHRlclN0YXRlLmpzXCIpO1xuY29uc3QgdGVtcFBvaW50cyA9IFtuZXcgbWF0aC5Qb2ludCgpLCBuZXcgbWF0aC5Qb2ludCgpLCBuZXcgbWF0aC5Qb2ludCgpLCBuZXcgbWF0aC5Qb2ludCgpXSwgdGVtcE1hdHJpeCA9IG5ldyBtYXRoLk1hdHJpeCgpO1xuY2xhc3MgRmlsdGVyU3lzdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIFN5c3RlbSB3b3JrcyBmb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlciwgdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2sgPSBbe31dLCB0aGlzLnRleHR1cmVQb29sID0gbmV3IFJlbmRlclRleHR1cmVQb29sLlJlbmRlclRleHR1cmVQb29sKCksIHRoaXMuc3RhdGVQb29sID0gW10sIHRoaXMucXVhZCA9IG5ldyBRdWFkLlF1YWQoKSwgdGhpcy5xdWFkVXYgPSBuZXcgUXVhZFV2LlF1YWRVdigpLCB0aGlzLnRlbXBSZWN0ID0gbmV3IG1hdGguUmVjdGFuZ2xlKCksIHRoaXMuYWN0aXZlU3RhdGUgPSB7fSwgdGhpcy5nbG9iYWxVbmlmb3JtcyA9IG5ldyBVbmlmb3JtR3JvdXAuVW5pZm9ybUdyb3VwKHtcbiAgICAgIG91dHB1dEZyYW1lOiBuZXcgbWF0aC5SZWN0YW5nbGUoKSxcbiAgICAgIGlucHV0U2l6ZTogbmV3IEZsb2F0MzJBcnJheSg0KSxcbiAgICAgIGlucHV0UGl4ZWw6IG5ldyBGbG9hdDMyQXJyYXkoNCksXG4gICAgICBpbnB1dENsYW1wOiBuZXcgRmxvYXQzMkFycmF5KDQpLFxuICAgICAgcmVzb2x1dGlvbjogMSxcbiAgICAgIC8vIGxlZ2FjeSB2YXJpYWJsZXNcbiAgICAgIGZpbHRlckFyZWE6IG5ldyBGbG9hdDMyQXJyYXkoNCksXG4gICAgICBmaWx0ZXJDbGFtcDogbmV3IEZsb2F0MzJBcnJheSg0KVxuICAgIH0sICEwKSwgdGhpcy5mb3JjZUNsZWFyID0gITEsIHRoaXMudXNlTWF4UGFkZGluZyA9ICExO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy50ZXh0dXJlUG9vbC5zZXRTY3JlZW5TaXplKHRoaXMucmVuZGVyZXIudmlldyk7XG4gIH1cbiAgLyoqXG4gICAqIFB1c2hlcyBhIHNldCBvZiBmaWx0ZXJzIHRvIGJlIGFwcGxpZWQgbGF0ZXIgdG8gdGhlIHN5c3RlbS4gVGhpcyB3aWxsIHJlZGlyZWN0IGZ1cnRoZXIgcmVuZGVyaW5nIGludG8gYW5cbiAgICogaW5wdXQgcmVuZGVyLXRleHR1cmUgZm9yIHRoZSByZXN0IG9mIHRoZSBmaWx0ZXJpbmcgcGlwZWxpbmUuXG4gICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9mIHRoZSBmaWx0ZXIgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0gZmlsdGVycyAtIFRoZSBmaWx0ZXJzIHRvIGFwcGx5LlxuICAgKi9cbiAgcHVzaCh0YXJnZXQsIGZpbHRlcnMpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsIGZpbHRlclN0YWNrID0gdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2ssIHN0YXRlID0gdGhpcy5zdGF0ZVBvb2wucG9wKCkgfHwgbmV3IEZpbHRlclN0YXRlLkZpbHRlclN0YXRlKCksIHJlbmRlclRleHR1cmVTeXN0ZW0gPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlO1xuICAgIGxldCBjdXJyZW50UmVzb2x1dGlvbiwgY3VycmVudE11bHRpc2FtcGxlO1xuICAgIGlmIChyZW5kZXJUZXh0dXJlU3lzdGVtLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IHJlbmRlclRleHR1cmUgPSByZW5kZXJUZXh0dXJlU3lzdGVtLmN1cnJlbnQ7XG4gICAgICBjdXJyZW50UmVzb2x1dGlvbiA9IHJlbmRlclRleHR1cmUucmVzb2x1dGlvbiwgY3VycmVudE11bHRpc2FtcGxlID0gcmVuZGVyVGV4dHVyZS5tdWx0aXNhbXBsZTtcbiAgICB9IGVsc2VcbiAgICAgIGN1cnJlbnRSZXNvbHV0aW9uID0gcmVuZGVyZXIucmVzb2x1dGlvbiwgY3VycmVudE11bHRpc2FtcGxlID0gcmVuZGVyZXIubXVsdGlzYW1wbGU7XG4gICAgbGV0IHJlc29sdXRpb24gPSBmaWx0ZXJzWzBdLnJlc29sdXRpb24gfHwgY3VycmVudFJlc29sdXRpb24sIG11bHRpc2FtcGxlID0gZmlsdGVyc1swXS5tdWx0aXNhbXBsZSA/PyBjdXJyZW50TXVsdGlzYW1wbGUsIHBhZGRpbmcgPSBmaWx0ZXJzWzBdLnBhZGRpbmcsIGF1dG9GaXQgPSBmaWx0ZXJzWzBdLmF1dG9GaXQsIGxlZ2FjeSA9IGZpbHRlcnNbMF0ubGVnYWN5ID8/ICEwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZmlsdGVyID0gZmlsdGVyc1tpXTtcbiAgICAgIHJlc29sdXRpb24gPSBNYXRoLm1pbihyZXNvbHV0aW9uLCBmaWx0ZXIucmVzb2x1dGlvbiB8fCBjdXJyZW50UmVzb2x1dGlvbiksIG11bHRpc2FtcGxlID0gTWF0aC5taW4obXVsdGlzYW1wbGUsIGZpbHRlci5tdWx0aXNhbXBsZSA/PyBjdXJyZW50TXVsdGlzYW1wbGUpLCBwYWRkaW5nID0gdGhpcy51c2VNYXhQYWRkaW5nID8gTWF0aC5tYXgocGFkZGluZywgZmlsdGVyLnBhZGRpbmcpIDogcGFkZGluZyArIGZpbHRlci5wYWRkaW5nLCBhdXRvRml0ID0gYXV0b0ZpdCAmJiBmaWx0ZXIuYXV0b0ZpdCwgbGVnYWN5ID0gbGVnYWN5IHx8IChmaWx0ZXIubGVnYWN5ID8/ICEwKTtcbiAgICB9XG4gICAgZmlsdGVyU3RhY2subGVuZ3RoID09PSAxICYmICh0aGlzLmRlZmF1bHRGaWx0ZXJTdGFja1swXS5yZW5kZXJUZXh0dXJlID0gcmVuZGVyVGV4dHVyZVN5c3RlbS5jdXJyZW50KSwgZmlsdGVyU3RhY2sucHVzaChzdGF0ZSksIHN0YXRlLnJlc29sdXRpb24gPSByZXNvbHV0aW9uLCBzdGF0ZS5tdWx0aXNhbXBsZSA9IG11bHRpc2FtcGxlLCBzdGF0ZS5sZWdhY3kgPSBsZWdhY3ksIHN0YXRlLnRhcmdldCA9IHRhcmdldCwgc3RhdGUuc291cmNlRnJhbWUuY29weUZyb20odGFyZ2V0LmZpbHRlckFyZWEgfHwgdGFyZ2V0LmdldEJvdW5kcyghMCkpLCBzdGF0ZS5zb3VyY2VGcmFtZS5wYWQocGFkZGluZyk7XG4gICAgY29uc3Qgc291cmNlRnJhbWVQcm9qZWN0ZWQgPSB0aGlzLnRlbXBSZWN0LmNvcHlGcm9tKHJlbmRlclRleHR1cmVTeXN0ZW0uc291cmNlRnJhbWUpO1xuICAgIHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtICYmIHRoaXMudHJhbnNmb3JtQUFCQihcbiAgICAgIHRlbXBNYXRyaXguY29weUZyb20ocmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0pLmludmVydCgpLFxuICAgICAgc291cmNlRnJhbWVQcm9qZWN0ZWRcbiAgICApLCBhdXRvRml0ID8gKHN0YXRlLnNvdXJjZUZyYW1lLmZpdChzb3VyY2VGcmFtZVByb2plY3RlZCksIChzdGF0ZS5zb3VyY2VGcmFtZS53aWR0aCA8PSAwIHx8IHN0YXRlLnNvdXJjZUZyYW1lLmhlaWdodCA8PSAwKSAmJiAoc3RhdGUuc291cmNlRnJhbWUud2lkdGggPSAwLCBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQgPSAwKSkgOiBzdGF0ZS5zb3VyY2VGcmFtZS5pbnRlcnNlY3RzKHNvdXJjZUZyYW1lUHJvamVjdGVkKSB8fCAoc3RhdGUuc291cmNlRnJhbWUud2lkdGggPSAwLCBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQgPSAwKSwgdGhpcy5yb3VuZEZyYW1lKFxuICAgICAgc3RhdGUuc291cmNlRnJhbWUsXG4gICAgICByZW5kZXJUZXh0dXJlU3lzdGVtLmN1cnJlbnQgPyByZW5kZXJUZXh0dXJlU3lzdGVtLmN1cnJlbnQucmVzb2x1dGlvbiA6IHJlbmRlcmVyLnJlc29sdXRpb24sXG4gICAgICByZW5kZXJUZXh0dXJlU3lzdGVtLnNvdXJjZUZyYW1lLFxuICAgICAgcmVuZGVyVGV4dHVyZVN5c3RlbS5kZXN0aW5hdGlvbkZyYW1lLFxuICAgICAgcmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm1cbiAgICApLCBzdGF0ZS5yZW5kZXJUZXh0dXJlID0gdGhpcy5nZXRPcHRpbWFsRmlsdGVyVGV4dHVyZShcbiAgICAgIHN0YXRlLnNvdXJjZUZyYW1lLndpZHRoLFxuICAgICAgc3RhdGUuc291cmNlRnJhbWUuaGVpZ2h0LFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIG11bHRpc2FtcGxlXG4gICAgKSwgc3RhdGUuZmlsdGVycyA9IGZpbHRlcnMsIHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUud2lkdGggPSBzdGF0ZS5yZW5kZXJUZXh0dXJlLndpZHRoLCBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLmhlaWdodCA9IHN0YXRlLnJlbmRlclRleHR1cmUuaGVpZ2h0O1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uRnJhbWUgPSB0aGlzLnRlbXBSZWN0O1xuICAgIGRlc3RpbmF0aW9uRnJhbWUueCA9IDAsIGRlc3RpbmF0aW9uRnJhbWUueSA9IDAsIGRlc3RpbmF0aW9uRnJhbWUud2lkdGggPSBzdGF0ZS5zb3VyY2VGcmFtZS53aWR0aCwgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgPSBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQsIHN0YXRlLnJlbmRlclRleHR1cmUuZmlsdGVyRnJhbWUgPSBzdGF0ZS5zb3VyY2VGcmFtZSwgc3RhdGUuYmluZGluZ1NvdXJjZUZyYW1lLmNvcHlGcm9tKHJlbmRlclRleHR1cmVTeXN0ZW0uc291cmNlRnJhbWUpLCBzdGF0ZS5iaW5kaW5nRGVzdGluYXRpb25GcmFtZS5jb3B5RnJvbShyZW5kZXJUZXh0dXJlU3lzdGVtLmRlc3RpbmF0aW9uRnJhbWUpLCBzdGF0ZS50cmFuc2Zvcm0gPSByZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSwgcmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0gPSBudWxsLCByZW5kZXJUZXh0dXJlU3lzdGVtLmJpbmQoc3RhdGUucmVuZGVyVGV4dHVyZSwgc3RhdGUuc291cmNlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUpLCByZW5kZXJlci5mcmFtZWJ1ZmZlci5jbGVhcigwLCAwLCAwLCAwKTtcbiAgfVxuICAvKiogUG9wcyBvZmYgdGhlIGZpbHRlciBhbmQgYXBwbGllcyBpdC4gKi9cbiAgcG9wKCkge1xuICAgIGNvbnN0IGZpbHRlclN0YWNrID0gdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2ssIHN0YXRlID0gZmlsdGVyU3RhY2sucG9wKCksIGZpbHRlcnMgPSBzdGF0ZS5maWx0ZXJzO1xuICAgIHRoaXMuYWN0aXZlU3RhdGUgPSBzdGF0ZTtcbiAgICBjb25zdCBnbG9iYWxVbmlmb3JtcyA9IHRoaXMuZ2xvYmFsVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgZ2xvYmFsVW5pZm9ybXMub3V0cHV0RnJhbWUgPSBzdGF0ZS5zb3VyY2VGcmFtZSwgZ2xvYmFsVW5pZm9ybXMucmVzb2x1dGlvbiA9IHN0YXRlLnJlc29sdXRpb247XG4gICAgY29uc3QgaW5wdXRTaXplID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRTaXplLCBpbnB1dFBpeGVsID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRQaXhlbCwgaW5wdXRDbGFtcCA9IGdsb2JhbFVuaWZvcm1zLmlucHV0Q2xhbXA7XG4gICAgaWYgKGlucHV0U2l6ZVswXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUud2lkdGgsIGlucHV0U2l6ZVsxXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0LCBpbnB1dFNpemVbMl0gPSAxIC8gaW5wdXRTaXplWzBdLCBpbnB1dFNpemVbM10gPSAxIC8gaW5wdXRTaXplWzFdLCBpbnB1dFBpeGVsWzBdID0gTWF0aC5yb3VuZChpbnB1dFNpemVbMF0gKiBzdGF0ZS5yZXNvbHV0aW9uKSwgaW5wdXRQaXhlbFsxXSA9IE1hdGgucm91bmQoaW5wdXRTaXplWzFdICogc3RhdGUucmVzb2x1dGlvbiksIGlucHV0UGl4ZWxbMl0gPSAxIC8gaW5wdXRQaXhlbFswXSwgaW5wdXRQaXhlbFszXSA9IDEgLyBpbnB1dFBpeGVsWzFdLCBpbnB1dENsYW1wWzBdID0gMC41ICogaW5wdXRQaXhlbFsyXSwgaW5wdXRDbGFtcFsxXSA9IDAuNSAqIGlucHV0UGl4ZWxbM10sIGlucHV0Q2xhbXBbMl0gPSBzdGF0ZS5zb3VyY2VGcmFtZS53aWR0aCAqIGlucHV0U2l6ZVsyXSAtIDAuNSAqIGlucHV0UGl4ZWxbMl0sIGlucHV0Q2xhbXBbM10gPSBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQgKiBpbnB1dFNpemVbM10gLSAwLjUgKiBpbnB1dFBpeGVsWzNdLCBzdGF0ZS5sZWdhY3kpIHtcbiAgICAgIGNvbnN0IGZpbHRlckFyZWEgPSBnbG9iYWxVbmlmb3Jtcy5maWx0ZXJBcmVhO1xuICAgICAgZmlsdGVyQXJlYVswXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUud2lkdGgsIGZpbHRlckFyZWFbMV0gPSBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLmhlaWdodCwgZmlsdGVyQXJlYVsyXSA9IHN0YXRlLnNvdXJjZUZyYW1lLngsIGZpbHRlckFyZWFbM10gPSBzdGF0ZS5zb3VyY2VGcmFtZS55LCBnbG9iYWxVbmlmb3Jtcy5maWx0ZXJDbGFtcCA9IGdsb2JhbFVuaWZvcm1zLmlucHV0Q2xhbXA7XG4gICAgfVxuICAgIHRoaXMuZ2xvYmFsVW5pZm9ybXMudXBkYXRlKCk7XG4gICAgY29uc3QgbGFzdFN0YXRlID0gZmlsdGVyU3RhY2tbZmlsdGVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgaWYgKHRoaXMucmVuZGVyZXIuZnJhbWVidWZmZXIuYmxpdCgpLCBmaWx0ZXJzLmxlbmd0aCA9PT0gMSlcbiAgICAgIGZpbHRlcnNbMF0uYXBwbHkodGhpcywgc3RhdGUucmVuZGVyVGV4dHVyZSwgbGFzdFN0YXRlLnJlbmRlclRleHR1cmUsIGNvbnN0YW50cy5DTEVBUl9NT0RFUy5CTEVORCwgc3RhdGUpLCB0aGlzLnJldHVybkZpbHRlclRleHR1cmUoc3RhdGUucmVuZGVyVGV4dHVyZSk7XG4gICAgZWxzZSB7XG4gICAgICBsZXQgZmxpcCA9IHN0YXRlLnJlbmRlclRleHR1cmUsIGZsb3AgPSB0aGlzLmdldE9wdGltYWxGaWx0ZXJUZXh0dXJlKFxuICAgICAgICBmbGlwLndpZHRoLFxuICAgICAgICBmbGlwLmhlaWdodCxcbiAgICAgICAgc3RhdGUucmVzb2x1dGlvblxuICAgICAgKTtcbiAgICAgIGZsb3AuZmlsdGVyRnJhbWUgPSBmbGlwLmZpbHRlckZyYW1lO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGkgPT09IDEgJiYgc3RhdGUubXVsdGlzYW1wbGUgPiAxICYmIChmbG9wID0gdGhpcy5nZXRPcHRpbWFsRmlsdGVyVGV4dHVyZShcbiAgICAgICAgICBmbGlwLndpZHRoLFxuICAgICAgICAgIGZsaXAuaGVpZ2h0LFxuICAgICAgICAgIHN0YXRlLnJlc29sdXRpb25cbiAgICAgICAgKSwgZmxvcC5maWx0ZXJGcmFtZSA9IGZsaXAuZmlsdGVyRnJhbWUpLCBmaWx0ZXJzW2ldLmFwcGx5KHRoaXMsIGZsaXAsIGZsb3AsIGNvbnN0YW50cy5DTEVBUl9NT0RFUy5DTEVBUiwgc3RhdGUpO1xuICAgICAgICBjb25zdCB0ID0gZmxpcDtcbiAgICAgICAgZmxpcCA9IGZsb3AsIGZsb3AgPSB0O1xuICAgICAgfVxuICAgICAgZmlsdGVyc1tpXS5hcHBseSh0aGlzLCBmbGlwLCBsYXN0U3RhdGUucmVuZGVyVGV4dHVyZSwgY29uc3RhbnRzLkNMRUFSX01PREVTLkJMRU5ELCBzdGF0ZSksIGkgPiAxICYmIHN0YXRlLm11bHRpc2FtcGxlID4gMSAmJiB0aGlzLnJldHVybkZpbHRlclRleHR1cmUoc3RhdGUucmVuZGVyVGV4dHVyZSksIHRoaXMucmV0dXJuRmlsdGVyVGV4dHVyZShmbGlwKSwgdGhpcy5yZXR1cm5GaWx0ZXJUZXh0dXJlKGZsb3ApO1xuICAgIH1cbiAgICBzdGF0ZS5jbGVhcigpLCB0aGlzLnN0YXRlUG9vbC5wdXNoKHN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgYSByZW5kZXJUZXh0dXJlIHdpdGggY29ycmVzcG9uZGluZyBgZmlsdGVyRnJhbWVgLCBjbGVhcnMgaXQgaWYgbW9kZSBjb3JyZXNwb25kcy5cbiAgICogQHBhcmFtIGZpbHRlclRleHR1cmUgLSByZW5kZXJUZXh0dXJlIHRvIGJpbmQsIHNob3VsZCBiZWxvbmcgdG8gZmlsdGVyIHBvb2wgb3IgZmlsdGVyIHN0YWNrXG4gICAqIEBwYXJhbSBjbGVhck1vZGUgLSBjbGVhck1vZGUsIGJ5IGRlZmF1bHQgaXRzIENMRUFSL1lFUy4gU2VlIHtAbGluayBQSVhJLkNMRUFSX01PREVTfVxuICAgKi9cbiAgYmluZEFuZENsZWFyKGZpbHRlclRleHR1cmUsIGNsZWFyTW9kZSA9IGNvbnN0YW50cy5DTEVBUl9NT0RFUy5DTEVBUikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlclRleHR1cmU6IHJlbmRlclRleHR1cmVTeXN0ZW0sXG4gICAgICBzdGF0ZTogc3RhdGVTeXN0ZW1cbiAgICB9ID0gdGhpcy5yZW5kZXJlcjtcbiAgICBpZiAoZmlsdGVyVGV4dHVyZSA9PT0gdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2tbdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2subGVuZ3RoIC0gMV0ucmVuZGVyVGV4dHVyZSA/IHRoaXMucmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0gPSB0aGlzLmFjdGl2ZVN0YXRlLnRyYW5zZm9ybSA6IHRoaXMucmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0gPSBudWxsLCBmaWx0ZXJUZXh0dXJlPy5maWx0ZXJGcmFtZSkge1xuICAgICAgY29uc3QgZGVzdGluYXRpb25GcmFtZSA9IHRoaXMudGVtcFJlY3Q7XG4gICAgICBkZXN0aW5hdGlvbkZyYW1lLnggPSAwLCBkZXN0aW5hdGlvbkZyYW1lLnkgPSAwLCBkZXN0aW5hdGlvbkZyYW1lLndpZHRoID0gZmlsdGVyVGV4dHVyZS5maWx0ZXJGcmFtZS53aWR0aCwgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgPSBmaWx0ZXJUZXh0dXJlLmZpbHRlckZyYW1lLmhlaWdodCwgcmVuZGVyVGV4dHVyZVN5c3RlbS5iaW5kKGZpbHRlclRleHR1cmUsIGZpbHRlclRleHR1cmUuZmlsdGVyRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUpO1xuICAgIH0gZWxzZVxuICAgICAgZmlsdGVyVGV4dHVyZSAhPT0gdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2tbdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2subGVuZ3RoIC0gMV0ucmVuZGVyVGV4dHVyZSA/IHJlbmRlclRleHR1cmVTeXN0ZW0uYmluZChmaWx0ZXJUZXh0dXJlKSA6IHRoaXMucmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKFxuICAgICAgICBmaWx0ZXJUZXh0dXJlLFxuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlLmJpbmRpbmdTb3VyY2VGcmFtZSxcbiAgICAgICAgdGhpcy5hY3RpdmVTdGF0ZS5iaW5kaW5nRGVzdGluYXRpb25GcmFtZVxuICAgICAgKTtcbiAgICBjb25zdCBhdXRvQ2xlYXIgPSBzdGF0ZVN5c3RlbS5zdGF0ZUlkICYgMSB8fCB0aGlzLmZvcmNlQ2xlYXI7XG4gICAgKGNsZWFyTW9kZSA9PT0gY29uc3RhbnRzLkNMRUFSX01PREVTLkNMRUFSIHx8IGNsZWFyTW9kZSA9PT0gY29uc3RhbnRzLkNMRUFSX01PREVTLkJMSVQgJiYgYXV0b0NsZWFyKSAmJiB0aGlzLnJlbmRlcmVyLmZyYW1lYnVmZmVyLmNsZWFyKDAsIDAsIDAsIDApO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIGZpbHRlciB1c2luZyB0aGUgZGVmYXVsdCByZW5kZXJpbmcgcHJvY2Vzcy5cbiAgICpcbiAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIG9ubHkgYnkge0BsaW5rIFBJWEkuRmlsdGVyI2FwcGx5fS5cbiAgICogQHBhcmFtIGZpbHRlciAtIFRoZSBmaWx0ZXIgdG8gZHJhdy5cbiAgICogQHBhcmFtIGlucHV0IC0gVGhlIGlucHV0IHJlbmRlciB0YXJnZXQuXG4gICAqIEBwYXJhbSBvdXRwdXQgLSBUaGUgdGFyZ2V0IHRvIG91dHB1dCB0by5cbiAgICogQHBhcmFtIGNsZWFyTW9kZSAtIFNob3VsZCB0aGUgb3V0cHV0IGJlIGNsZWFyZWQgYmVmb3JlIHJlbmRlcmluZyB0byBpdFxuICAgKi9cbiAgYXBwbHlGaWx0ZXIoZmlsdGVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgcmVuZGVyZXIuc3RhdGUuc2V0KGZpbHRlci5zdGF0ZSksIHRoaXMuYmluZEFuZENsZWFyKG91dHB1dCwgY2xlYXJNb2RlKSwgZmlsdGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gaW5wdXQsIGZpbHRlci51bmlmb3Jtcy5maWx0ZXJHbG9iYWxzID0gdGhpcy5nbG9iYWxVbmlmb3JtcywgcmVuZGVyZXIuc2hhZGVyLmJpbmQoZmlsdGVyKSwgZmlsdGVyLmxlZ2FjeSA9ICEhZmlsdGVyLnByb2dyYW0uYXR0cmlidXRlRGF0YS5hVGV4dHVyZUNvb3JkLCBmaWx0ZXIubGVnYWN5ID8gKHRoaXMucXVhZFV2Lm1hcChpbnB1dC5fZnJhbWUsIGlucHV0LmZpbHRlckZyYW1lKSwgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLnF1YWRVdiksIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcoY29uc3RhbnRzLkRSQVdfTU9ERVMuVFJJQU5HTEVTKSkgOiAocmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLnF1YWQpLCByZW5kZXJlci5nZW9tZXRyeS5kcmF3KGNvbnN0YW50cy5EUkFXX01PREVTLlRSSUFOR0xFX1NUUklQKSk7XG4gIH1cbiAgLyoqXG4gICAqIE11bHRpcGx5IF9pbnB1dCBub3JtYWxpemVkIGNvb3JkaW5hdGVzXyB0byB0aGlzIG1hdHJpeCB0byBnZXQgX3Nwcml0ZSB0ZXh0dXJlIG5vcm1hbGl6ZWQgY29vcmRpbmF0ZXNfLlxuICAgKlxuICAgKiBVc2UgYG91dHB1dE1hdHJpeCAqIHZUZXh0dXJlQ29vcmRgIGluIHRoZSBzaGFkZXIuXG4gICAqIEBwYXJhbSBvdXRwdXRNYXRyaXggLSBUaGUgbWF0cml4IHRvIG91dHB1dCB0by5cbiAgICogQHBhcmFtIHtQSVhJLlNwcml0ZX0gc3ByaXRlIC0gVGhlIHNwcml0ZSB0byBtYXAgdG8uXG4gICAqIEByZXR1cm5zIFRoZSBtYXBwZWQgbWF0cml4LlxuICAgKi9cbiAgY2FsY3VsYXRlU3ByaXRlTWF0cml4KG91dHB1dE1hdHJpeCwgc3ByaXRlKSB7XG4gICAgY29uc3QgeyBzb3VyY2VGcmFtZSwgZGVzdGluYXRpb25GcmFtZSB9ID0gdGhpcy5hY3RpdmVTdGF0ZSwgeyBvcmlnIH0gPSBzcHJpdGUuX3RleHR1cmUsIG1hcHBlZE1hdHJpeCA9IG91dHB1dE1hdHJpeC5zZXQoXG4gICAgICBkZXN0aW5hdGlvbkZyYW1lLndpZHRoLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCxcbiAgICAgIHNvdXJjZUZyYW1lLngsXG4gICAgICBzb3VyY2VGcmFtZS55XG4gICAgKSwgd29ybGRUcmFuc2Zvcm0gPSBzcHJpdGUud29ybGRUcmFuc2Zvcm0uY29weVRvKG1hdGguTWF0cml4LlRFTVBfTUFUUklYKTtcbiAgICByZXR1cm4gd29ybGRUcmFuc2Zvcm0uaW52ZXJ0KCksIG1hcHBlZE1hdHJpeC5wcmVwZW5kKHdvcmxkVHJhbnNmb3JtKSwgbWFwcGVkTWF0cml4LnNjYWxlKDEgLyBvcmlnLndpZHRoLCAxIC8gb3JpZy5oZWlnaHQpLCBtYXBwZWRNYXRyaXgudHJhbnNsYXRlKHNwcml0ZS5hbmNob3IueCwgc3ByaXRlLmFuY2hvci55KSwgbWFwcGVkTWF0cml4O1xuICB9XG4gIC8qKiBEZXN0cm95cyB0aGlzIEZpbHRlciBTeXN0ZW0uICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGwsIHRoaXMudGV4dHVyZVBvb2wuY2xlYXIoITEpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgUG93ZXItb2YtVHdvIHJlbmRlciB0ZXh0dXJlIG9yIGZ1bGxTY3JlZW4gdGV4dHVyZVxuICAgKiBAcGFyYW0gbWluV2lkdGggLSBUaGUgbWluaW11bSB3aWR0aCBvZiB0aGUgcmVuZGVyIHRleHR1cmUgaW4gcmVhbCBwaXhlbHMuXG4gICAqIEBwYXJhbSBtaW5IZWlnaHQgLSBUaGUgbWluaW11bSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0ZXh0dXJlIGluIHJlYWwgcGl4ZWxzLlxuICAgKiBAcGFyYW0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXIgdGV4dHVyZS5cbiAgICogQHBhcmFtIG11bHRpc2FtcGxlIC0gTnVtYmVyIG9mIHNhbXBsZXMgb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcmV0dXJucyAtIFRoZSBuZXcgcmVuZGVyIHRleHR1cmUuXG4gICAqL1xuICBnZXRPcHRpbWFsRmlsdGVyVGV4dHVyZShtaW5XaWR0aCwgbWluSGVpZ2h0LCByZXNvbHV0aW9uID0gMSwgbXVsdGlzYW1wbGUgPSBjb25zdGFudHMuTVNBQV9RVUFMSVRZLk5PTkUpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0dXJlUG9vbC5nZXRPcHRpbWFsVGV4dHVyZShtaW5XaWR0aCwgbWluSGVpZ2h0LCByZXNvbHV0aW9uLCBtdWx0aXNhbXBsZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgZXh0cmEgcmVuZGVyIHRleHR1cmUgdG8gdXNlIGluc2lkZSBjdXJyZW50IGZpbHRlclxuICAgKiBUbyBiZSBjb21wbGlhbnQgd2l0aCBvbGRlciBmaWx0ZXJzLCB5b3UgY2FuIHVzZSBwYXJhbXMgaW4gYW55IG9yZGVyXG4gICAqIEBwYXJhbSBpbnB1dCAtIHJlbmRlclRleHR1cmUgZnJvbSB3aGljaCBzaXplIGFuZCByZXNvbHV0aW9uIHdpbGwgYmUgY29waWVkXG4gICAqIEBwYXJhbSByZXNvbHV0aW9uIC0gb3ZlcnJpZGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyVGV4dHVyZVxuICAgKiBAcGFyYW0gbXVsdGlzYW1wbGUgLSBudW1iZXIgb2Ygc2FtcGxlcyBvZiB0aGUgcmVuZGVyVGV4dHVyZVxuICAgKi9cbiAgZ2V0RmlsdGVyVGV4dHVyZShpbnB1dCwgcmVzb2x1dGlvbiwgbXVsdGlzYW1wbGUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IHN3YXAgPSBpbnB1dDtcbiAgICAgIGlucHV0ID0gcmVzb2x1dGlvbiwgcmVzb2x1dGlvbiA9IHN3YXA7XG4gICAgfVxuICAgIGlucHV0ID0gaW5wdXQgfHwgdGhpcy5hY3RpdmVTdGF0ZS5yZW5kZXJUZXh0dXJlO1xuICAgIGNvbnN0IGZpbHRlclRleHR1cmUgPSB0aGlzLnRleHR1cmVQb29sLmdldE9wdGltYWxUZXh0dXJlKFxuICAgICAgaW5wdXQud2lkdGgsXG4gICAgICBpbnB1dC5oZWlnaHQsXG4gICAgICByZXNvbHV0aW9uIHx8IGlucHV0LnJlc29sdXRpb24sXG4gICAgICBtdWx0aXNhbXBsZSB8fCBjb25zdGFudHMuTVNBQV9RVUFMSVRZLk5PTkVcbiAgICApO1xuICAgIHJldHVybiBmaWx0ZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gaW5wdXQuZmlsdGVyRnJhbWUsIGZpbHRlclRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIEZyZWVzIGEgcmVuZGVyIHRleHR1cmUgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKiBAcGFyYW0gcmVuZGVyVGV4dHVyZSAtIFRoZSByZW5kZXJUYXJnZXQgdG8gZnJlZVxuICAgKi9cbiAgcmV0dXJuRmlsdGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlKSB7XG4gICAgdGhpcy50ZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKHJlbmRlclRleHR1cmUpO1xuICB9XG4gIC8qKiBFbXB0aWVzIHRoZSB0ZXh0dXJlIHBvb2wuICovXG4gIGVtcHR5UG9vbCgpIHtcbiAgICB0aGlzLnRleHR1cmVQb29sLmNsZWFyKCEwKTtcbiAgfVxuICAvKiogQ2FsbHMgYHRleHR1cmVQb29sLnJlc2l6ZSgpYCwgYWZmZWN0cyBmdWxsU2NyZWVuIHJlbmRlclRleHR1cmVzLiAqL1xuICByZXNpemUoKSB7XG4gICAgdGhpcy50ZXh0dXJlUG9vbC5zZXRTY3JlZW5TaXplKHRoaXMucmVuZGVyZXIudmlldyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBtYXRyaXggLSBmaXJzdCBwYXJhbVxuICAgKiBAcGFyYW0gcmVjdCAtIHNlY29uZCBwYXJhbVxuICAgKi9cbiAgdHJhbnNmb3JtQUFCQihtYXRyaXgsIHJlY3QpIHtcbiAgICBjb25zdCBsdCA9IHRlbXBQb2ludHNbMF0sIGxiID0gdGVtcFBvaW50c1sxXSwgcnQgPSB0ZW1wUG9pbnRzWzJdLCByYiA9IHRlbXBQb2ludHNbM107XG4gICAgbHQuc2V0KHJlY3QubGVmdCwgcmVjdC50b3ApLCBsYi5zZXQocmVjdC5sZWZ0LCByZWN0LmJvdHRvbSksIHJ0LnNldChyZWN0LnJpZ2h0LCByZWN0LnRvcCksIHJiLnNldChyZWN0LnJpZ2h0LCByZWN0LmJvdHRvbSksIG1hdHJpeC5hcHBseShsdCwgbHQpLCBtYXRyaXguYXBwbHkobGIsIGxiKSwgbWF0cml4LmFwcGx5KHJ0LCBydCksIG1hdHJpeC5hcHBseShyYiwgcmIpO1xuICAgIGNvbnN0IHgwID0gTWF0aC5taW4obHQueCwgbGIueCwgcnQueCwgcmIueCksIHkwID0gTWF0aC5taW4obHQueSwgbGIueSwgcnQueSwgcmIueSksIHgxID0gTWF0aC5tYXgobHQueCwgbGIueCwgcnQueCwgcmIueCksIHkxID0gTWF0aC5tYXgobHQueSwgbGIueSwgcnQueSwgcmIueSk7XG4gICAgcmVjdC54ID0geDAsIHJlY3QueSA9IHkwLCByZWN0LndpZHRoID0geDEgLSB4MCwgcmVjdC5oZWlnaHQgPSB5MSAtIHkwO1xuICB9XG4gIHJvdW5kRnJhbWUoZnJhbWUsIHJlc29sdXRpb24sIGJpbmRpbmdTb3VyY2VGcmFtZSwgYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUsIHRyYW5zZm9ybSkge1xuICAgIGlmICghKGZyYW1lLndpZHRoIDw9IDAgfHwgZnJhbWUuaGVpZ2h0IDw9IDAgfHwgYmluZGluZ1NvdXJjZUZyYW1lLndpZHRoIDw9IDAgfHwgYmluZGluZ1NvdXJjZUZyYW1lLmhlaWdodCA8PSAwKSkge1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCB7IGEsIGIsIGMsIGQgfSA9IHRyYW5zZm9ybTtcbiAgICAgICAgaWYgKChNYXRoLmFicyhiKSA+IDFlLTQgfHwgTWF0aC5hYnMoYykgPiAxZS00KSAmJiAoTWF0aC5hYnMoYSkgPiAxZS00IHx8IE1hdGguYWJzKGQpID4gMWUtNCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtID8gdGVtcE1hdHJpeC5jb3B5RnJvbSh0cmFuc2Zvcm0pIDogdGVtcE1hdHJpeC5pZGVudGl0eSgpLCB0cmFuc2Zvcm0udHJhbnNsYXRlKC1iaW5kaW5nU291cmNlRnJhbWUueCwgLWJpbmRpbmdTb3VyY2VGcmFtZS55KS5zY2FsZShcbiAgICAgICAgYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUud2lkdGggLyBiaW5kaW5nU291cmNlRnJhbWUud2lkdGgsXG4gICAgICAgIGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAvIGJpbmRpbmdTb3VyY2VGcmFtZS5oZWlnaHRcbiAgICAgICkudHJhbnNsYXRlKGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLngsIGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLnkpLCB0aGlzLnRyYW5zZm9ybUFBQkIodHJhbnNmb3JtLCBmcmFtZSksIGZyYW1lLmNlaWwocmVzb2x1dGlvbiksIHRoaXMudHJhbnNmb3JtQUFCQih0cmFuc2Zvcm0uaW52ZXJ0KCksIGZyYW1lKTtcbiAgICB9XG4gIH1cbn1cbkZpbHRlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJmaWx0ZXJcIlxufTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5hZGQoRmlsdGVyU3lzdGVtKTtcbmV4cG9ydHMuRmlsdGVyU3lzdGVtID0gRmlsdGVyU3lzdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsdGVyU3lzdGVtLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JRmlsdGVyVGFyZ2V0LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIGRlZmF1bHRGcmFnbWVudCA9IGB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcblxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG5cbnZvaWQgbWFpbih2b2lkKXtcbiAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG59XG5gO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdEZyYWdtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdEZpbHRlci5mcmFnLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIGRlZmF1bHRWZXJ0ZXggPSBgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcblxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cbnVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XG51bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XG5cbnZlYzQgZmlsdGVyVmVydGV4UG9zaXRpb24oIHZvaWQgKVxue1xuICAgIHZlYzIgcG9zaXRpb24gPSBhVmVydGV4UG9zaXRpb24gKiBtYXgob3V0cHV0RnJhbWUuencsIHZlYzIoMC4pKSArIG91dHB1dEZyYW1lLnh5O1xuXG4gICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xufVxuXG52ZWMyIGZpbHRlclRleHR1cmVDb29yZCggdm9pZCApXG57XG4gICAgcmV0dXJuIGFWZXJ0ZXhQb3NpdGlvbiAqIChvdXRwdXRGcmFtZS56dyAqIGlucHV0U2l6ZS56dyk7XG59XG5cbnZvaWQgbWFpbih2b2lkKVxue1xuICAgIGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oKTtcbiAgICB2VGV4dHVyZUNvb3JkID0gZmlsdGVyVGV4dHVyZUNvb3JkKCk7XG59XG5gO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdFZlcnRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRGaWx0ZXIudmVydC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1hdGggPSByZXF1aXJlKFwiQHBpeGkvbWF0aFwiKSwgVGV4dHVyZU1hdHJpeCA9IHJlcXVpcmUoXCIuLi8uLi90ZXh0dXJlcy9UZXh0dXJlTWF0cml4LmpzXCIpLCBGaWx0ZXIgPSByZXF1aXJlKFwiLi4vRmlsdGVyLmpzXCIpLCBzcHJpdGVNYXNrRmlsdGVyJDEgPSByZXF1aXJlKFwiLi9zcHJpdGVNYXNrRmlsdGVyLmZyYWcuanNcIiksIHNwcml0ZU1hc2tGaWx0ZXIgPSByZXF1aXJlKFwiLi9zcHJpdGVNYXNrRmlsdGVyLnZlcnQuanNcIik7XG5jbGFzcyBTcHJpdGVNYXNrRmlsdGVyIGV4dGVuZHMgRmlsdGVyLkZpbHRlciB7XG4gIC8qKiBAaWdub3JlICovXG4gIGNvbnN0cnVjdG9yKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIHVuaWZvcm1zKSB7XG4gICAgbGV0IHNwcml0ZSA9IG51bGw7XG4gICAgdHlwZW9mIHZlcnRleFNyYyAhPSBcInN0cmluZ1wiICYmIGZyYWdtZW50U3JjID09PSB2b2lkIDAgJiYgdW5pZm9ybXMgPT09IHZvaWQgMCAmJiAoc3ByaXRlID0gdmVydGV4U3JjLCB2ZXJ0ZXhTcmMgPSB2b2lkIDAsIGZyYWdtZW50U3JjID0gdm9pZCAwLCB1bmlmb3JtcyA9IHZvaWQgMCksIHN1cGVyKHZlcnRleFNyYyB8fCBzcHJpdGVNYXNrRmlsdGVyLmRlZmF1bHQsIGZyYWdtZW50U3JjIHx8IHNwcml0ZU1hc2tGaWx0ZXIkMS5kZWZhdWx0LCB1bmlmb3JtcyksIHRoaXMubWFza1Nwcml0ZSA9IHNwcml0ZSwgdGhpcy5tYXNrTWF0cml4ID0gbmV3IG1hdGguTWF0cml4KCk7XG4gIH1cbiAgLyoqXG4gICAqIFNwcml0ZSBtYXNrXG4gICAqIEB0eXBlIHtQSVhJLkRpc3BsYXlPYmplY3R9XG4gICAqL1xuICBnZXQgbWFza1Nwcml0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFza1Nwcml0ZTtcbiAgfVxuICBzZXQgbWFza1Nwcml0ZSh2YWx1ZSkge1xuICAgIHRoaXMuX21hc2tTcHJpdGUgPSB2YWx1ZSwgdGhpcy5fbWFza1Nwcml0ZSAmJiAodGhpcy5fbWFza1Nwcml0ZS5yZW5kZXJhYmxlID0gITEpO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtIGZpbHRlck1hbmFnZXIgLSBUaGUgcmVuZGVyZXIgdG8gcmV0cmlldmUgdGhlIGZpbHRlciBmcm9tXG4gICAqIEBwYXJhbSBpbnB1dCAtIFRoZSBpbnB1dCByZW5kZXIgdGFyZ2V0LlxuICAgKiBAcGFyYW0gb3V0cHV0IC0gVGhlIHRhcmdldCB0byBvdXRwdXQgdG8uXG4gICAqIEBwYXJhbSBjbGVhck1vZGUgLSBTaG91bGQgdGhlIG91dHB1dCBiZSBjbGVhcmVkIGJlZm9yZSByZW5kZXJpbmcgdG8gaXQuXG4gICAqL1xuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICBjb25zdCBtYXNrU3ByaXRlID0gdGhpcy5fbWFza1Nwcml0ZSwgdGV4ID0gbWFza1Nwcml0ZS5fdGV4dHVyZTtcbiAgICB0ZXgudmFsaWQgJiYgKHRleC51dk1hdHJpeCB8fCAodGV4LnV2TWF0cml4ID0gbmV3IFRleHR1cmVNYXRyaXguVGV4dHVyZU1hdHJpeCh0ZXgsIDApKSwgdGV4LnV2TWF0cml4LnVwZGF0ZSgpLCB0aGlzLnVuaWZvcm1zLm5wbUFscGhhID0gdGV4LmJhc2VUZXh0dXJlLmFscGhhTW9kZSA/IDAgOiAxLCB0aGlzLnVuaWZvcm1zLm1hc2sgPSB0ZXgsIHRoaXMudW5pZm9ybXMub3RoZXJNYXRyaXggPSBmaWx0ZXJNYW5hZ2VyLmNhbGN1bGF0ZVNwcml0ZU1hdHJpeCh0aGlzLm1hc2tNYXRyaXgsIG1hc2tTcHJpdGUpLnByZXBlbmQodGV4LnV2TWF0cml4Lm1hcENvb3JkKSwgdGhpcy51bmlmb3Jtcy5hbHBoYSA9IG1hc2tTcHJpdGUud29ybGRBbHBoYSwgdGhpcy51bmlmb3Jtcy5tYXNrQ2xhbXAgPSB0ZXgudXZNYXRyaXgudUNsYW1wRnJhbWUsIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKSk7XG4gIH1cbn1cbmV4cG9ydHMuU3ByaXRlTWFza0ZpbHRlciA9IFNwcml0ZU1hc2tGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TcHJpdGVNYXNrRmlsdGVyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIGZyYWdtZW50ID0gYHZhcnlpbmcgdmVjMiB2TWFza0Nvb3JkO1xudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xudW5pZm9ybSBzYW1wbGVyMkQgbWFzaztcbnVuaWZvcm0gZmxvYXQgYWxwaGE7XG51bmlmb3JtIGZsb2F0IG5wbUFscGhhO1xudW5pZm9ybSB2ZWM0IG1hc2tDbGFtcDtcblxudm9pZCBtYWluKHZvaWQpXG57XG4gICAgZmxvYXQgY2xpcCA9IHN0ZXAoMy41LFxuICAgICAgICBzdGVwKG1hc2tDbGFtcC54LCB2TWFza0Nvb3JkLngpICtcbiAgICAgICAgc3RlcChtYXNrQ2xhbXAueSwgdk1hc2tDb29yZC55KSArXG4gICAgICAgIHN0ZXAodk1hc2tDb29yZC54LCBtYXNrQ2xhbXAueikgK1xuICAgICAgICBzdGVwKHZNYXNrQ29vcmQueSwgbWFza0NsYW1wLncpKTtcblxuICAgIHZlYzQgb3JpZ2luYWwgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuICAgIHZlYzQgbWFza3kgPSB0ZXh0dXJlMkQobWFzaywgdk1hc2tDb29yZCk7XG4gICAgZmxvYXQgYWxwaGFNdWwgPSAxLjAgLSBucG1BbHBoYSAqICgxLjAgLSBtYXNreS5hKTtcblxuICAgIG9yaWdpbmFsICo9IChhbHBoYU11bCAqIG1hc2t5LnIgKiBhbHBoYSAqIGNsaXApO1xuXG4gICAgZ2xfRnJhZ0NvbG9yID0gb3JpZ2luYWw7XG59XG5gO1xuZXhwb3J0cy5kZWZhdWx0ID0gZnJhZ21lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcHJpdGVNYXNrRmlsdGVyLmZyYWcuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgdmVydGV4ID0gYGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG5cbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xudW5pZm9ybSBtYXQzIG90aGVyTWF0cml4O1xuXG52YXJ5aW5nIHZlYzIgdk1hc2tDb29yZDtcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXG52b2lkIG1haW4odm9pZClcbntcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcblxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgIHZNYXNrQ29vcmQgPSAoIG90aGVyTWF0cml4ICogdmVjMyggYVRleHR1cmVDb29yZCwgMS4wKSAgKS54eTtcbn1cbmA7XG5leHBvcnRzLmRlZmF1bHQgPSB2ZXJ0ZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcHJpdGVNYXNrRmlsdGVyLnZlcnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgJGRlZmF1bHRWZXJ0ZXggPSBgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcblxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XG5cbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXG52b2lkIG1haW4odm9pZClcbntcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbn1gO1xuZXhwb3J0cy5kZWZhdWx0ID0gJGRlZmF1bHRWZXJ0ZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0LnZlcnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgJGRlZmF1bHRGaWx0ZXJWZXJ0ZXggPSBgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcblxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cbnVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XG51bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XG5cbnZlYzQgZmlsdGVyVmVydGV4UG9zaXRpb24oIHZvaWQgKVxue1xuICAgIHZlYzIgcG9zaXRpb24gPSBhVmVydGV4UG9zaXRpb24gKiBtYXgob3V0cHV0RnJhbWUuencsIHZlYzIoMC4pKSArIG91dHB1dEZyYW1lLnh5O1xuXG4gICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xufVxuXG52ZWMyIGZpbHRlclRleHR1cmVDb29yZCggdm9pZCApXG57XG4gICAgcmV0dXJuIGFWZXJ0ZXhQb3NpdGlvbiAqIChvdXRwdXRGcmFtZS56dyAqIGlucHV0U2l6ZS56dyk7XG59XG5cbnZvaWQgbWFpbih2b2lkKVxue1xuICAgIGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oKTtcbiAgICB2VGV4dHVyZUNvb3JkID0gZmlsdGVyVGV4dHVyZUNvb3JkKCk7XG59XG5gO1xuZXhwb3J0cy5kZWZhdWx0ID0gJGRlZmF1bHRGaWx0ZXJWZXJ0ZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0RmlsdGVyLnZlcnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfZGVmYXVsdCA9IHJlcXVpcmUoXCIuL2RlZmF1bHQudmVydC5qc1wiKSwgZGVmYXVsdEZpbHRlciA9IHJlcXVpcmUoXCIuL2RlZmF1bHRGaWx0ZXIudmVydC5qc1wiKTtcbmNvbnN0IGRlZmF1bHRWZXJ0ZXggPSBfZGVmYXVsdC5kZWZhdWx0LCBkZWZhdWx0RmlsdGVyVmVydGV4ID0gZGVmYXVsdEZpbHRlci5kZWZhdWx0O1xuZXhwb3J0cy5kZWZhdWx0RmlsdGVyVmVydGV4ID0gZGVmYXVsdEZpbHRlclZlcnRleDtcbmV4cG9ydHMuZGVmYXVsdFZlcnRleCA9IGRlZmF1bHRWZXJ0ZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCJAcGl4aS9jb25zdGFudHNcIiksIHJ1bm5lciA9IHJlcXVpcmUoXCJAcGl4aS9ydW5uZXJcIiksIEJhc2VUZXh0dXJlID0gcmVxdWlyZShcIi4uL3RleHR1cmVzL0Jhc2VUZXh0dXJlLmpzXCIpO1xuY2xhc3MgRnJhbWVidWZmZXIge1xuICAvKipcbiAgICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgdGhlIGZyYW1lIGJ1ZmZlclxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSBmcmFtZSBidWZmZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy53aWR0aCA9IE1hdGgucm91bmQod2lkdGgpLCB0aGlzLmhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KSwgIXRoaXMud2lkdGggfHwgIXRoaXMuaGVpZ2h0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhbWVidWZmZXIgd2lkdGggb3IgaGVpZ2h0IGlzIHplcm9cIik7XG4gICAgdGhpcy5zdGVuY2lsID0gITEsIHRoaXMuZGVwdGggPSAhMSwgdGhpcy5kaXJ0eUlkID0gMCwgdGhpcy5kaXJ0eUZvcm1hdCA9IDAsIHRoaXMuZGlydHlTaXplID0gMCwgdGhpcy5kZXB0aFRleHR1cmUgPSBudWxsLCB0aGlzLmNvbG9yVGV4dHVyZXMgPSBbXSwgdGhpcy5nbEZyYW1lYnVmZmVycyA9IHt9LCB0aGlzLmRpc3Bvc2VSdW5uZXIgPSBuZXcgcnVubmVyLlJ1bm5lcihcImRpc3Bvc2VGcmFtZWJ1ZmZlclwiKSwgdGhpcy5tdWx0aXNhbXBsZSA9IGNvbnN0YW50cy5NU0FBX1FVQUxJVFkuTk9ORTtcbiAgfVxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBjb2xvclRleHR1cmUuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGNvbG9yVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclRleHR1cmVzWzBdO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgdGV4dHVyZSB0byB0aGUgY29sb3JUZXh0dXJlIGFycmF5LlxuICAgKiBAcGFyYW0gaW5kZXggLSBJbmRleCBvZiB0aGUgYXJyYXkgdG8gYWRkIHRoZSB0ZXh0dXJlIHRvXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gVGV4dHVyZSB0byBhZGQgdG8gdGhlIGFycmF5XG4gICAqL1xuICBhZGRDb2xvclRleHR1cmUoaW5kZXggPSAwLCB0ZXh0dXJlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JUZXh0dXJlc1tpbmRleF0gPSB0ZXh0dXJlIHx8IG5ldyBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZShudWxsLCB7XG4gICAgICBzY2FsZU1vZGU6IGNvbnN0YW50cy5TQ0FMRV9NT0RFUy5ORUFSRVNULFxuICAgICAgcmVzb2x1dGlvbjogMSxcbiAgICAgIG1pcG1hcDogY29uc3RhbnRzLk1JUE1BUF9NT0RFUy5PRkYsXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9KSwgdGhpcy5kaXJ0eUlkKyssIHRoaXMuZGlydHlGb3JtYXQrKywgdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkIGEgZGVwdGggdGV4dHVyZSB0byB0aGUgZnJhbWUgYnVmZmVyLlxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIFRleHR1cmUgdG8gYWRkLlxuICAgKi9cbiAgYWRkRGVwdGhUZXh0dXJlKHRleHR1cmUpIHtcbiAgICByZXR1cm4gdGhpcy5kZXB0aFRleHR1cmUgPSB0ZXh0dXJlIHx8IG5ldyBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZShudWxsLCB7XG4gICAgICBzY2FsZU1vZGU6IGNvbnN0YW50cy5TQ0FMRV9NT0RFUy5ORUFSRVNULFxuICAgICAgcmVzb2x1dGlvbjogMSxcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgIG1pcG1hcDogY29uc3RhbnRzLk1JUE1BUF9NT0RFUy5PRkYsXG4gICAgICBmb3JtYXQ6IGNvbnN0YW50cy5GT1JNQVRTLkRFUFRIX0NPTVBPTkVOVCxcbiAgICAgIHR5cGU6IGNvbnN0YW50cy5UWVBFUy5VTlNJR05FRF9TSE9SVFxuICAgIH0pLCB0aGlzLmRpcnR5SWQrKywgdGhpcy5kaXJ0eUZvcm1hdCsrLCB0aGlzO1xuICB9XG4gIC8qKiBFbmFibGUgZGVwdGggb24gdGhlIGZyYW1lIGJ1ZmZlci4gKi9cbiAgZW5hYmxlRGVwdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwdGggPSAhMCwgdGhpcy5kaXJ0eUlkKyssIHRoaXMuZGlydHlGb3JtYXQrKywgdGhpcztcbiAgfVxuICAvKiogRW5hYmxlIHN0ZW5jaWwgb24gdGhlIGZyYW1lIGJ1ZmZlci4gKi9cbiAgZW5hYmxlU3RlbmNpbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVuY2lsID0gITAsIHRoaXMuZGlydHlJZCsrLCB0aGlzLmRpcnR5Rm9ybWF0KyssIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2l6ZSB0aGUgZnJhbWUgYnVmZmVyXG4gICAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHRoZSBmcmFtZSBidWZmZXIgdG8gcmVzaXplIHRvXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIGZyYW1lIGJ1ZmZlciB0byByZXNpemUgdG9cbiAgICovXG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCksIGhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KSwgIXdpZHRoIHx8ICFoZWlnaHQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcmFtZWJ1ZmZlciB3aWR0aCBhbmQgaGVpZ2h0IG11c3Qgbm90IGJlIHplcm9cIik7XG4gICAgaWYgKCEod2lkdGggPT09IHRoaXMud2lkdGggJiYgaGVpZ2h0ID09PSB0aGlzLmhlaWdodCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aCwgdGhpcy5oZWlnaHQgPSBoZWlnaHQsIHRoaXMuZGlydHlJZCsrLCB0aGlzLmRpcnR5U2l6ZSsrO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbG9yVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuY29sb3JUZXh0dXJlc1tpXSwgcmVzb2x1dGlvbiA9IHRleHR1cmUucmVzb2x1dGlvbjtcbiAgICAgICAgdGV4dHVyZS5zZXRTaXplKHdpZHRoIC8gcmVzb2x1dGlvbiwgaGVpZ2h0IC8gcmVzb2x1dGlvbik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kZXB0aFRleHR1cmUpIHtcbiAgICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZGVwdGhUZXh0dXJlLnJlc29sdXRpb247XG4gICAgICAgIHRoaXMuZGVwdGhUZXh0dXJlLnNldFNpemUod2lkdGggLyByZXNvbHV0aW9uLCBoZWlnaHQgLyByZXNvbHV0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIERpc3Bvc2VzIFdlYkdMIHJlc291cmNlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhpcyBnZW9tZXRyeS4gKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmRpc3Bvc2VSdW5uZXIuZW1pdCh0aGlzLCAhMSk7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIGFuZCByZW1vdmVzIHRoZSBkZXB0aCB0ZXh0dXJlIGFkZGVkIHRvIHRoaXMgZnJhbWVidWZmZXIuICovXG4gIGRlc3Ryb3lEZXB0aFRleHR1cmUoKSB7XG4gICAgdGhpcy5kZXB0aFRleHR1cmUgJiYgKHRoaXMuZGVwdGhUZXh0dXJlLmRlc3Ryb3koKSwgdGhpcy5kZXB0aFRleHR1cmUgPSBudWxsLCArK3RoaXMuZGlydHlJZCwgKyt0aGlzLmRpcnR5Rm9ybWF0KTtcbiAgfVxufVxuZXhwb3J0cy5GcmFtZWJ1ZmZlciA9IEZyYW1lYnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJhbWVidWZmZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiQHBpeGkvY29uc3RhbnRzXCIpLCBleHRlbnNpb25zID0gcmVxdWlyZShcIkBwaXhpL2V4dGVuc2lvbnNcIiksIG1hdGggPSByZXF1aXJlKFwiQHBpeGkvbWF0aFwiKSwgc2V0dGluZ3MgPSByZXF1aXJlKFwiQHBpeGkvc2V0dGluZ3NcIiksIEZyYW1lYnVmZmVyID0gcmVxdWlyZShcIi4vRnJhbWVidWZmZXIuanNcIiksIEdMRnJhbWVidWZmZXIgPSByZXF1aXJlKFwiLi9HTEZyYW1lYnVmZmVyLmpzXCIpO1xuY29uc3QgdGVtcFJlY3RhbmdsZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgpO1xuY2xhc3MgRnJhbWVidWZmZXJTeXN0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyLCB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMgPSBbXSwgdGhpcy51bmtub3duRnJhbWVidWZmZXIgPSBuZXcgRnJhbWVidWZmZXIuRnJhbWVidWZmZXIoMTAsIDEwKSwgdGhpcy5tc2FhU2FtcGxlcyA9IG51bGw7XG4gIH1cbiAgLyoqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLiAqL1xuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIHRoaXMuZGlzcG9zZUFsbCghMCk7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICBpZiAodGhpcy5DT05URVhUX1VJRCA9IHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQsIHRoaXMuY3VycmVudCA9IHRoaXMudW5rbm93bkZyYW1lYnVmZmVyLCB0aGlzLnZpZXdwb3J0ID0gbmV3IG1hdGguUmVjdGFuZ2xlKCksIHRoaXMuaGFzTVJUID0gITAsIHRoaXMud3JpdGVEZXB0aFRleHR1cmUgPSAhMCwgdGhpcy5yZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbiA9PT0gMSkge1xuICAgICAgbGV0IG5hdGl2ZURyYXdCdWZmZXJzRXh0ZW5zaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMuZHJhd0J1ZmZlcnMsIG5hdGl2ZURlcHRoVGV4dHVyZUV4dGVuc2lvbiA9IHRoaXMucmVuZGVyZXIuY29udGV4dC5leHRlbnNpb25zLmRlcHRoVGV4dHVyZTtcbiAgICAgIHNldHRpbmdzLnNldHRpbmdzLlBSRUZFUl9FTlYgPT09IGNvbnN0YW50cy5FTlYuV0VCR0xfTEVHQUNZICYmIChuYXRpdmVEcmF3QnVmZmVyc0V4dGVuc2lvbiA9IG51bGwsIG5hdGl2ZURlcHRoVGV4dHVyZUV4dGVuc2lvbiA9IG51bGwpLCBuYXRpdmVEcmF3QnVmZmVyc0V4dGVuc2lvbiA/IGdsLmRyYXdCdWZmZXJzID0gKGFjdGl2ZVRleHR1cmVzKSA9PiBuYXRpdmVEcmF3QnVmZmVyc0V4dGVuc2lvbi5kcmF3QnVmZmVyc1dFQkdMKGFjdGl2ZVRleHR1cmVzKSA6ICh0aGlzLmhhc01SVCA9ICExLCBnbC5kcmF3QnVmZmVycyA9ICgpID0+IHtcbiAgICAgIH0pLCBuYXRpdmVEZXB0aFRleHR1cmVFeHRlbnNpb24gfHwgKHRoaXMud3JpdGVEZXB0aFRleHR1cmUgPSAhMSk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLm1zYWFTYW1wbGVzID0gZ2wuZ2V0SW50ZXJuYWxmb3JtYXRQYXJhbWV0ZXIoZ2wuUkVOREVSQlVGRkVSLCBnbC5SR0JBOCwgZ2wuU0FNUExFUyk7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmQgYSBmcmFtZWJ1ZmZlci5cbiAgICogQHBhcmFtIGZyYW1lYnVmZmVyXG4gICAqIEBwYXJhbSBmcmFtZSAtIGZyYW1lLCBkZWZhdWx0IGlzIGZyYW1lYnVmZmVyIHNpemVcbiAgICogQHBhcmFtIG1pcExldmVsIC0gb3B0aW9uYWwgbWlwIGxldmVsIHRvIHNldCBvbiB0aGUgZnJhbWVidWZmZXIgLSBkZWZhdWx0cyB0byAwXG4gICAqL1xuICBiaW5kKGZyYW1lYnVmZmVyLCBmcmFtZSwgbWlwTGV2ZWwgPSAwKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcztcbiAgICBpZiAoZnJhbWVidWZmZXIpIHtcbiAgICAgIGNvbnN0IGZibyA9IGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdIHx8IHRoaXMuaW5pdEZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKTtcbiAgICAgIHRoaXMuY3VycmVudCAhPT0gZnJhbWVidWZmZXIgJiYgKHRoaXMuY3VycmVudCA9IGZyYW1lYnVmZmVyLCBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZiby5mcmFtZWJ1ZmZlcikpLCBmYm8ubWlwTGV2ZWwgIT09IG1pcExldmVsICYmIChmcmFtZWJ1ZmZlci5kaXJ0eUlkKyssIGZyYW1lYnVmZmVyLmRpcnR5Rm9ybWF0KyssIGZiby5taXBMZXZlbCA9IG1pcExldmVsKSwgZmJvLmRpcnR5SWQgIT09IGZyYW1lYnVmZmVyLmRpcnR5SWQgJiYgKGZiby5kaXJ0eUlkID0gZnJhbWVidWZmZXIuZGlydHlJZCwgZmJvLmRpcnR5Rm9ybWF0ICE9PSBmcmFtZWJ1ZmZlci5kaXJ0eUZvcm1hdCA/IChmYm8uZGlydHlGb3JtYXQgPSBmcmFtZWJ1ZmZlci5kaXJ0eUZvcm1hdCwgZmJvLmRpcnR5U2l6ZSA9IGZyYW1lYnVmZmVyLmRpcnR5U2l6ZSwgdGhpcy51cGRhdGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlciwgbWlwTGV2ZWwpKSA6IGZiby5kaXJ0eVNpemUgIT09IGZyYW1lYnVmZmVyLmRpcnR5U2l6ZSAmJiAoZmJvLmRpcnR5U2l6ZSA9IGZyYW1lYnVmZmVyLmRpcnR5U2l6ZSwgdGhpcy5yZXNpemVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcikpKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0ZXggPSBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzW2ldO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUudW5iaW5kKHRleC5wYXJlbnRUZXh0dXJlQXJyYXkgfHwgdGV4KTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUgJiYgdGhpcy5yZW5kZXJlci50ZXh0dXJlLnVuYmluZChmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUpLCBmcmFtZSkge1xuICAgICAgICBjb25zdCBtaXBXaWR0aCA9IGZyYW1lLndpZHRoID4+IG1pcExldmVsLCBtaXBIZWlnaHQgPSBmcmFtZS5oZWlnaHQgPj4gbWlwTGV2ZWwsIHNjYWxlID0gbWlwV2lkdGggLyBmcmFtZS53aWR0aDtcbiAgICAgICAgdGhpcy5zZXRWaWV3cG9ydChcbiAgICAgICAgICBmcmFtZS54ICogc2NhbGUsXG4gICAgICAgICAgZnJhbWUueSAqIHNjYWxlLFxuICAgICAgICAgIG1pcFdpZHRoLFxuICAgICAgICAgIG1pcEhlaWdodFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWlwV2lkdGggPSBmcmFtZWJ1ZmZlci53aWR0aCA+PiBtaXBMZXZlbCwgbWlwSGVpZ2h0ID0gZnJhbWVidWZmZXIuaGVpZ2h0ID4+IG1pcExldmVsO1xuICAgICAgICB0aGlzLnNldFZpZXdwb3J0KDAsIDAsIG1pcFdpZHRoLCBtaXBIZWlnaHQpO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgdGhpcy5jdXJyZW50ICYmICh0aGlzLmN1cnJlbnQgPSBudWxsLCBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpKSwgZnJhbWUgPyB0aGlzLnNldFZpZXdwb3J0KGZyYW1lLngsIGZyYW1lLnksIGZyYW1lLndpZHRoLCBmcmFtZS5oZWlnaHQpIDogdGhpcy5zZXRWaWV3cG9ydCgwLCAwLCB0aGlzLnJlbmRlcmVyLndpZHRoLCB0aGlzLnJlbmRlcmVyLmhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0J3Mgdmlld3BvcnQuXG4gICAqIEBwYXJhbSB4IC0gWCBwb3NpdGlvbiBvZiB2aWV3cG9ydFxuICAgKiBAcGFyYW0geSAtIFkgcG9zaXRpb24gb2Ygdmlld3BvcnRcbiAgICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2Ygdmlld3BvcnRcbiAgICogQHBhcmFtIGhlaWdodCAtIEhlaWdodCBvZiB2aWV3cG9ydFxuICAgKi9cbiAgc2V0Vmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLnZpZXdwb3J0O1xuICAgIHggPSBNYXRoLnJvdW5kKHgpLCB5ID0gTWF0aC5yb3VuZCh5KSwgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKSwgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpLCAodi53aWR0aCAhPT0gd2lkdGggfHwgdi5oZWlnaHQgIT09IGhlaWdodCB8fCB2LnggIT09IHggfHwgdi55ICE9PSB5KSAmJiAodi54ID0geCwgdi55ID0geSwgdi53aWR0aCA9IHdpZHRoLCB2LmhlaWdodCA9IGhlaWdodCwgdGhpcy5nbC52aWV3cG9ydCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgY3VycmVudCB3aWR0aCBhbmQgaGVpZ2h0LiBSZXR1cm5zIG9iamVjdCB3aXRoIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHZhbHVlcy5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50ID8geyB4OiAwLCB5OiAwLCB3aWR0aDogdGhpcy5jdXJyZW50LndpZHRoLCBoZWlnaHQ6IHRoaXMuY3VycmVudC5oZWlnaHQgfSA6IHsgeDogMCwgeTogMCwgd2lkdGg6IHRoaXMucmVuZGVyZXIud2lkdGgsIGhlaWdodDogdGhpcy5yZW5kZXJlci5oZWlnaHQgfTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXIgdGhlIGNvbG9yIG9mIHRoZSBjb250ZXh0XG4gICAqIEBwYXJhbSByIC0gUmVkIHZhbHVlIGZyb20gMCB0byAxXG4gICAqIEBwYXJhbSBnIC0gR3JlZW4gdmFsdWUgZnJvbSAwIHRvIDFcbiAgICogQHBhcmFtIGIgLSBCbHVlIHZhbHVlIGZyb20gMCB0byAxXG4gICAqIEBwYXJhbSBhIC0gQWxwaGEgdmFsdWUgZnJvbSAwIHRvIDFcbiAgICogQHBhcmFtIHtQSVhJLkJVRkZFUl9CSVRTfSBbbWFzaz1CVUZGRVJfQklUUy5DT0xPUiB8IEJVRkZFUl9CSVRTLkRFUFRIXSAtIEJpdHdpc2UgT1Igb2YgbWFza3NcbiAgICogIHRoYXQgaW5kaWNhdGUgdGhlIGJ1ZmZlcnMgdG8gYmUgY2xlYXJlZCwgYnkgZGVmYXVsdCBDT0xPUiBhbmQgREVQVEggYnVmZmVycy5cbiAgICovXG4gIGNsZWFyKHIsIGcsIGIsIGEsIG1hc2sgPSBjb25zdGFudHMuQlVGRkVSX0JJVFMuQ09MT1IgfCBjb25zdGFudHMuQlVGRkVSX0JJVFMuREVQVEgpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIGdsLmNsZWFyQ29sb3IociwgZywgYiwgYSksIGdsLmNsZWFyKG1hc2spO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGZyYW1lYnVmZmVyIGZvciB0aGlzIGNvbnRleHRcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gZnJhbWVidWZmZXJcbiAgICogQHJldHVybnMgLSBjcmVhdGVkIEdMRnJhbWVidWZmZXJcbiAgICovXG4gIGluaXRGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcikge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMsIGZibyA9IG5ldyBHTEZyYW1lYnVmZmVyLkdMRnJhbWVidWZmZXIoZ2wuY3JlYXRlRnJhbWVidWZmZXIoKSk7XG4gICAgcmV0dXJuIGZiby5tdWx0aXNhbXBsZSA9IHRoaXMuZGV0ZWN0U2FtcGxlcyhmcmFtZWJ1ZmZlci5tdWx0aXNhbXBsZSksIGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdID0gZmJvLCB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMucHVzaChmcmFtZWJ1ZmZlciksIGZyYW1lYnVmZmVyLmRpc3Bvc2VSdW5uZXIuYWRkKHRoaXMpLCBmYm87XG4gIH1cbiAgLyoqXG4gICAqIFJlc2l6ZSB0aGUgZnJhbWVidWZmZXJcbiAgICogQHBhcmFtIGZyYW1lYnVmZmVyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHJlc2l6ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcywgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgaWYgKGZiby5zdGVuY2lsKSB7XG4gICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgZmJvLnN0ZW5jaWwpO1xuICAgICAgbGV0IHN0ZW5jaWxGb3JtYXQ7XG4gICAgICB0aGlzLnJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAxID8gc3RlbmNpbEZvcm1hdCA9IGdsLkRFUFRIX1NURU5DSUwgOiBmcmFtZWJ1ZmZlci5kZXB0aCAmJiBmcmFtZWJ1ZmZlci5zdGVuY2lsID8gc3RlbmNpbEZvcm1hdCA9IGdsLkRFUFRIMjRfU1RFTkNJTDggOiBmcmFtZWJ1ZmZlci5kZXB0aCA/IHN0ZW5jaWxGb3JtYXQgPSBnbC5ERVBUSF9DT01QT05FTlQyNCA6IHN0ZW5jaWxGb3JtYXQgPSBnbC5TVEVOQ0lMX0lOREVYOCwgZmJvLm1zYWFCdWZmZXIgPyBnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoXG4gICAgICAgIGdsLlJFTkRFUkJVRkZFUixcbiAgICAgICAgZmJvLm11bHRpc2FtcGxlLFxuICAgICAgICBzdGVuY2lsRm9ybWF0LFxuICAgICAgICBmcmFtZWJ1ZmZlci53aWR0aCxcbiAgICAgICAgZnJhbWVidWZmZXIuaGVpZ2h0XG4gICAgICApIDogZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIHN0ZW5jaWxGb3JtYXQsIGZyYW1lYnVmZmVyLndpZHRoLCBmcmFtZWJ1ZmZlci5oZWlnaHQpO1xuICAgIH1cbiAgICBjb25zdCBjb2xvclRleHR1cmVzID0gZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlcztcbiAgICBsZXQgY291bnQgPSBjb2xvclRleHR1cmVzLmxlbmd0aDtcbiAgICBnbC5kcmF3QnVmZmVycyB8fCAoY291bnQgPSBNYXRoLm1pbihjb3VudCwgMSkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IGNvbG9yVGV4dHVyZXNbaV0sIHBhcmVudFRleHR1cmUgPSB0ZXh0dXJlLnBhcmVudFRleHR1cmVBcnJheSB8fCB0ZXh0dXJlO1xuICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQocGFyZW50VGV4dHVyZSwgMCksIGkgPT09IDAgJiYgZmJvLm1zYWFCdWZmZXIgJiYgKGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBmYm8ubXNhYUJ1ZmZlciksIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShcbiAgICAgICAgZ2wuUkVOREVSQlVGRkVSLFxuICAgICAgICBmYm8ubXVsdGlzYW1wbGUsXG4gICAgICAgIHBhcmVudFRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0uaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgIGZyYW1lYnVmZmVyLndpZHRoLFxuICAgICAgICBmcmFtZWJ1ZmZlci5oZWlnaHRcbiAgICAgICkpO1xuICAgIH1cbiAgICBmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUgJiYgdGhpcy53cml0ZURlcHRoVGV4dHVyZSAmJiB0aGlzLnJlbmRlcmVyLnRleHR1cmUuYmluZChmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUsIDApO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGZyYW1lYnVmZmVyXG4gICAqIEBwYXJhbSBmcmFtZWJ1ZmZlclxuICAgKiBAcGFyYW0gbWlwTGV2ZWxcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdXBkYXRlRnJhbWVidWZmZXIoZnJhbWVidWZmZXIsIG1pcExldmVsKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcywgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF0sIGNvbG9yVGV4dHVyZXMgPSBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzO1xuICAgIGxldCBjb3VudCA9IGNvbG9yVGV4dHVyZXMubGVuZ3RoO1xuICAgIGdsLmRyYXdCdWZmZXJzIHx8IChjb3VudCA9IE1hdGgubWluKGNvdW50LCAxKSksIGZiby5tdWx0aXNhbXBsZSA+IDEgJiYgdGhpcy5jYW5NdWx0aXNhbXBsZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKSA/IGZiby5tc2FhQnVmZmVyID0gZmJvLm1zYWFCdWZmZXIgfHwgZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCkgOiBmYm8ubXNhYUJ1ZmZlciAmJiAoZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKGZiby5tc2FhQnVmZmVyKSwgZmJvLm1zYWFCdWZmZXIgPSBudWxsLCBmYm8uYmxpdEZyYW1lYnVmZmVyICYmIChmYm8uYmxpdEZyYW1lYnVmZmVyLmRpc3Bvc2UoKSwgZmJvLmJsaXRGcmFtZWJ1ZmZlciA9IG51bGwpKTtcbiAgICBjb25zdCBhY3RpdmVUZXh0dXJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IGNvbG9yVGV4dHVyZXNbaV0sIHBhcmVudFRleHR1cmUgPSB0ZXh0dXJlLnBhcmVudFRleHR1cmVBcnJheSB8fCB0ZXh0dXJlO1xuICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQocGFyZW50VGV4dHVyZSwgMCksIGkgPT09IDAgJiYgZmJvLm1zYWFCdWZmZXIgPyAoZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIGZiby5tc2FhQnVmZmVyKSwgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKFxuICAgICAgICBnbC5SRU5ERVJCVUZGRVIsXG4gICAgICAgIGZiby5tdWx0aXNhbXBsZSxcbiAgICAgICAgcGFyZW50VGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgZnJhbWVidWZmZXIud2lkdGgsXG4gICAgICAgIGZyYW1lYnVmZmVyLmhlaWdodFxuICAgICAgKSwgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5SRU5ERVJCVUZGRVIsIGZiby5tc2FhQnVmZmVyKSkgOiAoZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksXG4gICAgICAgIHRleHR1cmUudGFyZ2V0LFxuICAgICAgICBwYXJlbnRUZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLnRleHR1cmUsXG4gICAgICAgIG1pcExldmVsXG4gICAgICApLCBhY3RpdmVUZXh0dXJlcy5wdXNoKGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSkpO1xuICAgIH1cbiAgICBpZiAoYWN0aXZlVGV4dHVyZXMubGVuZ3RoID4gMSAmJiBnbC5kcmF3QnVmZmVycyhhY3RpdmVUZXh0dXJlcyksIGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSAmJiB0aGlzLndyaXRlRGVwdGhUZXh0dXJlKSB7XG4gICAgICBjb25zdCBkZXB0aFRleHR1cmUgPSBmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmU7XG4gICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUuYmluZChkZXB0aFRleHR1cmUsIDApLCBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICAgIGdsLkRFUFRIX0FUVEFDSE1FTlQsXG4gICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIGRlcHRoVGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXS50ZXh0dXJlLFxuICAgICAgICBtaXBMZXZlbFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKChmcmFtZWJ1ZmZlci5zdGVuY2lsIHx8IGZyYW1lYnVmZmVyLmRlcHRoKSAmJiAhKGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSAmJiB0aGlzLndyaXRlRGVwdGhUZXh0dXJlKSkge1xuICAgICAgZmJvLnN0ZW5jaWwgPSBmYm8uc3RlbmNpbCB8fCBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgIGxldCBzdGVuY2lsQXR0YWNobWVudCwgc3RlbmNpbEZvcm1hdDtcbiAgICAgIHRoaXMucmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24gPT09IDEgPyAoc3RlbmNpbEF0dGFjaG1lbnQgPSBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIHN0ZW5jaWxGb3JtYXQgPSBnbC5ERVBUSF9TVEVOQ0lMKSA6IGZyYW1lYnVmZmVyLmRlcHRoICYmIGZyYW1lYnVmZmVyLnN0ZW5jaWwgPyAoc3RlbmNpbEF0dGFjaG1lbnQgPSBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIHN0ZW5jaWxGb3JtYXQgPSBnbC5ERVBUSDI0X1NURU5DSUw4KSA6IGZyYW1lYnVmZmVyLmRlcHRoID8gKHN0ZW5jaWxBdHRhY2htZW50ID0gZ2wuREVQVEhfQVRUQUNITUVOVCwgc3RlbmNpbEZvcm1hdCA9IGdsLkRFUFRIX0NPTVBPTkVOVDI0KSA6IChzdGVuY2lsQXR0YWNobWVudCA9IGdsLlNURU5DSUxfQVRUQUNITUVOVCwgc3RlbmNpbEZvcm1hdCA9IGdsLlNURU5DSUxfSU5ERVg4KSwgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIGZiby5zdGVuY2lsKSwgZmJvLm1zYWFCdWZmZXIgPyBnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoXG4gICAgICAgIGdsLlJFTkRFUkJVRkZFUixcbiAgICAgICAgZmJvLm11bHRpc2FtcGxlLFxuICAgICAgICBzdGVuY2lsRm9ybWF0LFxuICAgICAgICBmcmFtZWJ1ZmZlci53aWR0aCxcbiAgICAgICAgZnJhbWVidWZmZXIuaGVpZ2h0XG4gICAgICApIDogZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIHN0ZW5jaWxGb3JtYXQsIGZyYW1lYnVmZmVyLndpZHRoLCBmcmFtZWJ1ZmZlci5oZWlnaHQpLCBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgc3RlbmNpbEF0dGFjaG1lbnQsIGdsLlJFTkRFUkJVRkZFUiwgZmJvLnN0ZW5jaWwpO1xuICAgIH0gZWxzZVxuICAgICAgZmJvLnN0ZW5jaWwgJiYgKGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihmYm8uc3RlbmNpbCksIGZiby5zdGVuY2lsID0gbnVsbCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZnJhbWUgYnVmZmVyIGNhbiBiZSBtdWx0aXNhbXBsZWQuXG4gICAqIEBwYXJhbSBmcmFtZWJ1ZmZlclxuICAgKi9cbiAgY2FuTXVsdGlzYW1wbGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcikge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uICE9PSAxICYmIGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXMubGVuZ3RoIDw9IDEgJiYgIWZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogRGV0ZWN0cyBudW1iZXIgb2Ygc2FtcGxlcyB0aGF0IGlzIG5vdCBtb3JlIHRoYW4gYSBwYXJhbSBidXQgYXMgY2xvc2UgdG8gaXQgYXMgcG9zc2libGVcbiAgICogQHBhcmFtIHNhbXBsZXMgLSBudW1iZXIgb2Ygc2FtcGxlc1xuICAgKiBAcmV0dXJucyAtIHJlY29tbWVuZGVkIG51bWJlciBvZiBzYW1wbGVzXG4gICAqL1xuICBkZXRlY3RTYW1wbGVzKHNhbXBsZXMpIHtcbiAgICBjb25zdCB7IG1zYWFTYW1wbGVzIH0gPSB0aGlzO1xuICAgIGxldCByZXMgPSBjb25zdGFudHMuTVNBQV9RVUFMSVRZLk5PTkU7XG4gICAgaWYgKHNhbXBsZXMgPD0gMSB8fCBtc2FhU2FtcGxlcyA9PT0gbnVsbClcbiAgICAgIHJldHVybiByZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtc2FhU2FtcGxlcy5sZW5ndGg7IGkrKylcbiAgICAgIGlmIChtc2FhU2FtcGxlc1tpXSA8PSBzYW1wbGVzKSB7XG4gICAgICAgIHJlcyA9IG1zYWFTYW1wbGVzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICByZXR1cm4gcmVzID09PSAxICYmIChyZXMgPSBjb25zdGFudHMuTVNBQV9RVUFMSVRZLk5PTkUpLCByZXM7XG4gIH1cbiAgLyoqXG4gICAqIE9ubHkgd29ya3Mgd2l0aCBXZWJHTDJcbiAgICpcbiAgICogYmxpdHMgZnJhbWVidWZmZXIgdG8gYW5vdGhlciBvZiB0aGUgc2FtZSBvciBiaWdnZXIgc2l6ZVxuICAgKiBhZnRlciB0aGF0IHRhcmdldCBmcmFtZWJ1ZmZlciBpcyBib3VuZFxuICAgKlxuICAgKiBGYWlscyB3aXRoIFdlYkdMIHdhcm5pbmcgaWYgYmxpdHMgbXVsdGlzYW1wbGUgZnJhbWVidWZmZXIgdG8gZGlmZmVyZW50IHNpemVcbiAgICogQHBhcmFtIGZyYW1lYnVmZmVyIC0gYnkgZGVmYXVsdCBpdCBibGl0cyBcImludG8gaXRzZWxmXCIsIGZyb20gcmVuZGVyQnVmZmVyIHRvIHRleHR1cmUuXG4gICAqIEBwYXJhbSBzb3VyY2VQaXhlbHMgLSBzb3VyY2UgcmVjdGFuZ2xlIGluIHBpeGVsc1xuICAgKiBAcGFyYW0gZGVzdFBpeGVscyAtIGRlc3QgcmVjdGFuZ2xlIGluIHBpeGVscywgYXNzdW1lZCB0byBiZSB0aGUgc2FtZSBhcyBzb3VyY2VQaXhlbHNcbiAgICovXG4gIGJsaXQoZnJhbWVidWZmZXIsIHNvdXJjZVBpeGVscywgZGVzdFBpeGVscykge1xuICAgIGNvbnN0IHsgY3VycmVudCwgcmVuZGVyZXIsIGdsLCBDT05URVhUX1VJRCB9ID0gdGhpcztcbiAgICBpZiAocmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24gIT09IDIgfHwgIWN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZmJvID0gY3VycmVudC5nbEZyYW1lYnVmZmVyc1tDT05URVhUX1VJRF07XG4gICAgaWYgKCFmYm8pXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFmcmFtZWJ1ZmZlcikge1xuICAgICAgaWYgKCFmYm8ubXNhYUJ1ZmZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgY29sb3JUZXh0dXJlID0gY3VycmVudC5jb2xvclRleHR1cmVzWzBdO1xuICAgICAgaWYgKCFjb2xvclRleHR1cmUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGZiby5ibGl0RnJhbWVidWZmZXIgfHwgKGZiby5ibGl0RnJhbWVidWZmZXIgPSBuZXcgRnJhbWVidWZmZXIuRnJhbWVidWZmZXIoY3VycmVudC53aWR0aCwgY3VycmVudC5oZWlnaHQpLCBmYm8uYmxpdEZyYW1lYnVmZmVyLmFkZENvbG9yVGV4dHVyZSgwLCBjb2xvclRleHR1cmUpKSwgZnJhbWVidWZmZXIgPSBmYm8uYmxpdEZyYW1lYnVmZmVyLCBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzWzBdICE9PSBjb2xvclRleHR1cmUgJiYgKGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXNbMF0gPSBjb2xvclRleHR1cmUsIGZyYW1lYnVmZmVyLmRpcnR5SWQrKywgZnJhbWVidWZmZXIuZGlydHlGb3JtYXQrKyksIChmcmFtZWJ1ZmZlci53aWR0aCAhPT0gY3VycmVudC53aWR0aCB8fCBmcmFtZWJ1ZmZlci5oZWlnaHQgIT09IGN1cnJlbnQuaGVpZ2h0KSAmJiAoZnJhbWVidWZmZXIud2lkdGggPSBjdXJyZW50LndpZHRoLCBmcmFtZWJ1ZmZlci5oZWlnaHQgPSBjdXJyZW50LmhlaWdodCwgZnJhbWVidWZmZXIuZGlydHlJZCsrLCBmcmFtZWJ1ZmZlci5kaXJ0eVNpemUrKyk7XG4gICAgfVxuICAgIHNvdXJjZVBpeGVscyB8fCAoc291cmNlUGl4ZWxzID0gdGVtcFJlY3RhbmdsZSwgc291cmNlUGl4ZWxzLndpZHRoID0gY3VycmVudC53aWR0aCwgc291cmNlUGl4ZWxzLmhlaWdodCA9IGN1cnJlbnQuaGVpZ2h0KSwgZGVzdFBpeGVscyB8fCAoZGVzdFBpeGVscyA9IHNvdXJjZVBpeGVscyk7XG4gICAgY29uc3Qgc2FtZVNpemUgPSBzb3VyY2VQaXhlbHMud2lkdGggPT09IGRlc3RQaXhlbHMud2lkdGggJiYgc291cmNlUGl4ZWxzLmhlaWdodCA9PT0gZGVzdFBpeGVscy5oZWlnaHQ7XG4gICAgdGhpcy5iaW5kKGZyYW1lYnVmZmVyKSwgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLlJFQURfRlJBTUVCVUZGRVIsIGZiby5mcmFtZWJ1ZmZlciksIGdsLmJsaXRGcmFtZWJ1ZmZlcihcbiAgICAgIHNvdXJjZVBpeGVscy5sZWZ0LFxuICAgICAgc291cmNlUGl4ZWxzLnRvcCxcbiAgICAgIHNvdXJjZVBpeGVscy5yaWdodCxcbiAgICAgIHNvdXJjZVBpeGVscy5ib3R0b20sXG4gICAgICBkZXN0UGl4ZWxzLmxlZnQsXG4gICAgICBkZXN0UGl4ZWxzLnRvcCxcbiAgICAgIGRlc3RQaXhlbHMucmlnaHQsXG4gICAgICBkZXN0UGl4ZWxzLmJvdHRvbSxcbiAgICAgIGdsLkNPTE9SX0JVRkZFUl9CSVQsXG4gICAgICBzYW1lU2l6ZSA/IGdsLk5FQVJFU1QgOiBnbC5MSU5FQVJcbiAgICApLCBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuUkVBRF9GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF0uZnJhbWVidWZmZXIpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNwb3NlcyBmcmFtZWJ1ZmZlci5cbiAgICogQHBhcmFtIGZyYW1lYnVmZmVyIC0gZnJhbWVidWZmZXIgdGhhdCBoYXMgdG8gYmUgZGlzcG9zZWQgb2ZcbiAgICogQHBhcmFtIGNvbnRleHRMb3N0IC0gSWYgY29udGV4dCB3YXMgbG9zdCwgd2Ugc3VwcHJlc3MgYWxsIGRlbGV0ZSBmdW5jdGlvbiBjYWxsc1xuICAgKi9cbiAgZGlzcG9zZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyLCBjb250ZXh0TG9zdCkge1xuICAgIGNvbnN0IGZibyA9IGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdLCBnbCA9IHRoaXMuZ2w7XG4gICAgaWYgKCFmYm8pXG4gICAgICByZXR1cm47XG4gICAgZGVsZXRlIGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzLmluZGV4T2YoZnJhbWVidWZmZXIpO1xuICAgIGluZGV4ID49IDAgJiYgdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzLnNwbGljZShpbmRleCwgMSksIGZyYW1lYnVmZmVyLmRpc3Bvc2VSdW5uZXIucmVtb3ZlKHRoaXMpLCBjb250ZXh0TG9zdCB8fCAoZ2wuZGVsZXRlRnJhbWVidWZmZXIoZmJvLmZyYW1lYnVmZmVyKSwgZmJvLm1zYWFCdWZmZXIgJiYgZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKGZiby5tc2FhQnVmZmVyKSwgZmJvLnN0ZW5jaWwgJiYgZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKGZiby5zdGVuY2lsKSksIGZiby5ibGl0RnJhbWVidWZmZXIgJiYgdGhpcy5kaXNwb3NlRnJhbWVidWZmZXIoZmJvLmJsaXRGcmFtZWJ1ZmZlciwgY29udGV4dExvc3QpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNwb3NlcyBhbGwgZnJhbWVidWZmZXJzLCBidXQgbm90IHRleHR1cmVzIGJvdW5kIHRvIHRoZW0uXG4gICAqIEBwYXJhbSBbY29udGV4dExvc3Q9ZmFsc2VdIC0gSWYgY29udGV4dCB3YXMgbG9zdCwgd2Ugc3VwcHJlc3MgYWxsIGRlbGV0ZSBmdW5jdGlvbiBjYWxsc1xuICAgKi9cbiAgZGlzcG9zZUFsbChjb250ZXh0TG9zdCkge1xuICAgIGNvbnN0IGxpc3QgPSB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnM7XG4gICAgdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5kaXNwb3NlRnJhbWVidWZmZXIobGlzdFtpXSwgY29udGV4dExvc3QpO1xuICB9XG4gIC8qKlxuICAgKiBGb3JjaW5nIGNyZWF0aW9uIG9mIHN0ZW5jaWwgYnVmZmVyIGZvciBjdXJyZW50IGZyYW1lYnVmZmVyLCBpZiBpdCB3YXNuJ3QgZG9uZSBiZWZvcmUuXG4gICAqIFVzZWQgYnkgTWFza1N5c3RlbSwgd2hlbiBpdHMgdGltZSB0byB1c2Ugc3RlbmNpbCBtYXNrIGZvciBHcmFwaGljcyBlbGVtZW50LlxuICAgKlxuICAgKiBJdHMgYW4gYWx0ZXJuYXRpdmUgZm9yIHB1YmxpYyBsYXp5IGBmcmFtZWJ1ZmZlci5lbmFibGVTdGVuY2lsYCwgaW4gY2FzZSB3ZSBuZWVkIHN0ZW5jaWwgd2l0aG91dCByZWJpbmQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmb3JjZVN0ZW5jaWwoKSB7XG4gICAgY29uc3QgZnJhbWVidWZmZXIgPSB0aGlzLmN1cnJlbnQ7XG4gICAgaWYgKCFmcmFtZWJ1ZmZlcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmYm8gPSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICBpZiAoIWZibyB8fCBmYm8uc3RlbmNpbCAmJiBmcmFtZWJ1ZmZlci5zdGVuY2lsKVxuICAgICAgcmV0dXJuO1xuICAgIGZyYW1lYnVmZmVyLnN0ZW5jaWwgPSAhMDtcbiAgICBjb25zdCB3ID0gZnJhbWVidWZmZXIud2lkdGgsIGggPSBmcmFtZWJ1ZmZlci5oZWlnaHQsIGdsID0gdGhpcy5nbCwgc3RlbmNpbCA9IGZiby5zdGVuY2lsID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHN0ZW5jaWwpO1xuICAgIGxldCBzdGVuY2lsQXR0YWNobWVudCwgc3RlbmNpbEZvcm1hdDtcbiAgICB0aGlzLnJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAxID8gKHN0ZW5jaWxBdHRhY2htZW50ID0gZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBzdGVuY2lsRm9ybWF0ID0gZ2wuREVQVEhfU1RFTkNJTCkgOiBmcmFtZWJ1ZmZlci5kZXB0aCA/IChzdGVuY2lsQXR0YWNobWVudCA9IGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgc3RlbmNpbEZvcm1hdCA9IGdsLkRFUFRIMjRfU1RFTkNJTDgpIDogKHN0ZW5jaWxBdHRhY2htZW50ID0gZ2wuU1RFTkNJTF9BVFRBQ0hNRU5ULCBzdGVuY2lsRm9ybWF0ID0gZ2wuU1RFTkNJTF9JTkRFWDgpLCBmYm8ubXNhYUJ1ZmZlciA/IGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShnbC5SRU5ERVJCVUZGRVIsIGZiby5tdWx0aXNhbXBsZSwgc3RlbmNpbEZvcm1hdCwgdywgaCkgOiBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgc3RlbmNpbEZvcm1hdCwgdywgaCksIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBzdGVuY2lsQXR0YWNobWVudCwgZ2wuUkVOREVSQlVGRkVSLCBzdGVuY2lsKTtcbiAgfVxuICAvKiogUmVzZXRzIGZyYW1lYnVmZmVyIHN0b3JlZCBzdGF0ZSwgYmluZHMgc2NyZWVuIGZyYW1lYnVmZmVyLiBTaG91bGQgYmUgY2FsbGVkIGJlZm9yZSByZW5kZXJUZXh0dXJlIHJlc2V0KCkuICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMudW5rbm93bkZyYW1lYnVmZmVyLCB0aGlzLnZpZXdwb3J0ID0gbmV3IG1hdGguUmVjdGFuZ2xlKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuRnJhbWVidWZmZXJTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwiZnJhbWVidWZmZXJcIlxufTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5hZGQoRnJhbWVidWZmZXJTeXN0ZW0pO1xuZXhwb3J0cy5GcmFtZWJ1ZmZlclN5c3RlbSA9IEZyYW1lYnVmZmVyU3lzdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJhbWVidWZmZXJTeXN0ZW0uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiQHBpeGkvY29uc3RhbnRzXCIpO1xuY2xhc3MgR0xGcmFtZWJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKGZyYW1lYnVmZmVyKSB7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyLCB0aGlzLnN0ZW5jaWwgPSBudWxsLCB0aGlzLmRpcnR5SWQgPSAtMSwgdGhpcy5kaXJ0eUZvcm1hdCA9IC0xLCB0aGlzLmRpcnR5U2l6ZSA9IC0xLCB0aGlzLm11bHRpc2FtcGxlID0gY29uc3RhbnRzLk1TQUFfUVVBTElUWS5OT05FLCB0aGlzLm1zYWFCdWZmZXIgPSBudWxsLCB0aGlzLmJsaXRGcmFtZWJ1ZmZlciA9IG51bGwsIHRoaXMubWlwTGV2ZWwgPSAwO1xuICB9XG59XG5leHBvcnRzLkdMRnJhbWVidWZmZXIgPSBHTEZyYW1lYnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R0xGcmFtZWJ1ZmZlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCJAcGl4aS9jb25zdGFudHNcIiksIGV4dGVuc2lvbnMgPSByZXF1aXJlKFwiQHBpeGkvZXh0ZW5zaW9uc1wiKTtcbmNsYXNzIE11bHRpc2FtcGxlU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgY29udGV4dENoYW5nZShnbCkge1xuICAgIGxldCBzYW1wbGVzO1xuICAgIGlmICh0aGlzLnJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IGdsLmdldFBhcmFtZXRlcihnbC5GUkFNRUJVRkZFUl9CSU5ESU5HKTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCksIHNhbXBsZXMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuU0FNUExFUyksIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IGdsLmdldFBhcmFtZXRlcihnbC5EUkFXX0ZSQU1FQlVGRkVSX0JJTkRJTkcpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkRSQVdfRlJBTUVCVUZGRVIsIG51bGwpLCBzYW1wbGVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlNBTVBMRVMpLCBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRFJBV19GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuICAgIH1cbiAgICBzYW1wbGVzID49IGNvbnN0YW50cy5NU0FBX1FVQUxJVFkuSElHSCA/IHRoaXMubXVsdGlzYW1wbGUgPSBjb25zdGFudHMuTVNBQV9RVUFMSVRZLkhJR0ggOiBzYW1wbGVzID49IGNvbnN0YW50cy5NU0FBX1FVQUxJVFkuTUVESVVNID8gdGhpcy5tdWx0aXNhbXBsZSA9IGNvbnN0YW50cy5NU0FBX1FVQUxJVFkuTUVESVVNIDogc2FtcGxlcyA+PSBjb25zdGFudHMuTVNBQV9RVUFMSVRZLkxPVyA/IHRoaXMubXVsdGlzYW1wbGUgPSBjb25zdGFudHMuTVNBQV9RVUFMSVRZLkxPVyA6IHRoaXMubXVsdGlzYW1wbGUgPSBjb25zdGFudHMuTVNBQV9RVUFMSVRZLk5PTkU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgfVxufVxuTXVsdGlzYW1wbGVTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwiX211bHRpc2FtcGxlXCJcbn07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKE11bHRpc2FtcGxlU3lzdGVtKTtcbmV4cG9ydHMuTXVsdGlzYW1wbGVTeXN0ZW0gPSBNdWx0aXNhbXBsZVN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU11bHRpc2FtcGxlU3lzdGVtLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKTtcbmNsYXNzIEF0dHJpYnV0ZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gdGhlIGlkIG9mIHRoZSBidWZmZXIgdGhhdCB0aGlzIGF0dHJpYnV0ZSB3aWxsIGxvb2sgZm9yXG4gICAqIEBwYXJhbSBzaXplIC0gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZS4gSWYgeW91IGhhdmUgMiBmbG9hdHMgcGVyIHZlcnRleCAoZWcgcG9zaXRpb24geCBhbmQgeSkgdGhpcyB3b3VsZCBiZSAyLlxuICAgKiBAcGFyYW0gbm9ybWFsaXplZCAtIHNob3VsZCB0aGUgZGF0YSBiZSBub3JtYWxpemVkLlxuICAgKiBAcGFyYW0ge1BJWEkuVFlQRVN9IFt0eXBlPVBJWEkuVFlQRVMuRkxPQVRdIC0gd2hhdCB0eXBlIG9mIG51bWJlciBpcyB0aGUgYXR0cmlidXRlLiBDaGVjayB7QGxpbmsgUElYSS5UWVBFU30gdG8gc2VlIHRoZSBvbmVzIGF2YWlsYWJsZVxuICAgKiBAcGFyYW0gW3N0cmlkZT0wXSAtIEhvdyBmYXIgYXBhcnQsIGluIGJ5dGVzLCB0aGUgc3RhcnQgb2YgZWFjaCB2YWx1ZSBpcy4gKHVzZWQgZm9yIGludGVybGVhdmluZyBkYXRhKVxuICAgKiBAcGFyYW0gW3N0YXJ0PTBdIC0gSG93IGZhciBpbnRvIHRoZSBhcnJheSB0byBzdGFydCByZWFkaW5nIHZhbHVlcyAodXNlZCBmb3IgaW50ZXJsZWF2aW5nIGRhdGEpXG4gICAqIEBwYXJhbSBbaW5zdGFuY2U9ZmFsc2VdIC0gV2hldGhlciB0aGUgZ2VvbWV0cnkgaXMgaW5zdGFuY2VkLlxuICAgKiBAcGFyYW0gW2Rpdmlzb3I9MV0gLSBEaXZpc29yIHRvIHVzZSB3aGVuIGRvaW5nIGluc3RhbmNlZCByZW5kZXJpbmdcbiAgICovXG4gIGNvbnN0cnVjdG9yKGJ1ZmZlciwgc2l6ZSA9IDAsIG5vcm1hbGl6ZWQgPSAhMSwgdHlwZSA9IGNvbnN0YW50cy5UWVBFUy5GTE9BVCwgc3RyaWRlLCBzdGFydCwgaW5zdGFuY2UsIGRpdmlzb3IgPSAxKSB7XG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXIsIHRoaXMuc2l6ZSA9IHNpemUsIHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQsIHRoaXMudHlwZSA9IHR5cGUsIHRoaXMuc3RyaWRlID0gc3RyaWRlLCB0aGlzLnN0YXJ0ID0gc3RhcnQsIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZSwgdGhpcy5kaXZpc29yID0gZGl2aXNvcjtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIEF0dHJpYnV0ZS4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYW4gQXR0cmlidXRlIGJhc2VkIG9uIHRoZSBpbmZvcm1hdGlvbiBwcm92aWRlZFxuICAgKiBAcGFyYW0gYnVmZmVyIC0gdGhlIGlkIG9mIHRoZSBidWZmZXIgdGhhdCB0aGlzIGF0dHJpYnV0ZSB3aWxsIGxvb2sgZm9yXG4gICAqIEBwYXJhbSBbc2l6ZT0wXSAtIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGUuIElmIHlvdSBoYXZlIDIgZmxvYXRzIHBlciB2ZXJ0ZXggKGVnIHBvc2l0aW9uIHggYW5kIHkpIHRoaXMgd291bGQgYmUgMlxuICAgKiBAcGFyYW0gW25vcm1hbGl6ZWQ9ZmFsc2VdIC0gc2hvdWxkIHRoZSBkYXRhIGJlIG5vcm1hbGl6ZWQuXG4gICAqIEBwYXJhbSBbdHlwZT1QSVhJLlRZUEVTLkZMT0FUXSAtIHdoYXQgdHlwZSBvZiBudW1iZXIgaXMgdGhlIGF0dHJpYnV0ZS4gQ2hlY2sge0BsaW5rIFBJWEkuVFlQRVN9IHRvIHNlZSB0aGUgb25lcyBhdmFpbGFibGVcbiAgICogQHBhcmFtIFtzdHJpZGU9MF0gLSBIb3cgZmFyIGFwYXJ0LCBpbiBieXRlcywgdGhlIHN0YXJ0IG9mIGVhY2ggdmFsdWUgaXMuICh1c2VkIGZvciBpbnRlcmxlYXZpbmcgZGF0YSlcbiAgICogQHJldHVybnMgLSBBIG5ldyB7QGxpbmsgUElYSS5BdHRyaWJ1dGV9IGJhc2VkIG9uIHRoZSBpbmZvcm1hdGlvbiBwcm92aWRlZFxuICAgKi9cbiAgc3RhdGljIGZyb20oYnVmZmVyLCBzaXplLCBub3JtYWxpemVkLCB0eXBlLCBzdHJpZGUpIHtcbiAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZShidWZmZXIsIHNpemUsIG5vcm1hbGl6ZWQsIHR5cGUsIHN0cmlkZSk7XG4gIH1cbn1cbmV4cG9ydHMuQXR0cmlidXRlID0gQXR0cmlidXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXR0cmlidXRlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKSwgcnVubmVyID0gcmVxdWlyZShcIkBwaXhpL3J1bm5lclwiKTtcbmxldCBVSUQgPSAwO1xuY2xhc3MgQnVmZmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5JQXJyYXlCdWZmZXJ9IGRhdGEgLSB0aGUgZGF0YSB0byBzdG9yZSBpbiB0aGUgYnVmZmVyLlxuICAgKiBAcGFyYW0gX3N0YXRpYyAtIGB0cnVlYCBmb3Igc3RhdGljIGJ1ZmZlclxuICAgKiBAcGFyYW0gaW5kZXggLSBgdHJ1ZWAgZm9yIGluZGV4IGJ1ZmZlclxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSwgX3N0YXRpYyA9ICEwLCBpbmRleCA9ICExKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YSB8fCBuZXcgRmxvYXQzMkFycmF5KDEpLCB0aGlzLl9nbEJ1ZmZlcnMgPSB7fSwgdGhpcy5fdXBkYXRlSUQgPSAwLCB0aGlzLmluZGV4ID0gaW5kZXgsIHRoaXMuc3RhdGljID0gX3N0YXRpYywgdGhpcy5pZCA9IFVJRCsrLCB0aGlzLmRpc3Bvc2VSdW5uZXIgPSBuZXcgcnVubmVyLlJ1bm5lcihcImRpc3Bvc2VCdWZmZXJcIik7XG4gIH1cbiAgLy8gVE9ETyBjb3VsZCBleHBsb3JlIGZsYWdnaW5nIG9ubHkgYSBwYXJ0aWFsIHVwbG9hZD9cbiAgLyoqXG4gICAqIEZsYWdzIHRoaXMgYnVmZmVyIGFzIHJlcXVpcmluZyBhbiB1cGxvYWQgdG8gdGhlIEdQVS5cbiAgICogQHBhcmFtIHtQSVhJLklBcnJheUJ1ZmZlcnxudW1iZXJbXX0gW2RhdGFdIC0gdGhlIGRhdGEgdG8gdXBkYXRlIGluIHRoZSBidWZmZXIuXG4gICAqL1xuICB1cGRhdGUoZGF0YSkge1xuICAgIGRhdGEgaW5zdGFuY2VvZiBBcnJheSAmJiAoZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSkpLCB0aGlzLmRhdGEgPSBkYXRhIHx8IHRoaXMuZGF0YSwgdGhpcy5fdXBkYXRlSUQrKztcbiAgfVxuICAvKiogRGlzcG9zZXMgV2ViR0wgcmVzb3VyY2VzIHRoYXQgYXJlIGNvbm5lY3RlZCB0byB0aGlzIGdlb21ldHJ5LiAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZGlzcG9zZVJ1bm5lci5lbWl0KHRoaXMsICExKTtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIGJ1ZmZlci4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRpc3Bvc2UoKSwgdGhpcy5kYXRhID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogRmxhZ3Mgd2hldGhlciB0aGlzIGlzIGFuIGluZGV4IGJ1ZmZlci5cbiAgICpcbiAgICogSW5kZXggYnVmZmVycyBhcmUgb2YgdHlwZSBgRUxFTUVOVF9BUlJBWV9CVUZGRVJgLiBOb3RlIHRoYXQgc2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIGZhbHNlIHdpbGwgbWFrZVxuICAgKiB0aGUgYnVmZmVyIG9mIHR5cGUgYEFSUkFZX0JVRkZFUmAuXG4gICAqXG4gICAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICovXG4gIHNldCBpbmRleCh2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHZhbHVlID8gY29uc3RhbnRzLkJVRkZFUl9UWVBFLkVMRU1FTlRfQVJSQVlfQlVGRkVSIDogY29uc3RhbnRzLkJVRkZFUl9UWVBFLkFSUkFZX0JVRkZFUjtcbiAgfVxuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gY29uc3RhbnRzLkJVRkZFUl9UWVBFLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgYnVmZmVyIGJhc2VkIG9uIGFuIGFycmF5IG9yIFR5cGVkQXJyYXlcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXcgfCBudW1iZXJbXX0gZGF0YSAtIHRoZSBUeXBlZEFycmF5IHRoYXQgdGhlIGJ1ZmZlciB3aWxsIHN0b3JlLiBJZiB0aGlzIGlzIGEgcmVndWxhciBBcnJheSBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIEZsb2F0MzJBcnJheS5cbiAgICogQHJldHVybnMgLSBBIG5ldyBCdWZmZXIgYmFzZWQgb24gdGhlIGRhdGEgcHJvdmlkZWQuXG4gICAqL1xuICBzdGF0aWMgZnJvbShkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBBcnJheSAmJiAoZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSkpLCBuZXcgQnVmZmVyKGRhdGEpO1xuICB9XG59XG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1ZmZlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4dGVuc2lvbnMgPSByZXF1aXJlKFwiQHBpeGkvZXh0ZW5zaW9uc1wiKSwgR0xCdWZmZXIgPSByZXF1aXJlKFwiLi9HTEJ1ZmZlci5qc1wiKTtcbmNsYXNzIEJ1ZmZlclN5c3RlbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyLCB0aGlzLm1hbmFnZWRCdWZmZXJzID0ge30sIHRoaXMuYm91bmRCdWZmZXJCYXNlcyA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG4gIC8qKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy4gKi9cbiAgY29udGV4dENoYW5nZSgpIHtcbiAgICB0aGlzLmRpc3Bvc2VBbGwoITApLCB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbCwgdGhpcy5DT05URVhUX1VJRCA9IHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgYmluZHMgc3BlY2lmaWVkIGJ1ZmZlci4gT24gZmlyc3QgcnVuLCBpdCB3aWxsIGNyZWF0ZSB0aGUgd2ViR0wgYnVmZmVycyBmb3IgdGhlIGNvbnRleHQgdG9vXG4gICAqIEBwYXJhbSBidWZmZXIgLSB0aGUgYnVmZmVyIHRvIGJpbmQgdG8gdGhlIHJlbmRlcmVyXG4gICAqL1xuICBiaW5kKGJ1ZmZlcikge1xuICAgIGNvbnN0IHsgZ2wsIENPTlRFWFRfVUlEIH0gPSB0aGlzLCBnbEJ1ZmZlciA9IGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXSB8fCB0aGlzLmNyZWF0ZUdMQnVmZmVyKGJ1ZmZlcik7XG4gICAgZ2wuYmluZEJ1ZmZlcihidWZmZXIudHlwZSwgZ2xCdWZmZXIuYnVmZmVyKTtcbiAgfVxuICB1bmJpbmQodHlwZSkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgZ2wuYmluZEJ1ZmZlcih0eXBlLCBudWxsKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgYW4gdW5pZm9ybSBidWZmZXIgdG8gYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgKlxuICAgKiBBIGNhY2hlIGlzIHVzZWQgc28gYSBidWZmZXIgd2lsbCBub3QgYmUgYm91bmQgYWdhaW4gaWYgYWxyZWFkeSBib3VuZC5cbiAgICogQHBhcmFtIGJ1ZmZlciAtIHRoZSBidWZmZXIgdG8gYmluZFxuICAgKiBAcGFyYW0gaW5kZXggLSB0aGUgYmFzZSBpbmRleCB0byBiaW5kIGl0IHRvLlxuICAgKi9cbiAgYmluZEJ1ZmZlckJhc2UoYnVmZmVyLCBpbmRleCkge1xuICAgIGNvbnN0IHsgZ2wsIENPTlRFWFRfVUlEIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLmJvdW5kQnVmZmVyQmFzZXNbaW5kZXhdICE9PSBidWZmZXIpIHtcbiAgICAgIGNvbnN0IGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdIHx8IHRoaXMuY3JlYXRlR0xCdWZmZXIoYnVmZmVyKTtcbiAgICAgIHRoaXMuYm91bmRCdWZmZXJCYXNlc1tpbmRleF0gPSBidWZmZXIsIGdsLmJpbmRCdWZmZXJCYXNlKGdsLlVOSUZPUk1fQlVGRkVSLCBpbmRleCwgZ2xCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEJpbmRzIGEgYnVmZmVyIHdoaWxzdCBhbHNvIGJpbmRpbmcgaXRzIHJhbmdlLlxuICAgKiBUaGlzIHdpbGwgbWFrZSB0aGUgYnVmZmVyIHN0YXJ0IGZyb20gdGhlIG9mZnNldCBzdXBwbGllZCByYXRoZXIgdGhhbiAwIHdoZW4gaXQgaXMgcmVhZC5cbiAgICogQHBhcmFtIGJ1ZmZlciAtIHRoZSBidWZmZXIgdG8gYmluZFxuICAgKiBAcGFyYW0gaW5kZXggLSB0aGUgYmFzZSBpbmRleCB0byBiaW5kIGF0LCBkZWZhdWx0cyB0byAwXG4gICAqIEBwYXJhbSBvZmZzZXQgLSB0aGUgb2Zmc2V0IHRvIGJpbmQgYXQgKHRoaXMgaXMgYmxvY2tzIG9mIDI1NikuIDAgPSAwLCAxID0gMjU2LCAyID0gNTEyIGV0Y1xuICAgKi9cbiAgYmluZEJ1ZmZlclJhbmdlKGJ1ZmZlciwgaW5kZXgsIG9mZnNldCkge1xuICAgIGNvbnN0IHsgZ2wsIENPTlRFWFRfVUlEIH0gPSB0aGlzO1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgIGNvbnN0IGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdIHx8IHRoaXMuY3JlYXRlR0xCdWZmZXIoYnVmZmVyKTtcbiAgICBnbC5iaW5kQnVmZmVyUmFuZ2UoZ2wuVU5JRk9STV9CVUZGRVIsIGluZGV4IHx8IDAsIGdsQnVmZmVyLmJ1ZmZlciwgb2Zmc2V0ICogMjU2LCAyNTYpO1xuICB9XG4gIC8qKlxuICAgKiBXaWxsIGVuc3VyZSB0aGUgZGF0YSBpbiB0aGUgYnVmZmVyIGlzIHVwbG9hZGVkIHRvIHRoZSBHUFUuXG4gICAqIEBwYXJhbSB7UElYSS5CdWZmZXJ9IGJ1ZmZlciAtIHRoZSBidWZmZXIgdG8gdXBkYXRlXG4gICAqL1xuICB1cGRhdGUoYnVmZmVyKSB7XG4gICAgY29uc3QgeyBnbCwgQ09OVEVYVF9VSUQgfSA9IHRoaXMsIGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdIHx8IHRoaXMuY3JlYXRlR0xCdWZmZXIoYnVmZmVyKTtcbiAgICBpZiAoYnVmZmVyLl91cGRhdGVJRCAhPT0gZ2xCdWZmZXIudXBkYXRlSUQpXG4gICAgICBpZiAoZ2xCdWZmZXIudXBkYXRlSUQgPSBidWZmZXIuX3VwZGF0ZUlELCBnbC5iaW5kQnVmZmVyKGJ1ZmZlci50eXBlLCBnbEJ1ZmZlci5idWZmZXIpLCBnbEJ1ZmZlci5ieXRlTGVuZ3RoID49IGJ1ZmZlci5kYXRhLmJ5dGVMZW5ndGgpXG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoYnVmZmVyLnR5cGUsIDAsIGJ1ZmZlci5kYXRhKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBkcmF3VHlwZSA9IGJ1ZmZlci5zdGF0aWMgPyBnbC5TVEFUSUNfRFJBVyA6IGdsLkRZTkFNSUNfRFJBVztcbiAgICAgICAgZ2xCdWZmZXIuYnl0ZUxlbmd0aCA9IGJ1ZmZlci5kYXRhLmJ5dGVMZW5ndGgsIGdsLmJ1ZmZlckRhdGEoYnVmZmVyLnR5cGUsIGJ1ZmZlci5kYXRhLCBkcmF3VHlwZSk7XG4gICAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERpc3Bvc2VzIGJ1ZmZlclxuICAgKiBAcGFyYW0ge1BJWEkuQnVmZmVyfSBidWZmZXIgLSBidWZmZXIgd2l0aCBkYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbnRleHRMb3N0PWZhbHNlXSAtIElmIGNvbnRleHQgd2FzIGxvc3QsIHdlIHN1cHByZXNzIGRlbGV0ZVZlcnRleEFycmF5XG4gICAqL1xuICBkaXNwb3NlKGJ1ZmZlciwgY29udGV4dExvc3QpIHtcbiAgICBpZiAoIXRoaXMubWFuYWdlZEJ1ZmZlcnNbYnVmZmVyLmlkXSlcbiAgICAgIHJldHVybjtcbiAgICBkZWxldGUgdGhpcy5tYW5hZ2VkQnVmZmVyc1tidWZmZXIuaWRdO1xuICAgIGNvbnN0IGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF0sIGdsID0gdGhpcy5nbDtcbiAgICBidWZmZXIuZGlzcG9zZVJ1bm5lci5yZW1vdmUodGhpcyksIGdsQnVmZmVyICYmIChjb250ZXh0TG9zdCB8fCBnbC5kZWxldGVCdWZmZXIoZ2xCdWZmZXIuYnVmZmVyKSwgZGVsZXRlIGJ1ZmZlci5fZ2xCdWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdKTtcbiAgfVxuICAvKipcbiAgICogZGlzcG9zZSBhbGwgV2ViR0wgcmVzb3VyY2VzIG9mIGFsbCBtYW5hZ2VkIGJ1ZmZlcnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbY29udGV4dExvc3Q9ZmFsc2VdIC0gSWYgY29udGV4dCB3YXMgbG9zdCwgd2Ugc3VwcHJlc3MgYGdsLmRlbGV0ZWAgY2FsbHNcbiAgICovXG4gIGRpc3Bvc2VBbGwoY29udGV4dExvc3QpIHtcbiAgICBjb25zdCBhbGwgPSBPYmplY3Qua2V5cyh0aGlzLm1hbmFnZWRCdWZmZXJzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMuZGlzcG9zZSh0aGlzLm1hbmFnZWRCdWZmZXJzW2FsbFtpXV0sIGNvbnRleHRMb3N0KTtcbiAgfVxuICAvKipcbiAgICogY3JlYXRlcyBhbmQgYXR0YWNoZXMgYSBHTEJ1ZmZlciBvYmplY3QgdGllZCB0byB0aGUgY3VycmVudCBjb250ZXh0LlxuICAgKiBAcGFyYW0gYnVmZmVyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNyZWF0ZUdMQnVmZmVyKGJ1ZmZlcikge1xuICAgIGNvbnN0IHsgQ09OVEVYVF9VSUQsIGdsIH0gPSB0aGlzO1xuICAgIHJldHVybiBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0gPSBuZXcgR0xCdWZmZXIuR0xCdWZmZXIoZ2wuY3JlYXRlQnVmZmVyKCkpLCB0aGlzLm1hbmFnZWRCdWZmZXJzW2J1ZmZlci5pZF0gPSBidWZmZXIsIGJ1ZmZlci5kaXNwb3NlUnVubmVyLmFkZCh0aGlzKSwgYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdO1xuICB9XG59XG5CdWZmZXJTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwiYnVmZmVyXCJcbn07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKEJ1ZmZlclN5c3RlbSk7XG5leHBvcnRzLkJ1ZmZlclN5c3RlbSA9IEJ1ZmZlclN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1ZmZlclN5c3RlbS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgR0xCdWZmZXIge1xuICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlciB8fCBudWxsLCB0aGlzLnVwZGF0ZUlEID0gLTEsIHRoaXMuYnl0ZUxlbmd0aCA9IC0xLCB0aGlzLnJlZkNvdW50ID0gMDtcbiAgfVxufVxuZXhwb3J0cy5HTEJ1ZmZlciA9IEdMQnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R0xCdWZmZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiQHBpeGkvY29uc3RhbnRzXCIpLCBydW5uZXIgPSByZXF1aXJlKFwiQHBpeGkvcnVubmVyXCIpLCB1dGlscyA9IHJlcXVpcmUoXCJAcGl4aS91dGlsc1wiKSwgQXR0cmlidXRlID0gcmVxdWlyZShcIi4vQXR0cmlidXRlLmpzXCIpLCBCdWZmZXIgPSByZXF1aXJlKFwiLi9CdWZmZXIuanNcIiksIGludGVybGVhdmVUeXBlZEFycmF5cyA9IHJlcXVpcmUoXCIuL3V0aWxzL2ludGVybGVhdmVUeXBlZEFycmF5cy5qc1wiKTtcbmNvbnN0IGJ5dGVTaXplTWFwID0geyA1MTI2OiA0LCA1MTIzOiAyLCA1MTIxOiAxIH07XG5sZXQgVUlEID0gMDtcbmNvbnN0IG1hcCA9IHtcbiAgRmxvYXQzMkFycmF5LFxuICBVaW50MzJBcnJheSxcbiAgSW50MzJBcnJheSxcbiAgVWludDhBcnJheSxcbiAgVWludDE2QXJyYXlcbn07XG5jbGFzcyBHZW9tZXRyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gYnVmZmVycyAtIEFuIGFycmF5IG9mIGJ1ZmZlcnMuIG9wdGlvbmFsLlxuICAgKiBAcGFyYW0gYXR0cmlidXRlcyAtIE9mIHRoZSBnZW9tZXRyeSwgb3B0aW9uYWwgc3RydWN0dXJlIG9mIHRoZSBhdHRyaWJ1dGVzIGxheW91dFxuICAgKi9cbiAgY29uc3RydWN0b3IoYnVmZmVycyA9IFtdLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBidWZmZXJzLCB0aGlzLmluZGV4QnVmZmVyID0gbnVsbCwgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcywgdGhpcy5nbFZlcnRleEFycmF5T2JqZWN0cyA9IHt9LCB0aGlzLmlkID0gVUlEKyssIHRoaXMuaW5zdGFuY2VkID0gITEsIHRoaXMuaW5zdGFuY2VDb3VudCA9IDEsIHRoaXMuZGlzcG9zZVJ1bm5lciA9IG5ldyBydW5uZXIuUnVubmVyKFwiZGlzcG9zZUdlb21ldHJ5XCIpLCB0aGlzLnJlZkNvdW50ID0gMDtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQWRkcyBhbiBhdHRyaWJ1dGUgdG8gdGhlIGdlb21ldHJ5XG4gICAqIE5vdGU6IGBzdHJpZGVgIGFuZCBgc3RhcnRgIHNob3VsZCBiZSBgdW5kZWZpbmVkYCBpZiB5b3UgZG9udCBrbm93IHRoZW0sIG5vdCAwIVxuICAgKiBAcGFyYW0gaWQgLSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIChtYXRjaGluZyB1cCB0byBhIHNoYWRlcilcbiAgICogQHBhcmFtIHtQSVhJLkJ1ZmZlcnxudW1iZXJbXX0gYnVmZmVyIC0gdGhlIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSBkYXRhIG9mIHRoZSBhdHRyaWJ1dGUgLiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhbiBBcnJheSBhbmQgYSBidWZmZXIgd2lsbCBiZSBjcmVhdGVkIGZyb20gaXQuXG4gICAqIEBwYXJhbSBzaXplIC0gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZS4gSWYgeW91IGhhdmUgMiBmbG9hdHMgcGVyIHZlcnRleCAoZWcgcG9zaXRpb24geCBhbmQgeSkgdGhpcyB3b3VsZCBiZSAyXG4gICAqIEBwYXJhbSBub3JtYWxpemVkIC0gc2hvdWxkIHRoZSBkYXRhIGJlIG5vcm1hbGl6ZWQuXG4gICAqIEBwYXJhbSBbdHlwZT1QSVhJLlRZUEVTLkZMT0FUXSAtIHdoYXQgdHlwZSBvZiBudW1iZXIgaXMgdGhlIGF0dHJpYnV0ZS4gQ2hlY2sge0BsaW5rIFBJWEkuVFlQRVN9IHRvIHNlZSB0aGUgb25lcyBhdmFpbGFibGVcbiAgICogQHBhcmFtIFtzdHJpZGU9MF0gLSBIb3cgZmFyIGFwYXJ0LCBpbiBieXRlcywgdGhlIHN0YXJ0IG9mIGVhY2ggdmFsdWUgaXMuICh1c2VkIGZvciBpbnRlcmxlYXZpbmcgZGF0YSlcbiAgICogQHBhcmFtIFtzdGFydD0wXSAtIEhvdyBmYXIgaW50byB0aGUgYXJyYXkgdG8gc3RhcnQgcmVhZGluZyB2YWx1ZXMgKHVzZWQgZm9yIGludGVybGVhdmluZyBkYXRhKVxuICAgKiBAcGFyYW0gaW5zdGFuY2UgLSBJbnN0YW5jaW5nIGZsYWdcbiAgICogQHJldHVybnMgLSBSZXR1cm5zIHNlbGYsIHVzZWZ1bCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhZGRBdHRyaWJ1dGUoaWQsIGJ1ZmZlciwgc2l6ZSA9IDAsIG5vcm1hbGl6ZWQgPSAhMSwgdHlwZSwgc3RyaWRlLCBzdGFydCwgaW5zdGFuY2UgPSAhMSkge1xuICAgIGlmICghYnVmZmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhIGJ1ZmZlciB3aGVuIGNyZWF0aW5nIGFuIGF0dHJpYnV0ZVwiKTtcbiAgICBidWZmZXIgaW5zdGFuY2VvZiBCdWZmZXIuQnVmZmVyIHx8IChidWZmZXIgaW5zdGFuY2VvZiBBcnJheSAmJiAoYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpKSwgYnVmZmVyID0gbmV3IEJ1ZmZlci5CdWZmZXIoYnVmZmVyKSk7XG4gICAgY29uc3QgaWRzID0gaWQuc3BsaXQoXCJ8XCIpO1xuICAgIGlmIChpZHMubGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKGlkc1tpXSwgYnVmZmVyLCBzaXplLCBub3JtYWxpemVkLCB0eXBlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsZXQgYnVmZmVySW5kZXggPSB0aGlzLmJ1ZmZlcnMuaW5kZXhPZihidWZmZXIpO1xuICAgIHJldHVybiBidWZmZXJJbmRleCA9PT0gLTEgJiYgKHRoaXMuYnVmZmVycy5wdXNoKGJ1ZmZlciksIGJ1ZmZlckluZGV4ID0gdGhpcy5idWZmZXJzLmxlbmd0aCAtIDEpLCB0aGlzLmF0dHJpYnV0ZXNbaWRdID0gbmV3IEF0dHJpYnV0ZS5BdHRyaWJ1dGUoYnVmZmVySW5kZXgsIHNpemUsIG5vcm1hbGl6ZWQsIHR5cGUsIHN0cmlkZSwgc3RhcnQsIGluc3RhbmNlKSwgdGhpcy5pbnN0YW5jZWQgPSB0aGlzLmluc3RhbmNlZCB8fCBpbnN0YW5jZSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVxdWVzdGVkIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtIGlkIC0gVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSByZXF1aXJlZFxuICAgKiBAcmV0dXJucyAtIFRoZSBhdHRyaWJ1dGUgcmVxdWVzdGVkLlxuICAgKi9cbiAgZ2V0QXR0cmlidXRlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1tpZF07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlcXVlc3RlZCBidWZmZXIuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBuYW1lIG9mIHRoZSBidWZmZXIgcmVxdWlyZWQuXG4gICAqIEByZXR1cm5zIC0gVGhlIGJ1ZmZlciByZXF1ZXN0ZWQuXG4gICAqL1xuICBnZXRCdWZmZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJzW3RoaXMuZ2V0QXR0cmlidXRlKGlkKS5idWZmZXJdO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBBZGRzIGFuIGluZGV4IGJ1ZmZlciB0byB0aGUgZ2VvbWV0cnlcbiAgICogVGhlIGluZGV4IGJ1ZmZlciBjb250YWlucyBpbnRlZ2VycywgdGhyZWUgZm9yIGVhY2ggdHJpYW5nbGUgaW4gdGhlIGdlb21ldHJ5LCB3aGljaCByZWZlcmVuY2UgdGhlIHZhcmlvdXMgYXR0cmlidXRlIGJ1ZmZlcnMgKHBvc2l0aW9uLCBjb2xvdXIsIFVWIGNvb3JkaW5hdGVzLCBvdGhlciBVViBjb29yZGluYXRlcywgbm9ybWFsLCDigKYpLiBUaGVyZSBpcyBvbmx5IE9ORSBpbmRleCBidWZmZXIuXG4gICAqIEBwYXJhbSB7UElYSS5CdWZmZXJ8bnVtYmVyW119IFtidWZmZXJdIC0gVGhlIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSBkYXRhIG9mIHRoZSBpbmRleCBidWZmZXIuIFlvdSBjYW4gYWxzbyBwcm92aWRlIGFuIEFycmF5IGFuZCBhIGJ1ZmZlciB3aWxsIGJlIGNyZWF0ZWQgZnJvbSBpdC5cbiAgICogQHJldHVybnMgLSBSZXR1cm5zIHNlbGYsIHVzZWZ1bCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhZGRJbmRleChidWZmZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyIGluc3RhbmNlb2YgQnVmZmVyLkJ1ZmZlciB8fCAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXkgJiYgKGJ1ZmZlciA9IG5ldyBVaW50MTZBcnJheShidWZmZXIpKSwgYnVmZmVyID0gbmV3IEJ1ZmZlci5CdWZmZXIoYnVmZmVyKSksIGJ1ZmZlci50eXBlID0gY29uc3RhbnRzLkJVRkZFUl9UWVBFLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyID0gYnVmZmVyLCB0aGlzLmJ1ZmZlcnMuaW5jbHVkZXMoYnVmZmVyKSB8fCB0aGlzLmJ1ZmZlcnMucHVzaChidWZmZXIpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBidWZmZXJcbiAgICogQHJldHVybnMgLSBUaGUgaW5kZXggYnVmZmVyLlxuICAgKi9cbiAgZ2V0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhCdWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlIHN0cnVjdHVyZSBzbyB0aGF0IGFsbCBjdXJyZW50IGF0dHJpYnV0ZXMgYmVjb21lIGludGVybGVhdmVkIGludG8gYSBzaW5nbGUgYnVmZmVyXG4gICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBpZiB5b3VyIG1vZGVsIHJlbWFpbnMgc3RhdGljIGFzIGl0IG9mZmVycyBhIGxpdHRsZSBwZXJmb3JtYW5jZSBib29zdFxuICAgKiBAcmV0dXJucyAtIFJldHVybnMgc2VsZiwgdXNlZnVsIGZvciBjaGFpbmluZy5cbiAgICovXG4gIGludGVybGVhdmUoKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IDEgfHwgdGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gMiAmJiB0aGlzLmluZGV4QnVmZmVyKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgYXJyYXlzID0gW10sIHNpemVzID0gW10sIGludGVybGVhdmVkQnVmZmVyID0gbmV3IEJ1ZmZlci5CdWZmZXIoKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbaV0sIGJ1ZmZlciA9IHRoaXMuYnVmZmVyc1thdHRyaWJ1dGUuYnVmZmVyXTtcbiAgICAgIGFycmF5cy5wdXNoKGJ1ZmZlci5kYXRhKSwgc2l6ZXMucHVzaChhdHRyaWJ1dGUuc2l6ZSAqIGJ5dGVTaXplTWFwW2F0dHJpYnV0ZS50eXBlXSAvIDQpLCBhdHRyaWJ1dGUuYnVmZmVyID0gMDtcbiAgICB9XG4gICAgZm9yIChpbnRlcmxlYXZlZEJ1ZmZlci5kYXRhID0gaW50ZXJsZWF2ZVR5cGVkQXJyYXlzLmludGVybGVhdmVUeXBlZEFycmF5cyhhcnJheXMsIHNpemVzKSwgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlcnNbaV0gIT09IHRoaXMuaW5kZXhCdWZmZXIgJiYgdGhpcy5idWZmZXJzW2ldLmRlc3Ryb3koKTtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJzID0gW2ludGVybGVhdmVkQnVmZmVyXSwgdGhpcy5pbmRleEJ1ZmZlciAmJiB0aGlzLmJ1ZmZlcnMucHVzaCh0aGlzLmluZGV4QnVmZmVyKSwgdGhpcztcbiAgfVxuICAvKiogR2V0IHRoZSBzaXplIG9mIHRoZSBnZW9tZXRyaWVzLCBpbiB2ZXJ0aWNlcy4gKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbaV07XG4gICAgICByZXR1cm4gdGhpcy5idWZmZXJzW2F0dHJpYnV0ZS5idWZmZXJdLmRhdGEubGVuZ3RoIC8gKGF0dHJpYnV0ZS5zdHJpZGUgLyA0IHx8IGF0dHJpYnV0ZS5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLyoqIERpc3Bvc2VzIFdlYkdMIHJlc291cmNlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhpcyBnZW9tZXRyeS4gKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmRpc3Bvc2VSdW5uZXIuZW1pdCh0aGlzLCAhMSk7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoZSBnZW9tZXRyeS4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRpc3Bvc2UoKSwgdGhpcy5idWZmZXJzID0gbnVsbCwgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGwsIHRoaXMuYXR0cmlidXRlcyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm5zIC0gQSBuZXcgY2xvbmUgb2YgdGhpcyBnZW9tZXRyeS5cbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoOyBpKyspXG4gICAgICBnZW9tZXRyeS5idWZmZXJzW2ldID0gbmV3IEJ1ZmZlci5CdWZmZXIodGhpcy5idWZmZXJzW2ldLmRhdGEuc2xpY2UoMCkpO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYiA9IHRoaXMuYXR0cmlidXRlc1tpXTtcbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXNbaV0gPSBuZXcgQXR0cmlidXRlLkF0dHJpYnV0ZShcbiAgICAgICAgYXR0cmliLmJ1ZmZlcixcbiAgICAgICAgYXR0cmliLnNpemUsXG4gICAgICAgIGF0dHJpYi5ub3JtYWxpemVkLFxuICAgICAgICBhdHRyaWIudHlwZSxcbiAgICAgICAgYXR0cmliLnN0cmlkZSxcbiAgICAgICAgYXR0cmliLnN0YXJ0LFxuICAgICAgICBhdHRyaWIuaW5zdGFuY2VcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmluZGV4QnVmZmVyICYmIChnZW9tZXRyeS5pbmRleEJ1ZmZlciA9IGdlb21ldHJ5LmJ1ZmZlcnNbdGhpcy5idWZmZXJzLmluZGV4T2YodGhpcy5pbmRleEJ1ZmZlcildLCBnZW9tZXRyeS5pbmRleEJ1ZmZlci50eXBlID0gY29uc3RhbnRzLkJVRkZFUl9UWVBFLkVMRU1FTlRfQVJSQVlfQlVGRkVSKSwgZ2VvbWV0cnk7XG4gIH1cbiAgLyoqXG4gICAqIE1lcmdlcyBhbiBhcnJheSBvZiBnZW9tZXRyaWVzIGludG8gYSBuZXcgc2luZ2xlIG9uZS5cbiAgICpcbiAgICogR2VvbWV0cnkgYXR0cmlidXRlIHN0eWxlcyBtdXN0IG1hdGNoIGZvciB0aGlzIG9wZXJhdGlvbiB0byB3b3JrLlxuICAgKiBAcGFyYW0gZ2VvbWV0cmllcyAtIGFycmF5IG9mIGdlb21ldHJpZXMgdG8gbWVyZ2VcbiAgICogQHJldHVybnMgLSBTaGlueSBuZXcgZ2VvbWV0cnkhXG4gICAqL1xuICBzdGF0aWMgbWVyZ2UoZ2VvbWV0cmllcykge1xuICAgIGNvbnN0IGdlb21ldHJ5T3V0ID0gbmV3IEdlb21ldHJ5KCksIGFycmF5cyA9IFtdLCBzaXplcyA9IFtdLCBvZmZzZXRzID0gW107XG4gICAgbGV0IGdlb21ldHJ5O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBnZW9tZXRyeS5idWZmZXJzLmxlbmd0aDsgaisrKVxuICAgICAgICBzaXplc1tqXSA9IHNpemVzW2pdIHx8IDAsIHNpemVzW2pdICs9IGdlb21ldHJ5LmJ1ZmZlcnNbal0uZGF0YS5sZW5ndGgsIG9mZnNldHNbal0gPSAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBpKyspXG4gICAgICBhcnJheXNbaV0gPSBuZXcgbWFwW3V0aWxzLmdldEJ1ZmZlclR5cGUoZ2VvbWV0cnkuYnVmZmVyc1tpXS5kYXRhKV0oc2l6ZXNbaV0pLCBnZW9tZXRyeU91dC5idWZmZXJzW2ldID0gbmV3IEJ1ZmZlci5CdWZmZXIoYXJyYXlzW2ldKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ2VvbWV0cnkuYnVmZmVycy5sZW5ndGg7IGorKylcbiAgICAgICAgYXJyYXlzW2pdLnNldChnZW9tZXRyeS5idWZmZXJzW2pdLmRhdGEsIG9mZnNldHNbal0pLCBvZmZzZXRzW2pdICs9IGdlb21ldHJ5LmJ1ZmZlcnNbal0uZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChnZW9tZXRyeU91dC5hdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcywgZ2VvbWV0cnkuaW5kZXhCdWZmZXIpIHtcbiAgICAgIGdlb21ldHJ5T3V0LmluZGV4QnVmZmVyID0gZ2VvbWV0cnlPdXQuYnVmZmVyc1tnZW9tZXRyeS5idWZmZXJzLmluZGV4T2YoZ2VvbWV0cnkuaW5kZXhCdWZmZXIpXSwgZ2VvbWV0cnlPdXQuaW5kZXhCdWZmZXIudHlwZSA9IGNvbnN0YW50cy5CVUZGRVJfVFlQRS5FTEVNRU5UX0FSUkFZX0JVRkZFUjtcbiAgICAgIGxldCBvZmZzZXQgPSAwLCBzdHJpZGUgPSAwLCBvZmZzZXQyID0gMCwgYnVmZmVySW5kZXhUb0NvdW50ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cnkuYnVmZmVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGdlb21ldHJ5LmJ1ZmZlcnNbaV0gIT09IGdlb21ldHJ5LmluZGV4QnVmZmVyKSB7XG4gICAgICAgICAgYnVmZmVySW5kZXhUb0NvdW50ID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlc1tpXTtcbiAgICAgICAgKGF0dHJpYnV0ZS5idWZmZXIgfCAwKSA9PT0gYnVmZmVySW5kZXhUb0NvdW50ICYmIChzdHJpZGUgKz0gYXR0cmlidXRlLnNpemUgKiBieXRlU2l6ZU1hcFthdHRyaWJ1dGUudHlwZV0gLyA0KTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpbmRleEJ1ZmZlckRhdGEgPSBnZW9tZXRyaWVzW2ldLmluZGV4QnVmZmVyLmRhdGE7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5kZXhCdWZmZXJEYXRhLmxlbmd0aDsgaisrKVxuICAgICAgICAgIGdlb21ldHJ5T3V0LmluZGV4QnVmZmVyLmRhdGFbaiArIG9mZnNldDJdICs9IG9mZnNldDtcbiAgICAgICAgb2Zmc2V0ICs9IGdlb21ldHJpZXNbaV0uYnVmZmVyc1tidWZmZXJJbmRleFRvQ291bnRdLmRhdGEubGVuZ3RoIC8gc3RyaWRlLCBvZmZzZXQyICs9IGluZGV4QnVmZmVyRGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZW9tZXRyeU91dDtcbiAgfVxufVxuZXhwb3J0cy5HZW9tZXRyeSA9IEdlb21ldHJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VvbWV0cnkuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiQHBpeGkvY29uc3RhbnRzXCIpLCBleHRlbnNpb25zID0gcmVxdWlyZShcIkBwaXhpL2V4dGVuc2lvbnNcIiksIHNldHRpbmdzID0gcmVxdWlyZShcIkBwaXhpL3NldHRpbmdzXCIpO1xuY29uc3QgYnl0ZVNpemVNYXAgPSB7IDUxMjY6IDQsIDUxMjM6IDIsIDUxMjE6IDEgfTtcbmNsYXNzIEdlb21ldHJ5U3lzdGVtIHtcbiAgLyoqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIFN5c3RlbSB3b3JrcyBmb3IuICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyLCB0aGlzLl9hY3RpdmVHZW9tZXRyeSA9IG51bGwsIHRoaXMuX2FjdGl2ZVZhbyA9IG51bGwsIHRoaXMuaGFzVmFvID0gITAsIHRoaXMuaGFzSW5zdGFuY2UgPSAhMCwgdGhpcy5jYW5Vc2VVSW50MzJFbGVtZW50SW5kZXggPSAhMSwgdGhpcy5tYW5hZ2VkR2VvbWV0cmllcyA9IHt9O1xuICB9XG4gIC8qKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy4gKi9cbiAgY29udGV4dENoYW5nZSgpIHtcbiAgICB0aGlzLmRpc3Bvc2VBbGwoITApO1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbCA9IHRoaXMucmVuZGVyZXIuZ2wsIGNvbnRleHQgPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQ7XG4gICAgaWYgKHRoaXMuQ09OVEVYVF9VSUQgPSB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlELCBjb250ZXh0LndlYkdMVmVyc2lvbiAhPT0gMikge1xuICAgICAgbGV0IG5hdGl2ZVZhb0V4dGVuc2lvbiA9IHRoaXMucmVuZGVyZXIuY29udGV4dC5leHRlbnNpb25zLnZlcnRleEFycmF5T2JqZWN0O1xuICAgICAgc2V0dGluZ3Muc2V0dGluZ3MuUFJFRkVSX0VOViA9PT0gY29uc3RhbnRzLkVOVi5XRUJHTF9MRUdBQ1kgJiYgKG5hdGl2ZVZhb0V4dGVuc2lvbiA9IG51bGwpLCBuYXRpdmVWYW9FeHRlbnNpb24gPyAoZ2wuY3JlYXRlVmVydGV4QXJyYXkgPSAoKSA9PiBuYXRpdmVWYW9FeHRlbnNpb24uY3JlYXRlVmVydGV4QXJyYXlPRVMoKSwgZ2wuYmluZFZlcnRleEFycmF5ID0gKHZhbykgPT4gbmF0aXZlVmFvRXh0ZW5zaW9uLmJpbmRWZXJ0ZXhBcnJheU9FUyh2YW8pLCBnbC5kZWxldGVWZXJ0ZXhBcnJheSA9ICh2YW8pID0+IG5hdGl2ZVZhb0V4dGVuc2lvbi5kZWxldGVWZXJ0ZXhBcnJheU9FUyh2YW8pKSA6ICh0aGlzLmhhc1ZhbyA9ICExLCBnbC5jcmVhdGVWZXJ0ZXhBcnJheSA9ICgpID0+IG51bGwsIGdsLmJpbmRWZXJ0ZXhBcnJheSA9ICgpID0+IG51bGwsIGdsLmRlbGV0ZVZlcnRleEFycmF5ID0gKCkgPT4gbnVsbCk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LndlYkdMVmVyc2lvbiAhPT0gMikge1xuICAgICAgY29uc3QgaW5zdGFuY2VFeHQgPSBnbC5nZXRFeHRlbnNpb24oXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpO1xuICAgICAgaW5zdGFuY2VFeHQgPyAoZ2wudmVydGV4QXR0cmliRGl2aXNvciA9IChhLCBiKSA9PiBpbnN0YW5jZUV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoYSwgYiksIGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZCA9IChhLCBiLCBjLCBkLCBlKSA9PiBpbnN0YW5jZUV4dC5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRShhLCBiLCBjLCBkLCBlKSwgZ2wuZHJhd0FycmF5c0luc3RhbmNlZCA9IChhLCBiLCBjLCBkKSA9PiBpbnN0YW5jZUV4dC5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoYSwgYiwgYywgZCkpIDogdGhpcy5oYXNJbnN0YW5jZSA9ICExO1xuICAgIH1cbiAgICB0aGlzLmNhblVzZVVJbnQzMkVsZW1lbnRJbmRleCA9IGNvbnRleHQud2ViR0xWZXJzaW9uID09PSAyIHx8ICEhY29udGV4dC5leHRlbnNpb25zLnVpbnQzMkVsZW1lbnRJbmRleDtcbiAgfVxuICAvKipcbiAgICogQmluZHMgZ2VvbWV0cnkgc28gdGhhdCBpcyBjYW4gYmUgZHJhd24uIENyZWF0aW5nIGEgVmFvIGlmIHJlcXVpcmVkXG4gICAqIEBwYXJhbSBnZW9tZXRyeSAtIEluc3RhbmNlIG9mIGdlb21ldHJ5IHRvIGJpbmQuXG4gICAqIEBwYXJhbSBzaGFkZXIgLSBJbnN0YW5jZSBvZiBzaGFkZXIgdG8gdXNlIHZhbyBmb3IuXG4gICAqL1xuICBiaW5kKGdlb21ldHJ5LCBzaGFkZXIpIHtcbiAgICBzaGFkZXIgPSBzaGFkZXIgfHwgdGhpcy5yZW5kZXJlci5zaGFkZXIuc2hhZGVyO1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgbGV0IHZhb3MgPSBnZW9tZXRyeS5nbFZlcnRleEFycmF5T2JqZWN0c1t0aGlzLkNPTlRFWFRfVUlEXSwgaW5jUmVmQ291bnQgPSAhMTtcbiAgICB2YW9zIHx8ICh0aGlzLm1hbmFnZWRHZW9tZXRyaWVzW2dlb21ldHJ5LmlkXSA9IGdlb21ldHJ5LCBnZW9tZXRyeS5kaXNwb3NlUnVubmVyLmFkZCh0aGlzKSwgZ2VvbWV0cnkuZ2xWZXJ0ZXhBcnJheU9iamVjdHNbdGhpcy5DT05URVhUX1VJRF0gPSB2YW9zID0ge30sIGluY1JlZkNvdW50ID0gITApO1xuICAgIGNvbnN0IHZhbyA9IHZhb3Nbc2hhZGVyLnByb2dyYW0uaWRdIHx8IHRoaXMuaW5pdEdlb21ldHJ5VmFvKGdlb21ldHJ5LCBzaGFkZXIsIGluY1JlZkNvdW50KTtcbiAgICB0aGlzLl9hY3RpdmVHZW9tZXRyeSA9IGdlb21ldHJ5LCB0aGlzLl9hY3RpdmVWYW8gIT09IHZhbyAmJiAodGhpcy5fYWN0aXZlVmFvID0gdmFvLCB0aGlzLmhhc1ZhbyA/IGdsLmJpbmRWZXJ0ZXhBcnJheSh2YW8pIDogdGhpcy5hY3RpdmF0ZVZhbyhnZW9tZXRyeSwgc2hhZGVyLnByb2dyYW0pKSwgdGhpcy51cGRhdGVCdWZmZXJzKCk7XG4gIH1cbiAgLyoqIFJlc2V0IGFuZCB1bmJpbmQgYW55IGFjdGl2ZSBWQU8gYW5kIGdlb21ldHJ5LiAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnVuYmluZCgpO1xuICB9XG4gIC8qKiBVcGRhdGUgYnVmZmVycyBvZiB0aGUgY3VycmVudGx5IGJvdW5kIGdlb21ldHJ5LiAqL1xuICB1cGRhdGVCdWZmZXJzKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5fYWN0aXZlR2VvbWV0cnksIGJ1ZmZlclN5c3RlbSA9IHRoaXMucmVuZGVyZXIuYnVmZmVyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cnkuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYnVmZmVyID0gZ2VvbWV0cnkuYnVmZmVyc1tpXTtcbiAgICAgIGJ1ZmZlclN5c3RlbS51cGRhdGUoYnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGNvbXBhdGliaWxpdHkgYmV0d2VlbiBhIGdlb21ldHJ5IGFuZCBhIHByb2dyYW1cbiAgICogQHBhcmFtIGdlb21ldHJ5IC0gR2VvbWV0cnkgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBwcm9ncmFtIC0gUHJvZ3JhbSBpbnN0YW5jZS5cbiAgICovXG4gIGNoZWNrQ29tcGF0aWJpbGl0eShnZW9tZXRyeSwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMsIHNoYWRlckF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZURhdGE7XG4gICAgZm9yIChjb25zdCBqIGluIHNoYWRlckF0dHJpYnV0ZXMpXG4gICAgICBpZiAoIWdlb21ldHJ5QXR0cmlidXRlc1tqXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaGFkZXIgYW5kIGdlb21ldHJ5IGluY29tcGF0aWJsZSwgZ2VvbWV0cnkgbWlzc2luZyB0aGUgXCIke2p9XCIgYXR0cmlidXRlYCk7XG4gIH1cbiAgLyoqXG4gICAqIFRha2VzIGEgZ2VvbWV0cnkgYW5kIHByb2dyYW0gYW5kIGdlbmVyYXRlcyBhIHVuaXF1ZSBzaWduYXR1cmUgZm9yIHRoZW0uXG4gICAqIEBwYXJhbSBnZW9tZXRyeSAtIFRvIGdldCBzaWduYXR1cmUgZnJvbS5cbiAgICogQHBhcmFtIHByb2dyYW0gLSBUbyB0ZXN0IGdlb21ldHJ5IGFnYWluc3QuXG4gICAqIEByZXR1cm5zIC0gVW5pcXVlIHNpZ25hdHVyZSBvZiB0aGUgZ2VvbWV0cnkgYW5kIHByb2dyYW1cbiAgICovXG4gIGdldFNpZ25hdHVyZShnZW9tZXRyeSwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IGF0dHJpYnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLCBzaGFkZXJBdHRyaWJ1dGVzID0gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhLCBzdHJpbmdzID0gW1wiZ1wiLCBnZW9tZXRyeS5pZF07XG4gICAgZm9yIChjb25zdCBpIGluIGF0dHJpYnMpXG4gICAgICBzaGFkZXJBdHRyaWJ1dGVzW2ldICYmIHN0cmluZ3MucHVzaChpLCBzaGFkZXJBdHRyaWJ1dGVzW2ldLmxvY2F0aW9uKTtcbiAgICByZXR1cm4gc3RyaW5ncy5qb2luKFwiLVwiKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBvciBnZXRzIFZhbyB3aXRoIHRoZSBzYW1lIHN0cnVjdHVyZSBhcyB0aGUgZ2VvbWV0cnkgYW5kIHN0b3JlcyBpdCBvbiB0aGUgZ2VvbWV0cnkuXG4gICAqIElmIHZhbyBpcyBjcmVhdGVkLCBpdCBpcyBib3VuZCBhdXRvbWF0aWNhbGx5LiBXZSB1c2UgYSBzaGFkZXIgdG8gaW5mZXIgd2hhdCBhbmQgaG93IHRvIHNldCB1cCB0aGVcbiAgICogYXR0cmlidXRlIGxvY2F0aW9ucy5cbiAgICogQHBhcmFtIGdlb21ldHJ5IC0gSW5zdGFuY2Ugb2YgZ2VvbWV0cnkgdG8gdG8gZ2VuZXJhdGUgVmFvIGZvci5cbiAgICogQHBhcmFtIHNoYWRlciAtIEluc3RhbmNlIG9mIHRoZSBzaGFkZXIuXG4gICAqIEBwYXJhbSBpbmNSZWZDb3VudCAtIEluY3JlbWVudCByZWZDb3VudCBvZiBhbGwgZ2VvbWV0cnkgYnVmZmVycy5cbiAgICovXG4gIGluaXRHZW9tZXRyeVZhbyhnZW9tZXRyeSwgc2hhZGVyLCBpbmNSZWZDb3VudCA9ICEwKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsLCBDT05URVhUX1VJRCA9IHRoaXMuQ09OVEVYVF9VSUQsIGJ1ZmZlclN5c3RlbSA9IHRoaXMucmVuZGVyZXIuYnVmZmVyLCBwcm9ncmFtID0gc2hhZGVyLnByb2dyYW07XG4gICAgcHJvZ3JhbS5nbFByb2dyYW1zW0NPTlRFWFRfVUlEXSB8fCB0aGlzLnJlbmRlcmVyLnNoYWRlci5nZW5lcmF0ZVByb2dyYW0oc2hhZGVyKSwgdGhpcy5jaGVja0NvbXBhdGliaWxpdHkoZ2VvbWV0cnksIHByb2dyYW0pO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuZ2V0U2lnbmF0dXJlKGdlb21ldHJ5LCBwcm9ncmFtKSwgdmFvT2JqZWN0SGFzaCA9IGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgIGxldCB2YW8gPSB2YW9PYmplY3RIYXNoW3NpZ25hdHVyZV07XG4gICAgaWYgKHZhbylcbiAgICAgIHJldHVybiB2YW9PYmplY3RIYXNoW3Byb2dyYW0uaWRdID0gdmFvLCB2YW87XG4gICAgY29uc3QgYnVmZmVycyA9IGdlb21ldHJ5LmJ1ZmZlcnMsIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLCB0ZW1wU3RyaWRlID0ge30sIHRlbXBTdGFydCA9IHt9O1xuICAgIGZvciAoY29uc3QgaiBpbiBidWZmZXJzKVxuICAgICAgdGVtcFN0cmlkZVtqXSA9IDAsIHRlbXBTdGFydFtqXSA9IDA7XG4gICAgZm9yIChjb25zdCBqIGluIGF0dHJpYnV0ZXMpXG4gICAgICAhYXR0cmlidXRlc1tqXS5zaXplICYmIHByb2dyYW0uYXR0cmlidXRlRGF0YVtqXSA/IGF0dHJpYnV0ZXNbal0uc2l6ZSA9IHByb2dyYW0uYXR0cmlidXRlRGF0YVtqXS5zaXplIDogYXR0cmlidXRlc1tqXS5zaXplIHx8IGNvbnNvbGUud2FybihgUElYSSBHZW9tZXRyeSBhdHRyaWJ1dGUgJyR7an0nIHNpemUgY2Fubm90IGJlIGRldGVybWluZWQgKGxpa2VseSB0aGUgYm91bmQgc2hhZGVyIGRvZXMgbm90IGhhdmUgdGhlIGF0dHJpYnV0ZSlgKSwgdGVtcFN0cmlkZVthdHRyaWJ1dGVzW2pdLmJ1ZmZlcl0gKz0gYXR0cmlidXRlc1tqXS5zaXplICogYnl0ZVNpemVNYXBbYXR0cmlidXRlc1tqXS50eXBlXTtcbiAgICBmb3IgKGNvbnN0IGogaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tqXSwgYXR0cmliU2l6ZSA9IGF0dHJpYnV0ZS5zaXplO1xuICAgICAgYXR0cmlidXRlLnN0cmlkZSA9PT0gdm9pZCAwICYmICh0ZW1wU3RyaWRlW2F0dHJpYnV0ZS5idWZmZXJdID09PSBhdHRyaWJTaXplICogYnl0ZVNpemVNYXBbYXR0cmlidXRlLnR5cGVdID8gYXR0cmlidXRlLnN0cmlkZSA9IDAgOiBhdHRyaWJ1dGUuc3RyaWRlID0gdGVtcFN0cmlkZVthdHRyaWJ1dGUuYnVmZmVyXSksIGF0dHJpYnV0ZS5zdGFydCA9PT0gdm9pZCAwICYmIChhdHRyaWJ1dGUuc3RhcnQgPSB0ZW1wU3RhcnRbYXR0cmlidXRlLmJ1ZmZlcl0sIHRlbXBTdGFydFthdHRyaWJ1dGUuYnVmZmVyXSArPSBhdHRyaWJTaXplICogYnl0ZVNpemVNYXBbYXR0cmlidXRlLnR5cGVdKTtcbiAgICB9XG4gICAgdmFvID0gZ2wuY3JlYXRlVmVydGV4QXJyYXkoKSwgZ2wuYmluZFZlcnRleEFycmF5KHZhbyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2ldO1xuICAgICAgYnVmZmVyU3lzdGVtLmJpbmQoYnVmZmVyKSwgaW5jUmVmQ291bnQgJiYgYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdLnJlZkNvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFjdGl2YXRlVmFvKGdlb21ldHJ5LCBwcm9ncmFtKSwgdmFvT2JqZWN0SGFzaFtwcm9ncmFtLmlkXSA9IHZhbywgdmFvT2JqZWN0SGFzaFtzaWduYXR1cmVdID0gdmFvLCBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCksIGJ1ZmZlclN5c3RlbS51bmJpbmQoY29uc3RhbnRzLkJVRkZFUl9UWVBFLkFSUkFZX0JVRkZFUiksIHZhbztcbiAgfVxuICAvKipcbiAgICogRGlzcG9zZXMgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSBnZW9tZXRyeSAtIEdlb21ldHJ5IHdpdGggYnVmZmVycy4gT25seSBWQU8gd2lsbCBiZSBkaXNwb3NlZFxuICAgKiBAcGFyYW0gW2NvbnRleHRMb3N0PWZhbHNlXSAtIElmIGNvbnRleHQgd2FzIGxvc3QsIHdlIHN1cHByZXNzIGRlbGV0ZVZlcnRleEFycmF5XG4gICAqL1xuICBkaXNwb3NlR2VvbWV0cnkoZ2VvbWV0cnksIGNvbnRleHRMb3N0KSB7XG4gICAgaWYgKCF0aGlzLm1hbmFnZWRHZW9tZXRyaWVzW2dlb21ldHJ5LmlkXSlcbiAgICAgIHJldHVybjtcbiAgICBkZWxldGUgdGhpcy5tYW5hZ2VkR2VvbWV0cmllc1tnZW9tZXRyeS5pZF07XG4gICAgY29uc3QgdmFvcyA9IGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdLCBnbCA9IHRoaXMuZ2wsIGJ1ZmZlcnMgPSBnZW9tZXRyeS5idWZmZXJzLCBidWZmZXJTeXN0ZW0gPSB0aGlzLnJlbmRlcmVyPy5idWZmZXI7XG4gICAgaWYgKGdlb21ldHJ5LmRpc3Bvc2VSdW5uZXIucmVtb3ZlKHRoaXMpLCAhIXZhb3MpIHtcbiAgICAgIGlmIChidWZmZXJTeXN0ZW0pXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGJ1ZiA9IGJ1ZmZlcnNbaV0uX2dsQnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgICBidWYgJiYgKGJ1Zi5yZWZDb3VudC0tLCBidWYucmVmQ291bnQgPT09IDAgJiYgIWNvbnRleHRMb3N0ICYmIGJ1ZmZlclN5c3RlbS5kaXNwb3NlKGJ1ZmZlcnNbaV0sIGNvbnRleHRMb3N0KSk7XG4gICAgICAgIH1cbiAgICAgIGlmICghY29udGV4dExvc3QpIHtcbiAgICAgICAgZm9yIChjb25zdCB2YW9JZCBpbiB2YW9zKVxuICAgICAgICAgIGlmICh2YW9JZFswXSA9PT0gXCJnXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbyA9IHZhb3NbdmFvSWRdO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlVmFvID09PSB2YW8gJiYgdGhpcy51bmJpbmQoKSwgZ2wuZGVsZXRlVmVydGV4QXJyYXkodmFvKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWxldGUgZ2VvbWV0cnkuZ2xWZXJ0ZXhBcnJheU9iamVjdHNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEaXNwb3NlIGFsbCBXZWJHTCByZXNvdXJjZXMgb2YgYWxsIG1hbmFnZWQgZ2VvbWV0cmllcy5cbiAgICogQHBhcmFtIFtjb250ZXh0TG9zdD1mYWxzZV0gLSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBgZ2wuZGVsZXRlYCBjYWxsc1xuICAgKi9cbiAgZGlzcG9zZUFsbChjb250ZXh0TG9zdCkge1xuICAgIGNvbnN0IGFsbCA9IE9iamVjdC5rZXlzKHRoaXMubWFuYWdlZEdlb21ldHJpZXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5kaXNwb3NlR2VvbWV0cnkodGhpcy5tYW5hZ2VkR2VvbWV0cmllc1thbGxbaV1dLCBjb250ZXh0TG9zdCk7XG4gIH1cbiAgLyoqXG4gICAqIEFjdGl2YXRlIHZlcnRleCBhcnJheSBvYmplY3QuXG4gICAqIEBwYXJhbSBnZW9tZXRyeSAtIEdlb21ldHJ5IGluc3RhbmNlLlxuICAgKiBAcGFyYW0gcHJvZ3JhbSAtIFNoYWRlciBwcm9ncmFtIGluc3RhbmNlLlxuICAgKi9cbiAgYWN0aXZhdGVWYW8oZ2VvbWV0cnksIHByb2dyYW0pIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2wsIENPTlRFWFRfVUlEID0gdGhpcy5DT05URVhUX1VJRCwgYnVmZmVyU3lzdGVtID0gdGhpcy5yZW5kZXJlci5idWZmZXIsIGJ1ZmZlcnMgPSBnZW9tZXRyeS5idWZmZXJzLCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICBnZW9tZXRyeS5pbmRleEJ1ZmZlciAmJiBidWZmZXJTeXN0ZW0uYmluZChnZW9tZXRyeS5pbmRleEJ1ZmZlcik7XG4gICAgbGV0IGxhc3RCdWZmZXIgPSBudWxsO1xuICAgIGZvciAoY29uc3QgaiBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2pdLCBidWZmZXIgPSBidWZmZXJzW2F0dHJpYnV0ZS5idWZmZXJdLCBnbEJ1ZmZlciA9IGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXTtcbiAgICAgIGlmIChwcm9ncmFtLmF0dHJpYnV0ZURhdGFbal0pIHtcbiAgICAgICAgbGFzdEJ1ZmZlciAhPT0gZ2xCdWZmZXIgJiYgKGJ1ZmZlclN5c3RlbS5iaW5kKGJ1ZmZlciksIGxhc3RCdWZmZXIgPSBnbEJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2pdLmxvY2F0aW9uO1xuICAgICAgICBpZiAoZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pLCBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIGF0dHJpYnV0ZS5zaXplLFxuICAgICAgICAgIGF0dHJpYnV0ZS50eXBlIHx8IGdsLkZMT0FULFxuICAgICAgICAgIGF0dHJpYnV0ZS5ub3JtYWxpemVkLFxuICAgICAgICAgIGF0dHJpYnV0ZS5zdHJpZGUsXG4gICAgICAgICAgYXR0cmlidXRlLnN0YXJ0XG4gICAgICAgICksIGF0dHJpYnV0ZS5pbnN0YW5jZSlcbiAgICAgICAgICBpZiAodGhpcy5oYXNJbnN0YW5jZSlcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IobG9jYXRpb24sIGF0dHJpYnV0ZS5kaXZpc29yKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZW9tZXRyeSBlcnJvciwgR1BVIEluc3RhbmNpbmcgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIHRoZSBjdXJyZW50bHkgYm91bmQgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgcHJpbWl0aXZlIHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHNpemUgLSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGJlIHJlbmRlcmVkLiBJZiBub3Qgc3BlY2lmaWVkLCBhbGwgdmVydGljZXMgYWZ0ZXIgdGhlXG4gICAqICBzdGFydGluZyB2ZXJ0ZXggd2lsbCBiZSBkcmF3bi5cbiAgICogQHBhcmFtIHN0YXJ0IC0gVGhlIHN0YXJ0aW5nIHZlcnRleCBpbiB0aGUgZ2VvbWV0cnkgdG8gc3RhcnQgZHJhd2luZyBmcm9tLiBJZiBub3Qgc3BlY2lmaWVkLFxuICAgKiAgZHJhd2luZyB3aWxsIHN0YXJ0IGZyb20gdGhlIGZpcnN0IHZlcnRleC5cbiAgICogQHBhcmFtIGluc3RhbmNlQ291bnQgLSBUaGUgbnVtYmVyIG9mIGluc3RhbmNlcyBvZiB0aGUgc2V0IG9mIGVsZW1lbnRzIHRvIGV4ZWN1dGUuIElmIG5vdCBzcGVjaWZpZWQsXG4gICAqICBhbGwgaW5zdGFuY2VzIHdpbGwgYmUgZHJhd24uXG4gICAqL1xuICBkcmF3KHR5cGUsIHNpemUsIHN0YXJ0LCBpbnN0YW5jZUNvdW50KSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcywgZ2VvbWV0cnkgPSB0aGlzLl9hY3RpdmVHZW9tZXRyeTtcbiAgICBpZiAoZ2VvbWV0cnkuaW5kZXhCdWZmZXIpIHtcbiAgICAgIGNvbnN0IGJ5dGVTaXplID0gZ2VvbWV0cnkuaW5kZXhCdWZmZXIuZGF0YS5CWVRFU19QRVJfRUxFTUVOVCwgZ2xUeXBlID0gYnl0ZVNpemUgPT09IDIgPyBnbC5VTlNJR05FRF9TSE9SVCA6IGdsLlVOU0lHTkVEX0lOVDtcbiAgICAgIGJ5dGVTaXplID09PSAyIHx8IGJ5dGVTaXplID09PSA0ICYmIHRoaXMuY2FuVXNlVUludDMyRWxlbWVudEluZGV4ID8gZ2VvbWV0cnkuaW5zdGFuY2VkID8gZ2wuZHJhd0VsZW1lbnRzSW5zdGFuY2VkKHR5cGUsIHNpemUgfHwgZ2VvbWV0cnkuaW5kZXhCdWZmZXIuZGF0YS5sZW5ndGgsIGdsVHlwZSwgKHN0YXJ0IHx8IDApICogYnl0ZVNpemUsIGluc3RhbmNlQ291bnQgfHwgMSkgOiBnbC5kcmF3RWxlbWVudHModHlwZSwgc2l6ZSB8fCBnZW9tZXRyeS5pbmRleEJ1ZmZlci5kYXRhLmxlbmd0aCwgZ2xUeXBlLCAoc3RhcnQgfHwgMCkgKiBieXRlU2l6ZSkgOiBjb25zb2xlLndhcm4oXCJ1bnN1cHBvcnRlZCBpbmRleCBidWZmZXIgdHlwZTogdWludDMyXCIpO1xuICAgIH0gZWxzZVxuICAgICAgZ2VvbWV0cnkuaW5zdGFuY2VkID8gZ2wuZHJhd0FycmF5c0luc3RhbmNlZCh0eXBlLCBzdGFydCwgc2l6ZSB8fCBnZW9tZXRyeS5nZXRTaXplKCksIGluc3RhbmNlQ291bnQgfHwgMSkgOiBnbC5kcmF3QXJyYXlzKHR5cGUsIHN0YXJ0LCBzaXplIHx8IGdlb21ldHJ5LmdldFNpemUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqIFVuYmluZC9yZXNldCBldmVyeXRoaW5nLiAqL1xuICB1bmJpbmQoKSB7XG4gICAgdGhpcy5nbC5iaW5kVmVydGV4QXJyYXkobnVsbCksIHRoaXMuX2FjdGl2ZVZhbyA9IG51bGwsIHRoaXMuX2FjdGl2ZUdlb21ldHJ5ID0gbnVsbDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5HZW9tZXRyeVN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJnZW9tZXRyeVwiXG59O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChHZW9tZXRyeVN5c3RlbSk7XG5leHBvcnRzLkdlb21ldHJ5U3lzdGVtID0gR2VvbWV0cnlTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW9tZXRyeVN5c3RlbS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgVmlld2FibGVCdWZmZXIge1xuICBjb25zdHJ1Y3RvcihzaXplT3JCdWZmZXIpIHtcbiAgICB0eXBlb2Ygc2l6ZU9yQnVmZmVyID09IFwibnVtYmVyXCIgPyB0aGlzLnJhd0JpbmFyeURhdGEgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZU9yQnVmZmVyKSA6IHNpemVPckJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyB0aGlzLnJhd0JpbmFyeURhdGEgPSBzaXplT3JCdWZmZXIuYnVmZmVyIDogdGhpcy5yYXdCaW5hcnlEYXRhID0gc2l6ZU9yQnVmZmVyLCB0aGlzLnVpbnQzMlZpZXcgPSBuZXcgVWludDMyQXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKSwgdGhpcy5mbG9hdDMyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgfVxuICAvKiogVmlldyBvbiB0aGUgcmF3IGJpbmFyeSBkYXRhIGFzIGEgYEludDhBcnJheWAuICovXG4gIGdldCBpbnQ4VmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5faW50OFZpZXcgfHwgKHRoaXMuX2ludDhWaWV3ID0gbmV3IEludDhBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpKSwgdGhpcy5faW50OFZpZXc7XG4gIH1cbiAgLyoqIFZpZXcgb24gdGhlIHJhdyBiaW5hcnkgZGF0YSBhcyBhIGBVaW50OEFycmF5YC4gKi9cbiAgZ2V0IHVpbnQ4VmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5fdWludDhWaWV3IHx8ICh0aGlzLl91aW50OFZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpKSwgdGhpcy5fdWludDhWaWV3O1xuICB9XG4gIC8qKiAgVmlldyBvbiB0aGUgcmF3IGJpbmFyeSBkYXRhIGFzIGEgYEludDE2QXJyYXlgLiAqL1xuICBnZXQgaW50MTZWaWV3KCkge1xuICAgIHJldHVybiB0aGlzLl9pbnQxNlZpZXcgfHwgKHRoaXMuX2ludDE2VmlldyA9IG5ldyBJbnQxNkFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSkpLCB0aGlzLl9pbnQxNlZpZXc7XG4gIH1cbiAgLyoqIFZpZXcgb24gdGhlIHJhdyBiaW5hcnkgZGF0YSBhcyBhIGBVaW50MTZBcnJheWAuICovXG4gIGdldCB1aW50MTZWaWV3KCkge1xuICAgIHJldHVybiB0aGlzLl91aW50MTZWaWV3IHx8ICh0aGlzLl91aW50MTZWaWV3ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSkpLCB0aGlzLl91aW50MTZWaWV3O1xuICB9XG4gIC8qKiBWaWV3IG9uIHRoZSByYXcgYmluYXJ5IGRhdGEgYXMgYSBgSW50MzJBcnJheWAuICovXG4gIGdldCBpbnQzMlZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludDMyVmlldyB8fCAodGhpcy5faW50MzJWaWV3ID0gbmV3IEludDMyQXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKSksIHRoaXMuX2ludDMyVmlldztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmlldyBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAgICogQHBhcmFtIHR5cGUgLSBPbmUgb2YgYGludDhgLCBgdWludDhgLCBgaW50MTZgLFxuICAgKiAgICBgdWludDE2YCwgYGludDMyYCwgYHVpbnQzMmAsIGFuZCBgZmxvYXQzMmAuXG4gICAqIEByZXR1cm5zIC0gdHlwZWQgYXJyYXkgb2YgZ2l2ZW4gdHlwZVxuICAgKi9cbiAgdmlldyh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXNbYCR7dHlwZX1WaWV3YF07XG4gIH1cbiAgLyoqIERlc3Ryb3lzIGFsbCBidWZmZXIgcmVmZXJlbmNlcy4gRG8gbm90IHVzZSBhZnRlciBjYWxsaW5nIHRoaXMuICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yYXdCaW5hcnlEYXRhID0gbnVsbCwgdGhpcy5faW50OFZpZXcgPSBudWxsLCB0aGlzLl91aW50OFZpZXcgPSBudWxsLCB0aGlzLl9pbnQxNlZpZXcgPSBudWxsLCB0aGlzLl91aW50MTZWaWV3ID0gbnVsbCwgdGhpcy5faW50MzJWaWV3ID0gbnVsbCwgdGhpcy51aW50MzJWaWV3ID0gbnVsbCwgdGhpcy5mbG9hdDMyVmlldyA9IG51bGw7XG4gIH1cbiAgc3RhdGljIHNpemVPZih0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiaW50OFwiOlxuICAgICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBcImludDE2XCI6XG4gICAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICBjYXNlIFwiZmxvYXQzMlwiOlxuICAgICAgICByZXR1cm4gNDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0eXBlfSBpc24ndCBhIHZhbGlkIHZpZXcgdHlwZWApO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5WaWV3YWJsZUJ1ZmZlciA9IFZpZXdhYmxlQnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vmlld2FibGVCdWZmZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCJAcGl4aS91dGlsc1wiKTtcbmNvbnN0IG1hcCA9IHtcbiAgRmxvYXQzMkFycmF5LFxuICBVaW50MzJBcnJheSxcbiAgSW50MzJBcnJheSxcbiAgVWludDhBcnJheVxufTtcbmZ1bmN0aW9uIGludGVybGVhdmVUeXBlZEFycmF5cyhhcnJheXMsIHNpemVzKSB7XG4gIGxldCBvdXRTaXplID0gMCwgc3RyaWRlID0gMDtcbiAgY29uc3Qgdmlld3MgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspXG4gICAgc3RyaWRlICs9IHNpemVzW2ldLCBvdXRTaXplICs9IGFycmF5c1tpXS5sZW5ndGg7XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihvdXRTaXplICogNCk7XG4gIGxldCBvdXQgPSBudWxsLCBsaXR0bGVPZmZzZXQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNpemUgPSBzaXplc1tpXSwgYXJyYXkgPSBhcnJheXNbaV0sIHR5cGUgPSB1dGlscy5nZXRCdWZmZXJUeXBlKGFycmF5KTtcbiAgICB2aWV3c1t0eXBlXSB8fCAodmlld3NbdHlwZV0gPSBuZXcgbWFwW3R5cGVdKGJ1ZmZlcikpLCBvdXQgPSB2aWV3c1t0eXBlXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBpbmRleFN0YXJ0ID0gKGogLyBzaXplIHwgMCkgKiBzdHJpZGUgKyBsaXR0bGVPZmZzZXQsIGluZGV4ID0gaiAlIHNpemU7XG4gICAgICBvdXRbaW5kZXhTdGFydCArIGluZGV4XSA9IGFycmF5W2pdO1xuICAgIH1cbiAgICBsaXR0bGVPZmZzZXQgKz0gc2l6ZTtcbiAgfVxuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xufVxuZXhwb3J0cy5pbnRlcmxlYXZlVHlwZWRBcnJheXMgPSBpbnRlcmxlYXZlVHlwZWRBcnJheXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmxlYXZlVHlwZWRBcnJheXMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnJlcXVpcmUoXCIuL3NldHRpbmdzLmpzXCIpO1xudmFyIGNvbG9yID0gcmVxdWlyZShcIkBwaXhpL2NvbG9yXCIpLCBjb25zdGFudHMgPSByZXF1aXJlKFwiQHBpeGkvY29uc3RhbnRzXCIpLCBleHRlbnNpb25zID0gcmVxdWlyZShcIkBwaXhpL2V4dGVuc2lvbnNcIiksIG1hdGggPSByZXF1aXJlKFwiQHBpeGkvbWF0aFwiKSwgcnVubmVyID0gcmVxdWlyZShcIkBwaXhpL3J1bm5lclwiKSwgc2V0dGluZ3MgPSByZXF1aXJlKFwiQHBpeGkvc2V0dGluZ3NcIiksIHRpY2tlciA9IHJlcXVpcmUoXCJAcGl4aS90aWNrZXJcIiksIHV0aWxzJDEgPSByZXF1aXJlKFwiQHBpeGkvdXRpbHNcIiksIGF1dG9EZXRlY3RSZW5kZXJlciA9IHJlcXVpcmUoXCIuL2F1dG9EZXRlY3RSZW5kZXJlci5qc1wiKSwgQmFja2dyb3VuZFN5c3RlbSA9IHJlcXVpcmUoXCIuL2JhY2tncm91bmQvQmFja2dyb3VuZFN5c3RlbS5qc1wiKSwgQmF0Y2hEcmF3Q2FsbCA9IHJlcXVpcmUoXCIuL2JhdGNoL0JhdGNoRHJhd0NhbGwuanNcIiksIEJhdGNoR2VvbWV0cnkgPSByZXF1aXJlKFwiLi9iYXRjaC9CYXRjaEdlb21ldHJ5LmpzXCIpLCBCYXRjaFJlbmRlcmVyID0gcmVxdWlyZShcIi4vYmF0Y2gvQmF0Y2hSZW5kZXJlci5qc1wiKSwgQmF0Y2hTaGFkZXJHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9iYXRjaC9CYXRjaFNoYWRlckdlbmVyYXRvci5qc1wiKSwgQmF0Y2hTeXN0ZW0gPSByZXF1aXJlKFwiLi9iYXRjaC9CYXRjaFN5c3RlbS5qc1wiKSwgQmF0Y2hUZXh0dXJlQXJyYXkgPSByZXF1aXJlKFwiLi9iYXRjaC9CYXRjaFRleHR1cmVBcnJheS5qc1wiKSwgT2JqZWN0UmVuZGVyZXIgPSByZXF1aXJlKFwiLi9iYXRjaC9PYmplY3RSZW5kZXJlci5qc1wiKSwgQ29udGV4dFN5c3RlbSA9IHJlcXVpcmUoXCIuL2NvbnRleHQvQ29udGV4dFN5c3RlbS5qc1wiKSwgRmlsdGVyID0gcmVxdWlyZShcIi4vZmlsdGVycy9GaWx0ZXIuanNcIiksIEZpbHRlclN0YXRlID0gcmVxdWlyZShcIi4vZmlsdGVycy9GaWx0ZXJTdGF0ZS5qc1wiKSwgRmlsdGVyU3lzdGVtID0gcmVxdWlyZShcIi4vZmlsdGVycy9GaWx0ZXJTeXN0ZW0uanNcIik7XG5yZXF1aXJlKFwiLi9maWx0ZXJzL0lGaWx0ZXJUYXJnZXQuanNcIik7XG52YXIgU3ByaXRlTWFza0ZpbHRlciA9IHJlcXVpcmUoXCIuL2ZpbHRlcnMvc3ByaXRlTWFzay9TcHJpdGVNYXNrRmlsdGVyLmpzXCIpLCBpbmRleCA9IHJlcXVpcmUoXCIuL2ZyYWdtZW50cy9pbmRleC5qc1wiKSwgRnJhbWVidWZmZXIgPSByZXF1aXJlKFwiLi9mcmFtZWJ1ZmZlci9GcmFtZWJ1ZmZlci5qc1wiKSwgRnJhbWVidWZmZXJTeXN0ZW0gPSByZXF1aXJlKFwiLi9mcmFtZWJ1ZmZlci9GcmFtZWJ1ZmZlclN5c3RlbS5qc1wiKSwgR0xGcmFtZWJ1ZmZlciA9IHJlcXVpcmUoXCIuL2ZyYW1lYnVmZmVyL0dMRnJhbWVidWZmZXIuanNcIiksIE11bHRpc2FtcGxlU3lzdGVtID0gcmVxdWlyZShcIi4vZnJhbWVidWZmZXIvTXVsdGlzYW1wbGVTeXN0ZW0uanNcIiksIEF0dHJpYnV0ZSA9IHJlcXVpcmUoXCIuL2dlb21ldHJ5L0F0dHJpYnV0ZS5qc1wiKSwgQnVmZmVyID0gcmVxdWlyZShcIi4vZ2VvbWV0cnkvQnVmZmVyLmpzXCIpLCBCdWZmZXJTeXN0ZW0gPSByZXF1aXJlKFwiLi9nZW9tZXRyeS9CdWZmZXJTeXN0ZW0uanNcIiksIEdlb21ldHJ5ID0gcmVxdWlyZShcIi4vZ2VvbWV0cnkvR2VvbWV0cnkuanNcIiksIEdlb21ldHJ5U3lzdGVtID0gcmVxdWlyZShcIi4vZ2VvbWV0cnkvR2VvbWV0cnlTeXN0ZW0uanNcIiksIFZpZXdhYmxlQnVmZmVyID0gcmVxdWlyZShcIi4vZ2VvbWV0cnkvVmlld2FibGVCdWZmZXIuanNcIik7XG5yZXF1aXJlKFwiLi9JUmVuZGVyZXIuanNcIik7XG52YXIgTWFza0RhdGEgPSByZXF1aXJlKFwiLi9tYXNrL01hc2tEYXRhLmpzXCIpLCBNYXNrU3lzdGVtID0gcmVxdWlyZShcIi4vbWFzay9NYXNrU3lzdGVtLmpzXCIpLCBTY2lzc29yU3lzdGVtID0gcmVxdWlyZShcIi4vbWFzay9TY2lzc29yU3lzdGVtLmpzXCIpLCBTdGVuY2lsU3lzdGVtID0gcmVxdWlyZShcIi4vbWFzay9TdGVuY2lsU3lzdGVtLmpzXCIpLCBQbHVnaW5TeXN0ZW0gPSByZXF1aXJlKFwiLi9wbHVnaW4vUGx1Z2luU3lzdGVtLmpzXCIpLCBQcm9qZWN0aW9uU3lzdGVtID0gcmVxdWlyZShcIi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uU3lzdGVtLmpzXCIpLCBPYmplY3RSZW5kZXJlclN5c3RlbSA9IHJlcXVpcmUoXCIuL3JlbmRlci9PYmplY3RSZW5kZXJlclN5c3RlbS5qc1wiKSwgUmVuZGVyZXIgPSByZXF1aXJlKFwiLi9SZW5kZXJlci5qc1wiKSwgQmFzZVJlbmRlclRleHR1cmUgPSByZXF1aXJlKFwiLi9yZW5kZXJUZXh0dXJlL0Jhc2VSZW5kZXJUZXh0dXJlLmpzXCIpLCBHZW5lcmF0ZVRleHR1cmVTeXN0ZW0gPSByZXF1aXJlKFwiLi9yZW5kZXJUZXh0dXJlL0dlbmVyYXRlVGV4dHVyZVN5c3RlbS5qc1wiKSwgUmVuZGVyVGV4dHVyZSA9IHJlcXVpcmUoXCIuL3JlbmRlclRleHR1cmUvUmVuZGVyVGV4dHVyZS5qc1wiKSwgUmVuZGVyVGV4dHVyZVBvb2wgPSByZXF1aXJlKFwiLi9yZW5kZXJUZXh0dXJlL1JlbmRlclRleHR1cmVQb29sLmpzXCIpLCBSZW5kZXJUZXh0dXJlU3lzdGVtID0gcmVxdWlyZShcIi4vcmVuZGVyVGV4dHVyZS9SZW5kZXJUZXh0dXJlU3lzdGVtLmpzXCIpLCBHTFByb2dyYW0gPSByZXF1aXJlKFwiLi9zaGFkZXIvR0xQcm9ncmFtLmpzXCIpLCBQcm9ncmFtID0gcmVxdWlyZShcIi4vc2hhZGVyL1Byb2dyYW0uanNcIiksIFNoYWRlciA9IHJlcXVpcmUoXCIuL3NoYWRlci9TaGFkZXIuanNcIiksIFNoYWRlclN5c3RlbSA9IHJlcXVpcmUoXCIuL3NoYWRlci9TaGFkZXJTeXN0ZW0uanNcIiksIFVuaWZvcm1Hcm91cCA9IHJlcXVpcmUoXCIuL3NoYWRlci9Vbmlmb3JtR3JvdXAuanNcIiksIGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIgPSByZXF1aXJlKFwiLi9zaGFkZXIvdXRpbHMvY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlci5qc1wiKSwgZ2VuZXJhdGVQcm9ncmFtID0gcmVxdWlyZShcIi4vc2hhZGVyL3V0aWxzL2dlbmVyYXRlUHJvZ3JhbS5qc1wiKSwgZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYyA9IHJlcXVpcmUoXCIuL3NoYWRlci91dGlscy9nZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jLmpzXCIpLCBnZXRUZXN0Q29udGV4dCA9IHJlcXVpcmUoXCIuL3NoYWRlci91dGlscy9nZXRUZXN0Q29udGV4dC5qc1wiKSwgdW5pZm9ybVBhcnNlcnMgPSByZXF1aXJlKFwiLi9zaGFkZXIvdXRpbHMvdW5pZm9ybVBhcnNlcnMuanNcIiksIHVuc2FmZUV2YWxTdXBwb3J0ZWQgPSByZXF1aXJlKFwiLi9zaGFkZXIvdXRpbHMvdW5zYWZlRXZhbFN1cHBvcnRlZC5qc1wiKSwgU3RhcnR1cFN5c3RlbSA9IHJlcXVpcmUoXCIuL3N0YXJ0dXAvU3RhcnR1cFN5c3RlbS5qc1wiKSwgU3RhdGUgPSByZXF1aXJlKFwiLi9zdGF0ZS9TdGF0ZS5qc1wiKSwgU3RhdGVTeXN0ZW0gPSByZXF1aXJlKFwiLi9zdGF0ZS9TdGF0ZVN5c3RlbS5qc1wiKTtcbnJlcXVpcmUoXCIuL3N5c3RlbS9JU3lzdGVtLmpzXCIpO1xucmVxdWlyZShcIi4vc3lzdGVtcy5qc1wiKTtcbnZhciBCYXNlVGV4dHVyZSA9IHJlcXVpcmUoXCIuL3RleHR1cmVzL0Jhc2VUZXh0dXJlLmpzXCIpLCBHTFRleHR1cmUgPSByZXF1aXJlKFwiLi90ZXh0dXJlcy9HTFRleHR1cmUuanNcIik7XG5yZXF1aXJlKFwiLi90ZXh0dXJlcy9yZXNvdXJjZXMvaW5kZXguanNcIik7XG52YXIgVGV4dHVyZSA9IHJlcXVpcmUoXCIuL3RleHR1cmVzL1RleHR1cmUuanNcIiksIFRleHR1cmVHQ1N5c3RlbSA9IHJlcXVpcmUoXCIuL3RleHR1cmVzL1RleHR1cmVHQ1N5c3RlbS5qc1wiKSwgVGV4dHVyZU1hdHJpeCA9IHJlcXVpcmUoXCIuL3RleHR1cmVzL1RleHR1cmVNYXRyaXguanNcIiksIFRleHR1cmVTeXN0ZW0gPSByZXF1aXJlKFwiLi90ZXh0dXJlcy9UZXh0dXJlU3lzdGVtLmpzXCIpLCBUZXh0dXJlVXZzID0gcmVxdWlyZShcIi4vdGV4dHVyZXMvVGV4dHVyZVV2cy5qc1wiKSwgVHJhbnNmb3JtRmVlZGJhY2sgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1GZWVkYmFjay9UcmFuc2Zvcm1GZWVkYmFjay5qc1wiKSwgVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0gPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1GZWVkYmFjay9UcmFuc2Zvcm1GZWVkYmFja1N5c3RlbS5qc1wiKSwgUXVhZCA9IHJlcXVpcmUoXCIuL3V0aWxzL1F1YWQuanNcIiksIFF1YWRVdiA9IHJlcXVpcmUoXCIuL3V0aWxzL1F1YWRVdi5qc1wiKSwgVmlld1N5c3RlbSA9IHJlcXVpcmUoXCIuL3ZpZXcvVmlld1N5c3RlbS5qc1wiKSwgU3lzdGVtTWFuYWdlciA9IHJlcXVpcmUoXCIuL3N5c3RlbS9TeXN0ZW1NYW5hZ2VyLmpzXCIpLCBCYXNlSW1hZ2VSZXNvdXJjZSA9IHJlcXVpcmUoXCIuL3RleHR1cmVzL3Jlc291cmNlcy9CYXNlSW1hZ2VSZXNvdXJjZS5qc1wiKSwgUmVzb3VyY2UgPSByZXF1aXJlKFwiLi90ZXh0dXJlcy9yZXNvdXJjZXMvUmVzb3VyY2UuanNcIiksIEFic3RyYWN0TXVsdGlSZXNvdXJjZSA9IHJlcXVpcmUoXCIuL3RleHR1cmVzL3Jlc291cmNlcy9BYnN0cmFjdE11bHRpUmVzb3VyY2UuanNcIiksIEFycmF5UmVzb3VyY2UgPSByZXF1aXJlKFwiLi90ZXh0dXJlcy9yZXNvdXJjZXMvQXJyYXlSZXNvdXJjZS5qc1wiKSwgYXV0b0RldGVjdFJlc291cmNlID0gcmVxdWlyZShcIi4vdGV4dHVyZXMvcmVzb3VyY2VzL2F1dG9EZXRlY3RSZXNvdXJjZS5qc1wiKSwgQnVmZmVyUmVzb3VyY2UgPSByZXF1aXJlKFwiLi90ZXh0dXJlcy9yZXNvdXJjZXMvQnVmZmVyUmVzb3VyY2UuanNcIiksIENhbnZhc1Jlc291cmNlID0gcmVxdWlyZShcIi4vdGV4dHVyZXMvcmVzb3VyY2VzL0NhbnZhc1Jlc291cmNlLmpzXCIpLCBDdWJlUmVzb3VyY2UgPSByZXF1aXJlKFwiLi90ZXh0dXJlcy9yZXNvdXJjZXMvQ3ViZVJlc291cmNlLmpzXCIpLCBJbWFnZUJpdG1hcFJlc291cmNlID0gcmVxdWlyZShcIi4vdGV4dHVyZXMvcmVzb3VyY2VzL0ltYWdlQml0bWFwUmVzb3VyY2UuanNcIiksIEltYWdlUmVzb3VyY2UgPSByZXF1aXJlKFwiLi90ZXh0dXJlcy9yZXNvdXJjZXMvSW1hZ2VSZXNvdXJjZS5qc1wiKSwgU1ZHUmVzb3VyY2UgPSByZXF1aXJlKFwiLi90ZXh0dXJlcy9yZXNvdXJjZXMvU1ZHUmVzb3VyY2UuanNcIiksIFZpZGVvUmVzb3VyY2UgPSByZXF1aXJlKFwiLi90ZXh0dXJlcy9yZXNvdXJjZXMvVmlkZW9SZXNvdXJjZS5qc1wiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChlKSB7XG4gIHZhciBuID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiBlICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIGlmIChrICE9PSBcImRlZmF1bHRcIikge1xuICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGVba107XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIG4uZGVmYXVsdCA9IGUsIG47XG59XG52YXIgdXRpbHNfX25hbWVzcGFjZSA9IC8qIEBfX1BVUkVfXyAqLyBfaW50ZXJvcE5hbWVzcGFjZURlZmF1bHQodXRpbHMkMSk7XG5jb25zdCBWRVJTSU9OID0gXCI3LjMuMlwiO1xuZXhwb3J0cy51dGlscyA9IHV0aWxzX19uYW1lc3BhY2U7XG5leHBvcnRzLmF1dG9EZXRlY3RSZW5kZXJlciA9IGF1dG9EZXRlY3RSZW5kZXJlci5hdXRvRGV0ZWN0UmVuZGVyZXI7XG5leHBvcnRzLkJhY2tncm91bmRTeXN0ZW0gPSBCYWNrZ3JvdW5kU3lzdGVtLkJhY2tncm91bmRTeXN0ZW07XG5leHBvcnRzLkJhdGNoRHJhd0NhbGwgPSBCYXRjaERyYXdDYWxsLkJhdGNoRHJhd0NhbGw7XG5leHBvcnRzLkJhdGNoR2VvbWV0cnkgPSBCYXRjaEdlb21ldHJ5LkJhdGNoR2VvbWV0cnk7XG5leHBvcnRzLkJhdGNoUmVuZGVyZXIgPSBCYXRjaFJlbmRlcmVyLkJhdGNoUmVuZGVyZXI7XG5leHBvcnRzLkJhdGNoU2hhZGVyR2VuZXJhdG9yID0gQmF0Y2hTaGFkZXJHZW5lcmF0b3IuQmF0Y2hTaGFkZXJHZW5lcmF0b3I7XG5leHBvcnRzLkJhdGNoU3lzdGVtID0gQmF0Y2hTeXN0ZW0uQmF0Y2hTeXN0ZW07XG5leHBvcnRzLkJhdGNoVGV4dHVyZUFycmF5ID0gQmF0Y2hUZXh0dXJlQXJyYXkuQmF0Y2hUZXh0dXJlQXJyYXk7XG5leHBvcnRzLk9iamVjdFJlbmRlcmVyID0gT2JqZWN0UmVuZGVyZXIuT2JqZWN0UmVuZGVyZXI7XG5leHBvcnRzLkNvbnRleHRTeXN0ZW0gPSBDb250ZXh0U3lzdGVtLkNvbnRleHRTeXN0ZW07XG5leHBvcnRzLkZpbHRlciA9IEZpbHRlci5GaWx0ZXI7XG5leHBvcnRzLkZpbHRlclN0YXRlID0gRmlsdGVyU3RhdGUuRmlsdGVyU3RhdGU7XG5leHBvcnRzLkZpbHRlclN5c3RlbSA9IEZpbHRlclN5c3RlbS5GaWx0ZXJTeXN0ZW07XG5leHBvcnRzLlNwcml0ZU1hc2tGaWx0ZXIgPSBTcHJpdGVNYXNrRmlsdGVyLlNwcml0ZU1hc2tGaWx0ZXI7XG5leHBvcnRzLmRlZmF1bHRGaWx0ZXJWZXJ0ZXggPSBpbmRleC5kZWZhdWx0RmlsdGVyVmVydGV4O1xuZXhwb3J0cy5kZWZhdWx0VmVydGV4ID0gaW5kZXguZGVmYXVsdFZlcnRleDtcbmV4cG9ydHMuRnJhbWVidWZmZXIgPSBGcmFtZWJ1ZmZlci5GcmFtZWJ1ZmZlcjtcbmV4cG9ydHMuRnJhbWVidWZmZXJTeXN0ZW0gPSBGcmFtZWJ1ZmZlclN5c3RlbS5GcmFtZWJ1ZmZlclN5c3RlbTtcbmV4cG9ydHMuR0xGcmFtZWJ1ZmZlciA9IEdMRnJhbWVidWZmZXIuR0xGcmFtZWJ1ZmZlcjtcbmV4cG9ydHMuTXVsdGlzYW1wbGVTeXN0ZW0gPSBNdWx0aXNhbXBsZVN5c3RlbS5NdWx0aXNhbXBsZVN5c3RlbTtcbmV4cG9ydHMuQXR0cmlidXRlID0gQXR0cmlidXRlLkF0dHJpYnV0ZTtcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyLkJ1ZmZlcjtcbmV4cG9ydHMuQnVmZmVyU3lzdGVtID0gQnVmZmVyU3lzdGVtLkJ1ZmZlclN5c3RlbTtcbmV4cG9ydHMuR2VvbWV0cnkgPSBHZW9tZXRyeS5HZW9tZXRyeTtcbmV4cG9ydHMuR2VvbWV0cnlTeXN0ZW0gPSBHZW9tZXRyeVN5c3RlbS5HZW9tZXRyeVN5c3RlbTtcbmV4cG9ydHMuVmlld2FibGVCdWZmZXIgPSBWaWV3YWJsZUJ1ZmZlci5WaWV3YWJsZUJ1ZmZlcjtcbmV4cG9ydHMuTWFza0RhdGEgPSBNYXNrRGF0YS5NYXNrRGF0YTtcbmV4cG9ydHMuTWFza1N5c3RlbSA9IE1hc2tTeXN0ZW0uTWFza1N5c3RlbTtcbmV4cG9ydHMuU2Npc3NvclN5c3RlbSA9IFNjaXNzb3JTeXN0ZW0uU2Npc3NvclN5c3RlbTtcbmV4cG9ydHMuU3RlbmNpbFN5c3RlbSA9IFN0ZW5jaWxTeXN0ZW0uU3RlbmNpbFN5c3RlbTtcbmV4cG9ydHMuUGx1Z2luU3lzdGVtID0gUGx1Z2luU3lzdGVtLlBsdWdpblN5c3RlbTtcbmV4cG9ydHMuUHJvamVjdGlvblN5c3RlbSA9IFByb2plY3Rpb25TeXN0ZW0uUHJvamVjdGlvblN5c3RlbTtcbmV4cG9ydHMuT2JqZWN0UmVuZGVyZXJTeXN0ZW0gPSBPYmplY3RSZW5kZXJlclN5c3RlbS5PYmplY3RSZW5kZXJlclN5c3RlbTtcbmV4cG9ydHMuUmVuZGVyZXIgPSBSZW5kZXJlci5SZW5kZXJlcjtcbmV4cG9ydHMuQmFzZVJlbmRlclRleHR1cmUgPSBCYXNlUmVuZGVyVGV4dHVyZS5CYXNlUmVuZGVyVGV4dHVyZTtcbmV4cG9ydHMuR2VuZXJhdGVUZXh0dXJlU3lzdGVtID0gR2VuZXJhdGVUZXh0dXJlU3lzdGVtLkdlbmVyYXRlVGV4dHVyZVN5c3RlbTtcbmV4cG9ydHMuUmVuZGVyVGV4dHVyZSA9IFJlbmRlclRleHR1cmUuUmVuZGVyVGV4dHVyZTtcbmV4cG9ydHMuUmVuZGVyVGV4dHVyZVBvb2wgPSBSZW5kZXJUZXh0dXJlUG9vbC5SZW5kZXJUZXh0dXJlUG9vbDtcbmV4cG9ydHMuUmVuZGVyVGV4dHVyZVN5c3RlbSA9IFJlbmRlclRleHR1cmVTeXN0ZW0uUmVuZGVyVGV4dHVyZVN5c3RlbTtcbmV4cG9ydHMuR0xQcm9ncmFtID0gR0xQcm9ncmFtLkdMUHJvZ3JhbTtcbmV4cG9ydHMuSUdMVW5pZm9ybURhdGEgPSBHTFByb2dyYW0uSUdMVW5pZm9ybURhdGE7XG5leHBvcnRzLlByb2dyYW0gPSBQcm9ncmFtLlByb2dyYW07XG5leHBvcnRzLlNoYWRlciA9IFNoYWRlci5TaGFkZXI7XG5leHBvcnRzLlNoYWRlclN5c3RlbSA9IFNoYWRlclN5c3RlbS5TaGFkZXJTeXN0ZW07XG5leHBvcnRzLlVuaWZvcm1Hcm91cCA9IFVuaWZvcm1Hcm91cC5Vbmlmb3JtR3JvdXA7XG5leHBvcnRzLmNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIgPSBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyLmNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXI7XG5leHBvcnRzLmdlbmVyYXRlUHJvZ3JhbSA9IGdlbmVyYXRlUHJvZ3JhbS5nZW5lcmF0ZVByb2dyYW07XG5leHBvcnRzLmNyZWF0ZVVCT0VsZW1lbnRzID0gZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYy5jcmVhdGVVQk9FbGVtZW50cztcbmV4cG9ydHMuZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYyA9IGdlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMuZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYztcbmV4cG9ydHMuZ2V0VUJPRGF0YSA9IGdlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMuZ2V0VUJPRGF0YTtcbmV4cG9ydHMuZ2V0VGVzdENvbnRleHQgPSBnZXRUZXN0Q29udGV4dC5nZXRUZXN0Q29udGV4dDtcbmV4cG9ydHMudW5pZm9ybVBhcnNlcnMgPSB1bmlmb3JtUGFyc2Vycy51bmlmb3JtUGFyc2VycztcbmV4cG9ydHMudW5zYWZlRXZhbFN1cHBvcnRlZCA9IHVuc2FmZUV2YWxTdXBwb3J0ZWQudW5zYWZlRXZhbFN1cHBvcnRlZDtcbmV4cG9ydHMuU3RhcnR1cFN5c3RlbSA9IFN0YXJ0dXBTeXN0ZW0uU3RhcnR1cFN5c3RlbTtcbmV4cG9ydHMuU3RhdGUgPSBTdGF0ZS5TdGF0ZTtcbmV4cG9ydHMuU3RhdGVTeXN0ZW0gPSBTdGF0ZVN5c3RlbS5TdGF0ZVN5c3RlbTtcbmV4cG9ydHMuQmFzZVRleHR1cmUgPSBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZTtcbmV4cG9ydHMuR0xUZXh0dXJlID0gR0xUZXh0dXJlLkdMVGV4dHVyZTtcbmV4cG9ydHMuVGV4dHVyZSA9IFRleHR1cmUuVGV4dHVyZTtcbmV4cG9ydHMuVGV4dHVyZUdDU3lzdGVtID0gVGV4dHVyZUdDU3lzdGVtLlRleHR1cmVHQ1N5c3RlbTtcbmV4cG9ydHMuVGV4dHVyZU1hdHJpeCA9IFRleHR1cmVNYXRyaXguVGV4dHVyZU1hdHJpeDtcbmV4cG9ydHMuVGV4dHVyZVN5c3RlbSA9IFRleHR1cmVTeXN0ZW0uVGV4dHVyZVN5c3RlbTtcbmV4cG9ydHMuVGV4dHVyZVV2cyA9IFRleHR1cmVVdnMuVGV4dHVyZVV2cztcbmV4cG9ydHMuVHJhbnNmb3JtRmVlZGJhY2sgPSBUcmFuc2Zvcm1GZWVkYmFjay5UcmFuc2Zvcm1GZWVkYmFjaztcbmV4cG9ydHMuVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0gPSBUcmFuc2Zvcm1GZWVkYmFja1N5c3RlbS5UcmFuc2Zvcm1GZWVkYmFja1N5c3RlbTtcbmV4cG9ydHMuUXVhZCA9IFF1YWQuUXVhZDtcbmV4cG9ydHMuUXVhZFV2ID0gUXVhZFV2LlF1YWRVdjtcbmV4cG9ydHMuVmlld1N5c3RlbSA9IFZpZXdTeXN0ZW0uVmlld1N5c3RlbTtcbmV4cG9ydHMuU3lzdGVtTWFuYWdlciA9IFN5c3RlbU1hbmFnZXIuU3lzdGVtTWFuYWdlcjtcbmV4cG9ydHMuQmFzZUltYWdlUmVzb3VyY2UgPSBCYXNlSW1hZ2VSZXNvdXJjZS5CYXNlSW1hZ2VSZXNvdXJjZTtcbmV4cG9ydHMuUmVzb3VyY2UgPSBSZXNvdXJjZS5SZXNvdXJjZTtcbmV4cG9ydHMuQWJzdHJhY3RNdWx0aVJlc291cmNlID0gQWJzdHJhY3RNdWx0aVJlc291cmNlLkFic3RyYWN0TXVsdGlSZXNvdXJjZTtcbmV4cG9ydHMuQXJyYXlSZXNvdXJjZSA9IEFycmF5UmVzb3VyY2UuQXJyYXlSZXNvdXJjZTtcbmV4cG9ydHMuSU5TVEFMTEVEID0gYXV0b0RldGVjdFJlc291cmNlLklOU1RBTExFRDtcbmV4cG9ydHMuYXV0b0RldGVjdFJlc291cmNlID0gYXV0b0RldGVjdFJlc291cmNlLmF1dG9EZXRlY3RSZXNvdXJjZTtcbmV4cG9ydHMuQnVmZmVyUmVzb3VyY2UgPSBCdWZmZXJSZXNvdXJjZS5CdWZmZXJSZXNvdXJjZTtcbmV4cG9ydHMuQ2FudmFzUmVzb3VyY2UgPSBDYW52YXNSZXNvdXJjZS5DYW52YXNSZXNvdXJjZTtcbmV4cG9ydHMuQ3ViZVJlc291cmNlID0gQ3ViZVJlc291cmNlLkN1YmVSZXNvdXJjZTtcbmV4cG9ydHMuSW1hZ2VCaXRtYXBSZXNvdXJjZSA9IEltYWdlQml0bWFwUmVzb3VyY2UuSW1hZ2VCaXRtYXBSZXNvdXJjZTtcbmV4cG9ydHMuSW1hZ2VSZXNvdXJjZSA9IEltYWdlUmVzb3VyY2UuSW1hZ2VSZXNvdXJjZTtcbmV4cG9ydHMuU1ZHUmVzb3VyY2UgPSBTVkdSZXNvdXJjZS5TVkdSZXNvdXJjZTtcbmV4cG9ydHMuVmlkZW9SZXNvdXJjZSA9IFZpZGVvUmVzb3VyY2UuVmlkZW9SZXNvdXJjZTtcbmV4cG9ydHMuVkVSU0lPTiA9IFZFUlNJT047XG5PYmplY3Qua2V5cyhjb2xvcikuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIGsgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgaykgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvbG9yW2tdO1xuICAgIH1cbiAgfSk7XG59KTtcbk9iamVjdC5rZXlzKGNvbnN0YW50cykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIGsgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgaykgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50c1trXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhleHRlbnNpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgayAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBrKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5zaW9uc1trXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhtYXRoKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgayAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBrKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF0aFtrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhydW5uZXIpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBrICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIGspICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBydW5uZXJba107XG4gICAgfVxuICB9KTtcbn0pO1xuT2JqZWN0LmtleXMoc2V0dGluZ3MpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBrICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIGspICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzZXR0aW5nc1trXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyh0aWNrZXIpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBrICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIGspICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aWNrZXJba107XG4gICAgfVxuICB9KTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEFic3RyYWN0TWFza1N5c3RlbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBTeXN0ZW0gd29ya3MgZm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIsIHRoaXMubWFza1N0YWNrID0gW10sIHRoaXMuZ2xDb25zdCA9IDA7XG4gIH1cbiAgLyoqIEdldHMgY291bnQgb2YgbWFza3Mgb2YgY2VydGFpbiB0eXBlLiAqL1xuICBnZXRTdGFja0xlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXNrU3RhY2subGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSBtYXNrIHN0YWNrIHRoYXQgaXMgdXNlZCBieSB0aGlzIFN5c3RlbS5cbiAgICogQHBhcmFtIHtQSVhJLk1hc2tEYXRhW119IG1hc2tTdGFjayAtIFRoZSBtYXNrIHN0YWNrXG4gICAqL1xuICBzZXRNYXNrU3RhY2sobWFza1N0YWNrKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcy5yZW5kZXJlciwgY3VyU3RhY2tMZW4gPSB0aGlzLmdldFN0YWNrTGVuZ3RoKCk7XG4gICAgdGhpcy5tYXNrU3RhY2sgPSBtYXNrU3RhY2s7XG4gICAgY29uc3QgbmV3U3RhY2tMZW4gPSB0aGlzLmdldFN0YWNrTGVuZ3RoKCk7XG4gICAgbmV3U3RhY2tMZW4gIT09IGN1clN0YWNrTGVuICYmIChuZXdTdGFja0xlbiA9PT0gMCA/IGdsLmRpc2FibGUodGhpcy5nbENvbnN0KSA6IChnbC5lbmFibGUodGhpcy5nbENvbnN0KSwgdGhpcy5fdXNlQ3VycmVudCgpKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHVwIHJlbmRlcmVyIHRvIHVzZSB0aGUgY3VycmVudCBtYXNrIGRhdGEuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXNlQ3VycmVudCgpIHtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIG1hc2sgc3RhY2suICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGwsIHRoaXMubWFza1N0YWNrID0gbnVsbDtcbiAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1hc2tTeXN0ZW0gPSBBYnN0cmFjdE1hc2tTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYnN0cmFjdE1hc2tTeXN0ZW0uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiQHBpeGkvY29uc3RhbnRzXCIpLCBGaWx0ZXIgPSByZXF1aXJlKFwiLi4vZmlsdGVycy9GaWx0ZXIuanNcIik7XG5jbGFzcyBNYXNrRGF0YSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgTWFza0RhdGFcbiAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IFttYXNrT2JqZWN0PW51bGxdIC0gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBtYXNrXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYXNrT2JqZWN0ID0gbnVsbCkge1xuICAgIHRoaXMudHlwZSA9IGNvbnN0YW50cy5NQVNLX1RZUEVTLk5PTkUsIHRoaXMuYXV0b0RldGVjdCA9ICEwLCB0aGlzLm1hc2tPYmplY3QgPSBtYXNrT2JqZWN0IHx8IG51bGwsIHRoaXMucG9vbGVkID0gITEsIHRoaXMuaXNNYXNrRGF0YSA9ICEwLCB0aGlzLnJlc29sdXRpb24gPSBudWxsLCB0aGlzLm11bHRpc2FtcGxlID0gRmlsdGVyLkZpbHRlci5kZWZhdWx0TXVsdGlzYW1wbGUsIHRoaXMuZW5hYmxlZCA9ICEwLCB0aGlzLmNvbG9yTWFzayA9IDE1LCB0aGlzLl9maWx0ZXJzID0gbnVsbCwgdGhpcy5fc3RlbmNpbENvdW50ZXIgPSAwLCB0aGlzLl9zY2lzc29yQ291bnRlciA9IDAsIHRoaXMuX3NjaXNzb3JSZWN0ID0gbnVsbCwgdGhpcy5fc2Npc3NvclJlY3RMb2NhbCA9IG51bGwsIHRoaXMuX2NvbG9yTWFzayA9IDE1LCB0aGlzLl90YXJnZXQgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3ByaXRlIG1hc2sgZmlsdGVyLlxuICAgKiBJZiBzZXQgdG8gYG51bGxgLCB0aGUgZGVmYXVsdCBzcHJpdGUgbWFzayBmaWx0ZXIgaXMgdXNlZC5cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cbiAgZ2V0IGZpbHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsdGVycyA/IHRoaXMuX2ZpbHRlcnNbMF0gOiBudWxsO1xuICB9XG4gIHNldCBmaWx0ZXIodmFsdWUpIHtcbiAgICB2YWx1ZSA/IHRoaXMuX2ZpbHRlcnMgPyB0aGlzLl9maWx0ZXJzWzBdID0gdmFsdWUgOiB0aGlzLl9maWx0ZXJzID0gW3ZhbHVlXSA6IHRoaXMuX2ZpbHRlcnMgPSBudWxsO1xuICB9XG4gIC8qKiBSZXNldHMgdGhlIG1hc2sgZGF0YSBhZnRlciBwb3BNYXNrKCkuICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMucG9vbGVkICYmICh0aGlzLm1hc2tPYmplY3QgPSBudWxsLCB0aGlzLnR5cGUgPSBjb25zdGFudHMuTUFTS19UWVBFUy5OT05FLCB0aGlzLmF1dG9EZXRlY3QgPSAhMCksIHRoaXMuX3RhcmdldCA9IG51bGwsIHRoaXMuX3NjaXNzb3JSZWN0TG9jYWwgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgY291bnRlcnMgZnJvbSBtYXNrRGF0YSBhYm92ZSwgY2FsbGVkIGZyb20gcHVzaE1hc2soKS5cbiAgICogQHBhcmFtIG1hc2tBYm92ZVxuICAgKi9cbiAgY29weUNvdW50ZXJzT3JSZXNldChtYXNrQWJvdmUpIHtcbiAgICBtYXNrQWJvdmUgPyAodGhpcy5fc3RlbmNpbENvdW50ZXIgPSBtYXNrQWJvdmUuX3N0ZW5jaWxDb3VudGVyLCB0aGlzLl9zY2lzc29yQ291bnRlciA9IG1hc2tBYm92ZS5fc2Npc3NvckNvdW50ZXIsIHRoaXMuX3NjaXNzb3JSZWN0ID0gbWFza0Fib3ZlLl9zY2lzc29yUmVjdCkgOiAodGhpcy5fc3RlbmNpbENvdW50ZXIgPSAwLCB0aGlzLl9zY2lzc29yQ291bnRlciA9IDAsIHRoaXMuX3NjaXNzb3JSZWN0ID0gbnVsbCk7XG4gIH1cbn1cbmV4cG9ydHMuTWFza0RhdGEgPSBNYXNrRGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hc2tEYXRhLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKSwgZXh0ZW5zaW9ucyA9IHJlcXVpcmUoXCJAcGl4aS9leHRlbnNpb25zXCIpLCBTcHJpdGVNYXNrRmlsdGVyID0gcmVxdWlyZShcIi4uL2ZpbHRlcnMvc3ByaXRlTWFzay9TcHJpdGVNYXNrRmlsdGVyLmpzXCIpLCBNYXNrRGF0YSA9IHJlcXVpcmUoXCIuL01hc2tEYXRhLmpzXCIpO1xuY2xhc3MgTWFza1N5c3RlbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBTeXN0ZW0gd29ya3MgZm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIsIHRoaXMuZW5hYmxlU2Npc3NvciA9ICEwLCB0aGlzLmFscGhhTWFza1Bvb2wgPSBbXSwgdGhpcy5tYXNrRGF0YVBvb2wgPSBbXSwgdGhpcy5tYXNrU3RhY2sgPSBbXSwgdGhpcy5hbHBoYU1hc2tJbmRleCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIG1hc2sgc3RhY2sgdGhhdCBpcyB1c2VkIGJ5IHRoaXMgU3lzdGVtLlxuICAgKiBAcGFyYW0gbWFza1N0YWNrIC0gVGhlIG1hc2sgc3RhY2tcbiAgICovXG4gIHNldE1hc2tTdGFjayhtYXNrU3RhY2spIHtcbiAgICB0aGlzLm1hc2tTdGFjayA9IG1hc2tTdGFjaywgdGhpcy5yZW5kZXJlci5zY2lzc29yLnNldE1hc2tTdGFjayhtYXNrU3RhY2spLCB0aGlzLnJlbmRlcmVyLnN0ZW5jaWwuc2V0TWFza1N0YWNrKG1hc2tTdGFjayk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgdGhlIG1hc2sgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIGN1cnJlbnQgbWFzayBzdGFjay5cbiAgICpcbiAgICogTk9URTogVGhlIGJhdGNoIHJlbmRlcmVyIHNob3VsZCBiZSBmbHVzaGVkIGJlZm9yZWhhbmQgdG8gcHJldmVudCBwZW5kaW5nIHJlbmRlcnMgZnJvbSBiZWluZyBtYXNrZWQuXG4gICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSB0YXJnZXQgLSBEaXNwbGF5IE9iamVjdCB0byBwdXNoIHRoZSBtYXNrIHRvXG4gICAqIEBwYXJhbSB7UElYSS5NYXNrRGF0YXxQSVhJLlNwcml0ZXxQSVhJLkdyYXBoaWNzfFBJWEkuRGlzcGxheU9iamVjdH0gbWFza0RhdGFPclRhcmdldCAtIFRoZSBtYXNraW5nIGRhdGEuXG4gICAqL1xuICBwdXNoKHRhcmdldCwgbWFza0RhdGFPclRhcmdldCkge1xuICAgIGxldCBtYXNrRGF0YSA9IG1hc2tEYXRhT3JUYXJnZXQ7XG4gICAgaWYgKCFtYXNrRGF0YS5pc01hc2tEYXRhKSB7XG4gICAgICBjb25zdCBkID0gdGhpcy5tYXNrRGF0YVBvb2wucG9wKCkgfHwgbmV3IE1hc2tEYXRhLk1hc2tEYXRhKCk7XG4gICAgICBkLnBvb2xlZCA9ICEwLCBkLm1hc2tPYmplY3QgPSBtYXNrRGF0YU9yVGFyZ2V0LCBtYXNrRGF0YSA9IGQ7XG4gICAgfVxuICAgIGNvbnN0IG1hc2tBYm92ZSA9IHRoaXMubWFza1N0YWNrLmxlbmd0aCAhPT0gMCA/IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICBpZiAobWFza0RhdGEuY29weUNvdW50ZXJzT3JSZXNldChtYXNrQWJvdmUpLCBtYXNrRGF0YS5fY29sb3JNYXNrID0gbWFza0Fib3ZlID8gbWFza0Fib3ZlLl9jb2xvck1hc2sgOiAxNSwgbWFza0RhdGEuYXV0b0RldGVjdCAmJiB0aGlzLmRldGVjdChtYXNrRGF0YSksIG1hc2tEYXRhLl90YXJnZXQgPSB0YXJnZXQsIG1hc2tEYXRhLnR5cGUgIT09IGNvbnN0YW50cy5NQVNLX1RZUEVTLlNQUklURSAmJiB0aGlzLm1hc2tTdGFjay5wdXNoKG1hc2tEYXRhKSwgbWFza0RhdGEuZW5hYmxlZClcbiAgICAgIHN3aXRjaCAobWFza0RhdGEudHlwZSkge1xuICAgICAgICBjYXNlIGNvbnN0YW50cy5NQVNLX1RZUEVTLlNDSVNTT1I6XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zY2lzc29yLnB1c2gobWFza0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGNvbnN0YW50cy5NQVNLX1RZUEVTLlNURU5DSUw6XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsLnB1c2gobWFza0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGNvbnN0YW50cy5NQVNLX1RZUEVTLlNQUklURTpcbiAgICAgICAgICBtYXNrRGF0YS5jb3B5Q291bnRlcnNPclJlc2V0KG51bGwpLCB0aGlzLnB1c2hTcHJpdGVNYXNrKG1hc2tEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBjb25zdGFudHMuTUFTS19UWVBFUy5DT0xPUjpcbiAgICAgICAgICB0aGlzLnB1c2hDb2xvck1hc2sobWFza0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIG1hc2tEYXRhLnR5cGUgPT09IGNvbnN0YW50cy5NQVNLX1RZUEVTLlNQUklURSAmJiB0aGlzLm1hc2tTdGFjay5wdXNoKG1hc2tEYXRhKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgbGFzdCBtYXNrIGZyb20gdGhlIG1hc2sgc3RhY2sgYW5kIGRvZXNuJ3QgcmV0dXJuIGl0LlxuICAgKlxuICAgKiBOT1RFOiBUaGUgYmF0Y2ggcmVuZGVyZXIgc2hvdWxkIGJlIGZsdXNoZWQgYmVmb3JlaGFuZCB0byByZW5kZXIgdGhlIG1hc2tlZCBjb250ZW50cyBiZWZvcmUgdGhlIG1hc2sgaXMgcmVtb3ZlZC5cbiAgICogQHBhcmFtIHtQSVhJLklNYXNrVGFyZ2V0fSB0YXJnZXQgLSBEaXNwbGF5IE9iamVjdCB0byBwb3AgdGhlIG1hc2sgZnJvbVxuICAgKi9cbiAgcG9wKHRhcmdldCkge1xuICAgIGNvbnN0IG1hc2tEYXRhID0gdGhpcy5tYXNrU3RhY2sucG9wKCk7XG4gICAgaWYgKCEoIW1hc2tEYXRhIHx8IG1hc2tEYXRhLl90YXJnZXQgIT09IHRhcmdldCkpIHtcbiAgICAgIGlmIChtYXNrRGF0YS5lbmFibGVkKVxuICAgICAgICBzd2l0Y2ggKG1hc2tEYXRhLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIGNvbnN0YW50cy5NQVNLX1RZUEVTLlNDSVNTT1I6XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjaXNzb3IucG9wKG1hc2tEYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgY29uc3RhbnRzLk1BU0tfVFlQRVMuU1RFTkNJTDpcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc3RlbmNpbC5wb3AobWFza0RhdGEubWFza09iamVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGNvbnN0YW50cy5NQVNLX1RZUEVTLlNQUklURTpcbiAgICAgICAgICAgIHRoaXMucG9wU3ByaXRlTWFzayhtYXNrRGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGNvbnN0YW50cy5NQVNLX1RZUEVTLkNPTE9SOlxuICAgICAgICAgICAgdGhpcy5wb3BDb2xvck1hc2sobWFza0RhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBpZiAobWFza0RhdGEucmVzZXQoKSwgbWFza0RhdGEucG9vbGVkICYmIHRoaXMubWFza0RhdGFQb29sLnB1c2gobWFza0RhdGEpLCB0aGlzLm1hc2tTdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc3QgbWFza0N1cnJlbnQgPSB0aGlzLm1hc2tTdGFja1t0aGlzLm1hc2tTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgbWFza0N1cnJlbnQudHlwZSA9PT0gY29uc3RhbnRzLk1BU0tfVFlQRVMuU1BSSVRFICYmIG1hc2tDdXJyZW50Ll9maWx0ZXJzICYmIChtYXNrQ3VycmVudC5fZmlsdGVyc1swXS5tYXNrU3ByaXRlID0gbWFza0N1cnJlbnQubWFza09iamVjdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHR5cGUgb2YgTWFza0RhdGEgYmFzZWQgb24gaXRzIG1hc2tPYmplY3QuXG4gICAqIEBwYXJhbSBtYXNrRGF0YVxuICAgKi9cbiAgZGV0ZWN0KG1hc2tEYXRhKSB7XG4gICAgY29uc3QgbWFza09iamVjdCA9IG1hc2tEYXRhLm1hc2tPYmplY3Q7XG4gICAgbWFza09iamVjdCA/IG1hc2tPYmplY3QuaXNTcHJpdGUgPyBtYXNrRGF0YS50eXBlID0gY29uc3RhbnRzLk1BU0tfVFlQRVMuU1BSSVRFIDogdGhpcy5lbmFibGVTY2lzc29yICYmIHRoaXMucmVuZGVyZXIuc2Npc3Nvci50ZXN0U2Npc3NvcihtYXNrRGF0YSkgPyBtYXNrRGF0YS50eXBlID0gY29uc3RhbnRzLk1BU0tfVFlQRVMuU0NJU1NPUiA6IG1hc2tEYXRhLnR5cGUgPSBjb25zdGFudHMuTUFTS19UWVBFUy5TVEVOQ0lMIDogbWFza0RhdGEudHlwZSA9IGNvbnN0YW50cy5NQVNLX1RZUEVTLkNPTE9SO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFjay5cbiAgICogQHBhcmFtIG1hc2tEYXRhIC0gU3ByaXRlIHRvIGJlIHVzZWQgYXMgdGhlIG1hc2suXG4gICAqL1xuICBwdXNoU3ByaXRlTWFzayhtYXNrRGF0YSkge1xuICAgIGNvbnN0IHsgbWFza09iamVjdCB9ID0gbWFza0RhdGEsIHRhcmdldCA9IG1hc2tEYXRhLl90YXJnZXQ7XG4gICAgbGV0IGFscGhhTWFza0ZpbHRlciA9IG1hc2tEYXRhLl9maWx0ZXJzO1xuICAgIGFscGhhTWFza0ZpbHRlciB8fCAoYWxwaGFNYXNrRmlsdGVyID0gdGhpcy5hbHBoYU1hc2tQb29sW3RoaXMuYWxwaGFNYXNrSW5kZXhdLCBhbHBoYU1hc2tGaWx0ZXIgfHwgKGFscGhhTWFza0ZpbHRlciA9IHRoaXMuYWxwaGFNYXNrUG9vbFt0aGlzLmFscGhhTWFza0luZGV4XSA9IFtuZXcgU3ByaXRlTWFza0ZpbHRlci5TcHJpdGVNYXNrRmlsdGVyKCldKSksIGFscGhhTWFza0ZpbHRlclswXS5yZXNvbHV0aW9uID0gbWFza0RhdGEucmVzb2x1dGlvbiwgYWxwaGFNYXNrRmlsdGVyWzBdLm11bHRpc2FtcGxlID0gbWFza0RhdGEubXVsdGlzYW1wbGUsIGFscGhhTWFza0ZpbHRlclswXS5tYXNrU3ByaXRlID0gbWFza09iamVjdDtcbiAgICBjb25zdCBzdGFzaEZpbHRlckFyZWEgPSB0YXJnZXQuZmlsdGVyQXJlYTtcbiAgICB0YXJnZXQuZmlsdGVyQXJlYSA9IG1hc2tPYmplY3QuZ2V0Qm91bmRzKCEwKSwgdGhpcy5yZW5kZXJlci5maWx0ZXIucHVzaCh0YXJnZXQsIGFscGhhTWFza0ZpbHRlciksIHRhcmdldC5maWx0ZXJBcmVhID0gc3Rhc2hGaWx0ZXJBcmVhLCBtYXNrRGF0YS5fZmlsdGVycyB8fCB0aGlzLmFscGhhTWFza0luZGV4Kys7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGxhc3QgZmlsdGVyIGZyb20gdGhlIGZpbHRlciBzdGFjayBhbmQgZG9lc24ndCByZXR1cm4gaXQuXG4gICAqIEBwYXJhbSBtYXNrRGF0YSAtIFNwcml0ZSB0byBiZSB1c2VkIGFzIHRoZSBtYXNrLlxuICAgKi9cbiAgcG9wU3ByaXRlTWFzayhtYXNrRGF0YSkge1xuICAgIHRoaXMucmVuZGVyZXIuZmlsdGVyLnBvcCgpLCBtYXNrRGF0YS5fZmlsdGVycyA/IG1hc2tEYXRhLl9maWx0ZXJzWzBdLm1hc2tTcHJpdGUgPSBudWxsIDogKHRoaXMuYWxwaGFNYXNrSW5kZXgtLSwgdGhpcy5hbHBoYU1hc2tQb29sW3RoaXMuYWxwaGFNYXNrSW5kZXhdWzBdLm1hc2tTcHJpdGUgPSBudWxsKTtcbiAgfVxuICAvKipcbiAgICogUHVzaGVzIHRoZSBjb2xvciBtYXNrLlxuICAgKiBAcGFyYW0gbWFza0RhdGEgLSBUaGUgbWFzayBkYXRhXG4gICAqL1xuICBwdXNoQ29sb3JNYXNrKG1hc2tEYXRhKSB7XG4gICAgY29uc3QgY3VyckNvbG9yTWFzayA9IG1hc2tEYXRhLl9jb2xvck1hc2ssIG5leHRDb2xvck1hc2sgPSBtYXNrRGF0YS5fY29sb3JNYXNrID0gY3VyckNvbG9yTWFzayAmIG1hc2tEYXRhLmNvbG9yTWFzaztcbiAgICBuZXh0Q29sb3JNYXNrICE9PSBjdXJyQ29sb3JNYXNrICYmIHRoaXMucmVuZGVyZXIuZ2wuY29sb3JNYXNrKFxuICAgICAgKG5leHRDb2xvck1hc2sgJiAxKSAhPT0gMCxcbiAgICAgIChuZXh0Q29sb3JNYXNrICYgMikgIT09IDAsXG4gICAgICAobmV4dENvbG9yTWFzayAmIDQpICE9PSAwLFxuICAgICAgKG5leHRDb2xvck1hc2sgJiA4KSAhPT0gMFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFBvcHMgdGhlIGNvbG9yIG1hc2suXG4gICAqIEBwYXJhbSBtYXNrRGF0YSAtIFRoZSBtYXNrIGRhdGFcbiAgICovXG4gIHBvcENvbG9yTWFzayhtYXNrRGF0YSkge1xuICAgIGNvbnN0IGN1cnJDb2xvck1hc2sgPSBtYXNrRGF0YS5fY29sb3JNYXNrLCBuZXh0Q29sb3JNYXNrID0gdGhpcy5tYXNrU3RhY2subGVuZ3RoID4gMCA/IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdLl9jb2xvck1hc2sgOiAxNTtcbiAgICBuZXh0Q29sb3JNYXNrICE9PSBjdXJyQ29sb3JNYXNrICYmIHRoaXMucmVuZGVyZXIuZ2wuY29sb3JNYXNrKFxuICAgICAgKG5leHRDb2xvck1hc2sgJiAxKSAhPT0gMCxcbiAgICAgIChuZXh0Q29sb3JNYXNrICYgMikgIT09IDAsXG4gICAgICAobmV4dENvbG9yTWFzayAmIDQpICE9PSAwLFxuICAgICAgKG5leHRDb2xvck1hc2sgJiA4KSAhPT0gMFxuICAgICk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuTWFza1N5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJtYXNrXCJcbn07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKE1hc2tTeXN0ZW0pO1xuZXhwb3J0cy5NYXNrU3lzdGVtID0gTWFza1N5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hc2tTeXN0ZW0uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBleHRlbnNpb25zID0gcmVxdWlyZShcIkBwaXhpL2V4dGVuc2lvbnNcIiksIG1hdGggPSByZXF1aXJlKFwiQHBpeGkvbWF0aFwiKSwgc2V0dGluZ3MgPSByZXF1aXJlKFwiQHBpeGkvc2V0dGluZ3NcIiksIEFic3RyYWN0TWFza1N5c3RlbSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0TWFza1N5c3RlbS5qc1wiKTtcbmNvbnN0IHRlbXBNYXRyaXggPSBuZXcgbWF0aC5NYXRyaXgoKSwgcmVjdFBvb2wgPSBbXSwgX1NjaXNzb3JTeXN0ZW0gPSBjbGFzcyBfU2Npc3NvclN5c3RlbTIgZXh0ZW5kcyBBYnN0cmFjdE1hc2tTeXN0ZW0uQWJzdHJhY3RNYXNrU3lzdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBTeXN0ZW0gd29ya3MgZm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICBzdXBlcihyZW5kZXJlciksIHRoaXMuZ2xDb25zdCA9IHNldHRpbmdzLnNldHRpbmdzLkFEQVBURVIuZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KCkuU0NJU1NPUl9URVNUO1xuICB9XG4gIGdldFN0YWNrTGVuZ3RoKCkge1xuICAgIGNvbnN0IG1hc2tEYXRhID0gdGhpcy5tYXNrU3RhY2tbdGhpcy5tYXNrU3RhY2subGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIG1hc2tEYXRhID8gbWFza0RhdGEuX3NjaXNzb3JDb3VudGVyIDogMDtcbiAgfVxuICAvKipcbiAgICogZXZhbHVhdGVzIF9ib3VuZHNUcmFuc2Zvcm1lZCwgX3NjaXNzb3JSZWN0IGZvciBNYXNrRGF0YVxuICAgKiBAcGFyYW0gbWFza0RhdGFcbiAgICovXG4gIGNhbGNTY2lzc29yUmVjdChtYXNrRGF0YSkge1xuICAgIGlmIChtYXNrRGF0YS5fc2Npc3NvclJlY3RMb2NhbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBwcmV2RGF0YSA9IG1hc2tEYXRhLl9zY2lzc29yUmVjdCwgeyBtYXNrT2JqZWN0IH0gPSBtYXNrRGF0YSwgeyByZW5kZXJlciB9ID0gdGhpcywgcmVuZGVyVGV4dHVyZVN5c3RlbSA9IHJlbmRlcmVyLnJlbmRlclRleHR1cmUsIHJlY3QgPSBtYXNrT2JqZWN0LmdldEJvdW5kcyghMCwgcmVjdFBvb2wucG9wKCkgPz8gbmV3IG1hdGguUmVjdGFuZ2xlKCkpO1xuICAgIHRoaXMucm91bmRGcmFtZVRvUGl4ZWxzKFxuICAgICAgcmVjdCxcbiAgICAgIHJlbmRlclRleHR1cmVTeXN0ZW0uY3VycmVudCA/IHJlbmRlclRleHR1cmVTeXN0ZW0uY3VycmVudC5yZXNvbHV0aW9uIDogcmVuZGVyZXIucmVzb2x1dGlvbixcbiAgICAgIHJlbmRlclRleHR1cmVTeXN0ZW0uc291cmNlRnJhbWUsXG4gICAgICByZW5kZXJUZXh0dXJlU3lzdGVtLmRlc3RpbmF0aW9uRnJhbWUsXG4gICAgICByZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybVxuICAgICksIHByZXZEYXRhICYmIHJlY3QuZml0KHByZXZEYXRhKSwgbWFza0RhdGEuX3NjaXNzb3JSZWN0TG9jYWwgPSByZWN0O1xuICB9XG4gIHN0YXRpYyBpc01hdHJpeFJvdGF0ZWQobWF0cml4KSB7XG4gICAgaWYgKCFtYXRyaXgpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgeyBhLCBiLCBjLCBkIH0gPSBtYXRyaXg7XG4gICAgcmV0dXJuIChNYXRoLmFicyhiKSA+IDFlLTQgfHwgTWF0aC5hYnMoYykgPiAxZS00KSAmJiAoTWF0aC5hYnMoYSkgPiAxZS00IHx8IE1hdGguYWJzKGQpID4gMWUtNCk7XG4gIH1cbiAgLyoqXG4gICAqIFRlc3QsIHdoZXRoZXIgdGhlIG9iamVjdCBjYW4gYmUgc2Npc3NvciBtYXNrIHdpdGggY3VycmVudCByZW5kZXJlciBwcm9qZWN0aW9uLlxuICAgKiBDYWxscyBcImNhbGNTY2lzc29yUmVjdCgpXCIgaWYgaXRzIHRydWUuXG4gICAqIEBwYXJhbSBtYXNrRGF0YSAtIG1hc2sgZGF0YVxuICAgKiBAcmV0dXJucyB3aGV0aGVyIFdoZXRoZXIgdGhlIG9iamVjdCBjYW4gYmUgc2Npc3NvciBtYXNrXG4gICAqL1xuICB0ZXN0U2Npc3NvcihtYXNrRGF0YSkge1xuICAgIGNvbnN0IHsgbWFza09iamVjdCB9ID0gbWFza0RhdGE7XG4gICAgaWYgKCFtYXNrT2JqZWN0LmlzRmFzdFJlY3QgfHwgIW1hc2tPYmplY3QuaXNGYXN0UmVjdCgpIHx8IF9TY2lzc29yU3lzdGVtMi5pc01hdHJpeFJvdGF0ZWQobWFza09iamVjdC53b3JsZFRyYW5zZm9ybSkgfHwgX1NjaXNzb3JTeXN0ZW0yLmlzTWF0cml4Um90YXRlZCh0aGlzLnJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICB0aGlzLmNhbGNTY2lzc29yUmVjdChtYXNrRGF0YSk7XG4gICAgY29uc3QgcmVjdCA9IG1hc2tEYXRhLl9zY2lzc29yUmVjdExvY2FsO1xuICAgIHJldHVybiByZWN0LndpZHRoID4gMCAmJiByZWN0LmhlaWdodCA+IDA7XG4gIH1cbiAgcm91bmRGcmFtZVRvUGl4ZWxzKGZyYW1lLCByZXNvbHV0aW9uLCBiaW5kaW5nU291cmNlRnJhbWUsIGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLCB0cmFuc2Zvcm0pIHtcbiAgICBfU2Npc3NvclN5c3RlbTIuaXNNYXRyaXhSb3RhdGVkKHRyYW5zZm9ybSkgfHwgKHRyYW5zZm9ybSA9IHRyYW5zZm9ybSA/IHRlbXBNYXRyaXguY29weUZyb20odHJhbnNmb3JtKSA6IHRlbXBNYXRyaXguaWRlbnRpdHkoKSwgdHJhbnNmb3JtLnRyYW5zbGF0ZSgtYmluZGluZ1NvdXJjZUZyYW1lLngsIC1iaW5kaW5nU291cmNlRnJhbWUueSkuc2NhbGUoXG4gICAgICBiaW5kaW5nRGVzdGluYXRpb25GcmFtZS53aWR0aCAvIGJpbmRpbmdTb3VyY2VGcmFtZS53aWR0aCxcbiAgICAgIGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAvIGJpbmRpbmdTb3VyY2VGcmFtZS5oZWlnaHRcbiAgICApLnRyYW5zbGF0ZShiaW5kaW5nRGVzdGluYXRpb25GcmFtZS54LCBiaW5kaW5nRGVzdGluYXRpb25GcmFtZS55KSwgdGhpcy5yZW5kZXJlci5maWx0ZXIudHJhbnNmb3JtQUFCQih0cmFuc2Zvcm0sIGZyYW1lKSwgZnJhbWUuZml0KGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lKSwgZnJhbWUueCA9IE1hdGgucm91bmQoZnJhbWUueCAqIHJlc29sdXRpb24pLCBmcmFtZS55ID0gTWF0aC5yb3VuZChmcmFtZS55ICogcmVzb2x1dGlvbiksIGZyYW1lLndpZHRoID0gTWF0aC5yb3VuZChmcmFtZS53aWR0aCAqIHJlc29sdXRpb24pLCBmcmFtZS5oZWlnaHQgPSBNYXRoLnJvdW5kKGZyYW1lLmhlaWdodCAqIHJlc29sdXRpb24pKTtcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBzdGVuY2lsIHN0YWNrLlxuICAgKiBAYXV0aG9yIGFsdmluXG4gICAqIEBwYXJhbSBtYXNrRGF0YSAtIFRoZSBtYXNrIGRhdGEuXG4gICAqL1xuICBwdXNoKG1hc2tEYXRhKSB7XG4gICAgbWFza0RhdGEuX3NjaXNzb3JSZWN0TG9jYWwgfHwgdGhpcy5jYWxjU2Npc3NvclJlY3QobWFza0RhdGEpO1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMucmVuZGVyZXI7XG4gICAgbWFza0RhdGEuX3NjaXNzb3JSZWN0IHx8IGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpLCBtYXNrRGF0YS5fc2Npc3NvckNvdW50ZXIrKywgbWFza0RhdGEuX3NjaXNzb3JSZWN0ID0gbWFza0RhdGEuX3NjaXNzb3JSZWN0TG9jYWwsIHRoaXMuX3VzZUN1cnJlbnQoKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGEgbWFzayBpcyBwb3BwZWQgb2ZmIHRoZSBtYXNrIHN0YWNrLiBJdCB3aWxsIHJlYmluZCB0aGUgc2Npc3NvciBib3ggdG8gYmUgbGF0ZXN0IHdpdGggdGhlXG4gICAqIGxhc3QgbWFzayBpbiB0aGUgc3RhY2suXG4gICAqXG4gICAqIFRoaXMgY2FuIGFsc28gYmUgY2FsbGVkIHdoZW4geW91IGRpcmVjdGx5IG1vZGlmeSB0aGUgc2Npc3NvciBib3ggYW5kIHdhbnQgdG8gcmVzdG9yZSBQaXhpSlMgc3RhdGUuXG4gICAqIEBwYXJhbSBtYXNrRGF0YSAtIFRoZSBtYXNrIGRhdGEuXG4gICAqL1xuICBwb3AobWFza0RhdGEpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIG1hc2tEYXRhICYmIHJlY3RQb29sLnB1c2gobWFza0RhdGEuX3NjaXNzb3JSZWN0TG9jYWwpLCB0aGlzLmdldFN0YWNrTGVuZ3RoKCkgPiAwID8gdGhpcy5fdXNlQ3VycmVudCgpIDogZ2wuZGlzYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR1cCByZW5kZXJlciB0byB1c2UgdGhlIGN1cnJlbnQgc2Npc3NvciBkYXRhLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VzZUN1cnJlbnQoKSB7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdLl9zY2lzc29yUmVjdDtcbiAgICBsZXQgeTtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlclRleHR1cmUuY3VycmVudCA/IHkgPSByZWN0LnkgOiB5ID0gdGhpcy5yZW5kZXJlci5oZWlnaHQgLSByZWN0LmhlaWdodCAtIHJlY3QueSwgdGhpcy5yZW5kZXJlci5nbC5zY2lzc29yKHJlY3QueCwgeSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICB9XG59O1xuX1NjaXNzb3JTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwic2Npc3NvclwiXG59O1xubGV0IFNjaXNzb3JTeXN0ZW0gPSBfU2Npc3NvclN5c3RlbTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5hZGQoU2Npc3NvclN5c3RlbSk7XG5leHBvcnRzLlNjaXNzb3JTeXN0ZW0gPSBTY2lzc29yU3lzdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2Npc3NvclN5c3RlbS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4dGVuc2lvbnMgPSByZXF1aXJlKFwiQHBpeGkvZXh0ZW5zaW9uc1wiKSwgc2V0dGluZ3MgPSByZXF1aXJlKFwiQHBpeGkvc2V0dGluZ3NcIiksIEFic3RyYWN0TWFza1N5c3RlbSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0TWFza1N5c3RlbS5qc1wiKTtcbmNsYXNzIFN0ZW5jaWxTeXN0ZW0gZXh0ZW5kcyBBYnN0cmFjdE1hc2tTeXN0ZW0uQWJzdHJhY3RNYXNrU3lzdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIFN5c3RlbSB3b3JrcyBmb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKSwgdGhpcy5nbENvbnN0ID0gc2V0dGluZ3Muc2V0dGluZ3MuQURBUFRFUi5nZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQoKS5TVEVOQ0lMX1RFU1Q7XG4gIH1cbiAgZ2V0U3RhY2tMZW5ndGgoKSB7XG4gICAgY29uc3QgbWFza0RhdGEgPSB0aGlzLm1hc2tTdGFja1t0aGlzLm1hc2tTdGFjay5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gbWFza0RhdGEgPyBtYXNrRGF0YS5fc3RlbmNpbENvdW50ZXIgOiAwO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IHN0ZW5jaWwgc3RhY2suXG4gICAqIEBwYXJhbSBtYXNrRGF0YSAtIFRoZSBtYXNrIGRhdGFcbiAgICovXG4gIHB1c2gobWFza0RhdGEpIHtcbiAgICBjb25zdCBtYXNrT2JqZWN0ID0gbWFza0RhdGEubWFza09iamVjdCwgeyBnbCB9ID0gdGhpcy5yZW5kZXJlciwgcHJldk1hc2tDb3VudCA9IG1hc2tEYXRhLl9zdGVuY2lsQ291bnRlcjtcbiAgICBwcmV2TWFza0NvdW50ID09PSAwICYmICh0aGlzLnJlbmRlcmVyLmZyYW1lYnVmZmVyLmZvcmNlU3RlbmNpbCgpLCBnbC5jbGVhclN0ZW5jaWwoMCksIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCksIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpKSwgbWFza0RhdGEuX3N0ZW5jaWxDb3VudGVyKys7XG4gICAgY29uc3QgY29sb3JNYXNrID0gbWFza0RhdGEuX2NvbG9yTWFzaztcbiAgICBjb2xvck1hc2sgIT09IDAgJiYgKG1hc2tEYXRhLl9jb2xvck1hc2sgPSAwLCBnbC5jb2xvck1hc2soITEsICExLCAhMSwgITEpKSwgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIHByZXZNYXNrQ291bnQsIDQyOTQ5NjcyOTUpLCBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuSU5DUiksIG1hc2tPYmplY3QucmVuZGVyYWJsZSA9ICEwLCBtYXNrT2JqZWN0LnJlbmRlcih0aGlzLnJlbmRlcmVyKSwgdGhpcy5yZW5kZXJlci5iYXRjaC5mbHVzaCgpLCBtYXNrT2JqZWN0LnJlbmRlcmFibGUgPSAhMSwgY29sb3JNYXNrICE9PSAwICYmIChtYXNrRGF0YS5fY29sb3JNYXNrID0gY29sb3JNYXNrLCBnbC5jb2xvck1hc2soXG4gICAgICAoY29sb3JNYXNrICYgMSkgIT09IDAsXG4gICAgICAoY29sb3JNYXNrICYgMikgIT09IDAsXG4gICAgICAoY29sb3JNYXNrICYgNCkgIT09IDAsXG4gICAgICAoY29sb3JNYXNrICYgOCkgIT09IDBcbiAgICApKSwgdGhpcy5fdXNlQ3VycmVudCgpO1xuICB9XG4gIC8qKlxuICAgKiBQb3BzIHN0ZW5jaWwgbWFzay4gTWFza0RhdGEgaXMgYWxyZWFkeSByZW1vdmVkIGZyb20gc3RhY2tcbiAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IG1hc2tPYmplY3QgLSBvYmplY3Qgb2YgcG9wcGVkIG1hc2sgZGF0YVxuICAgKi9cbiAgcG9wKG1hc2tPYmplY3QpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgaWYgKHRoaXMuZ2V0U3RhY2tMZW5ndGgoKSA9PT0gMClcbiAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG1hc2tEYXRhID0gdGhpcy5tYXNrU3RhY2subGVuZ3RoICE9PSAwID8gdGhpcy5tYXNrU3RhY2tbdGhpcy5tYXNrU3RhY2subGVuZ3RoIC0gMV0gOiBudWxsLCBjb2xvck1hc2sgPSBtYXNrRGF0YSA/IG1hc2tEYXRhLl9jb2xvck1hc2sgOiAxNTtcbiAgICAgIGNvbG9yTWFzayAhPT0gMCAmJiAobWFza0RhdGEuX2NvbG9yTWFzayA9IDAsIGdsLmNvbG9yTWFzayghMSwgITEsICExLCAhMSkpLCBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuREVDUiksIG1hc2tPYmplY3QucmVuZGVyYWJsZSA9ICEwLCBtYXNrT2JqZWN0LnJlbmRlcih0aGlzLnJlbmRlcmVyKSwgdGhpcy5yZW5kZXJlci5iYXRjaC5mbHVzaCgpLCBtYXNrT2JqZWN0LnJlbmRlcmFibGUgPSAhMSwgY29sb3JNYXNrICE9PSAwICYmIChtYXNrRGF0YS5fY29sb3JNYXNrID0gY29sb3JNYXNrLCBnbC5jb2xvck1hc2soXG4gICAgICAgIChjb2xvck1hc2sgJiAxKSAhPT0gMCxcbiAgICAgICAgKGNvbG9yTWFzayAmIDIpICE9PSAwLFxuICAgICAgICAoY29sb3JNYXNrICYgNCkgIT09IDAsXG4gICAgICAgIChjb2xvck1hc2sgJiA4KSAhPT0gMFxuICAgICAgKSksIHRoaXMuX3VzZUN1cnJlbnQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHVwIHJlbmRlcmVyIHRvIHVzZSB0aGUgY3VycmVudCBzdGVuY2lsIGRhdGEuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXNlQ3VycmVudCgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIHRoaXMuZ2V0U3RhY2tMZW5ndGgoKSwgNDI5NDk2NzI5NSksIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5LRUVQKTtcbiAgfVxufVxuU3RlbmNpbFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJzdGVuY2lsXCJcbn07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKFN0ZW5jaWxTeXN0ZW0pO1xuZXhwb3J0cy5TdGVuY2lsU3lzdGVtID0gU3RlbmNpbFN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0ZW5jaWxTeXN0ZW0uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBleHRlbnNpb25zID0gcmVxdWlyZShcIkBwaXhpL2V4dGVuc2lvbnNcIiksIHV0aWxzID0gcmVxdWlyZShcIkBwaXhpL3V0aWxzXCIpO1xuY2xhc3MgUGx1Z2luU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIsIHRoaXMucGx1Z2lucyA9IHt9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLnBsdWdpbnMsIHtcbiAgICAgIGV4dHJhY3Q6IHtcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbHMuZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLnBsdWdpbnMuZXh0cmFjdCBoYXMgbW92ZWQgdG8gcmVuZGVyZXIuZXh0cmFjdFwiKSwgcmVuZGVyZXIuZXh0cmFjdDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByZXBhcmU6IHtcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbHMuZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLnBsdWdpbnMucHJlcGFyZSBoYXMgbW92ZWQgdG8gcmVuZGVyZXIucHJlcGFyZVwiKSwgcmVuZGVyZXIucHJlcGFyZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGludGVyYWN0aW9uOiB7XG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSByZW5kZXJlci5ldmVudHNcIiksIHJlbmRlcmVyLmV2ZW50cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBwbHVnaW5zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBpbml0KCkge1xuICAgIGNvbnN0IHN0YXRpY01hcCA9IHRoaXMucmVuZGVyZXJQbHVnaW5zO1xuICAgIGZvciAoY29uc3QgbyBpbiBzdGF0aWNNYXApXG4gICAgICB0aGlzLnBsdWdpbnNbb10gPSBuZXcgc3RhdGljTWFwW29dKHRoaXMucmVuZGVyZXIpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBvIGluIHRoaXMucGx1Z2lucylcbiAgICAgIHRoaXMucGx1Z2luc1tvXS5kZXN0cm95KCksIHRoaXMucGx1Z2luc1tvXSA9IG51bGw7XG4gIH1cbn1cblBsdWdpblN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gICAgZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLkNhbnZhc1JlbmRlcmVyU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwiX3BsdWdpblwiXG59O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChQbHVnaW5TeXN0ZW0pO1xuZXhwb3J0cy5QbHVnaW5TeXN0ZW0gPSBQbHVnaW5TeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QbHVnaW5TeXN0ZW0uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBleHRlbnNpb25zID0gcmVxdWlyZShcIkBwaXhpL2V4dGVuc2lvbnNcIiksIG1hdGggPSByZXF1aXJlKFwiQHBpeGkvbWF0aFwiKTtcbmNsYXNzIFByb2plY3Rpb25TeXN0ZW0ge1xuICAvKiogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci4gKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIsIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IG51bGwsIHRoaXMuc291cmNlRnJhbWUgPSBudWxsLCB0aGlzLmRlZmF1bHRGcmFtZSA9IG51bGwsIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBtYXRoLk1hdHJpeCgpLCB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHByb2plY3Rpb24tbWF0cml4IGJhc2VkIG9uIHRoZSBzb3VyY2VGcmFtZSDihpIgZGVzdGluYXRpb25GcmFtZSBtYXBwaW5nIHByb3ZpZGVkLlxuICAgKlxuICAgKiBOT1RFOiBJdCBpcyBleHBlY3RlZCB5b3UgY2FsbCBgcmVuZGVyZXIuZnJhbWVidWZmZXIuc2V0Vmlld3BvcnQoZGVzdGluYXRpb25GcmFtZSlgIGFmdGVyIHRoaXMuIFRoaXMgaXMgYmVjYXVzZVxuICAgKiB0aGUgZnJhbWVidWZmZXIgdmlld3BvcnQgY29udmVydHMgc2hhZGVyIHZlcnRleCBvdXRwdXQgaW4gbm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZXMgdG8gd2luZG93IGNvb3JkaW5hdGVzLlxuICAgKlxuICAgKiBOT1RFLTI6IHtAbGluayBQSVhJLlJlbmRlclRleHR1cmVTeXN0ZW0jYmluZH0gdXBkYXRlcyB0aGUgcHJvamVjdGlvbi1tYXRyaXggd2hlbiB5b3UgYmluZCBhIHJlbmRlci10ZXh0dXJlLlxuICAgKiBJdCBpcyBleHBlY3RlZFxuICAgKiB0aGF0IHlvdSBkaXJ0eSB0aGUgY3VycmVudCBiaW5kaW5ncyB3aGVuIGNhbGxpbmcgdGhpcyBtYW51YWxseS5cbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uRnJhbWUgLSBUaGUgcmVjdGFuZ2xlIGluIHRoZSByZW5kZXItdGFyZ2V0IHRvIHJlbmRlciB0aGUgY29udGVudHMgaW50by4gSWYgcmVuZGVyaW5nIHRvIHRoZSBjYW52YXMsXG4gICAqICB0aGUgb3JpZ2luIGlzIG9uIHRoZSB0b3AtbGVmdDsgaWYgcmVuZGVyaW5nIHRvIGEgcmVuZGVyLXRleHR1cmUsIHRoZSBvcmlnaW4gaXMgb24gdGhlIGJvdHRvbS1sZWZ0LlxuICAgKiBAcGFyYW0gc291cmNlRnJhbWUgLSBUaGUgcmVjdGFuZ2xlIGluIHdvcmxkIHNwYWNlIHRoYXQgY29udGFpbnMgdGhlIGNvbnRlbnRzIGJlaW5nIHJlbmRlcmVkLlxuICAgKiBAcGFyYW0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXItdGFyZ2V0LCB3aGljaCBpcyB0aGUgcmF0aW8gb2ZcbiAgICogIHdvcmxkLXNwYWNlIChvciBDU1MpIHBpeGVscyB0byBwaHlzaWNhbCBwaXhlbHMuXG4gICAqIEBwYXJhbSByb290IC0gV2hldGhlciB0aGUgcmVuZGVyLXRhcmdldCBpcyB0aGUgc2NyZWVuLiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgcmVuZGVyaW5nIHRvIHRleHR1cmVzXG4gICAqICBpcyB5LWZsaXBwZWQgKGkuZS4gdXBzaWRlIGRvd24gcmVsYXRpdmUgdG8gdGhlIHNjcmVlbikuXG4gICAqL1xuICB1cGRhdGUoZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUsIHJlc29sdXRpb24sIHJvb3QpIHtcbiAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgPSBkZXN0aW5hdGlvbkZyYW1lIHx8IHRoaXMuZGVzdGluYXRpb25GcmFtZSB8fCB0aGlzLmRlZmF1bHRGcmFtZSwgdGhpcy5zb3VyY2VGcmFtZSA9IHNvdXJjZUZyYW1lIHx8IHRoaXMuc291cmNlRnJhbWUgfHwgZGVzdGluYXRpb25GcmFtZSwgdGhpcy5jYWxjdWxhdGVQcm9qZWN0aW9uKHRoaXMuZGVzdGluYXRpb25GcmFtZSwgdGhpcy5zb3VyY2VGcmFtZSwgcmVzb2x1dGlvbiwgcm9vdCksIHRoaXMudHJhbnNmb3JtICYmIHRoaXMucHJvamVjdGlvbk1hdHJpeC5hcHBlbmQodGhpcy50cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICByZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5wcm9qZWN0aW9uTWF0cml4LCByZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy51cGRhdGUoKSwgcmVuZGVyZXIuc2hhZGVyLnNoYWRlciAmJiByZW5kZXJlci5zaGFkZXIuc3luY1VuaWZvcm1Hcm91cChyZW5kZXJlci5zaGFkZXIuc2hhZGVyLnVuaWZvcm1zLmdsb2JhbHMpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBgcHJvamVjdGlvbk1hdHJpeGAgdG8gbWFwIHBvaW50cyBpbnNpZGUgYHNvdXJjZUZyYW1lYCB0byBpbnNpZGUgYGRlc3RpbmF0aW9uRnJhbWVgLlxuICAgKiBAcGFyYW0gX2Rlc3RpbmF0aW9uRnJhbWUgLSBUaGUgZGVzdGluYXRpb24gZnJhbWUgaW4gdGhlIHJlbmRlci10YXJnZXQuXG4gICAqIEBwYXJhbSBzb3VyY2VGcmFtZSAtIFRoZSBzb3VyY2UgZnJhbWUgaW4gd29ybGQgc3BhY2UuXG4gICAqIEBwYXJhbSBfcmVzb2x1dGlvbiAtIFRoZSByZW5kZXItdGFyZ2V0J3MgcmVzb2x1dGlvbiwgaS5lLiByYXRpbyBvZiBDU1MgdG8gcGh5c2ljYWwgcGl4ZWxzLlxuICAgKiBAcGFyYW0gcm9vdCAtIFdoZXRoZXIgcmVuZGVyaW5nIGludG8gdGhlIHNjcmVlbi4gT3RoZXJ3aXNlLCBpZiByZW5kZXJpbmcgdG8gYSBmcmFtZWJ1ZmZlciwgdGhlIHByb2plY3Rpb25cbiAgICogIGlzIHktZmxpcHBlZC5cbiAgICovXG4gIGNhbGN1bGF0ZVByb2plY3Rpb24oX2Rlc3RpbmF0aW9uRnJhbWUsIHNvdXJjZUZyYW1lLCBfcmVzb2x1dGlvbiwgcm9vdCkge1xuICAgIGNvbnN0IHBtID0gdGhpcy5wcm9qZWN0aW9uTWF0cml4LCBzaWduID0gcm9vdCA/IC0xIDogMTtcbiAgICBwbS5pZGVudGl0eSgpLCBwbS5hID0gMSAvIHNvdXJjZUZyYW1lLndpZHRoICogMiwgcG0uZCA9IHNpZ24gKiAoMSAvIHNvdXJjZUZyYW1lLmhlaWdodCAqIDIpLCBwbS50eCA9IC0xIC0gc291cmNlRnJhbWUueCAqIHBtLmEsIHBtLnR5ID0gLXNpZ24gLSBzb3VyY2VGcmFtZS55ICogcG0uZDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdHJhbnNmb3JtIG9mIHRoZSBhY3RpdmUgcmVuZGVyIHRhcmdldCB0byB0aGUgZ2l2ZW4gbWF0cml4LlxuICAgKiBAcGFyYW0gX21hdHJpeCAtIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICovXG4gIHNldFRyYW5zZm9ybShfbWF0cml4KSB7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuUHJvamVjdGlvblN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJwcm9qZWN0aW9uXCJcbn07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKFByb2plY3Rpb25TeXN0ZW0pO1xuZXhwb3J0cy5Qcm9qZWN0aW9uU3lzdGVtID0gUHJvamVjdGlvblN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByb2plY3Rpb25TeXN0ZW0uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb2xvciA9IHJlcXVpcmUoXCJAcGl4aS9jb2xvclwiKSwgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKSwgRnJhbWVidWZmZXIgPSByZXF1aXJlKFwiLi4vZnJhbWVidWZmZXIvRnJhbWVidWZmZXIuanNcIiksIEJhc2VUZXh0dXJlID0gcmVxdWlyZShcIi4uL3RleHR1cmVzL0Jhc2VUZXh0dXJlLmpzXCIpO1xuY2xhc3MgQmFzZVJlbmRlclRleHR1cmUgZXh0ZW5kcyBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2lkdGg9MTAwXSAtIFRoZSB3aWR0aCBvZiB0aGUgYmFzZSByZW5kZXIgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodD0xMDBdIC0gVGhlIGhlaWdodCBvZiB0aGUgYmFzZSByZW5kZXIgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtQSVhJLlNDQUxFX01PREVTfSBbb3B0aW9ucy5zY2FsZU1vZGU9UElYSS5CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5zY2FsZU1vZGVdIC0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfVxuICAgKiAgIGZvciBwb3NzaWJsZSB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uPVBJWEkuc2V0dGluZ3MuUkVTT0xVVElPTl0gLSBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpb1xuICAgKiAgIG9mIHRoZSB0ZXh0dXJlIGJlaW5nIGdlbmVyYXRlZC5cbiAgICogQHBhcmFtIHtQSVhJLk1TQUFfUVVBTElUWX0gW29wdGlvbnMubXVsdGlzYW1wbGU9UElYSS5NU0FBX1FVQUxJVFkuTk9ORV0gLSBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgb2YgdGhlIGZyYW1lIGJ1ZmZlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGFyZ3VtZW50c1swXSwgaGVpZ2h0ID0gYXJndW1lbnRzWzFdLCBzY2FsZU1vZGUgPSBhcmd1bWVudHNbMl0sIHJlc29sdXRpb24gPSBhcmd1bWVudHNbM107XG4gICAgICBvcHRpb25zID0geyB3aWR0aCwgaGVpZ2h0LCBzY2FsZU1vZGUsIHJlc29sdXRpb24gfTtcbiAgICB9XG4gICAgb3B0aW9ucy53aWR0aCA9IG9wdGlvbnMud2lkdGggPz8gMTAwLCBvcHRpb25zLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ID8/IDEwMCwgb3B0aW9ucy5tdWx0aXNhbXBsZSA/PyAob3B0aW9ucy5tdWx0aXNhbXBsZSA9IGNvbnN0YW50cy5NU0FBX1FVQUxJVFkuTk9ORSksIHN1cGVyKG51bGwsIG9wdGlvbnMpLCB0aGlzLm1pcG1hcCA9IGNvbnN0YW50cy5NSVBNQVBfTU9ERVMuT0ZGLCB0aGlzLnZhbGlkID0gITAsIHRoaXMuX2NsZWFyID0gbmV3IGNvbG9yLkNvbG9yKFswLCAwLCAwLCAwXSksIHRoaXMuZnJhbWVidWZmZXIgPSBuZXcgRnJhbWVidWZmZXIuRnJhbWVidWZmZXIodGhpcy5yZWFsV2lkdGgsIHRoaXMucmVhbEhlaWdodCkuYWRkQ29sb3JUZXh0dXJlKDAsIHRoaXMpLCB0aGlzLmZyYW1lYnVmZmVyLm11bHRpc2FtcGxlID0gb3B0aW9ucy5tdWx0aXNhbXBsZSwgdGhpcy5tYXNrU3RhY2sgPSBbXSwgdGhpcy5maWx0ZXJTdGFjayA9IFt7fV07XG4gIH1cbiAgLyoqIENvbG9yIHdoZW4gY2xlYXJuaW5nIHRoZSB0ZXh0dXJlLiAqL1xuICBzZXQgY2xlYXJDb2xvcih2YWx1ZSkge1xuICAgIHRoaXMuX2NsZWFyLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuICBnZXQgY2xlYXJDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xlYXIudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENvbG9yIG9iamVjdCB3aGVuIGNsZWFybmluZyB0aGUgdGV4dHVyZS5cbiAgICogQHJlYWRvbmx5XG4gICAqIEBzaW5jZSA3LjIuMFxuICAgKi9cbiAgZ2V0IGNsZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGVhcjtcbiAgfVxuICAvKipcbiAgICogU2hvcnRjdXQgdG8gYHRoaXMuZnJhbWVidWZmZXIubXVsdGlzYW1wbGVgLlxuICAgKiBAZGVmYXVsdCBQSVhJLk1TQUFfUVVBTElUWS5OT05FXG4gICAqL1xuICBnZXQgbXVsdGlzYW1wbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWVidWZmZXIubXVsdGlzYW1wbGU7XG4gIH1cbiAgc2V0IG11bHRpc2FtcGxlKHZhbHVlKSB7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci5tdWx0aXNhbXBsZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBCYXNlUmVuZGVyVGV4dHVyZS5cbiAgICogQHBhcmFtIGRlc2lyZWRXaWR0aCAtIFRoZSBkZXNpcmVkIHdpZHRoIHRvIHJlc2l6ZSB0by5cbiAgICogQHBhcmFtIGRlc2lyZWRIZWlnaHQgLSBUaGUgZGVzaXJlZCBoZWlnaHQgdG8gcmVzaXplIHRvLlxuICAgKi9cbiAgcmVzaXplKGRlc2lyZWRXaWR0aCwgZGVzaXJlZEhlaWdodCkge1xuICAgIHRoaXMuZnJhbWVidWZmZXIucmVzaXplKGRlc2lyZWRXaWR0aCAqIHRoaXMucmVzb2x1dGlvbiwgZGVzaXJlZEhlaWdodCAqIHRoaXMucmVzb2x1dGlvbiksIHRoaXMuc2V0UmVhbFNpemUodGhpcy5mcmFtZWJ1ZmZlci53aWR0aCwgdGhpcy5mcmFtZWJ1ZmZlci5oZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBGcmVlcyB0aGUgdGV4dHVyZSBhbmQgZnJhbWVidWZmZXIgZnJvbSBXZWJHTCBtZW1vcnkgd2l0aG91dCBkZXN0cm95aW5nIHRoaXMgdGV4dHVyZSBvYmplY3QuXG4gICAqIFRoaXMgbWVhbnMgeW91IGNhbiBzdGlsbCB1c2UgdGhlIHRleHR1cmUgbGF0ZXIgd2hpY2ggd2lsbCB1cGxvYWQgaXQgdG8gR1BVXG4gICAqIG1lbW9yeSBhZ2Fpbi5cbiAgICogQGZpcmVzIFBJWEkuQmFzZVRleHR1cmUjZGlzcG9zZVxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmZyYW1lYnVmZmVyLmRpc3Bvc2UoKSwgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIC8qKiBEZXN0cm95cyB0aGlzIHRleHR1cmUuICovXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpLCB0aGlzLmZyYW1lYnVmZmVyLmRlc3Ryb3lEZXB0aFRleHR1cmUoKSwgdGhpcy5mcmFtZWJ1ZmZlciA9IG51bGw7XG4gIH1cbn1cbmV4cG9ydHMuQmFzZVJlbmRlclRleHR1cmUgPSBCYXNlUmVuZGVyVGV4dHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VSZW5kZXJUZXh0dXJlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXh0ZW5zaW9ucyA9IHJlcXVpcmUoXCJAcGl4aS9leHRlbnNpb25zXCIpLCBtYXRoID0gcmVxdWlyZShcIkBwaXhpL21hdGhcIiksIFJlbmRlclRleHR1cmUgPSByZXF1aXJlKFwiLi9SZW5kZXJUZXh0dXJlLmpzXCIpO1xuY29uc3QgdGVtcFRyYW5zZm9ybSA9IG5ldyBtYXRoLlRyYW5zZm9ybSgpLCB0ZW1wUmVjdCA9IG5ldyBtYXRoLlJlY3RhbmdsZSgpO1xuY2xhc3MgR2VuZXJhdGVUZXh0dXJlU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIsIHRoaXMuX3RlbXBNYXRyaXggPSBuZXcgbWF0aC5NYXRyaXgoKTtcbiAgfVxuICAvKipcbiAgICogQSBVc2VmdWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdGV4dHVyZSBvZiB0aGUgZGlzcGxheSBvYmplY3QgdGhhdCBjYW4gdGhlbiBiZSB1c2VkIHRvIGNyZWF0ZSBzcHJpdGVzXG4gICAqIFRoaXMgY2FuIGJlIHF1aXRlIHVzZWZ1bCBpZiB5b3VyIGRpc3BsYXlPYmplY3QgaXMgY29tcGxpY2F0ZWQgYW5kIG5lZWRzIHRvIGJlIHJldXNlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICogQHBhcmFtIGRpc3BsYXlPYmplY3QgLSBUaGUgZGlzcGxheU9iamVjdCB0aGUgb2JqZWN0IHdpbGwgYmUgZ2VuZXJhdGVkIGZyb20uXG4gICAqIEBwYXJhbSB7SUdlbmVyYXRlVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgLSBHZW5lcmF0ZSB0ZXh0dXJlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IG9wdGlvbnMucmVnaW9uIC0gVGhlIHJlZ2lvbiBvZiB0aGUgZGlzcGxheU9iamVjdCwgdGhhdCBzaGFsbCBiZSByZW5kZXJlZCxcbiAgICogICAgICAgIGlmIG5vIHJlZ2lvbiBpcyBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uXSAtIElmIG5vdCBnaXZlbiwgdGhlIHJlbmRlcmVyJ3MgcmVzb2x1dGlvbiBpcyB1c2VkLlxuICAgKiBAcGFyYW0ge1BJWEkuTVNBQV9RVUFMSVRZfSBbb3B0aW9ucy5tdWx0aXNhbXBsZV0gLSBJZiBub3QgZ2l2ZW4sIHRoZSByZW5kZXJlcidzIG11bHRpc2FtcGxlIGlzIHVzZWQuXG4gICAqIEByZXR1cm5zIGEgc2hpbnkgbmV3IHRleHR1cmUgb2YgdGhlIGRpc3BsYXkgb2JqZWN0IHBhc3NlZCBpblxuICAgKi9cbiAgZ2VuZXJhdGVUZXh0dXJlKGRpc3BsYXlPYmplY3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJlZ2lvbjogbWFudWFsUmVnaW9uLCAuLi50ZXh0dXJlT3B0aW9ucyB9ID0gb3B0aW9ucyB8fCB7fSwgcmVnaW9uID0gbWFudWFsUmVnaW9uPy5jb3B5VG8odGVtcFJlY3QpIHx8IGRpc3BsYXlPYmplY3QuZ2V0TG9jYWxCb3VuZHModGVtcFJlY3QsICEwKSwgcmVzb2x1dGlvbiA9IHRleHR1cmVPcHRpb25zLnJlc29sdXRpb24gfHwgdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgIHJlZ2lvbi53aWR0aCA9IE1hdGgubWF4KHJlZ2lvbi53aWR0aCwgMSAvIHJlc29sdXRpb24pLCByZWdpb24uaGVpZ2h0ID0gTWF0aC5tYXgocmVnaW9uLmhlaWdodCwgMSAvIHJlc29sdXRpb24pLCB0ZXh0dXJlT3B0aW9ucy53aWR0aCA9IHJlZ2lvbi53aWR0aCwgdGV4dHVyZU9wdGlvbnMuaGVpZ2h0ID0gcmVnaW9uLmhlaWdodCwgdGV4dHVyZU9wdGlvbnMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24sIHRleHR1cmVPcHRpb25zLm11bHRpc2FtcGxlID8/ICh0ZXh0dXJlT3B0aW9ucy5tdWx0aXNhbXBsZSA9IHRoaXMucmVuZGVyZXIubXVsdGlzYW1wbGUpO1xuICAgIGNvbnN0IHJlbmRlclRleHR1cmUgPSBSZW5kZXJUZXh0dXJlLlJlbmRlclRleHR1cmUuY3JlYXRlKHRleHR1cmVPcHRpb25zKTtcbiAgICB0aGlzLl90ZW1wTWF0cml4LnR4ID0gLXJlZ2lvbi54LCB0aGlzLl90ZW1wTWF0cml4LnR5ID0gLXJlZ2lvbi55O1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGRpc3BsYXlPYmplY3QudHJhbnNmb3JtO1xuICAgIHJldHVybiBkaXNwbGF5T2JqZWN0LnRyYW5zZm9ybSA9IHRlbXBUcmFuc2Zvcm0sIHRoaXMucmVuZGVyZXIucmVuZGVyKGRpc3BsYXlPYmplY3QsIHtcbiAgICAgIHJlbmRlclRleHR1cmUsXG4gICAgICB0cmFuc2Zvcm06IHRoaXMuX3RlbXBNYXRyaXgsXG4gICAgICBza2lwVXBkYXRlVHJhbnNmb3JtOiAhIWRpc3BsYXlPYmplY3QucGFyZW50LFxuICAgICAgYmxpdDogITBcbiAgICB9KSwgZGlzcGxheU9iamVjdC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm0sIHJlbmRlclRleHR1cmU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgfVxufVxuR2VuZXJhdGVUZXh0dXJlU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgICBleHRlbnNpb25zLkV4dGVuc2lvblR5cGUuQ2FudmFzUmVuZGVyZXJTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJ0ZXh0dXJlR2VuZXJhdG9yXCJcbn07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKEdlbmVyYXRlVGV4dHVyZVN5c3RlbSk7XG5leHBvcnRzLkdlbmVyYXRlVGV4dHVyZVN5c3RlbSA9IEdlbmVyYXRlVGV4dHVyZVN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlbmVyYXRlVGV4dHVyZVN5c3RlbS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIFRleHR1cmUgPSByZXF1aXJlKFwiLi4vdGV4dHVyZXMvVGV4dHVyZS5qc1wiKSwgQmFzZVJlbmRlclRleHR1cmUgPSByZXF1aXJlKFwiLi9CYXNlUmVuZGVyVGV4dHVyZS5qc1wiKTtcbmNsYXNzIFJlbmRlclRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlLlRleHR1cmUge1xuICAvKipcbiAgICogQHBhcmFtIGJhc2VSZW5kZXJUZXh0dXJlIC0gVGhlIGJhc2UgdGV4dHVyZSBvYmplY3QgdGhhdCB0aGlzIHRleHR1cmUgdXNlcy5cbiAgICogQHBhcmFtIGZyYW1lIC0gVGhlIHJlY3RhbmdsZSBmcmFtZSBvZiB0aGUgdGV4dHVyZSB0byBzaG93LlxuICAgKi9cbiAgY29uc3RydWN0b3IoYmFzZVJlbmRlclRleHR1cmUsIGZyYW1lKSB7XG4gICAgc3VwZXIoYmFzZVJlbmRlclRleHR1cmUsIGZyYW1lKSwgdGhpcy52YWxpZCA9ICEwLCB0aGlzLmZpbHRlckZyYW1lID0gbnVsbCwgdGhpcy5maWx0ZXJQb29sS2V5ID0gbnVsbCwgdGhpcy51cGRhdGVVdnMoKTtcbiAgfVxuICAvKipcbiAgICogU2hvcnRjdXQgdG8gYHRoaXMuYmFzZVRleHR1cmUuZnJhbWVidWZmZXJgLCBzYXZlcyBiYXNlVGV4dHVyZSBjYXN0LlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBmcmFtZWJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlVGV4dHVyZS5mcmFtZWJ1ZmZlcjtcbiAgfVxuICAvKipcbiAgICogU2hvcnRjdXQgdG8gYHRoaXMuZnJhbWVidWZmZXIubXVsdGlzYW1wbGVgLlxuICAgKiBAZGVmYXVsdCBQSVhJLk1TQUFfUVVBTElUWS5OT05FXG4gICAqL1xuICBnZXQgbXVsdGlzYW1wbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWVidWZmZXIubXVsdGlzYW1wbGU7XG4gIH1cbiAgc2V0IG11bHRpc2FtcGxlKHZhbHVlKSB7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci5tdWx0aXNhbXBsZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBSZW5kZXJUZXh0dXJlLlxuICAgKiBAcGFyYW0gZGVzaXJlZFdpZHRoIC0gVGhlIGRlc2lyZWQgd2lkdGggdG8gcmVzaXplIHRvLlxuICAgKiBAcGFyYW0gZGVzaXJlZEhlaWdodCAtIFRoZSBkZXNpcmVkIGhlaWdodCB0byByZXNpemUgdG8uXG4gICAqIEBwYXJhbSByZXNpemVCYXNlVGV4dHVyZSAtIFNob3VsZCB0aGUgYmFzZVRleHR1cmUud2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgYmUgcmVzaXplZCBhcyB3ZWxsP1xuICAgKi9cbiAgcmVzaXplKGRlc2lyZWRXaWR0aCwgZGVzaXJlZEhlaWdodCwgcmVzaXplQmFzZVRleHR1cmUgPSAhMCkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmJhc2VUZXh0dXJlLnJlc29sdXRpb24sIHdpZHRoID0gTWF0aC5yb3VuZChkZXNpcmVkV2lkdGggKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb24sIGhlaWdodCA9IE1hdGgucm91bmQoZGVzaXJlZEhlaWdodCAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICB0aGlzLnZhbGlkID0gd2lkdGggPiAwICYmIGhlaWdodCA+IDAsIHRoaXMuX2ZyYW1lLndpZHRoID0gdGhpcy5vcmlnLndpZHRoID0gd2lkdGgsIHRoaXMuX2ZyYW1lLmhlaWdodCA9IHRoaXMub3JpZy5oZWlnaHQgPSBoZWlnaHQsIHJlc2l6ZUJhc2VUZXh0dXJlICYmIHRoaXMuYmFzZVRleHR1cmUucmVzaXplKHdpZHRoLCBoZWlnaHQpLCB0aGlzLnVwZGF0ZVV2cygpO1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSByZXNvbHV0aW9uIG9mIGJhc2VUZXh0dXJlLCBidXQgZG9lcyBub3QgY2hhbmdlIGZyYW1lYnVmZmVyIHNpemUuXG4gICAqIEBwYXJhbSByZXNvbHV0aW9uIC0gVGhlIG5ldyByZXNvbHV0aW9uIHRvIGFwcGx5IHRvIFJlbmRlclRleHR1cmVcbiAgICovXG4gIHNldFJlc29sdXRpb24ocmVzb2x1dGlvbikge1xuICAgIGNvbnN0IHsgYmFzZVRleHR1cmUgfSA9IHRoaXM7XG4gICAgYmFzZVRleHR1cmUucmVzb2x1dGlvbiAhPT0gcmVzb2x1dGlvbiAmJiAoYmFzZVRleHR1cmUuc2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKSwgdGhpcy5yZXNpemUoYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCwgITEpKTtcbiAgfVxuICAvKipcbiAgICogQSBzaG9ydCBoYW5kIHdheSBvZiBjcmVhdGluZyBhIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoPTEwMF0gLSBUaGUgd2lkdGggb2YgdGhlIHJlbmRlciB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MTAwXSAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7UElYSS5TQ0FMRV9NT0RFU30gW29wdGlvbnMuc2NhbGVNb2RlPVBJWEkuQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuc2NhbGVNb2RlXSAtIFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU31cbiAgICogICAgZm9yIHBvc3NpYmxlIHZhbHVlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvbj1QSVhJLnNldHRpbmdzLlJFU09MVVRJT05dIC0gVGhlIHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIHRleHR1cmVcbiAgICogICAgYmVpbmcgZ2VuZXJhdGVkXG4gICAqIEBwYXJhbSB7UElYSS5NU0FBX1FVQUxJVFl9IFtvcHRpb25zLm11bHRpc2FtcGxlPVBJWEkuTVNBQV9RVUFMSVRZLk5PTkVdIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzIG9mIHRoZSBmcmFtZSBidWZmZXJcbiAgICogQHJldHVybnMgVGhlIG5ldyByZW5kZXIgdGV4dHVyZVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZW5kZXJUZXh0dXJlKG5ldyBCYXNlUmVuZGVyVGV4dHVyZS5CYXNlUmVuZGVyVGV4dHVyZShvcHRpb25zKSk7XG4gIH1cbn1cbmV4cG9ydHMuUmVuZGVyVGV4dHVyZSA9IFJlbmRlclRleHR1cmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJUZXh0dXJlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKSwgdXRpbHMgPSByZXF1aXJlKFwiQHBpeGkvdXRpbHNcIiksIEJhc2VSZW5kZXJUZXh0dXJlID0gcmVxdWlyZShcIi4vQmFzZVJlbmRlclRleHR1cmUuanNcIiksIFJlbmRlclRleHR1cmUgPSByZXF1aXJlKFwiLi9SZW5kZXJUZXh0dXJlLmpzXCIpO1xuY2xhc3MgUmVuZGVyVGV4dHVyZVBvb2wge1xuICAvKipcbiAgICogQHBhcmFtIHRleHR1cmVPcHRpb25zIC0gb3B0aW9ucyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIEJhc2VSZW5kZXJUZXh0dXJlIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7UElYSS5TQ0FMRV9NT0RFU30gW3RleHR1cmVPcHRpb25zLnNjYWxlTW9kZV0gLSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlT3B0aW9ucykge1xuICAgIHRoaXMudGV4dHVyZVBvb2wgPSB7fSwgdGhpcy50ZXh0dXJlT3B0aW9ucyA9IHRleHR1cmVPcHRpb25zIHx8IHt9LCB0aGlzLmVuYWJsZUZ1bGxTY3JlZW4gPSAhMSwgdGhpcy5fcGl4ZWxzV2lkdGggPSAwLCB0aGlzLl9waXhlbHNIZWlnaHQgPSAwO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHRleHR1cmUgd2l0aCBwYXJhbXMgdGhhdCB3ZXJlIHNwZWNpZmllZCBpbiBwb29sIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gcmVhbFdpZHRoIC0gV2lkdGggb2YgdGV4dHVyZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSByZWFsSGVpZ2h0IC0gSGVpZ2h0IG9mIHRleHR1cmUgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0gbXVsdGlzYW1wbGUgLSBOdW1iZXIgb2Ygc2FtcGxlcyBvZiB0aGUgZnJhbWVidWZmZXIuXG4gICAqL1xuICBjcmVhdGVUZXh0dXJlKHJlYWxXaWR0aCwgcmVhbEhlaWdodCwgbXVsdGlzYW1wbGUgPSBjb25zdGFudHMuTVNBQV9RVUFMSVRZLk5PTkUpIHtcbiAgICBjb25zdCBiYXNlUmVuZGVyVGV4dHVyZSA9IG5ldyBCYXNlUmVuZGVyVGV4dHVyZS5CYXNlUmVuZGVyVGV4dHVyZShPYmplY3QuYXNzaWduKHtcbiAgICAgIHdpZHRoOiByZWFsV2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlYWxIZWlnaHQsXG4gICAgICByZXNvbHV0aW9uOiAxLFxuICAgICAgbXVsdGlzYW1wbGVcbiAgICB9LCB0aGlzLnRleHR1cmVPcHRpb25zKSk7XG4gICAgcmV0dXJuIG5ldyBSZW5kZXJUZXh0dXJlLlJlbmRlclRleHR1cmUoYmFzZVJlbmRlclRleHR1cmUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgUG93ZXItb2YtVHdvIHJlbmRlciB0ZXh0dXJlIG9yIGZ1bGxTY3JlZW4gdGV4dHVyZVxuICAgKiBAcGFyYW0gbWluV2lkdGggLSBUaGUgbWluaW11bSB3aWR0aCBvZiB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAqIEBwYXJhbSBtaW5IZWlnaHQgLSBUaGUgbWluaW11bSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXIgdGV4dHVyZS5cbiAgICogQHBhcmFtIG11bHRpc2FtcGxlIC0gTnVtYmVyIG9mIHNhbXBsZXMgb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcmV0dXJucyBUaGUgbmV3IHJlbmRlciB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0T3B0aW1hbFRleHR1cmUobWluV2lkdGgsIG1pbkhlaWdodCwgcmVzb2x1dGlvbiA9IDEsIG11bHRpc2FtcGxlID0gY29uc3RhbnRzLk1TQUFfUVVBTElUWS5OT05FKSB7XG4gICAgbGV0IGtleTtcbiAgICBtaW5XaWR0aCA9IE1hdGgubWF4KE1hdGguY2VpbChtaW5XaWR0aCAqIHJlc29sdXRpb24gLSAxZS02KSwgMSksIG1pbkhlaWdodCA9IE1hdGgubWF4KE1hdGguY2VpbChtaW5IZWlnaHQgKiByZXNvbHV0aW9uIC0gMWUtNiksIDEpLCAhdGhpcy5lbmFibGVGdWxsU2NyZWVuIHx8IG1pbldpZHRoICE9PSB0aGlzLl9waXhlbHNXaWR0aCB8fCBtaW5IZWlnaHQgIT09IHRoaXMuX3BpeGVsc0hlaWdodCA/IChtaW5XaWR0aCA9IHV0aWxzLm5leHRQb3cyKG1pbldpZHRoKSwgbWluSGVpZ2h0ID0gdXRpbHMubmV4dFBvdzIobWluSGVpZ2h0KSwga2V5ID0gKChtaW5XaWR0aCAmIDY1NTM1KSA8PCAxNiB8IG1pbkhlaWdodCAmIDY1NTM1KSA+Pj4gMCwgbXVsdGlzYW1wbGUgPiAxICYmIChrZXkgKz0gbXVsdGlzYW1wbGUgKiA0Mjk0OTY3Mjk2KSkgOiBrZXkgPSBtdWx0aXNhbXBsZSA+IDEgPyAtbXVsdGlzYW1wbGUgOiAtMSwgdGhpcy50ZXh0dXJlUG9vbFtrZXldIHx8ICh0aGlzLnRleHR1cmVQb29sW2tleV0gPSBbXSk7XG4gICAgbGV0IHJlbmRlclRleHR1cmUgPSB0aGlzLnRleHR1cmVQb29sW2tleV0ucG9wKCk7XG4gICAgcmV0dXJuIHJlbmRlclRleHR1cmUgfHwgKHJlbmRlclRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUobWluV2lkdGgsIG1pbkhlaWdodCwgbXVsdGlzYW1wbGUpKSwgcmVuZGVyVGV4dHVyZS5maWx0ZXJQb29sS2V5ID0ga2V5LCByZW5kZXJUZXh0dXJlLnNldFJlc29sdXRpb24ocmVzb2x1dGlvbiksIHJlbmRlclRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgZXh0cmEgdGV4dHVyZSBvZiB0aGUgc2FtZSBzaXplIGFzIGlucHV0IHJlbmRlclRleHR1cmVcbiAgICpcbiAgICogYGdldEZpbHRlclRleHR1cmUoaW5wdXQsIDAuNSlgIG9yIGBnZXRGaWx0ZXJUZXh0dXJlKDAuNSwgaW5wdXQpYFxuICAgKiBAcGFyYW0gaW5wdXQgLSByZW5kZXJUZXh0dXJlIGZyb20gd2hpY2ggc2l6ZSBhbmQgcmVzb2x1dGlvbiB3aWxsIGJlIGNvcGllZFxuICAgKiBAcGFyYW0gcmVzb2x1dGlvbiAtIG92ZXJyaWRlIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlclRleHR1cmVcbiAgICogIEl0IG92ZXJyaWRlcywgaXQgZG9lcyBub3QgbXVsdGlwbHlcbiAgICogQHBhcmFtIG11bHRpc2FtcGxlIC0gbnVtYmVyIG9mIHNhbXBsZXMgb2YgdGhlIHJlbmRlclRleHR1cmVcbiAgICovXG4gIGdldEZpbHRlclRleHR1cmUoaW5wdXQsIHJlc29sdXRpb24sIG11bHRpc2FtcGxlKSB7XG4gICAgY29uc3QgZmlsdGVyVGV4dHVyZSA9IHRoaXMuZ2V0T3B0aW1hbFRleHR1cmUoXG4gICAgICBpbnB1dC53aWR0aCxcbiAgICAgIGlucHV0LmhlaWdodCxcbiAgICAgIHJlc29sdXRpb24gfHwgaW5wdXQucmVzb2x1dGlvbixcbiAgICAgIG11bHRpc2FtcGxlIHx8IGNvbnN0YW50cy5NU0FBX1FVQUxJVFkuTk9ORVxuICAgICk7XG4gICAgcmV0dXJuIGZpbHRlclRleHR1cmUuZmlsdGVyRnJhbWUgPSBpbnB1dC5maWx0ZXJGcmFtZSwgZmlsdGVyVGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUGxhY2UgYSByZW5kZXIgdGV4dHVyZSBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSByZW5kZXJUZXh0dXJlIC0gVGhlIHJlbmRlclRleHR1cmUgdG8gZnJlZVxuICAgKi9cbiAgcmV0dXJuVGV4dHVyZShyZW5kZXJUZXh0dXJlKSB7XG4gICAgY29uc3Qga2V5ID0gcmVuZGVyVGV4dHVyZS5maWx0ZXJQb29sS2V5O1xuICAgIHJlbmRlclRleHR1cmUuZmlsdGVyRnJhbWUgPSBudWxsLCB0aGlzLnRleHR1cmVQb29sW2tleV0ucHVzaChyZW5kZXJUZXh0dXJlKTtcbiAgfVxuICAvKipcbiAgICogQWxpYXMgZm9yIHJldHVyblRleHR1cmUsIHRvIGJlIGNvbXBsaWFudCB3aXRoIEZpbHRlclN5c3RlbSBpbnRlcmZhY2UuXG4gICAqIEBwYXJhbSByZW5kZXJUZXh0dXJlIC0gVGhlIHJlbmRlclRleHR1cmUgdG8gZnJlZVxuICAgKi9cbiAgcmV0dXJuRmlsdGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlKSB7XG4gICAgdGhpcy5yZXR1cm5UZXh0dXJlKHJlbmRlclRleHR1cmUpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIHBvb2wuXG4gICAqIEBwYXJhbSBkZXN0cm95VGV4dHVyZXMgLSBEZXN0cm95IGFsbCBzdG9yZWQgdGV4dHVyZXMuXG4gICAqL1xuICBjbGVhcihkZXN0cm95VGV4dHVyZXMpIHtcbiAgICBpZiAoZGVzdHJveVRleHR1cmVzID0gZGVzdHJveVRleHR1cmVzICE9PSAhMSwgZGVzdHJveVRleHR1cmVzKVxuICAgICAgZm9yIChjb25zdCBpIGluIHRoaXMudGV4dHVyZVBvb2wpIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVQb29sW2ldO1xuICAgICAgICBpZiAodGV4dHVyZXMpXG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXh0dXJlcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgIHRleHR1cmVzW2pdLmRlc3Ryb3koITApO1xuICAgICAgfVxuICAgIHRoaXMudGV4dHVyZVBvb2wgPSB7fTtcbiAgfVxuICAvKipcbiAgICogSWYgc2NyZWVuIHNpemUgd2FzIGNoYW5nZWQsIGRyb3BzIGFsbCBzY3JlZW4tc2l6ZWQgdGV4dHVyZXMsXG4gICAqIHNldHMgbmV3IHNjcmVlbiBzaXplLCBzZXRzIGBlbmFibGVGdWxsU2NyZWVuYCB0byB0cnVlXG4gICAqXG4gICAqIFNpemUgaXMgbWVhc3VyZWQgaW4gcGl4ZWxzLCBgcmVuZGVyZXIudmlld2AgY2FuIGJlIHBhc3NlZCBoZXJlLCBub3QgYHJlbmRlcmVyLnNjcmVlbmBcbiAgICogQHBhcmFtIHNpemUgLSBJbml0aWFsIHNpemUgb2Ygc2NyZWVuLlxuICAgKi9cbiAgc2V0U2NyZWVuU2l6ZShzaXplKSB7XG4gICAgaWYgKCEoc2l6ZS53aWR0aCA9PT0gdGhpcy5fcGl4ZWxzV2lkdGggJiYgc2l6ZS5oZWlnaHQgPT09IHRoaXMuX3BpeGVsc0hlaWdodCkpIHtcbiAgICAgIHRoaXMuZW5hYmxlRnVsbFNjcmVlbiA9IHNpemUud2lkdGggPiAwICYmIHNpemUuaGVpZ2h0ID4gMDtcbiAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnRleHR1cmVQb29sKSB7XG4gICAgICAgIGlmICghKE51bWJlcihpKSA8IDApKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB0ZXh0dXJlcyA9IHRoaXMudGV4dHVyZVBvb2xbaV07XG4gICAgICAgIGlmICh0ZXh0dXJlcylcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRleHR1cmVzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgdGV4dHVyZXNbal0uZGVzdHJveSghMCk7XG4gICAgICAgIHRoaXMudGV4dHVyZVBvb2xbaV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BpeGVsc1dpZHRoID0gc2l6ZS53aWR0aCwgdGhpcy5fcGl4ZWxzSGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgfVxuICB9XG59XG5SZW5kZXJUZXh0dXJlUG9vbC5TQ1JFRU5fS0VZID0gLTE7XG5leHBvcnRzLlJlbmRlclRleHR1cmVQb29sID0gUmVuZGVyVGV4dHVyZVBvb2w7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJUZXh0dXJlUG9vbC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbG9yID0gcmVxdWlyZShcIkBwaXhpL2NvbG9yXCIpLCBleHRlbnNpb25zID0gcmVxdWlyZShcIkBwaXhpL2V4dGVuc2lvbnNcIiksIG1hdGggPSByZXF1aXJlKFwiQHBpeGkvbWF0aFwiKTtcbmNvbnN0IHRlbXBSZWN0ID0gbmV3IG1hdGguUmVjdGFuZ2xlKCksIHRlbXBSZWN0MiA9IG5ldyBtYXRoLlJlY3RhbmdsZSgpO1xuY2xhc3MgUmVuZGVyVGV4dHVyZVN5c3RlbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBTeXN0ZW0gd29ya3MgZm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIsIHRoaXMuZGVmYXVsdE1hc2tTdGFjayA9IFtdLCB0aGlzLmN1cnJlbnQgPSBudWxsLCB0aGlzLnNvdXJjZUZyYW1lID0gbmV3IG1hdGguUmVjdGFuZ2xlKCksIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgpLCB0aGlzLnZpZXdwb3J0RnJhbWUgPSBuZXcgbWF0aC5SZWN0YW5nbGUoKTtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLnJlbmRlcmVyPy5nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuICAgIHRoaXMuX3JlbmRlcmVyUHJlbXVsdGlwbGllZEFscGhhID0gISEoYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLmFscGhhICYmIGF0dHJpYnV0ZXMucHJlbXVsdGlwbGllZEFscGhhKTtcbiAgfVxuICAvKipcbiAgICogQmluZCB0aGUgY3VycmVudCByZW5kZXIgdGV4dHVyZS5cbiAgICogQHBhcmFtIHJlbmRlclRleHR1cmUgLSBSZW5kZXJUZXh0dXJlIHRvIGJpbmQsIGJ5IGRlZmF1bHQgaXRzIGBudWxsYCAtIHRoZSBzY3JlZW4uXG4gICAqIEBwYXJhbSBzb3VyY2VGcmFtZSAtIFBhcnQgb2Ygd29ybGQgdGhhdCBpcyBtYXBwZWQgdG8gdGhlIHJlbmRlclRleHR1cmUuXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvbkZyYW1lIC0gUGFydCBvZiByZW5kZXJUZXh0dXJlLCBieSBkZWZhdWx0IGl0IGhhcyB0aGUgc2FtZSBzaXplIGFzIHNvdXJjZUZyYW1lLlxuICAgKi9cbiAgYmluZChyZW5kZXJUZXh0dXJlID0gbnVsbCwgc291cmNlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgdGhpcy5jdXJyZW50ID0gcmVuZGVyVGV4dHVyZTtcbiAgICBsZXQgYmFzZVRleHR1cmUsIGZyYW1lYnVmZmVyLCByZXNvbHV0aW9uO1xuICAgIHJlbmRlclRleHR1cmUgPyAoYmFzZVRleHR1cmUgPSByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLCByZXNvbHV0aW9uID0gYmFzZVRleHR1cmUucmVzb2x1dGlvbiwgc291cmNlRnJhbWUgfHwgKHRlbXBSZWN0LndpZHRoID0gcmVuZGVyVGV4dHVyZS5mcmFtZS53aWR0aCwgdGVtcFJlY3QuaGVpZ2h0ID0gcmVuZGVyVGV4dHVyZS5mcmFtZS5oZWlnaHQsIHNvdXJjZUZyYW1lID0gdGVtcFJlY3QpLCBkZXN0aW5hdGlvbkZyYW1lIHx8ICh0ZW1wUmVjdDIueCA9IHJlbmRlclRleHR1cmUuZnJhbWUueCwgdGVtcFJlY3QyLnkgPSByZW5kZXJUZXh0dXJlLmZyYW1lLnksIHRlbXBSZWN0Mi53aWR0aCA9IHNvdXJjZUZyYW1lLndpZHRoLCB0ZW1wUmVjdDIuaGVpZ2h0ID0gc291cmNlRnJhbWUuaGVpZ2h0LCBkZXN0aW5hdGlvbkZyYW1lID0gdGVtcFJlY3QyKSwgZnJhbWVidWZmZXIgPSBiYXNlVGV4dHVyZS5mcmFtZWJ1ZmZlcikgOiAocmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb24sIHNvdXJjZUZyYW1lIHx8ICh0ZW1wUmVjdC53aWR0aCA9IHJlbmRlcmVyLl92aWV3LnNjcmVlbi53aWR0aCwgdGVtcFJlY3QuaGVpZ2h0ID0gcmVuZGVyZXIuX3ZpZXcuc2NyZWVuLmhlaWdodCwgc291cmNlRnJhbWUgPSB0ZW1wUmVjdCksIGRlc3RpbmF0aW9uRnJhbWUgfHwgKGRlc3RpbmF0aW9uRnJhbWUgPSB0ZW1wUmVjdCwgZGVzdGluYXRpb25GcmFtZS53aWR0aCA9IHNvdXJjZUZyYW1lLndpZHRoLCBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCA9IHNvdXJjZUZyYW1lLmhlaWdodCkpO1xuICAgIGNvbnN0IHZpZXdwb3J0RnJhbWUgPSB0aGlzLnZpZXdwb3J0RnJhbWU7XG4gICAgdmlld3BvcnRGcmFtZS54ID0gZGVzdGluYXRpb25GcmFtZS54ICogcmVzb2x1dGlvbiwgdmlld3BvcnRGcmFtZS55ID0gZGVzdGluYXRpb25GcmFtZS55ICogcmVzb2x1dGlvbiwgdmlld3BvcnRGcmFtZS53aWR0aCA9IGRlc3RpbmF0aW9uRnJhbWUud2lkdGggKiByZXNvbHV0aW9uLCB2aWV3cG9ydEZyYW1lLmhlaWdodCA9IGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ICogcmVzb2x1dGlvbiwgcmVuZGVyVGV4dHVyZSB8fCAodmlld3BvcnRGcmFtZS55ID0gcmVuZGVyZXIudmlldy5oZWlnaHQgLSAodmlld3BvcnRGcmFtZS55ICsgdmlld3BvcnRGcmFtZS5oZWlnaHQpKSwgdmlld3BvcnRGcmFtZS5jZWlsKCksIHRoaXMucmVuZGVyZXIuZnJhbWVidWZmZXIuYmluZChmcmFtZWJ1ZmZlciwgdmlld3BvcnRGcmFtZSksIHRoaXMucmVuZGVyZXIucHJvamVjdGlvbi51cGRhdGUoZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUsIHJlc29sdXRpb24sICFmcmFtZWJ1ZmZlciksIHJlbmRlclRleHR1cmUgPyB0aGlzLnJlbmRlcmVyLm1hc2suc2V0TWFza1N0YWNrKGJhc2VUZXh0dXJlLm1hc2tTdGFjaykgOiB0aGlzLnJlbmRlcmVyLm1hc2suc2V0TWFza1N0YWNrKHRoaXMuZGVmYXVsdE1hc2tTdGFjayksIHRoaXMuc291cmNlRnJhbWUuY29weUZyb20oc291cmNlRnJhbWUpLCB0aGlzLmRlc3RpbmF0aW9uRnJhbWUuY29weUZyb20oZGVzdGluYXRpb25GcmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEVyYXNlcyB0aGUgcmVuZGVyIHRleHR1cmUgYW5kIGZpbGxzIHRoZSBkcmF3aW5nIGFyZWEgd2l0aCBhIGNvbG91ci5cbiAgICogQHBhcmFtIGNsZWFyQ29sb3IgLSBUaGUgY29sb3IgYXMgcmdiYSwgZGVmYXVsdCB0byB1c2UgdGhlIHJlbmRlcmVyIGJhY2tncm91bmRDb2xvclxuICAgKiBAcGFyYW0gW21hc2s9QlVGRkVSX0JJVFMuQ09MT1IgfCBCVUZGRVJfQklUUy5ERVBUSF0gLSBCaXR3aXNlIE9SIG9mIG1hc2tzXG4gICAqICB0aGF0IGluZGljYXRlIHRoZSBidWZmZXJzIHRvIGJlIGNsZWFyZWQsIGJ5IGRlZmF1bHQgQ09MT1IgYW5kIERFUFRIIGJ1ZmZlcnMuXG4gICAqL1xuICBjbGVhcihjbGVhckNvbG9yLCBtYXNrKSB7XG4gICAgY29uc3QgZmFsbGJhY2tDb2xvciA9IHRoaXMuY3VycmVudCA/IHRoaXMuY3VycmVudC5iYXNlVGV4dHVyZS5jbGVhciA6IHRoaXMucmVuZGVyZXIuYmFja2dyb3VuZC5iYWNrZ3JvdW5kQ29sb3IsIGNvbG9yJDEgPSBjb2xvci5Db2xvci5zaGFyZWQuc2V0VmFsdWUoY2xlYXJDb2xvciB8fCBmYWxsYmFja0NvbG9yKTtcbiAgICAodGhpcy5jdXJyZW50ICYmIHRoaXMuY3VycmVudC5iYXNlVGV4dHVyZS5hbHBoYU1vZGUgPiAwIHx8ICF0aGlzLmN1cnJlbnQgJiYgdGhpcy5fcmVuZGVyZXJQcmVtdWx0aXBsaWVkQWxwaGEpICYmIGNvbG9yJDEucHJlbXVsdGlwbHkoY29sb3IkMS5hbHBoYSk7XG4gICAgY29uc3QgZGVzdGluYXRpb25GcmFtZSA9IHRoaXMuZGVzdGluYXRpb25GcmFtZSwgYmFzZUZyYW1lID0gdGhpcy5jdXJyZW50ID8gdGhpcy5jdXJyZW50LmJhc2VUZXh0dXJlIDogdGhpcy5yZW5kZXJlci5fdmlldy5zY3JlZW4sIGNsZWFyTWFzayA9IGRlc3RpbmF0aW9uRnJhbWUud2lkdGggIT09IGJhc2VGcmFtZS53aWR0aCB8fCBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAhPT0gYmFzZUZyYW1lLmhlaWdodDtcbiAgICBpZiAoY2xlYXJNYXNrKSB7XG4gICAgICBsZXQgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLnZpZXdwb3J0RnJhbWU7XG4gICAgICB4ID0gTWF0aC5yb3VuZCh4KSwgeSA9IE1hdGgucm91bmQoeSksIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCksIGhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KSwgdGhpcy5yZW5kZXJlci5nbC5lbmFibGUodGhpcy5yZW5kZXJlci5nbC5TQ0lTU09SX1RFU1QpLCB0aGlzLnJlbmRlcmVyLmdsLnNjaXNzb3IoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIuZnJhbWVidWZmZXIuY2xlYXIoY29sb3IkMS5yZWQsIGNvbG9yJDEuZ3JlZW4sIGNvbG9yJDEuYmx1ZSwgY29sb3IkMS5hbHBoYSwgbWFzayksIGNsZWFyTWFzayAmJiB0aGlzLnJlbmRlcmVyLnNjaXNzb3IucG9wKCk7XG4gIH1cbiAgcmVzaXplKCkge1xuICAgIHRoaXMuYmluZChudWxsKTtcbiAgfVxuICAvKiogUmVzZXRzIHJlbmRlci10ZXh0dXJlIHN0YXRlLiAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLmJpbmQobnVsbCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuUmVuZGVyVGV4dHVyZVN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJyZW5kZXJUZXh0dXJlXCJcbn07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKFJlbmRlclRleHR1cmVTeXN0ZW0pO1xuZXhwb3J0cy5SZW5kZXJUZXh0dXJlU3lzdGVtID0gUmVuZGVyVGV4dHVyZVN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlbmRlclRleHR1cmVTeXN0ZW0uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBleHRlbnNpb25zID0gcmVxdWlyZShcIkBwaXhpL2V4dGVuc2lvbnNcIik7XG5jbGFzcyBPYmplY3RSZW5kZXJlclN5c3RlbSB7XG4gIC8vIHJlbmRlcmVycyBzY2VuZSBncmFwaCFcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBpdHMgV2ViR0wgdmlldy5cbiAgICogQHBhcmFtIGRpc3BsYXlPYmplY3QgLSBUaGUgb2JqZWN0IHRvIGJlIHJlbmRlcmVkLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byB0aGUgcmVuZGVyZXJcbiAgICovXG4gIHJlbmRlcihkaXNwbGF5T2JqZWN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGxldCByZW5kZXJUZXh0dXJlLCBjbGVhciwgdHJhbnNmb3JtLCBza2lwVXBkYXRlVHJhbnNmb3JtO1xuICAgIGlmIChvcHRpb25zICYmIChyZW5kZXJUZXh0dXJlID0gb3B0aW9ucy5yZW5kZXJUZXh0dXJlLCBjbGVhciA9IG9wdGlvbnMuY2xlYXIsIHRyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtLCBza2lwVXBkYXRlVHJhbnNmb3JtID0gb3B0aW9ucy5za2lwVXBkYXRlVHJhbnNmb3JtKSwgdGhpcy5yZW5kZXJpbmdUb1NjcmVlbiA9ICFyZW5kZXJUZXh0dXJlLCByZW5kZXJlci5ydW5uZXJzLnByZXJlbmRlci5lbWl0KCksIHJlbmRlcmVyLmVtaXQoXCJwcmVyZW5kZXJcIiksIHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtID0gdHJhbnNmb3JtLCAhcmVuZGVyZXIuY29udGV4dC5pc0xvc3QpIHtcbiAgICAgIGlmIChyZW5kZXJUZXh0dXJlIHx8ICh0aGlzLmxhc3RPYmplY3RSZW5kZXJlZCA9IGRpc3BsYXlPYmplY3QpLCAhc2tpcFVwZGF0ZVRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBjYWNoZVBhcmVudCA9IGRpc3BsYXlPYmplY3QuZW5hYmxlVGVtcFBhcmVudCgpO1xuICAgICAgICBkaXNwbGF5T2JqZWN0LnVwZGF0ZVRyYW5zZm9ybSgpLCBkaXNwbGF5T2JqZWN0LmRpc2FibGVUZW1wUGFyZW50KGNhY2hlUGFyZW50KTtcbiAgICAgIH1cbiAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChyZW5kZXJUZXh0dXJlKSwgcmVuZGVyZXIuYmF0Y2guY3VycmVudFJlbmRlcmVyLnN0YXJ0KCksIChjbGVhciA/PyByZW5kZXJlci5iYWNrZ3JvdW5kLmNsZWFyQmVmb3JlUmVuZGVyKSAmJiByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmNsZWFyKCksIGRpc3BsYXlPYmplY3QucmVuZGVyKHJlbmRlcmVyKSwgcmVuZGVyZXIuYmF0Y2guY3VycmVudFJlbmRlcmVyLmZsdXNoKCksIHJlbmRlclRleHR1cmUgJiYgKG9wdGlvbnMuYmxpdCAmJiByZW5kZXJlci5mcmFtZWJ1ZmZlci5ibGl0KCksIHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUudXBkYXRlKCkpLCByZW5kZXJlci5ydW5uZXJzLnBvc3RyZW5kZXIuZW1pdCgpLCByZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSA9IG51bGwsIHJlbmRlcmVyLmVtaXQoXCJwb3N0cmVuZGVyXCIpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsLCB0aGlzLmxhc3RPYmplY3RSZW5kZXJlZCA9IG51bGw7XG4gIH1cbn1cbk9iamVjdFJlbmRlcmVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcIm9iamVjdFJlbmRlcmVyXCJcbn07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKE9iamVjdFJlbmRlcmVyU3lzdGVtKTtcbmV4cG9ydHMuT2JqZWN0UmVuZGVyZXJTeXN0ZW0gPSBPYmplY3RSZW5kZXJlclN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdFJlbmRlcmVyU3lzdGVtLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKSwgc2V0dGluZ3MgPSByZXF1aXJlKFwiQHBpeGkvc2V0dGluZ3NcIiksIHV0aWxzID0gcmVxdWlyZShcIkBwaXhpL3V0aWxzXCIpLCBCYXRjaFJlbmRlcmVyID0gcmVxdWlyZShcIi4vYmF0Y2gvQmF0Y2hSZW5kZXJlci5qc1wiKSwgRmlsdGVyID0gcmVxdWlyZShcIi4vZmlsdGVycy9GaWx0ZXIuanNcIiksIFByb2dyYW0gPSByZXF1aXJlKFwiLi9zaGFkZXIvUHJvZ3JhbS5qc1wiKTtcbnJlcXVpcmUoXCIuL3N5c3RlbXMuanNcIik7XG52YXIgQmFzZVRleHR1cmUgPSByZXF1aXJlKFwiLi90ZXh0dXJlcy9CYXNlVGV4dHVyZS5qc1wiKSwgQ29udGV4dFN5c3RlbSA9IHJlcXVpcmUoXCIuL2NvbnRleHQvQ29udGV4dFN5c3RlbS5qc1wiKSwgQmFja2dyb3VuZFN5c3RlbSA9IHJlcXVpcmUoXCIuL2JhY2tncm91bmQvQmFja2dyb3VuZFN5c3RlbS5qc1wiKSwgVmlld1N5c3RlbSA9IHJlcXVpcmUoXCIuL3ZpZXcvVmlld1N5c3RlbS5qc1wiKSwgU3RhcnR1cFN5c3RlbSA9IHJlcXVpcmUoXCIuL3N0YXJ0dXAvU3RhcnR1cFN5c3RlbS5qc1wiKSwgVGV4dHVyZUdDU3lzdGVtID0gcmVxdWlyZShcIi4vdGV4dHVyZXMvVGV4dHVyZUdDU3lzdGVtLmpzXCIpO1xuc2V0dGluZ3Muc2V0dGluZ3MuUFJFRkVSX0VOViA9IGNvbnN0YW50cy5FTlYuV0VCR0wyO1xuc2V0dGluZ3Muc2V0dGluZ3MuU1RSSUNUX1RFWFRVUkVfQ0FDSEUgPSAhMTtcbnNldHRpbmdzLnNldHRpbmdzLlJFTkRFUl9PUFRJT05TID0ge1xuICAuLi5Db250ZXh0U3lzdGVtLkNvbnRleHRTeXN0ZW0uZGVmYXVsdE9wdGlvbnMsXG4gIC4uLkJhY2tncm91bmRTeXN0ZW0uQmFja2dyb3VuZFN5c3RlbS5kZWZhdWx0T3B0aW9ucyxcbiAgLi4uVmlld1N5c3RlbS5WaWV3U3lzdGVtLmRlZmF1bHRPcHRpb25zLFxuICAuLi5TdGFydHVwU3lzdGVtLlN0YXJ0dXBTeXN0ZW0uZGVmYXVsdE9wdGlvbnNcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhzZXR0aW5ncy5zZXR0aW5ncywge1xuICAvKipcbiAgICogQHN0YXRpY1xuICAgKiBAbmFtZSBXUkFQX01PREVcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge1BJWEkuV1JBUF9NT0RFU31cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4xLjBcbiAgICogQHNlZSBQSVhJLkJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLndyYXBNb2RlXG4gICAqL1xuICBXUkFQX01PREU6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gQmFzZVRleHR1cmUuQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMud3JhcE1vZGU7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5XUkFQX01PREUgaXMgZGVwcmVjYXRlZCwgdXNlIEJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLndyYXBNb2RlXCIpLCBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy53cmFwTW9kZSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEBzdGF0aWNcbiAgICogQG5hbWUgU0NBTEVfTU9ERVxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7UElYSS5TQ0FMRV9NT0RFU31cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4xLjBcbiAgICogQHNlZSBQSVhJLkJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLnNjYWxlTW9kZVxuICAgKi9cbiAgU0NBTEVfTU9ERToge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5zY2FsZU1vZGU7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5TQ0FMRV9NT0RFIGlzIGRlcHJlY2F0ZWQsIHVzZSBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5zY2FsZU1vZGVcIiksIEJhc2VUZXh0dXJlLkJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLnNjYWxlTW9kZSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEBzdGF0aWNcbiAgICogQG5hbWUgTUlQTUFQX1RFWFRVUkVTXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtQSVhJLk1JUE1BUF9NT0RFU31cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4xLjBcbiAgICogQHNlZSBQSVhJLkJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLm1pcG1hcFxuICAgKi9cbiAgTUlQTUFQX1RFWFRVUkVTOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIEJhc2VUZXh0dXJlLkJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLm1pcG1hcDtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLk1JUE1BUF9URVhUVVJFUyBpcyBkZXByZWNhdGVkLCB1c2UgQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMubWlwbWFwXCIpLCBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5taXBtYXAgPSB2YWx1ZTtcbiAgICB9XG4gICAgLy8gTUlQTUFQX01PREVTLlBPVzIsXG4gIH0sXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBuYW1lIEFOSVNPVFJPUElDX0xFVkVMXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5hbmlzb3Ryb3BpY0xldmVsXG4gICAqL1xuICBBTklTT1RST1BJQ19MRVZFTDoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5hbmlzb3Ryb3BpY0xldmVsO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGlvbihcbiAgICAgICAgXCI3LjEuMFwiLFxuICAgICAgICBcInNldHRpbmdzLkFOSVNPVFJPUElDX0xFVkVMIGlzIGRlcHJlY2F0ZWQsIHVzZSBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5hbmlzb3Ryb3BpY0xldmVsXCJcbiAgICAgICksIEJhc2VUZXh0dXJlLkJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLmFuaXNvdHJvcGljTGV2ZWwgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBEZWZhdWx0IGZpbHRlciByZXNvbHV0aW9uLlxuICAgKiBAc3RhdGljXG4gICAqIEBuYW1lIEZJTFRFUl9SRVNPTFVUSU9OXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEB0eXBlIHtudW1iZXJ8bnVsbH1cbiAgICogQHNlZSBQSVhJLkZpbHRlci5kZWZhdWx0UmVzb2x1dGlvblxuICAgKi9cbiAgRklMVEVSX1JFU09MVVRJT046IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLkZJTFRFUl9SRVNPTFVUSU9OIGlzIGRlcHJlY2F0ZWQsIHVzZSBGaWx0ZXIuZGVmYXVsdFJlc29sdXRpb25cIiksIEZpbHRlci5GaWx0ZXIuZGVmYXVsdFJlc29sdXRpb247XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIEZpbHRlci5GaWx0ZXIuZGVmYXVsdFJlc29sdXRpb24gPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBEZWZhdWx0IGZpbHRlciBzYW1wbGVzLlxuICAgKiBAc3RhdGljXG4gICAqIEBuYW1lIEZJTFRFUl9NVUxUSVNBTVBMRVxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKiBAdHlwZSB7UElYSS5NU0FBX1FVQUxJVFl9XG4gICAqIEBzZWUgUElYSS5GaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlXG4gICAqL1xuICBGSUxURVJfTVVMVElTQU1QTEU6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLkZJTFRFUl9NVUxUSVNBTVBMRSBpcyBkZXByZWNhdGVkLCB1c2UgRmlsdGVyLmRlZmF1bHRNdWx0aXNhbXBsZVwiKSwgRmlsdGVyLkZpbHRlci5kZWZhdWx0TXVsdGlzYW1wbGU7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIEZpbHRlci5GaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogVGhlIG1heGltdW0gdGV4dHVyZXMgdGhhdCB0aGlzIGRldmljZSBzdXBwb3J0cy5cbiAgICogQHN0YXRpY1xuICAgKiBAbmFtZSBTUFJJVEVfTUFYX1RFWFRVUkVTXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5CYXRjaFJlbmRlcmVyLmRlZmF1bHRNYXhUZXh0dXJlc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgU1BSSVRFX01BWF9URVhUVVJFUzoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXRjaFJlbmRlcmVyLkJhdGNoUmVuZGVyZXIuZGVmYXVsdE1heFRleHR1cmVzO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuU1BSSVRFX01BWF9URVhUVVJFUyBpcyBkZXByZWNhdGVkLCB1c2UgQmF0Y2hSZW5kZXJlci5kZWZhdWx0TWF4VGV4dHVyZXNcIiksIEJhdGNoUmVuZGVyZXIuQmF0Y2hSZW5kZXJlci5kZWZhdWx0TWF4VGV4dHVyZXMgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBzcHJpdGUgYmF0Y2ggc2l6ZS5cbiAgICpcbiAgICogVGhlIGRlZmF1bHQgYWltcyB0byBiYWxhbmNlIGRlc2t0b3AgYW5kIG1vYmlsZSBkZXZpY2VzLlxuICAgKiBAc3RhdGljXG4gICAqIEBuYW1lIFNQUklURV9CQVRDSF9TSVpFXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEBzZWUgUElYSS5CYXRjaFJlbmRlcmVyLmRlZmF1bHRCYXRjaFNpemVcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4xLjBcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIFNQUklURV9CQVRDSF9TSVpFOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIEJhdGNoUmVuZGVyZXIuQmF0Y2hSZW5kZXJlci5kZWZhdWx0QmF0Y2hTaXplO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuU1BSSVRFX0JBVENIX1NJWkUgaXMgZGVwcmVjYXRlZCwgdXNlIEJhdGNoUmVuZGVyZXIuZGVmYXVsdEJhdGNoU2l6ZVwiKSwgQmF0Y2hSZW5kZXJlci5CYXRjaFJlbmRlcmVyLmRlZmF1bHRCYXRjaFNpemUgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBDYW4gd2UgdXBsb2FkIHRoZSBzYW1lIGJ1ZmZlciBpbiBhIHNpbmdsZSBmcmFtZT9cbiAgICogQHN0YXRpY1xuICAgKiBAbmFtZSBDQU5fVVBMT0FEX1NBTUVfQlVGRkVSXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEBzZWUgUElYSS5CYXRjaFJlbmRlcmVyLmNhblVwbG9hZFNhbWVCdWZmZXJcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4xLjBcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBDQU5fVVBMT0FEX1NBTUVfQlVGRkVSOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIEJhdGNoUmVuZGVyZXIuQmF0Y2hSZW5kZXJlci5jYW5VcGxvYWRTYW1lQnVmZmVyO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuQ0FOX1VQTE9BRF9TQU1FX0JVRkZFUiBpcyBkZXByZWNhdGVkLCB1c2UgQmF0Y2hSZW5kZXJlci5jYW5VcGxvYWRTYW1lQnVmZmVyXCIpLCBCYXRjaFJlbmRlcmVyLkJhdGNoUmVuZGVyZXIuY2FuVXBsb2FkU2FtZUJ1ZmZlciA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIERlZmF1bHQgR2FyYmFnZSBDb2xsZWN0aW9uIG1vZGUuXG4gICAqIEBzdGF0aWNcbiAgICogQG5hbWUgR0NfTU9ERVxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7UElYSS5HQ19NT0RFU31cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4xLjBcbiAgICogQHNlZSBQSVhJLlRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TW9kZVxuICAgKi9cbiAgR0NfTU9ERToge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBUZXh0dXJlR0NTeXN0ZW0uVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNb2RlO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuR0NfTU9ERSBpcyBkZXByZWNhdGVkLCB1c2UgVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNb2RlXCIpLCBUZXh0dXJlR0NTeXN0ZW0uVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNb2RlID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogRGVmYXVsdCBHYXJiYWdlIENvbGxlY3Rpb24gbWF4IGlkbGUuXG4gICAqIEBzdGF0aWNcbiAgICogQG5hbWUgR0NfTUFYX0lETEVcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4xLjBcbiAgICogQHNlZSBQSVhJLlRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TWF4SWRsZVxuICAgKi9cbiAgR0NfTUFYX0lETEU6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gVGV4dHVyZUdDU3lzdGVtLlRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TWF4SWRsZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLkdDX01BWF9JRExFIGlzIGRlcHJlY2F0ZWQsIHVzZSBUZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE1heElkbGVcIiksIFRleHR1cmVHQ1N5c3RlbS5UZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE1heElkbGUgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBEZWZhdWx0IEdhcmJhZ2UgQ29sbGVjdGlvbiBtYXhpbXVtIGNoZWNrIGNvdW50LlxuICAgKiBAc3RhdGljXG4gICAqIEBuYW1lIEdDX01BWF9DSEVDS19DT1VOVFxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKiBAc2VlIFBJWEkuVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRDaGVja0NvdW50TWF4XG4gICAqL1xuICBHQ19NQVhfQ0hFQ0tfQ09VTlQ6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gVGV4dHVyZUdDU3lzdGVtLlRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0Q2hlY2tDb3VudE1heDtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLkdDX01BWF9DSEVDS19DT1VOVCBpcyBkZXByZWNhdGVkLCB1c2UgVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRDaGVja0NvdW50TWF4XCIpLCBUZXh0dXJlR0NTeXN0ZW0uVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRDaGVja0NvdW50TWF4ID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogRGVmYXVsdCBzcGVjaWZ5IGZsb2F0IHByZWNpc2lvbiBpbiB2ZXJ0ZXggc2hhZGVyLlxuICAgKiBAc3RhdGljXG4gICAqIEBuYW1lIFBSRUNJU0lPTl9WRVJURVhcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge1BJWEkuUFJFQ0lTSU9OfVxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKiBAc2VlIFBJWEkuUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uXG4gICAqL1xuICBQUkVDSVNJT05fVkVSVEVYOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIFByb2dyYW0uUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuUFJFQ0lTSU9OX1ZFUlRFWCBpcyBkZXByZWNhdGVkLCB1c2UgUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uXCIpLCBQcm9ncmFtLlByb2dyYW0uZGVmYXVsdFZlcnRleFByZWNpc2lvbiA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIERlZmF1bHQgc3BlY2lmeSBmbG9hdCBwcmVjaXNpb24gaW4gZnJhZ21lbnQgc2hhZGVyLlxuICAgKiBAc3RhdGljXG4gICAqIEBuYW1lIFBSRUNJU0lPTl9GUkFHTUVOVFxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7UElYSS5QUkVDSVNJT059XG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5Qcm9ncmFtLmRlZmF1bHRGcmFnbWVudFByZWNpc2lvblxuICAgKi9cbiAgUFJFQ0lTSU9OX0ZSQUdNRU5UOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIFByb2dyYW0uUHJvZ3JhbS5kZWZhdWx0RnJhZ21lbnRQcmVjaXNpb247XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5QUkVDSVNJT05fRlJBR01FTlQgaXMgZGVwcmVjYXRlZCwgdXNlIFByb2dyYW0uZGVmYXVsdEZyYWdtZW50UHJlY2lzaW9uXCIpLCBQcm9ncmFtLlByb2dyYW0uZGVmYXVsdEZyYWdtZW50UHJlY2lzaW9uID0gdmFsdWU7XG4gICAgfVxuICB9XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldHRpbmdzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBJR0xVbmlmb3JtRGF0YSB7XG59XG5jbGFzcyBHTFByb2dyYW0ge1xuICAvKipcbiAgICogTWFrZXMgYSBuZXcgUGl4aSBwcm9ncmFtLlxuICAgKiBAcGFyYW0gcHJvZ3JhbSAtIHdlYmdsIHByb2dyYW1cbiAgICogQHBhcmFtIHVuaWZvcm1EYXRhIC0gdW5pZm9ybXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb2dyYW0sIHVuaWZvcm1EYXRhKSB7XG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbSwgdGhpcy51bmlmb3JtRGF0YSA9IHVuaWZvcm1EYXRhLCB0aGlzLnVuaWZvcm1Hcm91cHMgPSB7fSwgdGhpcy51bmlmb3JtRGlydHlHcm91cHMgPSB7fSwgdGhpcy51bmlmb3JtQnVmZmVyQmluZGluZ3MgPSB7fTtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhpcyBwcm9ncmFtLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5pZm9ybURhdGEgPSBudWxsLCB0aGlzLnVuaWZvcm1Hcm91cHMgPSBudWxsLCB0aGlzLnVuaWZvcm1EaXJ0eUdyb3VwcyA9IG51bGwsIHRoaXMudW5pZm9ybUJ1ZmZlckJpbmRpbmdzID0gbnVsbCwgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgfVxufVxuZXhwb3J0cy5HTFByb2dyYW0gPSBHTFByb2dyYW07XG5leHBvcnRzLklHTFVuaWZvcm1EYXRhID0gSUdMVW5pZm9ybURhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HTFByb2dyYW0uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiQHBpeGkvY29uc3RhbnRzXCIpLCB1dGlscyA9IHJlcXVpcmUoXCJAcGl4aS91dGlsc1wiKSwgZGVmYXVsdFByb2dyYW0kMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHRQcm9ncmFtLmZyYWcuanNcIiksIGRlZmF1bHRQcm9ncmFtID0gcmVxdWlyZShcIi4vZGVmYXVsdFByb2dyYW0udmVydC5qc1wiKTtcbnJlcXVpcmUoXCIuL3V0aWxzL2luZGV4LmpzXCIpO1xudmFyIHNldFByZWNpc2lvbiA9IHJlcXVpcmUoXCIuL3V0aWxzL3NldFByZWNpc2lvbi5qc1wiKSwgZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24gPSByZXF1aXJlKFwiLi91dGlscy9nZXRNYXhGcmFnbWVudFByZWNpc2lvbi5qc1wiKTtcbmxldCBVSUQgPSAwO1xuY29uc3QgbmFtZUNhY2hlID0ge30sIF9Qcm9ncmFtID0gY2xhc3MgX1Byb2dyYW0yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB2ZXJ0ZXhTcmMgLSBUaGUgc291cmNlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgKiBAcGFyYW0gZnJhZ21lbnRTcmMgLSBUaGUgc291cmNlIG9mIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBmb3Igc2hhZGVyXG4gICAqIEBwYXJhbSBleHRyYSAtIEV4dHJhIGRhdGEgZm9yIHNoYWRlclxuICAgKi9cbiAgY29uc3RydWN0b3IodmVydGV4U3JjLCBmcmFnbWVudFNyYywgbmFtZSA9IFwicGl4aS1zaGFkZXJcIiwgZXh0cmEgPSB7fSkge1xuICAgIHRoaXMuZXh0cmEgPSB7fSwgdGhpcy5pZCA9IFVJRCsrLCB0aGlzLnZlcnRleFNyYyA9IHZlcnRleFNyYyB8fCBfUHJvZ3JhbTIuZGVmYXVsdFZlcnRleFNyYywgdGhpcy5mcmFnbWVudFNyYyA9IGZyYWdtZW50U3JjIHx8IF9Qcm9ncmFtMi5kZWZhdWx0RnJhZ21lbnRTcmMsIHRoaXMudmVydGV4U3JjID0gdGhpcy52ZXJ0ZXhTcmMudHJpbSgpLCB0aGlzLmZyYWdtZW50U3JjID0gdGhpcy5mcmFnbWVudFNyYy50cmltKCksIHRoaXMuZXh0cmEgPSBleHRyYSwgdGhpcy52ZXJ0ZXhTcmMuc3Vic3RyaW5nKDAsIDgpICE9PSBcIiN2ZXJzaW9uXCIgJiYgKG5hbWUgPSBuYW1lLnJlcGxhY2UoL1xccysvZywgXCItXCIpLCBuYW1lQ2FjaGVbbmFtZV0gPyAobmFtZUNhY2hlW25hbWVdKyssIG5hbWUgKz0gYC0ke25hbWVDYWNoZVtuYW1lXX1gKSA6IG5hbWVDYWNoZVtuYW1lXSA9IDEsIHRoaXMudmVydGV4U3JjID0gYCNkZWZpbmUgU0hBREVSX05BTUUgJHtuYW1lfVxuJHt0aGlzLnZlcnRleFNyY31gLCB0aGlzLmZyYWdtZW50U3JjID0gYCNkZWZpbmUgU0hBREVSX05BTUUgJHtuYW1lfVxuJHt0aGlzLmZyYWdtZW50U3JjfWAsIHRoaXMudmVydGV4U3JjID0gc2V0UHJlY2lzaW9uLnNldFByZWNpc2lvbihcbiAgICAgIHRoaXMudmVydGV4U3JjLFxuICAgICAgX1Byb2dyYW0yLmRlZmF1bHRWZXJ0ZXhQcmVjaXNpb24sXG4gICAgICBjb25zdGFudHMuUFJFQ0lTSU9OLkhJR0hcbiAgICApLCB0aGlzLmZyYWdtZW50U3JjID0gc2V0UHJlY2lzaW9uLnNldFByZWNpc2lvbihcbiAgICAgIHRoaXMuZnJhZ21lbnRTcmMsXG4gICAgICBfUHJvZ3JhbTIuZGVmYXVsdEZyYWdtZW50UHJlY2lzaW9uLFxuICAgICAgZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24uZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24oKVxuICAgICkpLCB0aGlzLmdsUHJvZ3JhbXMgPSB7fSwgdGhpcy5zeW5jVW5pZm9ybXMgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCB2ZXJ0ZXggc2hhZGVyIHNvdXJjZS5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRWZXJ0ZXhTcmMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRQcm9ncmFtLmRlZmF1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGZyYWdtZW50IHNoYWRlciBzb3VyY2UuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0RnJhZ21lbnRTcmMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRQcm9ncmFtJDEuZGVmYXVsdDtcbiAgfVxuICAvKipcbiAgICogQSBzaG9ydCBoYW5kIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHByb2dyYW0gYmFzZWQgb2YgYSB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlci5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBhbHNvIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhIGNhY2hlZCBwcm9ncmFtLlxuICAgKiBAcGFyYW0gdmVydGV4U3JjIC0gVGhlIHNvdXJjZSBvZiB0aGUgdmVydGV4IHNoYWRlci5cbiAgICogQHBhcmFtIGZyYWdtZW50U3JjIC0gVGhlIHNvdXJjZSBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgZm9yIHNoYWRlclxuICAgKiBAcmV0dXJucyBBIHNoaW55IG5ldyBQaXhpSlMgc2hhZGVyIHByb2dyYW0hXG4gICAqL1xuICBzdGF0aWMgZnJvbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBuYW1lKSB7XG4gICAgY29uc3Qga2V5ID0gdmVydGV4U3JjICsgZnJhZ21lbnRTcmM7XG4gICAgbGV0IHByb2dyYW0gPSB1dGlscy5Qcm9ncmFtQ2FjaGVba2V5XTtcbiAgICByZXR1cm4gcHJvZ3JhbSB8fCAodXRpbHMuUHJvZ3JhbUNhY2hlW2tleV0gPSBwcm9ncmFtID0gbmV3IF9Qcm9ncmFtMih2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBuYW1lKSksIHByb2dyYW07XG4gIH1cbn07XG5fUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uID0gY29uc3RhbnRzLlBSRUNJU0lPTi5ISUdILCAvKipcbiogRGVmYXVsdCBzcGVjaWZ5IGZsb2F0IHByZWNpc2lvbiBpbiBmcmFnbWVudCBzaGFkZXIuXG4qIGlPUyBpcyBiZXN0IHNldCBhdCBoaWdocCBkdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpanMvaXNzdWVzLzM3NDJcbiogQHN0YXRpY1xuKiBAdHlwZSB7UElYSS5QUkVDSVNJT059XG4qIEBkZWZhdWx0IFBJWEkuUFJFQ0lTSU9OLk1FRElVTVxuKi9cbl9Qcm9ncmFtLmRlZmF1bHRGcmFnbWVudFByZWNpc2lvbiA9IHV0aWxzLmlzTW9iaWxlLmFwcGxlLmRldmljZSA/IGNvbnN0YW50cy5QUkVDSVNJT04uSElHSCA6IGNvbnN0YW50cy5QUkVDSVNJT04uTUVESVVNO1xubGV0IFByb2dyYW0gPSBfUHJvZ3JhbTtcbmV4cG9ydHMuUHJvZ3JhbSA9IFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcm9ncmFtLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcnVubmVyID0gcmVxdWlyZShcIkBwaXhpL3J1bm5lclwiKSwgUHJvZ3JhbSA9IHJlcXVpcmUoXCIuL1Byb2dyYW0uanNcIiksIFVuaWZvcm1Hcm91cCA9IHJlcXVpcmUoXCIuL1VuaWZvcm1Hcm91cC5qc1wiKTtcbmNsYXNzIFNoYWRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gcHJvZ3JhbSAtIFRoZSBwcm9ncmFtIHRoZSBzaGFkZXIgd2lsbCB1c2UuXG4gICAqIEBwYXJhbSB1bmlmb3JtcyAtIEN1c3RvbSB1bmlmb3JtcyB0byB1c2UgdG8gYXVnbWVudCB0aGUgYnVpbHQtaW4gb25lcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb2dyYW0sIHVuaWZvcm1zKSB7XG4gICAgdGhpcy51bmlmb3JtQmluZENvdW50ID0gMCwgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbSwgdW5pZm9ybXMgPyB1bmlmb3JtcyBpbnN0YW5jZW9mIFVuaWZvcm1Hcm91cC5Vbmlmb3JtR3JvdXAgPyB0aGlzLnVuaWZvcm1Hcm91cCA9IHVuaWZvcm1zIDogdGhpcy51bmlmb3JtR3JvdXAgPSBuZXcgVW5pZm9ybUdyb3VwLlVuaWZvcm1Hcm91cCh1bmlmb3JtcykgOiB0aGlzLnVuaWZvcm1Hcm91cCA9IG5ldyBVbmlmb3JtR3JvdXAuVW5pZm9ybUdyb3VwKHt9KSwgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IHJ1bm5lci5SdW5uZXIoXCJkaXNwb3NlU2hhZGVyXCIpO1xuICB9XG4gIC8vIFRPRE8gbW92ZSB0byBzaGFkZXIgc3lzdGVtLi5cbiAgY2hlY2tVbmlmb3JtRXhpc3RzKG5hbWUsIGdyb3VwKSB7XG4gICAgaWYgKGdyb3VwLnVuaWZvcm1zW25hbWVdKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGZvciAoY29uc3QgaSBpbiBncm91cC51bmlmb3Jtcykge1xuICAgICAgY29uc3QgdW5pZm9ybSA9IGdyb3VwLnVuaWZvcm1zW2ldO1xuICAgICAgaWYgKHVuaWZvcm0uZ3JvdXAgPT09ICEwICYmIHRoaXMuY2hlY2tVbmlmb3JtRXhpc3RzKG5hbWUsIHVuaWZvcm0pKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5pZm9ybUdyb3VwID0gbnVsbCwgdGhpcy5kaXNwb3NlUnVubmVyLmVtaXQodGhpcyksIHRoaXMuZGlzcG9zZVJ1bm5lci5kZXN0cm95KCk7XG4gIH1cbiAgLyoqXG4gICAqIFNoYWRlciB1bmlmb3JtIHZhbHVlcywgc2hvcnRjdXQgZm9yIGB1bmlmb3JtR3JvdXAudW5pZm9ybXNgLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB1bmlmb3JtcygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3JtR3JvdXAudW5pZm9ybXM7XG4gIH1cbiAgLyoqXG4gICAqIEEgc2hvcnQgaGFuZCBmdW5jdGlvbiB0byBjcmVhdGUgYSBzaGFkZXIgYmFzZWQgb2YgYSB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlci5cbiAgICogQHBhcmFtIHZlcnRleFNyYyAtIFRoZSBzb3VyY2Ugb2YgdGhlIHZlcnRleCBzaGFkZXIuXG4gICAqIEBwYXJhbSBmcmFnbWVudFNyYyAtIFRoZSBzb3VyY2Ugb2YgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICogQHBhcmFtIHVuaWZvcm1zIC0gQ3VzdG9tIHVuaWZvcm1zIHRvIHVzZSB0byBhdWdtZW50IHRoZSBidWlsdC1pbiBvbmVzLlxuICAgKiBAcmV0dXJucyBBIHNoaW55IG5ldyBQaXhpSlMgc2hhZGVyIVxuICAgKi9cbiAgc3RhdGljIGZyb20odmVydGV4U3JjLCBmcmFnbWVudFNyYywgdW5pZm9ybXMpIHtcbiAgICBjb25zdCBwcm9ncmFtID0gUHJvZ3JhbS5Qcm9ncmFtLmZyb20odmVydGV4U3JjLCBmcmFnbWVudFNyYyk7XG4gICAgcmV0dXJuIG5ldyBTaGFkZXIocHJvZ3JhbSwgdW5pZm9ybXMpO1xuICB9XG59XG5leHBvcnRzLlNoYWRlciA9IFNoYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNoYWRlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4dGVuc2lvbnMgPSByZXF1aXJlKFwiQHBpeGkvZXh0ZW5zaW9uc1wiKTtcbnJlcXVpcmUoXCIuL3V0aWxzL2luZGV4LmpzXCIpO1xudmFyIGdlbmVyYXRlUHJvZ3JhbSA9IHJlcXVpcmUoXCIuL3V0aWxzL2dlbmVyYXRlUHJvZ3JhbS5qc1wiKSwgZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYyA9IHJlcXVpcmUoXCIuL3V0aWxzL2dlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMuanNcIiksIHVuc2FmZUV2YWxTdXBwb3J0ZWQgPSByZXF1aXJlKFwiLi91dGlscy91bnNhZmVFdmFsU3VwcG9ydGVkLmpzXCIpLCBnZW5lcmF0ZVVuaWZvcm1zU3luYyA9IHJlcXVpcmUoXCIuL3V0aWxzL2dlbmVyYXRlVW5pZm9ybXNTeW5jLmpzXCIpO1xubGV0IFVJRCA9IDA7XG5jb25zdCBkZWZhdWx0U3luY0RhdGEgPSB7IHRleHR1cmVDb3VudDogMCwgdWJvQ291bnQ6IDAgfTtcbmNsYXNzIFNoYWRlclN5c3RlbSB7XG4gIC8qKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBTeXN0ZW0gd29ya3MgZm9yLiAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuZGVzdHJveWVkID0gITEsIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlciwgdGhpcy5zeXN0ZW1DaGVjaygpLCB0aGlzLmdsID0gbnVsbCwgdGhpcy5zaGFkZXIgPSBudWxsLCB0aGlzLnByb2dyYW0gPSBudWxsLCB0aGlzLmNhY2hlID0ge30sIHRoaXMuX3Vib0NhY2hlID0ge30sIHRoaXMuaWQgPSBVSUQrKztcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGVhYmxlIGZ1bmN0aW9uIGJ5IGBAcGl4aS91bnNhZmUtZXZhbGAgdG8gc2lsZW5jZVxuICAgKiB0aHJvd2luZyBhbiBlcnJvciBpZiBwbGF0Zm9ybSBkb2Vzbid0IHN1cHBvcnQgdW5zYWZlLWV2YWxzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3lzdGVtQ2hlY2soKSB7XG4gICAgaWYgKCF1bnNhZmVFdmFsU3VwcG9ydGVkLnVuc2FmZUV2YWxTdXBwb3J0ZWQoKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3QgYWxsb3cgdW5zYWZlLWV2YWwsIHBsZWFzZSB1c2UgQHBpeGkvdW5zYWZlLWV2YWwgbW9kdWxlIHRvIGVuYWJsZSBzdXBwb3J0LlwiKTtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKGdsKSB7XG4gICAgdGhpcy5nbCA9IGdsLCB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgc2hhZGVyIHRvIHRoZSBvbmUgZ2l2ZW4gaW4gcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0gc2hhZGVyIC0gdGhlIG5ldyBzaGFkZXJcbiAgICogQHBhcmFtIGRvbnRTeW5jIC0gZmFsc2UgaWYgdGhlIHNoYWRlciBzaG91bGQgYXV0b21hdGljYWxseSBzeW5jIGl0cyB1bmlmb3Jtcy5cbiAgICogQHJldHVybnMgdGhlIGdsUHJvZ3JhbSB0aGF0IGJlbG9uZ3MgdG8gdGhlIHNoYWRlci5cbiAgICovXG4gIGJpbmQoc2hhZGVyLCBkb250U3luYykge1xuICAgIHNoYWRlci5kaXNwb3NlUnVubmVyLmFkZCh0aGlzKSwgc2hhZGVyLnVuaWZvcm1zLmdsb2JhbHMgPSB0aGlzLnJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zO1xuICAgIGNvbnN0IHByb2dyYW0gPSBzaGFkZXIucHJvZ3JhbSwgZ2xQcm9ncmFtID0gcHJvZ3JhbS5nbFByb2dyYW1zW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdIHx8IHRoaXMuZ2VuZXJhdGVQcm9ncmFtKHNoYWRlcik7XG4gICAgcmV0dXJuIHRoaXMuc2hhZGVyID0gc2hhZGVyLCB0aGlzLnByb2dyYW0gIT09IHByb2dyYW0gJiYgKHRoaXMucHJvZ3JhbSA9IHByb2dyYW0sIHRoaXMuZ2wudXNlUHJvZ3JhbShnbFByb2dyYW0ucHJvZ3JhbSkpLCBkb250U3luYyB8fCAoZGVmYXVsdFN5bmNEYXRhLnRleHR1cmVDb3VudCA9IDAsIGRlZmF1bHRTeW5jRGF0YS51Ym9Db3VudCA9IDAsIHRoaXMuc3luY1VuaWZvcm1Hcm91cChzaGFkZXIudW5pZm9ybUdyb3VwLCBkZWZhdWx0U3luY0RhdGEpKSwgZ2xQcm9ncmFtO1xuICB9XG4gIC8qKlxuICAgKiBVcGxvYWRzIHRoZSB1bmlmb3JtcyB2YWx1ZXMgdG8gdGhlIGN1cnJlbnRseSBib3VuZCBzaGFkZXIuXG4gICAqIEBwYXJhbSB1bmlmb3JtcyAtIHRoZSB1bmlmb3JtcyB2YWx1ZXMgdGhhdCBiZSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHNoYWRlclxuICAgKi9cbiAgc2V0VW5pZm9ybXModW5pZm9ybXMpIHtcbiAgICBjb25zdCBzaGFkZXIgPSB0aGlzLnNoYWRlci5wcm9ncmFtLCBnbFByb2dyYW0gPSBzaGFkZXIuZ2xQcm9ncmFtc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXTtcbiAgICBzaGFkZXIuc3luY1VuaWZvcm1zKGdsUHJvZ3JhbS51bmlmb3JtRGF0YSwgdW5pZm9ybXMsIHRoaXMucmVuZGVyZXIpO1xuICB9XG4gIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXMgKi9cbiAgLyoqXG4gICAqIFN5bmNzIHVuaWZvcm1zIG9uIHRoZSBncm91cFxuICAgKiBAcGFyYW0gZ3JvdXAgLSB0aGUgdW5pZm9ybSBncm91cCB0byBzeW5jXG4gICAqIEBwYXJhbSBzeW5jRGF0YSAtIHRoaXMgaXMgZGF0YSB0aGF0IGlzIHBhc3NlZCB0byB0aGUgc3luYyBmdW5jdGlvbiBhbmQgYW55IG5lc3RlZCBzeW5jIGZ1bmN0aW9uc1xuICAgKi9cbiAgc3luY1VuaWZvcm1Hcm91cChncm91cCwgc3luY0RhdGEpIHtcbiAgICBjb25zdCBnbFByb2dyYW0gPSB0aGlzLmdldEdsUHJvZ3JhbSgpO1xuICAgICghZ3JvdXAuc3RhdGljIHx8IGdyb3VwLmRpcnR5SWQgIT09IGdsUHJvZ3JhbS51bmlmb3JtRGlydHlHcm91cHNbZ3JvdXAuaWRdKSAmJiAoZ2xQcm9ncmFtLnVuaWZvcm1EaXJ0eUdyb3Vwc1tncm91cC5pZF0gPSBncm91cC5kaXJ0eUlkLCB0aGlzLnN5bmNVbmlmb3Jtcyhncm91cCwgZ2xQcm9ncmFtLCBzeW5jRGF0YSkpO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZWFibGUgYnkgdGhlIEBwaXhpL3Vuc2FmZS1ldmFsIHBhY2thZ2UgdG8gdXNlIHN0YXRpYyBzeW5jVW5pZm9ybXMgaW5zdGVhZC5cbiAgICogQHBhcmFtIGdyb3VwXG4gICAqIEBwYXJhbSBnbFByb2dyYW1cbiAgICogQHBhcmFtIHN5bmNEYXRhXG4gICAqL1xuICBzeW5jVW5pZm9ybXMoZ3JvdXAsIGdsUHJvZ3JhbSwgc3luY0RhdGEpIHtcbiAgICAoZ3JvdXAuc3luY1VuaWZvcm1zW3RoaXMuc2hhZGVyLnByb2dyYW0uaWRdIHx8IHRoaXMuY3JlYXRlU3luY0dyb3Vwcyhncm91cCkpKGdsUHJvZ3JhbS51bmlmb3JtRGF0YSwgZ3JvdXAudW5pZm9ybXMsIHRoaXMucmVuZGVyZXIsIHN5bmNEYXRhKTtcbiAgfVxuICBjcmVhdGVTeW5jR3JvdXBzKGdyb3VwKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldFNpZ25hdHVyZShncm91cCwgdGhpcy5zaGFkZXIucHJvZ3JhbS51bmlmb3JtRGF0YSwgXCJ1XCIpO1xuICAgIHJldHVybiB0aGlzLmNhY2hlW2lkXSB8fCAodGhpcy5jYWNoZVtpZF0gPSBnZW5lcmF0ZVVuaWZvcm1zU3luYy5nZW5lcmF0ZVVuaWZvcm1zU3luYyhncm91cCwgdGhpcy5zaGFkZXIucHJvZ3JhbS51bmlmb3JtRGF0YSkpLCBncm91cC5zeW5jVW5pZm9ybXNbdGhpcy5zaGFkZXIucHJvZ3JhbS5pZF0gPSB0aGlzLmNhY2hlW2lkXSwgZ3JvdXAuc3luY1VuaWZvcm1zW3RoaXMuc2hhZGVyLnByb2dyYW0uaWRdO1xuICB9XG4gIC8qKlxuICAgKiBTeW5jcyB1bmlmb3JtIGJ1ZmZlcnNcbiAgICogQHBhcmFtIGdyb3VwIC0gdGhlIHVuaWZvcm0gYnVmZmVyIGdyb3VwIHRvIHN5bmNcbiAgICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgdW5pZm9ybSBidWZmZXJcbiAgICovXG4gIHN5bmNVbmlmb3JtQnVmZmVyR3JvdXAoZ3JvdXAsIG5hbWUpIHtcbiAgICBjb25zdCBnbFByb2dyYW0gPSB0aGlzLmdldEdsUHJvZ3JhbSgpO1xuICAgIGlmICghZ3JvdXAuc3RhdGljIHx8IGdyb3VwLmRpcnR5SWQgIT09IDAgfHwgIWdsUHJvZ3JhbS51bmlmb3JtR3JvdXBzW2dyb3VwLmlkXSkge1xuICAgICAgZ3JvdXAuZGlydHlJZCA9IDA7XG4gICAgICBjb25zdCBzeW5jRnVuYyA9IGdsUHJvZ3JhbS51bmlmb3JtR3JvdXBzW2dyb3VwLmlkXSB8fCB0aGlzLmNyZWF0ZVN5bmNCdWZmZXJHcm91cChncm91cCwgZ2xQcm9ncmFtLCBuYW1lKTtcbiAgICAgIGdyb3VwLmJ1ZmZlci51cGRhdGUoKSwgc3luY0Z1bmMoXG4gICAgICAgIGdsUHJvZ3JhbS51bmlmb3JtRGF0YSxcbiAgICAgICAgZ3JvdXAudW5pZm9ybXMsXG4gICAgICAgIHRoaXMucmVuZGVyZXIsXG4gICAgICAgIGRlZmF1bHRTeW5jRGF0YSxcbiAgICAgICAgZ3JvdXAuYnVmZmVyXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcmVyLmJ1ZmZlci5iaW5kQnVmZmVyQmFzZShncm91cC5idWZmZXIsIGdsUHJvZ3JhbS51bmlmb3JtQnVmZmVyQmluZGluZ3NbbmFtZV0pO1xuICB9XG4gIC8qKlxuICAgKiBXaWxsIGNyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgdXBsb2FkcyBhIHVuaWZvcm0gYnVmZmVyIHVzaW5nIHRoZSBTVEQxNDAgc3RhbmRhcmQuXG4gICAqIFRoZSB1cGxvYWQgZnVuY3Rpb24gd2lsbCB0aGVuIGJlIGNhY2hlZCBmb3IgZnV0dXJlIGNhbGxzXG4gICAqIElmIGEgZ3JvdXAgaXMgbWFudWFsbHkgbWFuYWdlZCwgdGhlbiBhIHNpbXBsZSB1cGxvYWQgZnVuY3Rpb24gaXMgZ2VuZXJhdGVkXG4gICAqIEBwYXJhbSBncm91cCAtIHRoZSB1bmlmb3JtIGJ1ZmZlciBncm91cCB0byBzeW5jXG4gICAqIEBwYXJhbSBnbFByb2dyYW0gLSB0aGUgZ2wgcHJvZ3JhbSB0byBhdHRhY2ggdGhlIHVuaWZvcm0gYmluZGluZ3MgdG9cbiAgICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgdW5pZm9ybSBidWZmZXIgKG11c3QgZXhpc3Qgb24gdGhlIHNoYWRlcilcbiAgICovXG4gIGNyZWF0ZVN5bmNCdWZmZXJHcm91cChncm91cCwgZ2xQcm9ncmFtLCBuYW1lKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcy5yZW5kZXJlcjtcbiAgICB0aGlzLnJlbmRlcmVyLmJ1ZmZlci5iaW5kKGdyb3VwLmJ1ZmZlcik7XG4gICAgY29uc3QgdW5pZm9ybUJsb2NrSW5kZXggPSB0aGlzLmdsLmdldFVuaWZvcm1CbG9ja0luZGV4KGdsUHJvZ3JhbS5wcm9ncmFtLCBuYW1lKTtcbiAgICBnbFByb2dyYW0udW5pZm9ybUJ1ZmZlckJpbmRpbmdzW25hbWVdID0gdGhpcy5zaGFkZXIudW5pZm9ybUJpbmRDb3VudCwgZ2wudW5pZm9ybUJsb2NrQmluZGluZyhnbFByb2dyYW0ucHJvZ3JhbSwgdW5pZm9ybUJsb2NrSW5kZXgsIHRoaXMuc2hhZGVyLnVuaWZvcm1CaW5kQ291bnQpLCB0aGlzLnNoYWRlci51bmlmb3JtQmluZENvdW50Kys7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldFNpZ25hdHVyZShncm91cCwgdGhpcy5zaGFkZXIucHJvZ3JhbS51bmlmb3JtRGF0YSwgXCJ1Ym9cIik7XG4gICAgbGV0IHVib0RhdGEgPSB0aGlzLl91Ym9DYWNoZVtpZF07XG4gICAgaWYgKHVib0RhdGEgfHwgKHVib0RhdGEgPSB0aGlzLl91Ym9DYWNoZVtpZF0gPSBnZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jLmdlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMoZ3JvdXAsIHRoaXMuc2hhZGVyLnByb2dyYW0udW5pZm9ybURhdGEpKSwgZ3JvdXAuYXV0b01hbmFnZSkge1xuICAgICAgY29uc3QgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodWJvRGF0YS5zaXplIC8gNCk7XG4gICAgICBncm91cC5idWZmZXIudXBkYXRlKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZ2xQcm9ncmFtLnVuaWZvcm1Hcm91cHNbZ3JvdXAuaWRdID0gdWJvRGF0YS5zeW5jRnVuYywgZ2xQcm9ncmFtLnVuaWZvcm1Hcm91cHNbZ3JvdXAuaWRdO1xuICB9XG4gIC8qKlxuICAgKiBUYWtlcyBhIHVuaWZvcm0gZ3JvdXAgYW5kIGRhdGEgYW5kIGdlbmVyYXRlcyBhIHVuaXF1ZSBzaWduYXR1cmUgZm9yIHRoZW0uXG4gICAqIEBwYXJhbSBncm91cCAtIFRoZSB1bmlmb3JtIGdyb3VwIHRvIGdldCBzaWduYXR1cmUgb2ZcbiAgICogQHBhcmFtIGdyb3VwLnVuaWZvcm1zXG4gICAqIEBwYXJhbSB1bmlmb3JtRGF0YSAtIFVuaWZvcm0gaW5mb3JtYXRpb24gZ2VuZXJhdGVkIGJ5IHRoZSBzaGFkZXJcbiAgICogQHBhcmFtIHByZUZpeFxuICAgKiBAcmV0dXJucyBVbmlxdWUgc2lnbmF0dXJlIG9mIHRoZSB1bmlmb3JtIGdyb3VwXG4gICAqL1xuICBnZXRTaWduYXR1cmUoZ3JvdXAsIHVuaWZvcm1EYXRhLCBwcmVGaXgpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IGdyb3VwLnVuaWZvcm1zLCBzdHJpbmdzID0gW2Ake3ByZUZpeH0tYF07XG4gICAgZm9yIChjb25zdCBpIGluIHVuaWZvcm1zKVxuICAgICAgc3RyaW5ncy5wdXNoKGkpLCB1bmlmb3JtRGF0YVtpXSAmJiBzdHJpbmdzLnB1c2godW5pZm9ybURhdGFbaV0udHlwZSk7XG4gICAgcmV0dXJuIHN0cmluZ3Muam9pbihcIi1cIik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgR0xTaGFkZSByb2YgdGhlIGN1cnJlbnRseSBib3VuZCBzaGFkZXIuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIGhhbmR5IGZvciB3aGVuIHlvdSB0byBoYXZlIGEgbGl0dGxlIG1vcmUgY29udHJvbCBvdmVyIHRoZSBzZXR0aW5nIG9mIHlvdXIgdW5pZm9ybXMuXG4gICAqIEByZXR1cm5zIFRoZSBnbFByb2dyYW0gZm9yIHRoZSBjdXJyZW50bHkgYm91bmQgU2hhZGVyIGZvciB0aGlzIGNvbnRleHRcbiAgICovXG4gIGdldEdsUHJvZ3JhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaGFkZXIgPyB0aGlzLnNoYWRlci5wcm9ncmFtLmdsUHJvZ3JhbXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF0gOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBnbFByb2dyYW0gdmVyc2lvbiBvZiB0aGUgU2hhZGVyIHByb3ZpZGVkLlxuICAgKiBAcGFyYW0gc2hhZGVyIC0gVGhlIHNoYWRlciB0aGF0IHRoZSBnbFByb2dyYW0gd2lsbCBiZSBiYXNlZCBvbi5cbiAgICogQHJldHVybnMgQSBzaGlueSBuZXcgZ2xQcm9ncmFtIVxuICAgKi9cbiAgZ2VuZXJhdGVQcm9ncmFtKHNoYWRlcikge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbCwgcHJvZ3JhbSA9IHNoYWRlci5wcm9ncmFtLCBnbFByb2dyYW0gPSBnZW5lcmF0ZVByb2dyYW0uZ2VuZXJhdGVQcm9ncmFtKGdsLCBwcm9ncmFtKTtcbiAgICByZXR1cm4gcHJvZ3JhbS5nbFByb2dyYW1zW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdID0gZ2xQcm9ncmFtLCBnbFByb2dyYW07XG4gIH1cbiAgLyoqIFJlc2V0cyBTaGFkZXJTeXN0ZW0gc3RhdGUsIGRvZXMgbm90IGFmZmVjdCBXZWJHTCBzdGF0ZS4gKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbCwgdGhpcy5zaGFkZXIgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBEaXNwb3NlcyBzaGFkZXIuXG4gICAqIElmIGRpc3Bvc2luZyBvbmUgZXF1YWxzIHdpdGggY3VycmVudCBzaGFkZXIsIHNldCBjdXJyZW50IGFzIG51bGwuXG4gICAqIEBwYXJhbSBzaGFkZXIgLSBTaGFkZXIgb2JqZWN0XG4gICAqL1xuICBkaXNwb3NlU2hhZGVyKHNoYWRlcikge1xuICAgIHRoaXMuc2hhZGVyID09PSBzaGFkZXIgJiYgKHRoaXMuc2hhZGVyID0gbnVsbCk7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoaXMgU3lzdGVtIGFuZCByZW1vdmVzIGFsbCBpdHMgdGV4dHVyZXMuICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGwsIHRoaXMuZGVzdHJveWVkID0gITA7XG4gIH1cbn1cblNoYWRlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJzaGFkZXJcIlxufTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5hZGQoU2hhZGVyU3lzdGVtKTtcbmV4cG9ydHMuU2hhZGVyU3lzdGVtID0gU2hhZGVyU3lzdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2hhZGVyU3lzdGVtLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKSwgQnVmZmVyID0gcmVxdWlyZShcIi4uL2dlb21ldHJ5L0J1ZmZlci5qc1wiKTtcbmxldCBVSUQgPSAwO1xuY2xhc3MgVW5pZm9ybUdyb3VwIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0IHwgQnVmZmVyfSBbdW5pZm9ybXNdIC0gQ3VzdG9tIHVuaWZvcm1zIHRvIHVzZSB0byBhdWdtZW50IHRoZSBidWlsdC1pbiBvbmVzLiBPciBhIHBpeGkgYnVmZmVyLlxuICAgKiBAcGFyYW0gaXNTdGF0aWMgLSBVbmlmb3JtcyB3b250IGJlIGNoYW5nZWQgYWZ0ZXIgY3JlYXRpb24uXG4gICAqIEBwYXJhbSBpc1VibyAtIElmIHRydWUsIHdpbGwgdHJlYXQgdGhpcyB1bmlmb3JtIGdyb3VwIGFzIGEgdW5pZm9ybSBidWZmZXIgb2JqZWN0LlxuICAgKi9cbiAgY29uc3RydWN0b3IodW5pZm9ybXMsIGlzU3RhdGljLCBpc1Vibykge1xuICAgIHRoaXMuZ3JvdXAgPSAhMCwgdGhpcy5zeW5jVW5pZm9ybXMgPSB7fSwgdGhpcy5kaXJ0eUlkID0gMCwgdGhpcy5pZCA9IFVJRCsrLCB0aGlzLnN0YXRpYyA9ICEhaXNTdGF0aWMsIHRoaXMudWJvID0gISFpc1VibywgdW5pZm9ybXMgaW5zdGFuY2VvZiBCdWZmZXIuQnVmZmVyID8gKHRoaXMuYnVmZmVyID0gdW5pZm9ybXMsIHRoaXMuYnVmZmVyLnR5cGUgPSBjb25zdGFudHMuQlVGRkVSX1RZUEUuVU5JRk9STV9CVUZGRVIsIHRoaXMuYXV0b01hbmFnZSA9ICExLCB0aGlzLnVibyA9ICEwKSA6ICh0aGlzLnVuaWZvcm1zID0gdW5pZm9ybXMsIHRoaXMudWJvICYmICh0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXIuQnVmZmVyKG5ldyBGbG9hdDMyQXJyYXkoMSkpLCB0aGlzLmJ1ZmZlci50eXBlID0gY29uc3RhbnRzLkJVRkZFUl9UWVBFLlVOSUZPUk1fQlVGRkVSLCB0aGlzLmF1dG9NYW5hZ2UgPSAhMCkpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLmRpcnR5SWQrKywgIXRoaXMuYXV0b01hbmFnZSAmJiB0aGlzLmJ1ZmZlciAmJiB0aGlzLmJ1ZmZlci51cGRhdGUoKTtcbiAgfVxuICBhZGQobmFtZSwgdW5pZm9ybXMsIF9zdGF0aWMpIHtcbiAgICBpZiAoIXRoaXMudWJvKVxuICAgICAgdGhpcy51bmlmb3Jtc1tuYW1lXSA9IG5ldyBVbmlmb3JtR3JvdXAodW5pZm9ybXMsIF9zdGF0aWMpO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltVbmlmb3JtR3JvdXBdIHVuaWZvcm0gZ3JvdXBzIGluIHVibyBtb2RlIGNhbm5vdCBiZSBtb2RpZmllZCwgb3IgaGF2ZSB1bmlmb3JtIGdyb3VwcyBuZXN0ZWQgaW4gdGhlbVwiKTtcbiAgfVxuICBzdGF0aWMgZnJvbSh1bmlmb3JtcywgX3N0YXRpYywgX3Vibykge1xuICAgIHJldHVybiBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zLCBfc3RhdGljLCBfdWJvKTtcbiAgfVxuICAvKipcbiAgICogQSBzaG9ydCBoYW5kIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHN0YXRpYyBVQk8gVW5pZm9ybUdyb3VwLlxuICAgKiBAcGFyYW0gdW5pZm9ybXMgLSB0aGUgdWJvIGl0ZW1cbiAgICogQHBhcmFtIF9zdGF0aWMgLSBzaG91bGQgdGhpcyBiZSB1cGRhdGVkIGVhY2ggdGltZSBpdCBpcyB1c2VkPyBkZWZhdWx0cyB0byB0cnVlIGhlcmUhXG4gICAqL1xuICBzdGF0aWMgdWJvRnJvbSh1bmlmb3JtcywgX3N0YXRpYykge1xuICAgIHJldHVybiBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zLCBfc3RhdGljID8/ICEwLCAhMCk7XG4gIH1cbn1cbmV4cG9ydHMuVW5pZm9ybUdyb3VwID0gVW5pZm9ybUdyb3VwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5pZm9ybUdyb3VwLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIGRlZmF1bHRGcmFnbWVudCA9IGB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcblxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG5cbnZvaWQgbWFpbih2b2lkKXtcbiAgIGdsX0ZyYWdDb2xvciAqPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xufWA7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0RnJhZ21lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0UHJvZ3JhbS5mcmFnLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIGRlZmF1bHRWZXJ0ZXggPSBgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcblxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XG5cbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXG52b2lkIG1haW4odm9pZCl7XG4gICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcbiAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xufVxuYDtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRWZXJ0ZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0UHJvZ3JhbS52ZXJ0LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBmcmFnVGVtcGxhdGUgPSBbXG4gIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCIsXG4gIFwidm9pZCBtYWluKHZvaWQpe1wiLFxuICBcImZsb2F0IHRlc3QgPSAwLjE7XCIsXG4gIFwiJWZvcmxvb3AlXCIsXG4gIFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApO1wiLFxuICBcIn1cIlxuXS5qb2luKGBcbmApO1xuZnVuY3Rpb24gZ2VuZXJhdGVJZlRlc3RTcmMobWF4SWZzKSB7XG4gIGxldCBzcmMgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heElmczsgKytpKVxuICAgIGkgPiAwICYmIChzcmMgKz0gYFxuZWxzZSBgKSwgaSA8IG1heElmcyAtIDEgJiYgKHNyYyArPSBgaWYodGVzdCA9PSAke2l9LjApe31gKTtcbiAgcmV0dXJuIHNyYztcbn1cbmZ1bmN0aW9uIGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIobWF4SWZzLCBnbCkge1xuICBpZiAobWF4SWZzID09PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgb2YgYDBgIHBhc3NlZCB0byBgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlcmBcIik7XG4gIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICBmb3IgKDsgOyApIHtcbiAgICBjb25zdCBmcmFnbWVudFNyYyA9IGZyYWdUZW1wbGF0ZS5yZXBsYWNlKC8lZm9ybG9vcCUvZ2ksIGdlbmVyYXRlSWZUZXN0U3JjKG1heElmcykpO1xuICAgIGlmIChnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBmcmFnbWVudFNyYyksIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKSwgIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSlcbiAgICAgIG1heElmcyA9IG1heElmcyAvIDIgfCAwO1xuICAgIGVsc2VcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBtYXhJZnM7XG59XG5leHBvcnRzLmNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIgPSBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gY29tcGlsZVNoYWRlcihnbCwgdHlwZSwgc3JjKSB7XG4gIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgcmV0dXJuIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNyYyksIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKSwgc2hhZGVyO1xufVxuZXhwb3J0cy5jb21waWxlU2hhZGVyID0gY29tcGlsZVNoYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBpbGVTaGFkZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGJvb2xlYW5BcnJheShzaXplKSB7XG4gIGNvbnN0IGFycmF5ID0gbmV3IEFycmF5KHNpemUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuICAgIGFycmF5W2ldID0gITE7XG4gIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRWYWx1ZSh0eXBlLCBzaXplKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSBcInZlYzJcIjpcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KDIgKiBzaXplKTtcbiAgICBjYXNlIFwidmVjM1wiOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoMyAqIHNpemUpO1xuICAgIGNhc2UgXCJ2ZWM0XCI6XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSg0ICogc2l6ZSk7XG4gICAgY2FzZSBcImludFwiOlxuICAgIGNhc2UgXCJ1aW50XCI6XG4gICAgY2FzZSBcInNhbXBsZXIyRFwiOlxuICAgIGNhc2UgXCJzYW1wbGVyMkRBcnJheVwiOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSBcIml2ZWMyXCI6XG4gICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoMiAqIHNpemUpO1xuICAgIGNhc2UgXCJpdmVjM1wiOlxuICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KDMgKiBzaXplKTtcbiAgICBjYXNlIFwiaXZlYzRcIjpcbiAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheSg0ICogc2l6ZSk7XG4gICAgY2FzZSBcInV2ZWMyXCI6XG4gICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KDIgKiBzaXplKTtcbiAgICBjYXNlIFwidXZlYzNcIjpcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoMyAqIHNpemUpO1xuICAgIGNhc2UgXCJ1dmVjNFwiOlxuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheSg0ICogc2l6ZSk7XG4gICAgY2FzZSBcImJvb2xcIjpcbiAgICAgIHJldHVybiAhMTtcbiAgICBjYXNlIFwiYnZlYzJcIjpcbiAgICAgIHJldHVybiBib29sZWFuQXJyYXkoMiAqIHNpemUpO1xuICAgIGNhc2UgXCJidmVjM1wiOlxuICAgICAgcmV0dXJuIGJvb2xlYW5BcnJheSgzICogc2l6ZSk7XG4gICAgY2FzZSBcImJ2ZWM0XCI6XG4gICAgICByZXR1cm4gYm9vbGVhbkFycmF5KDQgKiBzaXplKTtcbiAgICBjYXNlIFwibWF0MlwiOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdKTtcbiAgICBjYXNlIFwibWF0M1wiOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdKTtcbiAgICBjYXNlIFwibWF0NFwiOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdFZhbHVlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgR0xQcm9ncmFtID0gcmVxdWlyZShcIi4uL0dMUHJvZ3JhbS5qc1wiKSwgY29tcGlsZVNoYWRlciA9IHJlcXVpcmUoXCIuL2NvbXBpbGVTaGFkZXIuanNcIiksIGRlZmF1bHRWYWx1ZSA9IHJlcXVpcmUoXCIuL2RlZmF1bHRWYWx1ZS5qc1wiKSwgZ2V0QXR0cmlidXRlRGF0YSA9IHJlcXVpcmUoXCIuL2dldEF0dHJpYnV0ZURhdGEuanNcIiksIGdldFVuaWZvcm1EYXRhID0gcmVxdWlyZShcIi4vZ2V0VW5pZm9ybURhdGEuanNcIiksIGxvZ1Byb2dyYW1FcnJvciA9IHJlcXVpcmUoXCIuL2xvZ1Byb2dyYW1FcnJvci5qc1wiKTtcbmZ1bmN0aW9uIGdlbmVyYXRlUHJvZ3JhbShnbCwgcHJvZ3JhbSkge1xuICBjb25zdCBnbFZlcnRTaGFkZXIgPSBjb21waWxlU2hhZGVyLmNvbXBpbGVTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHByb2dyYW0udmVydGV4U3JjKSwgZ2xGcmFnU2hhZGVyID0gY29tcGlsZVNoYWRlci5jb21waWxlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIHByb2dyYW0uZnJhZ21lbnRTcmMpLCB3ZWJHTFByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIGdsLmF0dGFjaFNoYWRlcih3ZWJHTFByb2dyYW0sIGdsVmVydFNoYWRlciksIGdsLmF0dGFjaFNoYWRlcih3ZWJHTFByb2dyYW0sIGdsRnJhZ1NoYWRlcik7XG4gIGNvbnN0IHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MgPSBwcm9ncmFtLmV4dHJhPy50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzO1xuICBpZiAodHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyAmJiAodHlwZW9mIGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MgIT0gXCJmdW5jdGlvblwiID8gY29uc29sZS53YXJuKFwiVHJhbnNmb3JtRmVlZGJhY2sgaXMgbm90IHN1cHBvcnRlZCBidXQgVHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyBhcmUgZ2l2ZW4uXCIpIDogZ2wudHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyhcbiAgICB3ZWJHTFByb2dyYW0sXG4gICAgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncy5uYW1lcyxcbiAgICB0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzLmJ1ZmZlck1vZGUgPT09IFwic2VwYXJhdGVcIiA/IGdsLlNFUEFSQVRFX0FUVFJJQlMgOiBnbC5JTlRFUkxFQVZFRF9BVFRSSUJTXG4gICkpLCBnbC5saW5rUHJvZ3JhbSh3ZWJHTFByb2dyYW0pLCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHdlYkdMUHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpIHx8IGxvZ1Byb2dyYW1FcnJvci5sb2dQcm9ncmFtRXJyb3IoZ2wsIHdlYkdMUHJvZ3JhbSwgZ2xWZXJ0U2hhZGVyLCBnbEZyYWdTaGFkZXIpLCBwcm9ncmFtLmF0dHJpYnV0ZURhdGEgPSBnZXRBdHRyaWJ1dGVEYXRhLmdldEF0dHJpYnV0ZURhdGEod2ViR0xQcm9ncmFtLCBnbCksIHByb2dyYW0udW5pZm9ybURhdGEgPSBnZXRVbmlmb3JtRGF0YS5nZXRVbmlmb3JtRGF0YSh3ZWJHTFByb2dyYW0sIGdsKSwgIS9eWyBcXHRdKiNbIFxcdF0qdmVyc2lvblsgXFx0XSszMDBbIFxcdF0rZXNbIFxcdF0qJC9tLnRlc3QocHJvZ3JhbS52ZXJ0ZXhTcmMpKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb2dyYW0uYXR0cmlidXRlRGF0YSk7XG4gICAga2V5cy5zb3J0KChhLCBiKSA9PiBhID4gYiA/IDEgOiAtMSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKVxuICAgICAgcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2tleXNbaV1dLmxvY2F0aW9uID0gaSwgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgaSwga2V5c1tpXSk7XG4gICAgZ2wubGlua1Byb2dyYW0od2ViR0xQcm9ncmFtKTtcbiAgfVxuICBnbC5kZWxldGVTaGFkZXIoZ2xWZXJ0U2hhZGVyKSwgZ2wuZGVsZXRlU2hhZGVyKGdsRnJhZ1NoYWRlcik7XG4gIGNvbnN0IHVuaWZvcm1EYXRhID0ge307XG4gIGZvciAoY29uc3QgaSBpbiBwcm9ncmFtLnVuaWZvcm1EYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IHByb2dyYW0udW5pZm9ybURhdGFbaV07XG4gICAgdW5pZm9ybURhdGFbaV0gPSB7XG4gICAgICBsb2NhdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgaSksXG4gICAgICB2YWx1ZTogZGVmYXVsdFZhbHVlLmRlZmF1bHRWYWx1ZShkYXRhLnR5cGUsIGRhdGEuc2l6ZSlcbiAgICB9O1xuICB9XG4gIHJldHVybiBuZXcgR0xQcm9ncmFtLkdMUHJvZ3JhbSh3ZWJHTFByb2dyYW0sIHVuaWZvcm1EYXRhKTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVQcm9ncmFtID0gZ2VuZXJhdGVQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJhdGVQcm9ncmFtLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5yZXF1aXJlKFwiLi9pbmRleC5qc1wiKTtcbnZhciB1bmlmb3JtUGFyc2VycyA9IHJlcXVpcmUoXCIuL3VuaWZvcm1QYXJzZXJzLmpzXCIpLCBtYXBTaXplID0gcmVxdWlyZShcIi4vbWFwU2l6ZS5qc1wiKTtcbmZ1bmN0aW9uIHVib1VwZGF0ZShfdWQsIF91diwgX3JlbmRlcmVyLCBfc3luY0RhdGEsIGJ1ZmZlcikge1xuICBfcmVuZGVyZXIuYnVmZmVyLnVwZGF0ZShidWZmZXIpO1xufVxuY29uc3QgVUJPX1RPX1NJTkdMRV9TRVRURVJTID0ge1xuICBmbG9hdDogYFxuICAgICAgICBkYXRhW29mZnNldF0gPSB2O1xuICAgIGAsXG4gIHZlYzI6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdlswXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSB2WzFdO1xuICAgIGAsXG4gIHZlYzM6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdlswXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSB2WzFdO1xuICAgICAgICBkYXRhW29mZnNldCsyXSA9IHZbMl07XG5cbiAgICBgLFxuICB2ZWM0OiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdlsxXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrMl0gPSB2WzJdO1xuICAgICAgICBkYXRhW29mZnNldCszXSA9IHZbM107XG4gICAgYCxcbiAgbWF0MjogYFxuICAgICAgICBkYXRhW29mZnNldF0gPSB2WzBdO1xuICAgICAgICBkYXRhW29mZnNldCsxXSA9IHZbMV07XG5cbiAgICAgICAgZGF0YVtvZmZzZXQrNF0gPSB2WzJdO1xuICAgICAgICBkYXRhW29mZnNldCs1XSA9IHZbM107XG4gICAgYCxcbiAgbWF0MzogYFxuICAgICAgICBkYXRhW29mZnNldF0gPSB2WzBdO1xuICAgICAgICBkYXRhW29mZnNldCsxXSA9IHZbMV07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzJdID0gdlsyXTtcblxuICAgICAgICBkYXRhW29mZnNldCArIDRdID0gdlszXTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyA1XSA9IHZbNF07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgNl0gPSB2WzVdO1xuXG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgOF0gPSB2WzZdO1xuICAgICAgICBkYXRhW29mZnNldCArIDldID0gdls3XTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyAxMF0gPSB2WzhdO1xuICAgIGAsXG4gIG1hdDQ6IGBcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgaV0gPSB2W2ldO1xuICAgICAgICB9XG4gICAgYFxufSwgR0xTTF9UT19TVEQ0MF9TSVpFID0ge1xuICBmbG9hdDogNCxcbiAgdmVjMjogOCxcbiAgdmVjMzogMTIsXG4gIHZlYzQ6IDE2LFxuICBpbnQ6IDQsXG4gIGl2ZWMyOiA4LFxuICBpdmVjMzogMTIsXG4gIGl2ZWM0OiAxNixcbiAgdWludDogNCxcbiAgdXZlYzI6IDgsXG4gIHV2ZWMzOiAxMixcbiAgdXZlYzQ6IDE2LFxuICBib29sOiA0LFxuICBidmVjMjogOCxcbiAgYnZlYzM6IDEyLFxuICBidmVjNDogMTYsXG4gIG1hdDI6IDE2ICogMixcbiAgbWF0MzogMTYgKiAzLFxuICBtYXQ0OiAxNiAqIDRcbn07XG5mdW5jdGlvbiBjcmVhdGVVQk9FbGVtZW50cyh1bmlmb3JtRGF0YSkge1xuICBjb25zdCB1Ym9FbGVtZW50cyA9IHVuaWZvcm1EYXRhLm1hcCgoZGF0YSkgPT4gKHtcbiAgICBkYXRhLFxuICAgIG9mZnNldDogMCxcbiAgICBkYXRhTGVuOiAwLFxuICAgIGRpcnR5OiAwXG4gIH0pKTtcbiAgbGV0IHNpemUgPSAwLCBjaHVua1NpemUgPSAwLCBvZmZzZXQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHVib0VsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdWJvRWxlbWVudCA9IHVib0VsZW1lbnRzW2ldO1xuICAgIGlmIChzaXplID0gR0xTTF9UT19TVEQ0MF9TSVpFW3Vib0VsZW1lbnQuZGF0YS50eXBlXSwgdWJvRWxlbWVudC5kYXRhLnNpemUgPiAxICYmIChzaXplID0gTWF0aC5tYXgoc2l6ZSwgMTYpICogdWJvRWxlbWVudC5kYXRhLnNpemUpLCB1Ym9FbGVtZW50LmRhdGFMZW4gPSBzaXplLCBjaHVua1NpemUgJSBzaXplICE9PSAwICYmIGNodW5rU2l6ZSA8IDE2KSB7XG4gICAgICBjb25zdCBsaW5lVXBWYWx1ZSA9IGNodW5rU2l6ZSAlIHNpemUgJSAxNjtcbiAgICAgIGNodW5rU2l6ZSArPSBsaW5lVXBWYWx1ZSwgb2Zmc2V0ICs9IGxpbmVVcFZhbHVlO1xuICAgIH1cbiAgICBjaHVua1NpemUgKyBzaXplID4gMTYgPyAob2Zmc2V0ID0gTWF0aC5jZWlsKG9mZnNldCAvIDE2KSAqIDE2LCB1Ym9FbGVtZW50Lm9mZnNldCA9IG9mZnNldCwgb2Zmc2V0ICs9IHNpemUsIGNodW5rU2l6ZSA9IHNpemUpIDogKHVib0VsZW1lbnQub2Zmc2V0ID0gb2Zmc2V0LCBjaHVua1NpemUgKz0gc2l6ZSwgb2Zmc2V0ICs9IHNpemUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgPSBNYXRoLmNlaWwob2Zmc2V0IC8gMTYpICogMTYsIHsgdWJvRWxlbWVudHMsIHNpemU6IG9mZnNldCB9O1xufVxuZnVuY3Rpb24gZ2V0VUJPRGF0YSh1bmlmb3JtcywgdW5pZm9ybURhdGEpIHtcbiAgY29uc3QgdXNlZFVuaWZvcm1EYXRhcyA9IFtdO1xuICBmb3IgKGNvbnN0IGkgaW4gdW5pZm9ybXMpXG4gICAgdW5pZm9ybURhdGFbaV0gJiYgdXNlZFVuaWZvcm1EYXRhcy5wdXNoKHVuaWZvcm1EYXRhW2ldKTtcbiAgcmV0dXJuIHVzZWRVbmlmb3JtRGF0YXMuc29ydCgoYSwgYikgPT4gYS5pbmRleCAtIGIuaW5kZXgpLCB1c2VkVW5pZm9ybURhdGFzO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYyhncm91cCwgdW5pZm9ybURhdGEpIHtcbiAgaWYgKCFncm91cC5hdXRvTWFuYWdlKVxuICAgIHJldHVybiB7IHNpemU6IDAsIHN5bmNGdW5jOiB1Ym9VcGRhdGUgfTtcbiAgY29uc3QgdXNlZFVuaWZvcm1EYXRhcyA9IGdldFVCT0RhdGEoZ3JvdXAudW5pZm9ybXMsIHVuaWZvcm1EYXRhKSwgeyB1Ym9FbGVtZW50cywgc2l6ZSB9ID0gY3JlYXRlVUJPRWxlbWVudHModXNlZFVuaWZvcm1EYXRhcyksIGZ1bmNGcmFnbWVudHMgPSBbYFxuICAgIHZhciB2ID0gbnVsbDtcbiAgICB2YXIgdjIgPSBudWxsO1xuICAgIHZhciBjdiA9IG51bGw7XG4gICAgdmFyIHQgPSAwO1xuICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgZGF0YSA9IGJ1ZmZlci5kYXRhO1xuICAgIGBdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHVib0VsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdWJvRWxlbWVudCA9IHVib0VsZW1lbnRzW2ldLCB1bmlmb3JtID0gZ3JvdXAudW5pZm9ybXNbdWJvRWxlbWVudC5kYXRhLm5hbWVdLCBuYW1lID0gdWJvRWxlbWVudC5kYXRhLm5hbWU7XG4gICAgbGV0IHBhcnNlZCA9ICExO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdW5pZm9ybVBhcnNlcnMudW5pZm9ybVBhcnNlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHVuaWZvcm1QYXJzZXIgPSB1bmlmb3JtUGFyc2Vycy51bmlmb3JtUGFyc2Vyc1tqXTtcbiAgICAgIGlmICh1bmlmb3JtUGFyc2VyLmNvZGVVYm8gJiYgdW5pZm9ybVBhcnNlci50ZXN0KHVib0VsZW1lbnQuZGF0YSwgdW5pZm9ybSkpIHtcbiAgICAgICAgZnVuY0ZyYWdtZW50cy5wdXNoKFxuICAgICAgICAgIGBvZmZzZXQgPSAke3Vib0VsZW1lbnQub2Zmc2V0IC8gNH07YCxcbiAgICAgICAgICB1bmlmb3JtUGFyc2Vycy51bmlmb3JtUGFyc2Vyc1tqXS5jb2RlVWJvKHVib0VsZW1lbnQuZGF0YS5uYW1lLCB1bmlmb3JtKVxuICAgICAgICApLCBwYXJzZWQgPSAhMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcGFyc2VkKVxuICAgICAgaWYgKHVib0VsZW1lbnQuZGF0YS5zaXplID4gMSkge1xuICAgICAgICBjb25zdCBzaXplMiA9IG1hcFNpemUubWFwU2l6ZSh1Ym9FbGVtZW50LmRhdGEudHlwZSksIHJvd1NpemUgPSBNYXRoLm1heChHTFNMX1RPX1NURDQwX1NJWkVbdWJvRWxlbWVudC5kYXRhLnR5cGVdIC8gMTYsIDEpLCBlbGVtZW50U2l6ZSA9IHNpemUyIC8gcm93U2l6ZSwgcmVtYWluZGVyID0gKDQgLSBlbGVtZW50U2l6ZSAlIDQpICUgNDtcbiAgICAgICAgZnVuY0ZyYWdtZW50cy5wdXNoKGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkLiR7bmFtZX0udmFsdWU7XG4gICAgICAgICAgICAgICAgdiA9IHV2LiR7bmFtZX07XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gJHt1Ym9FbGVtZW50Lm9mZnNldCAvIDR9O1xuXG4gICAgICAgICAgICAgICAgdCA9IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IodmFyIGk9MDsgaSA8ICR7dWJvRWxlbWVudC5kYXRhLnNpemUgKiByb3dTaXplfTsgaSsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8ICR7ZWxlbWVudFNpemV9OyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdID0gdlt0KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSAke3JlbWFpbmRlcn07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IFVCT19UT19TSU5HTEVfU0VUVEVSU1t1Ym9FbGVtZW50LmRhdGEudHlwZV07XG4gICAgICAgIGZ1bmNGcmFnbWVudHMucHVzaChgXG4gICAgICAgICAgICAgICAgY3YgPSB1ZC4ke25hbWV9LnZhbHVlO1xuICAgICAgICAgICAgICAgIHYgPSB1di4ke25hbWV9O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9ICR7dWJvRWxlbWVudC5vZmZzZXQgLyA0fTtcbiAgICAgICAgICAgICAgICAke3RlbXBsYXRlfTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY0ZyYWdtZW50cy5wdXNoKGBcbiAgICAgICByZW5kZXJlci5idWZmZXIudXBkYXRlKGJ1ZmZlcik7XG4gICAgYCksIHtcbiAgICBzaXplLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgIHN5bmNGdW5jOiBuZXcgRnVuY3Rpb24oXG4gICAgICBcInVkXCIsXG4gICAgICBcInV2XCIsXG4gICAgICBcInJlbmRlcmVyXCIsXG4gICAgICBcInN5bmNEYXRhXCIsXG4gICAgICBcImJ1ZmZlclwiLFxuICAgICAgZnVuY0ZyYWdtZW50cy5qb2luKGBcbmApXG4gICAgKVxuICB9O1xufVxuZXhwb3J0cy5jcmVhdGVVQk9FbGVtZW50cyA9IGNyZWF0ZVVCT0VsZW1lbnRzO1xuZXhwb3J0cy5nZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jID0gZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYztcbmV4cG9ydHMuZ2V0VUJPRGF0YSA9IGdldFVCT0RhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdW5pZm9ybVBhcnNlcnMgPSByZXF1aXJlKFwiLi91bmlmb3JtUGFyc2Vycy5qc1wiKTtcbmNvbnN0IEdMU0xfVE9fU0lOR0xFX1NFVFRFUlNfQ0FDSEVEID0ge1xuICBmbG9hdDogYFxuICAgIGlmIChjdiAhPT0gdilcbiAgICB7XG4gICAgICAgIGN1LnZhbHVlID0gdjtcbiAgICAgICAgZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2KTtcbiAgICB9YCxcbiAgdmVjMjogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yZihsb2NhdGlvbiwgdlswXSwgdlsxXSlcbiAgICB9YCxcbiAgdmVjMzogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG5cbiAgICAgICAgZ2wudW5pZm9ybTNmKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdKVxuICAgIH1gLFxuICB2ZWM0OiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdIHx8IGN2WzNdICE9PSB2WzNdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcbiAgICAgICAgY3ZbM10gPSB2WzNdO1xuXG4gICAgICAgIGdsLnVuaWZvcm00Zihsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSk7XG4gICAgfWAsXG4gIGludDogYFxuICAgIGlmIChjdiAhPT0gdilcbiAgICB7XG4gICAgICAgIGN1LnZhbHVlID0gdjtcblxuICAgICAgICBnbC51bmlmb3JtMWkobG9jYXRpb24sIHYpO1xuICAgIH1gLFxuICBpdmVjMjogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yaShsb2NhdGlvbiwgdlswXSwgdlsxXSk7XG4gICAgfWAsXG4gIGl2ZWMzOiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcblxuICAgICAgICBnbC51bmlmb3JtM2kobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0pO1xuICAgIH1gLFxuICBpdmVjNDogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSB8fCBjdlszXSAhPT0gdlszXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG4gICAgICAgIGN2WzNdID0gdlszXTtcblxuICAgICAgICBnbC51bmlmb3JtNGkobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pO1xuICAgIH1gLFxuICB1aW50OiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xdWkobG9jYXRpb24sIHYpO1xuICAgIH1gLFxuICB1dmVjMjogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuXG4gICAgICAgIGdsLnVuaWZvcm0ydWkobG9jYXRpb24sIHZbMF0sIHZbMV0pO1xuICAgIH1gLFxuICB1dmVjMzogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG5cbiAgICAgICAgZ2wudW5pZm9ybTN1aShsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSk7XG4gICAgfWAsXG4gIHV2ZWM0OiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdIHx8IGN2WzNdICE9PSB2WzNdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcbiAgICAgICAgY3ZbM10gPSB2WzNdO1xuXG4gICAgICAgIGdsLnVuaWZvcm00dWkobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pO1xuICAgIH1gLFxuICBib29sOiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuICAgICAgICBnbC51bmlmb3JtMWkobG9jYXRpb24sIHYpO1xuICAgIH1gLFxuICBidmVjMjogYFxuICAgIGlmIChjdlswXSAhPSB2WzBdIHx8IGN2WzFdICE9IHZbMV0pXG4gICAge1xuICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgIGN2WzFdID0gdlsxXTtcblxuICAgICAgICBnbC51bmlmb3JtMmkobG9jYXRpb24sIHZbMF0sIHZbMV0pO1xuICAgIH1gLFxuICBidmVjMzogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG5cbiAgICAgICAgZ2wudW5pZm9ybTNpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdKTtcbiAgICB9YCxcbiAgYnZlYzQ6IGBcbiAgICBpZiAoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0gfHwgY3ZbM10gIT09IHZbM10pXG4gICAge1xuICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgIGN2WzFdID0gdlsxXTtcbiAgICAgICAgY3ZbMl0gPSB2WzJdO1xuICAgICAgICBjdlszXSA9IHZbM107XG5cbiAgICAgICAgZ2wudW5pZm9ybTRpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdLCB2WzNdKTtcbiAgICB9YCxcbiAgbWF0MjogXCJnbC51bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgbWF0MzogXCJnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgbWF0NDogXCJnbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgc2FtcGxlcjJEOiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gICAgfWAsXG4gIHNhbXBsZXJDdWJlOiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gICAgfWAsXG4gIHNhbXBsZXIyREFycmF5OiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gICAgfWBcbn0sIEdMU0xfVE9fQVJSQVlfU0VUVEVSUyA9IHtcbiAgZmxvYXQ6IFwiZ2wudW5pZm9ybTFmdihsb2NhdGlvbiwgdilcIixcbiAgdmVjMjogXCJnbC51bmlmb3JtMmZ2KGxvY2F0aW9uLCB2KVwiLFxuICB2ZWMzOiBcImdsLnVuaWZvcm0zZnYobG9jYXRpb24sIHYpXCIsXG4gIHZlYzQ6IFwiZ2wudW5pZm9ybTRmdihsb2NhdGlvbiwgdilcIixcbiAgbWF0NDogXCJnbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgbWF0MzogXCJnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgbWF0MjogXCJnbC51bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgaW50OiBcImdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpXCIsXG4gIGl2ZWMyOiBcImdsLnVuaWZvcm0yaXYobG9jYXRpb24sIHYpXCIsXG4gIGl2ZWMzOiBcImdsLnVuaWZvcm0zaXYobG9jYXRpb24sIHYpXCIsXG4gIGl2ZWM0OiBcImdsLnVuaWZvcm00aXYobG9jYXRpb24sIHYpXCIsXG4gIHVpbnQ6IFwiZ2wudW5pZm9ybTF1aXYobG9jYXRpb24sIHYpXCIsXG4gIHV2ZWMyOiBcImdsLnVuaWZvcm0ydWl2KGxvY2F0aW9uLCB2KVwiLFxuICB1dmVjMzogXCJnbC51bmlmb3JtM3Vpdihsb2NhdGlvbiwgdilcIixcbiAgdXZlYzQ6IFwiZ2wudW5pZm9ybTR1aXYobG9jYXRpb24sIHYpXCIsXG4gIGJvb2w6IFwiZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdilcIixcbiAgYnZlYzI6IFwiZ2wudW5pZm9ybTJpdihsb2NhdGlvbiwgdilcIixcbiAgYnZlYzM6IFwiZ2wudW5pZm9ybTNpdihsb2NhdGlvbiwgdilcIixcbiAgYnZlYzQ6IFwiZ2wudW5pZm9ybTRpdihsb2NhdGlvbiwgdilcIixcbiAgc2FtcGxlcjJEOiBcImdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpXCIsXG4gIHNhbXBsZXJDdWJlOiBcImdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpXCIsXG4gIHNhbXBsZXIyREFycmF5OiBcImdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpXCJcbn07XG5mdW5jdGlvbiBnZW5lcmF0ZVVuaWZvcm1zU3luYyhncm91cCwgdW5pZm9ybURhdGEpIHtcbiAgY29uc3QgZnVuY0ZyYWdtZW50cyA9IFtgXG4gICAgICAgIHZhciB2ID0gbnVsbDtcbiAgICAgICAgdmFyIGN2ID0gbnVsbDtcbiAgICAgICAgdmFyIGN1ID0gbnVsbDtcbiAgICAgICAgdmFyIHQgPSAwO1xuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcbiAgICBgXTtcbiAgZm9yIChjb25zdCBpIGluIGdyb3VwLnVuaWZvcm1zKSB7XG4gICAgY29uc3QgZGF0YSA9IHVuaWZvcm1EYXRhW2ldO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgZ3JvdXAudW5pZm9ybXNbaV0/Lmdyb3VwID09PSAhMCAmJiAoZ3JvdXAudW5pZm9ybXNbaV0udWJvID8gZnVuY0ZyYWdtZW50cy5wdXNoKGBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNoYWRlci5zeW5jVW5pZm9ybUJ1ZmZlckdyb3VwKHV2LiR7aX0sICcke2l9Jyk7XG4gICAgICAgICAgICAgICAgICAgIGApIDogZnVuY0ZyYWdtZW50cy5wdXNoKGBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNoYWRlci5zeW5jVW5pZm9ybUdyb3VwKHV2LiR7aX0sIHN5bmNEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHVuaWZvcm0gPSBncm91cC51bmlmb3Jtc1tpXTtcbiAgICBsZXQgcGFyc2VkID0gITE7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB1bmlmb3JtUGFyc2Vycy51bmlmb3JtUGFyc2Vycy5sZW5ndGg7IGorKylcbiAgICAgIGlmICh1bmlmb3JtUGFyc2Vycy51bmlmb3JtUGFyc2Vyc1tqXS50ZXN0KGRhdGEsIHVuaWZvcm0pKSB7XG4gICAgICAgIGZ1bmNGcmFnbWVudHMucHVzaCh1bmlmb3JtUGFyc2Vycy51bmlmb3JtUGFyc2Vyc1tqXS5jb2RlKGksIHVuaWZvcm0pKSwgcGFyc2VkID0gITA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IChkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSA/IEdMU0xfVE9fU0lOR0xFX1NFVFRFUlNfQ0FDSEVEIDogR0xTTF9UT19BUlJBWV9TRVRURVJTKVtkYXRhLnR5cGVdLnJlcGxhY2UoXCJsb2NhdGlvblwiLCBgdWRbXCIke2l9XCJdLmxvY2F0aW9uYCk7XG4gICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgY3UgPSB1ZFtcIiR7aX1cIl07XG4gICAgICAgICAgICBjdiA9IGN1LnZhbHVlO1xuICAgICAgICAgICAgdiA9IHV2W1wiJHtpfVwiXTtcbiAgICAgICAgICAgICR7dGVtcGxhdGV9O2ApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwidWRcIiwgXCJ1dlwiLCBcInJlbmRlcmVyXCIsIFwic3luY0RhdGFcIiwgZnVuY0ZyYWdtZW50cy5qb2luKGBcbmApKTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVVbmlmb3Jtc1N5bmMgPSBnZW5lcmF0ZVVuaWZvcm1zU3luYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlVW5pZm9ybXNTeW5jLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbWFwU2l6ZSA9IHJlcXVpcmUoXCIuL21hcFNpemUuanNcIiksIG1hcFR5cGUgPSByZXF1aXJlKFwiLi9tYXBUeXBlLmpzXCIpO1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlRGF0YShwcm9ncmFtLCBnbCkge1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge30sIHRvdGFsQXR0cmlidXRlcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsQXR0cmlidXRlczsgaSsrKSB7XG4gICAgY29uc3QgYXR0cmliRGF0YSA9IGdsLmdldEFjdGl2ZUF0dHJpYihwcm9ncmFtLCBpKTtcbiAgICBpZiAoYXR0cmliRGF0YS5uYW1lLnN0YXJ0c1dpdGgoXCJnbF9cIikpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCB0eXBlID0gbWFwVHlwZS5tYXBUeXBlKGdsLCBhdHRyaWJEYXRhLnR5cGUpLCBkYXRhID0ge1xuICAgICAgdHlwZSxcbiAgICAgIG5hbWU6IGF0dHJpYkRhdGEubmFtZSxcbiAgICAgIHNpemU6IG1hcFNpemUubWFwU2l6ZSh0eXBlKSxcbiAgICAgIGxvY2F0aW9uOiBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJEYXRhLm5hbWUpXG4gICAgfTtcbiAgICBhdHRyaWJ1dGVzW2F0dHJpYkRhdGEubmFtZV0gPSBkYXRhO1xuICB9XG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufVxuZXhwb3J0cy5nZXRBdHRyaWJ1dGVEYXRhID0gZ2V0QXR0cmlidXRlRGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEF0dHJpYnV0ZURhdGEuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiQHBpeGkvY29uc3RhbnRzXCIpLCBnZXRUZXN0Q29udGV4dCA9IHJlcXVpcmUoXCIuL2dldFRlc3RDb250ZXh0LmpzXCIpO1xubGV0IG1heEZyYWdtZW50UHJlY2lzaW9uO1xuZnVuY3Rpb24gZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24oKSB7XG4gIGlmICghbWF4RnJhZ21lbnRQcmVjaXNpb24pIHtcbiAgICBtYXhGcmFnbWVudFByZWNpc2lvbiA9IGNvbnN0YW50cy5QUkVDSVNJT04uTUVESVVNO1xuICAgIGNvbnN0IGdsID0gZ2V0VGVzdENvbnRleHQuZ2V0VGVzdENvbnRleHQoKTtcbiAgICBpZiAoZ2wgJiYgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KSB7XG4gICAgICBjb25zdCBzaGFkZXJGcmFnbWVudCA9IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQpO1xuICAgICAgc2hhZGVyRnJhZ21lbnQgJiYgKG1heEZyYWdtZW50UHJlY2lzaW9uID0gc2hhZGVyRnJhZ21lbnQucHJlY2lzaW9uID8gY29uc3RhbnRzLlBSRUNJU0lPTi5ISUdIIDogY29uc3RhbnRzLlBSRUNJU0lPTi5NRURJVU0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4RnJhZ21lbnRQcmVjaXNpb247XG59XG5leHBvcnRzLmdldE1heEZyYWdtZW50UHJlY2lzaW9uID0gZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRNYXhGcmFnbWVudFByZWNpc2lvbi5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCJAcGl4aS9jb25zdGFudHNcIiksIHNldHRpbmdzID0gcmVxdWlyZShcIkBwaXhpL3NldHRpbmdzXCIpO1xuY29uc3QgdW5rbm93bkNvbnRleHQgPSB7fTtcbmxldCBjb250ZXh0ID0gdW5rbm93bkNvbnRleHQ7XG5mdW5jdGlvbiBnZXRUZXN0Q29udGV4dCgpIHtcbiAgaWYgKGNvbnRleHQgPT09IHVua25vd25Db250ZXh0IHx8IGNvbnRleHQ/LmlzQ29udGV4dExvc3QoKSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHNldHRpbmdzLnNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCk7XG4gICAgbGV0IGdsO1xuICAgIHNldHRpbmdzLnNldHRpbmdzLlBSRUZFUl9FTlYgPj0gY29uc3RhbnRzLkVOVi5XRUJHTDIgJiYgKGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwge30pKSwgZ2wgfHwgKGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCB7fSkgfHwgY2FudmFzLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwge30pLCBnbCA/IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2RyYXdfYnVmZmVyc1wiKSA6IGdsID0gbnVsbCksIGNvbnRleHQgPSBnbDtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cbmV4cG9ydHMuZ2V0VGVzdENvbnRleHQgPSBnZXRUZXN0Q29udGV4dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFRlc3RDb250ZXh0LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZGVmYXVsdFZhbHVlID0gcmVxdWlyZShcIi4vZGVmYXVsdFZhbHVlLmpzXCIpLCBtYXBUeXBlID0gcmVxdWlyZShcIi4vbWFwVHlwZS5qc1wiKTtcbmZ1bmN0aW9uIGdldFVuaWZvcm1EYXRhKHByb2dyYW0sIGdsKSB7XG4gIGNvbnN0IHVuaWZvcm1zID0ge30sIHRvdGFsVW5pZm9ybXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxVbmlmb3JtczsgaSsrKSB7XG4gICAgY29uc3QgdW5pZm9ybURhdGEgPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpLCBuYW1lID0gdW5pZm9ybURhdGEubmFtZS5yZXBsYWNlKC9cXFsuKj9cXF0kLywgXCJcIiksIGlzQXJyYXkgPSAhIXVuaWZvcm1EYXRhLm5hbWUubWF0Y2goL1xcWy4qP1xcXSQvKSwgdHlwZSA9IG1hcFR5cGUubWFwVHlwZShnbCwgdW5pZm9ybURhdGEudHlwZSk7XG4gICAgdW5pZm9ybXNbbmFtZV0gPSB7XG4gICAgICBuYW1lLFxuICAgICAgaW5kZXg6IGksXG4gICAgICB0eXBlLFxuICAgICAgc2l6ZTogdW5pZm9ybURhdGEuc2l6ZSxcbiAgICAgIGlzQXJyYXksXG4gICAgICB2YWx1ZTogZGVmYXVsdFZhbHVlLmRlZmF1bHRWYWx1ZSh0eXBlLCB1bmlmb3JtRGF0YS5zaXplKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHVuaWZvcm1zO1xufVxuZXhwb3J0cy5nZXRVbmlmb3JtRGF0YSA9IGdldFVuaWZvcm1EYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0VW5pZm9ybURhdGEuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyID0gcmVxdWlyZShcIi4vY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlci5qc1wiKSwgY29tcGlsZVNoYWRlciA9IHJlcXVpcmUoXCIuL2NvbXBpbGVTaGFkZXIuanNcIiksIGRlZmF1bHRWYWx1ZSA9IHJlcXVpcmUoXCIuL2RlZmF1bHRWYWx1ZS5qc1wiKSwgZ2VuZXJhdGVVbmlmb3Jtc1N5bmMgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZVVuaWZvcm1zU3luYy5qc1wiKSwgZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24gPSByZXF1aXJlKFwiLi9nZXRNYXhGcmFnbWVudFByZWNpc2lvbi5qc1wiKSwgZ2V0VGVzdENvbnRleHQgPSByZXF1aXJlKFwiLi9nZXRUZXN0Q29udGV4dC5qc1wiKSwgbG9nUHJvZ3JhbUVycm9yID0gcmVxdWlyZShcIi4vbG9nUHJvZ3JhbUVycm9yLmpzXCIpLCBtYXBTaXplID0gcmVxdWlyZShcIi4vbWFwU2l6ZS5qc1wiKSwgbWFwVHlwZSA9IHJlcXVpcmUoXCIuL21hcFR5cGUuanNcIiksIHNldFByZWNpc2lvbiA9IHJlcXVpcmUoXCIuL3NldFByZWNpc2lvbi5qc1wiKSwgdW5pZm9ybVBhcnNlcnMgPSByZXF1aXJlKFwiLi91bmlmb3JtUGFyc2Vycy5qc1wiKSwgdW5zYWZlRXZhbFN1cHBvcnRlZCA9IHJlcXVpcmUoXCIuL3Vuc2FmZUV2YWxTdXBwb3J0ZWQuanNcIik7XG5leHBvcnRzLmNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIgPSBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyLmNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXI7XG5leHBvcnRzLmNvbXBpbGVTaGFkZXIgPSBjb21waWxlU2hhZGVyLmNvbXBpbGVTaGFkZXI7XG5leHBvcnRzLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZS5kZWZhdWx0VmFsdWU7XG5leHBvcnRzLmdlbmVyYXRlVW5pZm9ybXNTeW5jID0gZ2VuZXJhdGVVbmlmb3Jtc1N5bmMuZ2VuZXJhdGVVbmlmb3Jtc1N5bmM7XG5leHBvcnRzLmdldE1heEZyYWdtZW50UHJlY2lzaW9uID0gZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24uZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb247XG5leHBvcnRzLmdldFRlc3RDb250ZXh0ID0gZ2V0VGVzdENvbnRleHQuZ2V0VGVzdENvbnRleHQ7XG5leHBvcnRzLmxvZ1Byb2dyYW1FcnJvciA9IGxvZ1Byb2dyYW1FcnJvci5sb2dQcm9ncmFtRXJyb3I7XG5leHBvcnRzLm1hcFNpemUgPSBtYXBTaXplLm1hcFNpemU7XG5leHBvcnRzLm1hcFR5cGUgPSBtYXBUeXBlLm1hcFR5cGU7XG5leHBvcnRzLnNldFByZWNpc2lvbiA9IHNldFByZWNpc2lvbi5zZXRQcmVjaXNpb247XG5leHBvcnRzLnVuaWZvcm1QYXJzZXJzID0gdW5pZm9ybVBhcnNlcnMudW5pZm9ybVBhcnNlcnM7XG5leHBvcnRzLnVuc2FmZUV2YWxTdXBwb3J0ZWQgPSB1bnNhZmVFdmFsU3VwcG9ydGVkLnVuc2FmZUV2YWxTdXBwb3J0ZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gbG9nUHJldHR5U2hhZGVyRXJyb3IoZ2wsIHNoYWRlcikge1xuICBjb25zdCBzaGFkZXJTcmMgPSBnbC5nZXRTaGFkZXJTb3VyY2Uoc2hhZGVyKS5zcGxpdChgXG5gKS5tYXAoKGxpbmUsIGluZGV4KSA9PiBgJHtpbmRleH06ICR7bGluZX1gKSwgc2hhZGVyTG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpLCBzcGxpdFNoYWRlciA9IHNoYWRlckxvZy5zcGxpdChgXG5gKSwgZGVkdXBlID0ge30sIGxpbmVOdW1iZXJzID0gc3BsaXRTaGFkZXIubWFwKChsaW5lKSA9PiBwYXJzZUZsb2F0KGxpbmUucmVwbGFjZSgvXkVSUk9SXFw6IDBcXDooW1xcZF0rKVxcOi4qJC8sIFwiJDFcIikpKS5maWx0ZXIoKG4pID0+IG4gJiYgIWRlZHVwZVtuXSA/IChkZWR1cGVbbl0gPSAhMCwgITApIDogITEpLCBsb2dBcmdzID0gW1wiXCJdO1xuICBsaW5lTnVtYmVycy5mb3JFYWNoKChudW1iZXIpID0+IHtcbiAgICBzaGFkZXJTcmNbbnVtYmVyIC0gMV0gPSBgJWMke3NoYWRlclNyY1tudW1iZXIgLSAxXX0lY2AsIGxvZ0FyZ3MucHVzaChcImJhY2tncm91bmQ6ICNGRjAwMDA7IGNvbG9yOiNGRkZGRkY7IGZvbnQtc2l6ZTogMTBweFwiLCBcImZvbnQtc2l6ZTogMTBweFwiKTtcbiAgfSk7XG4gIGNvbnN0IGZyYWdtZW50U291cmNlVG9Mb2cgPSBzaGFkZXJTcmMuam9pbihgXG5gKTtcbiAgbG9nQXJnc1swXSA9IGZyYWdtZW50U291cmNlVG9Mb2csIGNvbnNvbGUuZXJyb3Ioc2hhZGVyTG9nKSwgY29uc29sZS5ncm91cENvbGxhcHNlZChcImNsaWNrIHRvIHZpZXcgZnVsbCBzaGFkZXIgY29kZVwiKSwgY29uc29sZS53YXJuKC4uLmxvZ0FyZ3MpLCBjb25zb2xlLmdyb3VwRW5kKCk7XG59XG5mdW5jdGlvbiBsb2dQcm9ncmFtRXJyb3IoZ2wsIHByb2dyYW0sIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpIHtcbiAgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykgfHwgKGdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSB8fCBsb2dQcmV0dHlTaGFkZXJFcnJvcihnbCwgdmVydGV4U2hhZGVyKSwgZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdtZW50U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykgfHwgbG9nUHJldHR5U2hhZGVyRXJyb3IoZ2wsIGZyYWdtZW50U2hhZGVyKSwgY29uc29sZS5lcnJvcihcIlBpeGlKUyBFcnJvcjogQ291bGQgbm90IGluaXRpYWxpemUgc2hhZGVyLlwiKSwgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkgIT09IFwiXCIgJiYgY29uc29sZS53YXJuKFwiUGl4aUpTIFdhcm5pbmc6IGdsLmdldFByb2dyYW1JbmZvTG9nKClcIiwgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpKTtcbn1cbmV4cG9ydHMubG9nUHJvZ3JhbUVycm9yID0gbG9nUHJvZ3JhbUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nUHJvZ3JhbUVycm9yLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBHTFNMX1RPX1NJWkUgPSB7XG4gIGZsb2F0OiAxLFxuICB2ZWMyOiAyLFxuICB2ZWMzOiAzLFxuICB2ZWM0OiA0LFxuICBpbnQ6IDEsXG4gIGl2ZWMyOiAyLFxuICBpdmVjMzogMyxcbiAgaXZlYzQ6IDQsXG4gIHVpbnQ6IDEsXG4gIHV2ZWMyOiAyLFxuICB1dmVjMzogMyxcbiAgdXZlYzQ6IDQsXG4gIGJvb2w6IDEsXG4gIGJ2ZWMyOiAyLFxuICBidmVjMzogMyxcbiAgYnZlYzQ6IDQsXG4gIG1hdDI6IDQsXG4gIG1hdDM6IDksXG4gIG1hdDQ6IDE2LFxuICBzYW1wbGVyMkQ6IDFcbn07XG5mdW5jdGlvbiBtYXBTaXplKHR5cGUpIHtcbiAgcmV0dXJuIEdMU0xfVE9fU0laRVt0eXBlXTtcbn1cbmV4cG9ydHMubWFwU2l6ZSA9IG1hcFNpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBTaXplLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgR0xfVEFCTEUgPSBudWxsO1xuY29uc3QgR0xfVE9fR0xTTF9UWVBFUyA9IHtcbiAgRkxPQVQ6IFwiZmxvYXRcIixcbiAgRkxPQVRfVkVDMjogXCJ2ZWMyXCIsXG4gIEZMT0FUX1ZFQzM6IFwidmVjM1wiLFxuICBGTE9BVF9WRUM0OiBcInZlYzRcIixcbiAgSU5UOiBcImludFwiLFxuICBJTlRfVkVDMjogXCJpdmVjMlwiLFxuICBJTlRfVkVDMzogXCJpdmVjM1wiLFxuICBJTlRfVkVDNDogXCJpdmVjNFwiLFxuICBVTlNJR05FRF9JTlQ6IFwidWludFwiLFxuICBVTlNJR05FRF9JTlRfVkVDMjogXCJ1dmVjMlwiLFxuICBVTlNJR05FRF9JTlRfVkVDMzogXCJ1dmVjM1wiLFxuICBVTlNJR05FRF9JTlRfVkVDNDogXCJ1dmVjNFwiLFxuICBCT09MOiBcImJvb2xcIixcbiAgQk9PTF9WRUMyOiBcImJ2ZWMyXCIsXG4gIEJPT0xfVkVDMzogXCJidmVjM1wiLFxuICBCT09MX1ZFQzQ6IFwiYnZlYzRcIixcbiAgRkxPQVRfTUFUMjogXCJtYXQyXCIsXG4gIEZMT0FUX01BVDM6IFwibWF0M1wiLFxuICBGTE9BVF9NQVQ0OiBcIm1hdDRcIixcbiAgU0FNUExFUl8yRDogXCJzYW1wbGVyMkRcIixcbiAgSU5UX1NBTVBMRVJfMkQ6IFwic2FtcGxlcjJEXCIsXG4gIFVOU0lHTkVEX0lOVF9TQU1QTEVSXzJEOiBcInNhbXBsZXIyRFwiLFxuICBTQU1QTEVSX0NVQkU6IFwic2FtcGxlckN1YmVcIixcbiAgSU5UX1NBTVBMRVJfQ1VCRTogXCJzYW1wbGVyQ3ViZVwiLFxuICBVTlNJR05FRF9JTlRfU0FNUExFUl9DVUJFOiBcInNhbXBsZXJDdWJlXCIsXG4gIFNBTVBMRVJfMkRfQVJSQVk6IFwic2FtcGxlcjJEQXJyYXlcIixcbiAgSU5UX1NBTVBMRVJfMkRfQVJSQVk6IFwic2FtcGxlcjJEQXJyYXlcIixcbiAgVU5TSUdORURfSU5UX1NBTVBMRVJfMkRfQVJSQVk6IFwic2FtcGxlcjJEQXJyYXlcIlxufTtcbmZ1bmN0aW9uIG1hcFR5cGUoZ2wsIHR5cGUpIHtcbiAgaWYgKCFHTF9UQUJMRSkge1xuICAgIGNvbnN0IHR5cGVOYW1lcyA9IE9iamVjdC5rZXlzKEdMX1RPX0dMU0xfVFlQRVMpO1xuICAgIEdMX1RBQkxFID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHRuID0gdHlwZU5hbWVzW2ldO1xuICAgICAgR0xfVEFCTEVbZ2xbdG5dXSA9IEdMX1RPX0dMU0xfVFlQRVNbdG5dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gR0xfVEFCTEVbdHlwZV07XG59XG5leHBvcnRzLm1hcFR5cGUgPSBtYXBUeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwVHlwZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCJAcGl4aS9jb25zdGFudHNcIik7XG5mdW5jdGlvbiBzZXRQcmVjaXNpb24oc3JjLCByZXF1ZXN0ZWRQcmVjaXNpb24sIG1heFN1cHBvcnRlZFByZWNpc2lvbikge1xuICBpZiAoc3JjLnN1YnN0cmluZygwLCA5KSAhPT0gXCJwcmVjaXNpb25cIikge1xuICAgIGxldCBwcmVjaXNpb24gPSByZXF1ZXN0ZWRQcmVjaXNpb247XG4gICAgcmV0dXJuIHJlcXVlc3RlZFByZWNpc2lvbiA9PT0gY29uc3RhbnRzLlBSRUNJU0lPTi5ISUdIICYmIG1heFN1cHBvcnRlZFByZWNpc2lvbiAhPT0gY29uc3RhbnRzLlBSRUNJU0lPTi5ISUdIICYmIChwcmVjaXNpb24gPSBjb25zdGFudHMuUFJFQ0lTSU9OLk1FRElVTSksIGBwcmVjaXNpb24gJHtwcmVjaXNpb259IGZsb2F0O1xuJHtzcmN9YDtcbiAgfSBlbHNlIGlmIChtYXhTdXBwb3J0ZWRQcmVjaXNpb24gIT09IGNvbnN0YW50cy5QUkVDSVNJT04uSElHSCAmJiBzcmMuc3Vic3RyaW5nKDAsIDE1KSA9PT0gXCJwcmVjaXNpb24gaGlnaHBcIilcbiAgICByZXR1cm4gc3JjLnJlcGxhY2UoXCJwcmVjaXNpb24gaGlnaHBcIiwgXCJwcmVjaXNpb24gbWVkaXVtcFwiKTtcbiAgcmV0dXJuIHNyYztcbn1cbmV4cG9ydHMuc2V0UHJlY2lzaW9uID0gc2V0UHJlY2lzaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0UHJlY2lzaW9uLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB1bmlmb3JtUGFyc2VycyA9IFtcbiAgLy8gYSBmbG9hdCBjYWNoZSBsYXllclxuICB7XG4gICAgdGVzdDogKGRhdGEpID0+IGRhdGEudHlwZSA9PT0gXCJmbG9hdFwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5LFxuICAgIGNvZGU6IChuYW1lKSA9PiBgXG4gICAgICAgICAgICBpZih1dltcIiR7bmFtZX1cIl0gIT09IHVkW1wiJHtuYW1lfVwiXS52YWx1ZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1ZFtcIiR7bmFtZX1cIl0udmFsdWUgPSB1dltcIiR7bmFtZX1cIl1cbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYodWRbXCIke25hbWV9XCJdLmxvY2F0aW9uLCB1dltcIiR7bmFtZX1cIl0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBgXG4gIH0sXG4gIC8vIGhhbmRsaW5nIHNhbXBsZXJzXG4gIHtcbiAgICB0ZXN0OiAoZGF0YSwgdW5pZm9ybSkgPT4gKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW4sbm8tZXEtbnVsbCxlcWVxZXFcbiAgICAgIChkYXRhLnR5cGUgPT09IFwic2FtcGxlcjJEXCIgfHwgZGF0YS50eXBlID09PSBcInNhbXBsZXJDdWJlXCIgfHwgZGF0YS50eXBlID09PSBcInNhbXBsZXIyREFycmF5XCIpICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5ICYmICh1bmlmb3JtID09IG51bGwgfHwgdW5pZm9ybS5jYXN0VG9CYXNlVGV4dHVyZSAhPT0gdm9pZCAwKVxuICAgICksXG4gICAgY29kZTogKG5hbWUpID0+IGB0ID0gc3luY0RhdGEudGV4dHVyZUNvdW50Kys7XG5cbiAgICAgICAgICAgIHJlbmRlcmVyLnRleHR1cmUuYmluZCh1dltcIiR7bmFtZX1cIl0sIHQpO1xuXG4gICAgICAgICAgICBpZih1ZFtcIiR7bmFtZX1cIl0udmFsdWUgIT09IHQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdWRbXCIke25hbWV9XCJdLnZhbHVlID0gdDtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkodWRbXCIke25hbWV9XCJdLmxvY2F0aW9uLCB0KTtcbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG4gICAgICAgICAgICB9YFxuICB9LFxuICAvLyB1cGxvYWRpbmcgcGl4aSBtYXRyaXggb2JqZWN0IHRvIG1hdDNcbiAge1xuICAgIHRlc3Q6IChkYXRhLCB1bmlmb3JtKSA9PiBkYXRhLnR5cGUgPT09IFwibWF0M1wiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5ICYmIHVuaWZvcm0uYSAhPT0gdm9pZCAwLFxuICAgIGNvZGU6IChuYW1lKSA9PiAoXG4gICAgICAvLyBUT0RPIGFuZCBzb21lIHNtYXJ0IGNhY2hpbmcgZGlydHkgaWRzIGhlcmUhXG4gICAgICBgXG4gICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgZmFsc2UsIHV2W1wiJHtuYW1lfVwiXS50b0FycmF5KHRydWUpKTtcbiAgICAgICAgICAgIGBcbiAgICApLFxuICAgIGNvZGVVYm86IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgdmFyICR7bmFtZX1fbWF0cml4ID0gdXYuJHtuYW1lfS50b0FycmF5KHRydWUpO1xuXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gJHtuYW1lfV9tYXRyaXhbMF07XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSAke25hbWV9X21hdHJpeFsxXTtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsyXSA9ICR7bmFtZX1fbWF0cml4WzJdO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDRdID0gJHtuYW1lfV9tYXRyaXhbM107XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyA1XSA9ICR7bmFtZX1fbWF0cml4WzRdO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgNl0gPSAke25hbWV9X21hdHJpeFs1XTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyA4XSA9ICR7bmFtZX1fbWF0cml4WzZdO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgOV0gPSAke25hbWV9X21hdHJpeFs3XTtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDEwXSA9ICR7bmFtZX1fbWF0cml4WzhdO1xuICAgICAgICAgICAgYFxuICB9LFxuICAvLyB1cGxvYWRpbmcgYSBwaXhpIHBvaW50IGFzIGEgdmVjMiB3aXRoIGNhY2hpbmcgbGF5ZXJcbiAge1xuICAgIHRlc3Q6IChkYXRhLCB1bmlmb3JtKSA9PiBkYXRhLnR5cGUgPT09IFwidmVjMlwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5ICYmIHVuaWZvcm0ueCAhPT0gdm9pZCAwLFxuICAgIGNvZGU6IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgY3YgPSB1ZFtcIiR7bmFtZX1cIl0udmFsdWU7XG4gICAgICAgICAgICAgICAgdiA9IHV2W1wiJHtuYW1lfVwiXTtcblxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2LnggfHwgY3ZbMV0gIT09IHYueSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdi54O1xuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHYueTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgdi54LCB2LnkpO1xuICAgICAgICAgICAgICAgIH1gLFxuICAgIGNvZGVVYm86IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgdiA9IHV2LiR7bmFtZX07XG5cbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldF0gPSB2Lng7XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSB2Lnk7XG4gICAgICAgICAgICBgXG4gIH0sXG4gIC8vIGNhY2hpbmcgbGF5ZXIgZm9yIGEgdmVjMlxuICB7XG4gICAgdGVzdDogKGRhdGEpID0+IGRhdGEudHlwZSA9PT0gXCJ2ZWMyXCIgJiYgZGF0YS5zaXplID09PSAxICYmICFkYXRhLmlzQXJyYXksXG4gICAgY29kZTogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkW1wiJHtuYW1lfVwiXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2ID0gdXZbXCIke25hbWV9XCJdO1xuXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0pXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdlsxXTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgdlswXSwgdlsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYFxuICB9LFxuICAvLyB1cGxvYWQgYSBwaXhpIHJlY3RhbmdsZSBhcyBhIHZlYzQgd2l0aCBjYWNoaW5nIGxheWVyXG4gIHtcbiAgICB0ZXN0OiAoZGF0YSwgdW5pZm9ybSkgPT4gZGF0YS50eXBlID09PSBcInZlYzRcIiAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSAmJiB1bmlmb3JtLndpZHRoICE9PSB2b2lkIDAsXG4gICAgY29kZTogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkW1wiJHtuYW1lfVwiXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2ID0gdXZbXCIke25hbWV9XCJdO1xuXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHYueCB8fCBjdlsxXSAhPT0gdi55IHx8IGN2WzJdICE9PSB2LndpZHRoIHx8IGN2WzNdICE9PSB2LmhlaWdodClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdi54O1xuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHYueTtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMl0gPSB2LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjdlszXSA9IHYuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtNGYodWRbXCIke25hbWV9XCJdLmxvY2F0aW9uLCB2LngsIHYueSwgdi53aWR0aCwgdi5oZWlnaHQpXG4gICAgICAgICAgICAgICAgfWAsXG4gICAgY29kZVVibzogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICAgICAgdiA9IHV2LiR7bmFtZX07XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gdi54O1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsxXSA9IHYueTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMl0gPSB2LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCszXSA9IHYuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGBcbiAgfSxcbiAgLy8gdXBsb2FkIGEgcGl4aSBjb2xvciBhcyB2ZWM0IHdpdGggY2FjaGluZyBsYXllclxuICB7XG4gICAgdGVzdDogKGRhdGEsIHVuaWZvcm0pID0+IGRhdGEudHlwZSA9PT0gXCJ2ZWM0XCIgJiYgZGF0YS5zaXplID09PSAxICYmICFkYXRhLmlzQXJyYXkgJiYgdW5pZm9ybS5yZWQgIT09IHZvaWQgMCxcbiAgICBjb2RlOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgIGN2ID0gdWRbXCIke25hbWV9XCJdLnZhbHVlO1xuICAgICAgICAgICAgICAgIHYgPSB1dltcIiR7bmFtZX1cIl07XG5cbiAgICAgICAgICAgICAgICBpZihjdlswXSAhPT0gdi5yZWQgfHwgY3ZbMV0gIT09IHYuZ3JlZW4gfHwgY3ZbMl0gIT09IHYuYmx1ZSB8fCBjdlszXSAhPT0gdi5hbHBoYSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdi5yZWQ7XG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdi5ncmVlbjtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMl0gPSB2LmJsdWU7XG4gICAgICAgICAgICAgICAgICAgIGN2WzNdID0gdi5hbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgdi5yZWQsIHYuZ3JlZW4sIHYuYmx1ZSwgdi5hbHBoYSlcbiAgICAgICAgICAgICAgICB9YCxcbiAgICBjb2RlVWJvOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgICAgICB2ID0gdXYuJHtuYW1lfTtcblxuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldF0gPSB2LnJlZDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSB2LmdyZWVuO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsyXSA9IHYuYmx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrM10gPSB2LmFscGhhO1xuICAgICAgICAgICAgICAgIGBcbiAgfSxcbiAgLy8gdXBsb2FkIGEgcGl4aSBjb2xvciBhcyBhIHZlYzMgd2l0aCBjYWNoaW5nIGxheWVyXG4gIHtcbiAgICB0ZXN0OiAoZGF0YSwgdW5pZm9ybSkgPT4gZGF0YS50eXBlID09PSBcInZlYzNcIiAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSAmJiB1bmlmb3JtLnJlZCAhPT0gdm9pZCAwLFxuICAgIGNvZGU6IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgY3YgPSB1ZFtcIiR7bmFtZX1cIl0udmFsdWU7XG4gICAgICAgICAgICAgICAgdiA9IHV2W1wiJHtuYW1lfVwiXTtcblxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2LnJlZCB8fCBjdlsxXSAhPT0gdi5ncmVlbiB8fCBjdlsyXSAhPT0gdi5ibHVlIHx8IGN2WzNdICE9PSB2LmEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdlswXSA9IHYucmVkO1xuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHYuZ3JlZW47XG4gICAgICAgICAgICAgICAgICAgIGN2WzJdID0gdi5ibHVlO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2YodWRbXCIke25hbWV9XCJdLmxvY2F0aW9uLCB2LnJlZCwgdi5ncmVlbiwgdi5ibHVlKVxuICAgICAgICAgICAgICAgIH1gLFxuICAgIGNvZGVVYm86IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgICAgIHYgPSB1di4ke25hbWV9O1xuXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IHYucmVkO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsxXSA9IHYuZ3JlZW47XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzJdID0gdi5ibHVlO1xuICAgICAgICAgICAgICAgIGBcbiAgfSxcbiAgLy8gYSBjYWNoaW5nIGxheWVyIGZvciB2ZWM0IHVwbG9hZGluZ1xuICB7XG4gICAgdGVzdDogKGRhdGEpID0+IGRhdGEudHlwZSA9PT0gXCJ2ZWM0XCIgJiYgZGF0YS5zaXplID09PSAxICYmICFkYXRhLmlzQXJyYXksXG4gICAgY29kZTogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkW1wiJHtuYW1lfVwiXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2ID0gdXZbXCIke25hbWV9XCJdO1xuXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0gfHwgY3ZbM10gIT09IHZbM10pXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdlsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMl0gPSB2WzJdO1xuICAgICAgICAgICAgICAgICAgICBjdlszXSA9IHZbM107XG5cbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSlcbiAgICAgICAgICAgICAgICB9YFxuICB9XG5dO1xuZXhwb3J0cy51bmlmb3JtUGFyc2VycyA9IHVuaWZvcm1QYXJzZXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pZm9ybVBhcnNlcnMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmxldCB1bnNhZmVFdmFsO1xuZnVuY3Rpb24gdW5zYWZlRXZhbFN1cHBvcnRlZCgpIHtcbiAgaWYgKHR5cGVvZiB1bnNhZmVFdmFsID09IFwiYm9vbGVhblwiKVxuICAgIHJldHVybiB1bnNhZmVFdmFsO1xuICB0cnkge1xuICAgIHVuc2FmZUV2YWwgPSBuZXcgRnVuY3Rpb24oXCJwYXJhbTFcIiwgXCJwYXJhbTJcIiwgXCJwYXJhbTNcIiwgXCJyZXR1cm4gcGFyYW0xW3BhcmFtMl0gPT09IHBhcmFtMztcIikoeyBhOiBcImJcIiB9LCBcImFcIiwgXCJiXCIpID09PSAhMDtcbiAgfSBjYXRjaCB7XG4gICAgdW5zYWZlRXZhbCA9ICExO1xuICB9XG4gIHJldHVybiB1bnNhZmVFdmFsO1xufVxuZXhwb3J0cy51bnNhZmVFdmFsU3VwcG9ydGVkID0gdW5zYWZlRXZhbFN1cHBvcnRlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuc2FmZUV2YWxTdXBwb3J0ZWQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBleHRlbnNpb25zID0gcmVxdWlyZShcIkBwaXhpL2V4dGVuc2lvbnNcIik7XG5jbGFzcyBTdGFydHVwU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIEl0IGFsbCBzdGFydHMgaGVyZSEgVGhpcyBpbml0aWF0ZXMgZXZlcnkgc3lzdGVtLCBwYXNzaW5nIGluIHRoZSBvcHRpb25zIGZvciBhbnkgc3lzdGVtIGJ5IG5hbWUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIGNvbmZpZyBmb3IgdGhlIHJlbmRlcmVyIGFuZCBhbGwgaXRzIHN5c3RlbXNcbiAgICovXG4gIHJ1bihvcHRpb25zKSB7XG4gICAgY29uc3QgeyByZW5kZXJlciB9ID0gdGhpcztcbiAgICByZW5kZXJlci5ydW5uZXJzLmluaXQuZW1pdChyZW5kZXJlci5vcHRpb25zKSwgb3B0aW9ucy5oZWxsbyAmJiBjb25zb2xlLmxvZyhgUGl4aUpTIDcuMy4yIC0gJHtyZW5kZXJlci5yZW5kZXJlckxvZ0lkfSAtIGh0dHBzOi8vcGl4aWpzLmNvbWApLCByZW5kZXJlci5yZXNpemUocmVuZGVyZXIuc2NyZWVuLndpZHRoLCByZW5kZXJlci5zY3JlZW4uaGVpZ2h0KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICB9XG59XG5TdGFydHVwU3lzdGVtLmRlZmF1bHRPcHRpb25zID0ge1xuICAvKipcbiAgICoge0BsaW5rIFBJWEkuSVJlbmRlcmVyT3B0aW9ucy5oZWxsb31cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3MuUkVOREVSX09QVElPTlNcbiAgICovXG4gIGhlbGxvOiAhMVxufSwgLyoqIEBpZ25vcmUgKi9cblN0YXJ0dXBTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICAgIGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5DYW52YXNSZW5kZXJlclN5c3RlbVxuICBdLFxuICBuYW1lOiBcInN0YXJ0dXBcIlxufTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5hZGQoU3RhcnR1cFN5c3RlbSk7XG5leHBvcnRzLlN0YXJ0dXBTeXN0ZW0gPSBTdGFydHVwU3lzdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhcnR1cFN5c3RlbS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCJAcGl4aS9jb25zdGFudHNcIik7XG5jb25zdCBCTEVORCA9IDAsIE9GRlNFVCA9IDEsIENVTExJTkcgPSAyLCBERVBUSF9URVNUID0gMywgV0lORElORyA9IDQsIERFUFRIX01BU0sgPSA1O1xuY2xhc3MgU3RhdGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRhdGEgPSAwLCB0aGlzLmJsZW5kTW9kZSA9IGNvbnN0YW50cy5CTEVORF9NT0RFUy5OT1JNQUwsIHRoaXMucG9seWdvbk9mZnNldCA9IDAsIHRoaXMuYmxlbmQgPSAhMCwgdGhpcy5kZXB0aE1hc2sgPSAhMDtcbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGVzIGJsZW5kaW5nIG9mIHRoZSBjb21wdXRlZCBmcmFnbWVudCBjb2xvciB2YWx1ZXMuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGdldCBibGVuZCgpIHtcbiAgICByZXR1cm4gISEodGhpcy5kYXRhICYgMSA8PCBCTEVORCk7XG4gIH1cbiAgc2V0IGJsZW5kKHZhbHVlKSB7XG4gICAgISEodGhpcy5kYXRhICYgMSA8PCBCTEVORCkgIT09IHZhbHVlICYmICh0aGlzLmRhdGEgXj0gMSA8PCBCTEVORCk7XG4gIH1cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyBhZGRpbmcgYW4gb2Zmc2V0IHRvIGRlcHRoIHZhbHVlcyBvZiBwb2x5Z29uJ3MgZnJhZ21lbnRzXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBnZXQgb2Zmc2V0cygpIHtcbiAgICByZXR1cm4gISEodGhpcy5kYXRhICYgMSA8PCBPRkZTRVQpO1xuICB9XG4gIHNldCBvZmZzZXRzKHZhbHVlKSB7XG4gICAgISEodGhpcy5kYXRhICYgMSA8PCBPRkZTRVQpICE9PSB2YWx1ZSAmJiAodGhpcy5kYXRhIF49IDEgPDwgT0ZGU0VUKTtcbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGVzIGN1bGxpbmcgb2YgcG9seWdvbnMuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBnZXQgY3VsbGluZygpIHtcbiAgICByZXR1cm4gISEodGhpcy5kYXRhICYgMSA8PCBDVUxMSU5HKTtcbiAgfVxuICBzZXQgY3VsbGluZyh2YWx1ZSkge1xuICAgICEhKHRoaXMuZGF0YSAmIDEgPDwgQ1VMTElORykgIT09IHZhbHVlICYmICh0aGlzLmRhdGEgXj0gMSA8PCBDVUxMSU5HKTtcbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGVzIGRlcHRoIGNvbXBhcmlzb25zIGFuZCB1cGRhdGVzIHRvIHRoZSBkZXB0aCBidWZmZXIuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBnZXQgZGVwdGhUZXN0KCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAxIDw8IERFUFRIX1RFU1QpO1xuICB9XG4gIHNldCBkZXB0aFRlc3QodmFsdWUpIHtcbiAgICAhISh0aGlzLmRhdGEgJiAxIDw8IERFUFRIX1RFU1QpICE9PSB2YWx1ZSAmJiAodGhpcy5kYXRhIF49IDEgPDwgREVQVEhfVEVTVCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgd3JpdGluZyB0byB0aGUgZGVwdGggYnVmZmVyLlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBnZXQgZGVwdGhNYXNrKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAxIDw8IERFUFRIX01BU0spO1xuICB9XG4gIHNldCBkZXB0aE1hc2sodmFsdWUpIHtcbiAgICAhISh0aGlzLmRhdGEgJiAxIDw8IERFUFRIX01BU0spICE9PSB2YWx1ZSAmJiAodGhpcy5kYXRhIF49IDEgPDwgREVQVEhfTUFTSyk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCBmcm9udCBvciBiYWNrLWZhY2luZyBwb2x5Z29ucyBjYW4gYmUgY3VsbGVkLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZ2V0IGNsb2Nrd2lzZUZyb250RmFjZSgpIHtcbiAgICByZXR1cm4gISEodGhpcy5kYXRhICYgMSA8PCBXSU5ESU5HKTtcbiAgfVxuICBzZXQgY2xvY2t3aXNlRnJvbnRGYWNlKHZhbHVlKSB7XG4gICAgISEodGhpcy5kYXRhICYgMSA8PCBXSU5ESU5HKSAhPT0gdmFsdWUgJiYgKHRoaXMuZGF0YSBePSAxIDw8IFdJTkRJTkcpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHdoZW4gdGhpcyBzdGF0ZSBpcyBzZXQuIEFwcGx5IGEgdmFsdWUgb2YgYFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMYCB0byByZXNldCB0aGUgYmxlbmQgbW9kZS5cbiAgICogU2V0dGluZyB0aGlzIG1vZGUgdG8gYW55dGhpbmcgb3RoZXIgdGhhbiBOT19CTEVORCB3aWxsIGF1dG9tYXRpY2FsbHkgc3dpdGNoIGJsZW5kaW5nIG9uLlxuICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTFxuICAgKi9cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxlbmRNb2RlO1xuICB9XG4gIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLmJsZW5kID0gdmFsdWUgIT09IGNvbnN0YW50cy5CTEVORF9NT0RFUy5OT05FLCB0aGlzLl9ibGVuZE1vZGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHBvbHlnb24gb2Zmc2V0LiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgdG8gYW55dGhpbmcgb3RoZXIgdGhhbiAwIHdpbGwgYXV0b21hdGljYWxseSBlbmFibGUgcG9seWdvbiBvZmZzZXQgZmlsbC5cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZ2V0IHBvbHlnb25PZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvbHlnb25PZmZzZXQ7XG4gIH1cbiAgc2V0IHBvbHlnb25PZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLm9mZnNldHMgPSAhIXZhbHVlLCB0aGlzLl9wb2x5Z29uT2Zmc2V0ID0gdmFsdWU7XG4gIH1cbiAgc3RhdGljIGZvcjJkKCkge1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgcmV0dXJuIHN0YXRlLmRlcHRoVGVzdCA9ICExLCBzdGF0ZS5ibGVuZCA9ICEwLCBzdGF0ZTtcbiAgfVxufVxuU3RhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBgW0BwaXhpL2NvcmU6U3RhdGUgYmxlbmRNb2RlPSR7dGhpcy5ibGVuZE1vZGV9IGNsb2Nrd2lzZUZyb250RmFjZT0ke3RoaXMuY2xvY2t3aXNlRnJvbnRGYWNlfSBjdWxsaW5nPSR7dGhpcy5jdWxsaW5nfSBkZXB0aE1hc2s9JHt0aGlzLmRlcHRoTWFza30gcG9seWdvbk9mZnNldD0ke3RoaXMucG9seWdvbk9mZnNldH1dYDtcbn07XG5leHBvcnRzLlN0YXRlID0gU3RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0ZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCJAcGl4aS9jb25zdGFudHNcIiksIGV4dGVuc2lvbnMgPSByZXF1aXJlKFwiQHBpeGkvZXh0ZW5zaW9uc1wiKSwgU3RhdGUgPSByZXF1aXJlKFwiLi9TdGF0ZS5qc1wiKSwgbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpID0gcmVxdWlyZShcIi4vdXRpbHMvbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpLmpzXCIpO1xuY29uc3QgQkxFTkQgPSAwLCBPRkZTRVQgPSAxLCBDVUxMSU5HID0gMiwgREVQVEhfVEVTVCA9IDMsIFdJTkRJTkcgPSA0LCBERVBUSF9NQVNLID0gNSwgX1N0YXRlU3lzdGVtID0gY2xhc3MgX1N0YXRlU3lzdGVtMiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZ2wgPSBudWxsLCB0aGlzLnN0YXRlSWQgPSAwLCB0aGlzLnBvbHlnb25PZmZzZXQgPSAwLCB0aGlzLmJsZW5kTW9kZSA9IGNvbnN0YW50cy5CTEVORF9NT0RFUy5OT05FLCB0aGlzLl9ibGVuZEVxID0gITEsIHRoaXMubWFwID0gW10sIHRoaXMubWFwW0JMRU5EXSA9IHRoaXMuc2V0QmxlbmQsIHRoaXMubWFwW09GRlNFVF0gPSB0aGlzLnNldE9mZnNldCwgdGhpcy5tYXBbQ1VMTElOR10gPSB0aGlzLnNldEN1bGxGYWNlLCB0aGlzLm1hcFtERVBUSF9URVNUXSA9IHRoaXMuc2V0RGVwdGhUZXN0LCB0aGlzLm1hcFtXSU5ESU5HXSA9IHRoaXMuc2V0RnJvbnRGYWNlLCB0aGlzLm1hcFtERVBUSF9NQVNLXSA9IHRoaXMuc2V0RGVwdGhNYXNrLCB0aGlzLmNoZWNrcyA9IFtdLCB0aGlzLmRlZmF1bHRTdGF0ZSA9IG5ldyBTdGF0ZS5TdGF0ZSgpLCB0aGlzLmRlZmF1bHRTdGF0ZS5ibGVuZCA9ICEwO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoZ2wpIHtcbiAgICB0aGlzLmdsID0gZ2wsIHRoaXMuYmxlbmRNb2RlcyA9IG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aS5tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkoZ2wpLCB0aGlzLnNldCh0aGlzLmRlZmF1bHRTdGF0ZSksIHRoaXMucmVzZXQoKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBzdGF0ZVxuICAgKiBAcGFyYW0geyp9IHN0YXRlIC0gVGhlIHN0YXRlIHRvIHNldC5cbiAgICovXG4gIHNldChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9IHN0YXRlIHx8IHRoaXMuZGVmYXVsdFN0YXRlLCB0aGlzLnN0YXRlSWQgIT09IHN0YXRlLmRhdGEpIHtcbiAgICAgIGxldCBkaWZmID0gdGhpcy5zdGF0ZUlkIF4gc3RhdGUuZGF0YSwgaSA9IDA7XG4gICAgICBmb3IgKDsgZGlmZjsgKVxuICAgICAgICBkaWZmICYgMSAmJiB0aGlzLm1hcFtpXS5jYWxsKHRoaXMsICEhKHN0YXRlLmRhdGEgJiAxIDw8IGkpKSwgZGlmZiA9IGRpZmYgPj4gMSwgaSsrO1xuICAgICAgdGhpcy5zdGF0ZUlkID0gc3RhdGUuZGF0YTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoZWNrcy5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMuY2hlY2tzW2ldKHRoaXMsIHN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc3RhdGUsIHdoZW4gcHJldmlvdXMgc3RhdGUgaXMgdW5rbm93bi5cbiAgICogQHBhcmFtIHsqfSBzdGF0ZSAtIFRoZSBzdGF0ZSB0byBzZXRcbiAgICovXG4gIGZvcmNlU3RhdGUoc3RhdGUpIHtcbiAgICBzdGF0ZSA9IHN0YXRlIHx8IHRoaXMuZGVmYXVsdFN0YXRlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXAubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLm1hcFtpXS5jYWxsKHRoaXMsICEhKHN0YXRlLmRhdGEgJiAxIDw8IGkpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hlY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5jaGVja3NbaV0odGhpcywgc3RhdGUpO1xuICAgIHRoaXMuc3RhdGVJZCA9IHN0YXRlLmRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0byBlbmFibGUgb3IgZGlzYWJsZSBibGVuZGluZy5cbiAgICogQHBhcmFtIHZhbHVlIC0gVHVybiBvbiBvciBvZmYgV2ViR2wgYmxlbmRpbmcuXG4gICAqL1xuICBzZXRCbGVuZCh2YWx1ZSkge1xuICAgIHRoaXMudXBkYXRlQ2hlY2soX1N0YXRlU3lzdGVtMi5jaGVja0JsZW5kTW9kZSwgdmFsdWUpLCB0aGlzLmdsW3ZhbHVlID8gXCJlbmFibGVcIiA6IFwiZGlzYWJsZVwiXSh0aGlzLmdsLkJMRU5EKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlIHBvbHlnb24gb2Zmc2V0IGZpbGwuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFR1cm4gb24gb3Igb2ZmIHdlYmdsIHBvbHlnb24gb2Zmc2V0IHRlc3RpbmcuXG4gICAqL1xuICBzZXRPZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLnVwZGF0ZUNoZWNrKF9TdGF0ZVN5c3RlbTIuY2hlY2tQb2x5Z29uT2Zmc2V0LCB2YWx1ZSksIHRoaXMuZ2xbdmFsdWUgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCJdKHRoaXMuZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0byBlbmFibGUgb3IgZGlzYWJsZSBkZXB0aCB0ZXN0LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiB3ZWJnbCBkZXB0aCB0ZXN0aW5nLlxuICAgKi9cbiAgc2V0RGVwdGhUZXN0KHZhbHVlKSB7XG4gICAgdGhpcy5nbFt2YWx1ZSA/IFwiZW5hYmxlXCIgOiBcImRpc2FibGVcIl0odGhpcy5nbC5ERVBUSF9URVNUKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlIGRlcHRoIG1hc2suXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFR1cm4gb24gb3Igb2ZmIHdlYmdsIGRlcHRoIG1hc2suXG4gICAqL1xuICBzZXREZXB0aE1hc2sodmFsdWUpIHtcbiAgICB0aGlzLmdsLmRlcHRoTWFzayh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0byBlbmFibGUgb3IgZGlzYWJsZSBjdWxsIGZhY2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiB3ZWJnbCBjdWxsIGZhY2UuXG4gICAqL1xuICBzZXRDdWxsRmFjZSh2YWx1ZSkge1xuICAgIHRoaXMuZ2xbdmFsdWUgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCJdKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZ2wgZnJvbnQgZmFjZS5cbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIHRydWUgaXMgY2xvY2t3aXNlIGFuZCBmYWxzZSBpcyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgKi9cbiAgc2V0RnJvbnRGYWNlKHZhbHVlKSB7XG4gICAgdGhpcy5nbC5mcm9udEZhY2UodGhpcy5nbFt2YWx1ZSA/IFwiQ1dcIiA6IFwiQ0NXXCJdKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmxlbmQgbW9kZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIGJsZW5kIG1vZGUgdG8gc2V0IHRvLlxuICAgKi9cbiAgc2V0QmxlbmRNb2RlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0aGlzLmJsZW5kTW9kZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IHZhbHVlO1xuICAgIGNvbnN0IG1vZGUgPSB0aGlzLmJsZW5kTW9kZXNbdmFsdWVdLCBnbCA9IHRoaXMuZ2w7XG4gICAgbW9kZS5sZW5ndGggPT09IDIgPyBnbC5ibGVuZEZ1bmMobW9kZVswXSwgbW9kZVsxXSkgOiBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShtb2RlWzBdLCBtb2RlWzFdLCBtb2RlWzJdLCBtb2RlWzNdKSwgbW9kZS5sZW5ndGggPT09IDYgPyAodGhpcy5fYmxlbmRFcSA9ICEwLCBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUobW9kZVs0XSwgbW9kZVs1XSkpIDogdGhpcy5fYmxlbmRFcSAmJiAodGhpcy5fYmxlbmRFcSA9ICExLCBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvbHlnb24gb2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB0aGUgcG9seWdvbiBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0gdGhlIHBvbHlnb24gb2Zmc2V0IHNjYWxlXG4gICAqL1xuICBzZXRQb2x5Z29uT2Zmc2V0KHZhbHVlLCBzY2FsZSkge1xuICAgIHRoaXMuZ2wucG9seWdvbk9mZnNldCh2YWx1ZSwgc2NhbGUpO1xuICB9XG4gIC8vIHVzZWRcbiAgLyoqIFJlc2V0cyBhbGwgdGhlIGxvZ2ljIGFuZCBkaXNhYmxlcyB0aGUgVkFPcy4gKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5nbC5waXhlbFN0b3JlaSh0aGlzLmdsLlVOUEFDS19GTElQX1lfV0VCR0wsICExKSwgdGhpcy5mb3JjZVN0YXRlKHRoaXMuZGVmYXVsdFN0YXRlKSwgdGhpcy5fYmxlbmRFcSA9ICEwLCB0aGlzLmJsZW5kTW9kZSA9IC0xLCB0aGlzLnNldEJsZW5kTW9kZSgwKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHRvIHNlZSB3aGljaCB1cGRhdGVzIHNob3VsZCBiZSBjaGVja2VkIGJhc2VkIG9uIHdoaWNoIHNldHRpbmdzIGhhdmUgYmVlbiBhY3RpdmF0ZWQuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBpZiBibGVuZCBpcyBlbmFibGVkIHRoZW4gd2Ugc2hvdWxkIGNoZWNrIHRoZSBibGVuZCBtb2RlcyBlYWNoIHRpbWUgdGhlIHN0YXRlIGlzIGNoYW5nZWRcbiAgICogb3IgaWYgcG9seWdvbiBmaWxsIGlzIGFjdGl2YXRlZCB0aGVuIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHBvbHlnb24gb2Zmc2V0IGNoYW5nZXMuXG4gICAqIFRoZSBpZGVhIGlzIHRoYXQgd2Ugb25seSBjaGVjayB3aGF0IHdlIGhhdmUgdG9vLlxuICAgKiBAcGFyYW0gZnVuYyAtIHRoZSBjaGVja2luZyBmdW5jdGlvbiB0byBhZGQgb3IgcmVtb3ZlXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHNob3VsZCB0aGUgY2hlY2sgZnVuY3Rpb24gYmUgYWRkZWQgb3IgcmVtb3ZlZC5cbiAgICovXG4gIHVwZGF0ZUNoZWNrKGZ1bmMsIHZhbHVlKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNoZWNrcy5pbmRleE9mKGZ1bmMpO1xuICAgIHZhbHVlICYmIGluZGV4ID09PSAtMSA/IHRoaXMuY2hlY2tzLnB1c2goZnVuYykgOiAhdmFsdWUgJiYgaW5kZXggIT09IC0xICYmIHRoaXMuY2hlY2tzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgcHJpdmF0ZSBsaXR0bGUgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHdlIGNhbGwgdG8gY2hlY2sgdGhlIGJsZW5kIG1vZGUuXG4gICAqIEBwYXJhbSBzeXN0ZW0gLSB0aGUgU3lzdGVtIHRvIHBlcmZvcm0gdGhlIHN0YXRlIGNoZWNrIG9uXG4gICAqIEBwYXJhbSBzdGF0ZSAtIHRoZSBzdGF0ZSB0aGF0IHRoZSBibGVuZE1vZGUgd2lsbCBwdWxsZWQgZnJvbVxuICAgKi9cbiAgc3RhdGljIGNoZWNrQmxlbmRNb2RlKHN5c3RlbSwgc3RhdGUpIHtcbiAgICBzeXN0ZW0uc2V0QmxlbmRNb2RlKHN0YXRlLmJsZW5kTW9kZSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgcHJpdmF0ZSBsaXR0bGUgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHdlIGNhbGwgdG8gY2hlY2sgdGhlIHBvbHlnb24gb2Zmc2V0LlxuICAgKiBAcGFyYW0gc3lzdGVtIC0gdGhlIFN5c3RlbSB0byBwZXJmb3JtIHRoZSBzdGF0ZSBjaGVjayBvblxuICAgKiBAcGFyYW0gc3RhdGUgLSB0aGUgc3RhdGUgdGhhdCB0aGUgYmxlbmRNb2RlIHdpbGwgcHVsbGVkIGZyb21cbiAgICovXG4gIHN0YXRpYyBjaGVja1BvbHlnb25PZmZzZXQoc3lzdGVtLCBzdGF0ZSkge1xuICAgIHN5c3RlbS5zZXRQb2x5Z29uT2Zmc2V0KDEsIHN0YXRlLnBvbHlnb25PZmZzZXQpO1xuICB9XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuICB9XG59O1xuX1N0YXRlU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcInN0YXRlXCJcbn07XG5sZXQgU3RhdGVTeXN0ZW0gPSBfU3RhdGVTeXN0ZW07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKFN0YXRlU3lzdGVtKTtcbmV4cG9ydHMuU3RhdGVTeXN0ZW0gPSBTdGF0ZVN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YXRlU3lzdGVtLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKTtcbmZ1bmN0aW9uIG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aShnbCwgYXJyYXkgPSBbXSkge1xuICByZXR1cm4gYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLk5PUk1BTF0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXSwgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLkFERF0gPSBbZ2wuT05FLCBnbC5PTkVdLCBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuTVVMVElQTFldID0gW2dsLkRTVF9DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXSwgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLlNDUkVFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdLCBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuT1ZFUkxBWV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXSwgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLkRBUktFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXSwgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLkxJR0hURU5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5DT0xPUl9ET0RHRV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXSwgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLkNPTE9SX0JVUk5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5IQVJEX0xJR0hUXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdLCBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuU09GVF9MSUdIVF0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXSwgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLkRJRkZFUkVOQ0VdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5FWENMVVNJT05dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5IVUVdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5TQVRVUkFUSU9OXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdLCBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuQ09MT1JdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5MVU1JTk9TSVRZXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdLCBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuTk9ORV0gPSBbMCwgMF0sIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5OT1JNQUxfTlBNXSA9IFtnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5BRERfTlBNXSA9IFtnbC5TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FLCBnbC5PTkVdLCBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuU0NSRUVOX05QTV0gPSBbZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdLCBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuU1JDX0lOXSA9IFtnbC5EU1RfQUxQSEEsIGdsLlpFUk9dLCBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuU1JDX09VVF0gPSBbZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgZ2wuWkVST10sIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5TUkNfQVRPUF0gPSBbZ2wuRFNUX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXSwgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLkRTVF9PVkVSXSA9IFtnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5PTkVdLCBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuRFNUX0lOXSA9IFtnbC5aRVJPLCBnbC5TUkNfQUxQSEFdLCBhcnJheVtjb25zdGFudHMuQkxFTkRfTU9ERVMuRFNUX09VVF0gPSBbZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5EU1RfQVRPUF0gPSBbZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgZ2wuU1JDX0FMUEhBXSwgYXJyYXlbY29uc3RhbnRzLkJMRU5EX01PREVTLlhPUl0gPSBbZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV0sIGFycmF5W2NvbnN0YW50cy5CTEVORF9NT0RFUy5TVUJUUkFDVF0gPSBbZ2wuT05FLCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FLCBnbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1QsIGdsLkZVTkNfQUREXSwgYXJyYXk7XG59XG5leHBvcnRzLm1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aSA9IG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SVN5c3RlbS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJ1bm5lciA9IHJlcXVpcmUoXCJAcGl4aS9ydW5uZXJcIiksIHV0aWxzID0gcmVxdWlyZShcIkBwaXhpL3V0aWxzXCIpO1xuY2xhc3MgU3lzdGVtTWFuYWdlciBleHRlbmRzIHV0aWxzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMucnVubmVycyA9IHt9LCB0aGlzLl9zeXN0ZW1zSGFzaCA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdXAgYSBzeXN0ZW0gd2l0aCBhIGNvbGxlY3Rpb24gb2YgU3lzdGVtQ2xhc3NlcyBhbmQgcnVubmVycy5cbiAgICogU3lzdGVtcyBhcmUgYXR0YWNoZWQgZHluYW1pY2FsbHkgdG8gdGhpcyBjbGFzcyB3aGVuIGFkZGVkLlxuICAgKiBAcGFyYW0gY29uZmlnIC0gdGhlIGNvbmZpZyBmb3IgdGhlIHN5c3RlbSBtYW5hZ2VyXG4gICAqL1xuICBzZXR1cChjb25maWcpIHtcbiAgICB0aGlzLmFkZFJ1bm5lcnMoLi4uY29uZmlnLnJ1bm5lcnMpO1xuICAgIGNvbnN0IHByaW9yaXR5ID0gKGNvbmZpZy5wcmlvcml0eSA/PyBbXSkuZmlsdGVyKChrZXkpID0+IGNvbmZpZy5zeXN0ZW1zW2tleV0pLCBvcmRlckJ5UHJpb3JpdHkgPSBbXG4gICAgICAuLi5wcmlvcml0eSxcbiAgICAgIC4uLk9iamVjdC5rZXlzKGNvbmZpZy5zeXN0ZW1zKS5maWx0ZXIoKGtleSkgPT4gIXByaW9yaXR5LmluY2x1ZGVzKGtleSkpXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IGkgb2Ygb3JkZXJCeVByaW9yaXR5KVxuICAgICAgdGhpcy5hZGRTeXN0ZW0oY29uZmlnLnN5c3RlbXNbaV0sIGkpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBidW5jaCBvZiBydW5uZXJzIGJhc2VkIG9mIGEgY29sbGVjdGlvbiBvZiBpZHNcbiAgICogQHBhcmFtIHJ1bm5lcklkcyAtIHRoZSBydW5uZXIgaWRzIHRvIGFkZFxuICAgKi9cbiAgYWRkUnVubmVycyguLi5ydW5uZXJJZHMpIHtcbiAgICBydW5uZXJJZHMuZm9yRWFjaCgocnVubmVySWQpID0+IHtcbiAgICAgIHRoaXMucnVubmVyc1tydW5uZXJJZF0gPSBuZXcgcnVubmVyLlJ1bm5lcihydW5uZXJJZCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBzeXN0ZW0gdG8gdGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0gQ2xhc3NSZWYgLSBDbGFzcyByZWZlcmVuY2VcbiAgICogQHBhcmFtIG5hbWUgLSBQcm9wZXJ0eSBuYW1lIGZvciBzeXN0ZW0sIGlmIG5vdCBzcGVjaWZpZWRcbiAgICogICAgICAgIHdpbGwgdXNlIGEgc3RhdGljIGBuYW1lYCBwcm9wZXJ0eSBvbiB0aGUgY2xhc3MgaXRzZWxmLiBUaGlzXG4gICAqICAgICAgICBuYW1lIHdpbGwgYmUgYXNzaWduZWQgYXMgcyBwcm9wZXJ0eSBvbiB0aGUgUmVuZGVyZXIgc28gbWFrZVxuICAgKiAgICAgICAgc3VyZSBpdCBkb2Vzbid0IGNvbGxpZGUgd2l0aCBwcm9wZXJ0aWVzIG9uIFJlbmRlcmVyLlxuICAgKiBAcmV0dXJucyBSZXR1cm4gaW5zdGFuY2Ugb2YgcmVuZGVyZXJcbiAgICovXG4gIGFkZFN5c3RlbShDbGFzc1JlZiwgbmFtZSkge1xuICAgIGNvbnN0IHN5c3RlbSA9IG5ldyBDbGFzc1JlZih0aGlzKTtcbiAgICBpZiAodGhpc1tuYW1lXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgV2hvb3BzISBUaGUgbmFtZSBcIiR7bmFtZX1cIiBpcyBhbHJlYWR5IGluIHVzZWApO1xuICAgIHRoaXNbbmFtZV0gPSBzeXN0ZW0sIHRoaXMuX3N5c3RlbXNIYXNoW25hbWVdID0gc3lzdGVtO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnJ1bm5lcnMpXG4gICAgICB0aGlzLnJ1bm5lcnNbaV0uYWRkKHN5c3RlbSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJ1biBhIHJ1bm5lciBhbmQgY2FsbCB0aGUgcnVubmVycyBmdW5jdGlvbiBidXQgcGFzcyBpbiBkaWZmZXJlbnQgb3B0aW9uc1xuICAgKiB0byBlYWNoIHN5c3RlbSBiYXNlZCBvbiB0aGVyZSBuYW1lLlxuICAgKlxuICAgKiBFLmcuIElmIHlvdSBoYXZlIHR3byBzeXN0ZW1zIGFkZGVkIGNhbGxlZCBgc3lzdGVtQWAgYW5kIGBzeXN0ZW1CYCB5b3UgY291bGQgY2FsbCBkbyB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBzeXN0ZW0uZW1pdFdpdGhDdXN0b21PcHRpb25zKGluaXQsIHtcbiAgICogICAgIHN5c3RlbUE6IHsuLi5vcHRpb25zRm9yQX0sXG4gICAqICAgICBzeXN0ZW1COiB7Li4ub3B0aW9uc0ZvckJ9LFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIGBpbml0YCB3b3VsZCBiZSBjYWxsZWQgb24gc3lzdGVtIEEgcGFzc2luZyBgb3B0aW9uc0ZvckFgIGFuZCBvbiBzeXN0ZW0gQiBwYXNzaW5nIGBvcHRpb25zRm9yQmAuXG4gICAqIEBwYXJhbSBydW5uZXIgLSB0aGUgcnVubmVyIHRvIHRhcmdldFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGtleSB2YWx1ZSBvcHRpb25zIGZvciBlYWNoIHN5c3RlbVxuICAgKi9cbiAgZW1pdFdpdGhDdXN0b21PcHRpb25zKHJ1bm5lcjIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzeXN0ZW1IYXNoS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX3N5c3RlbXNIYXNoKTtcbiAgICBydW5uZXIyLml0ZW1zLmZvckVhY2goKHN5c3RlbSkgPT4ge1xuICAgICAgY29uc3Qgc3lzdGVtTmFtZSA9IHN5c3RlbUhhc2hLZXlzLmZpbmQoKHN5c3RlbUlkKSA9PiB0aGlzLl9zeXN0ZW1zSGFzaFtzeXN0ZW1JZF0gPT09IHN5c3RlbSk7XG4gICAgICBzeXN0ZW1bcnVubmVyMi5uYW1lXShvcHRpb25zW3N5c3RlbU5hbWVdKTtcbiAgICB9KTtcbiAgfVxuICAvKiogZGVzdHJveSB0aGUgYWxsIHJ1bm5lcnMgYW5kIHN5c3RlbXMuIEl0cyBhcHBzIGpvYiB0byAqL1xuICBkZXN0cm95KCkge1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5ydW5uZXJzKS5mb3JFYWNoKChydW5uZXIyKSA9PiB7XG4gICAgICBydW5uZXIyLmRlc3Ryb3koKTtcbiAgICB9KSwgdGhpcy5fc3lzdGVtc0hhc2ggPSB7fTtcbiAgfVxuICAvLyBUT0RPIGltcGxlbWVudCFcbiAgLy8gcmVtb3ZlU3lzdGVtKENsYXNzUmVmOiBJU3lzdGVtQ29uc3RydWN0b3IsIG5hbWU6IHN0cmluZyk6IHZvaWRcbiAgLy8ge1xuICAvLyB9XG59XG5leHBvcnRzLlN5c3RlbU1hbmFnZXIgPSBTeXN0ZW1NYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3lzdGVtTWFuYWdlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIEJhY2tncm91bmRTeXN0ZW0gPSByZXF1aXJlKFwiLi9iYWNrZ3JvdW5kL0JhY2tncm91bmRTeXN0ZW0uanNcIiksIEJhdGNoU3lzdGVtID0gcmVxdWlyZShcIi4vYmF0Y2gvQmF0Y2hTeXN0ZW0uanNcIiksIENvbnRleHRTeXN0ZW0gPSByZXF1aXJlKFwiLi9jb250ZXh0L0NvbnRleHRTeXN0ZW0uanNcIiksIEZpbHRlclN5c3RlbSA9IHJlcXVpcmUoXCIuL2ZpbHRlcnMvRmlsdGVyU3lzdGVtLmpzXCIpLCBGcmFtZWJ1ZmZlclN5c3RlbSA9IHJlcXVpcmUoXCIuL2ZyYW1lYnVmZmVyL0ZyYW1lYnVmZmVyU3lzdGVtLmpzXCIpLCBHZW9tZXRyeVN5c3RlbSA9IHJlcXVpcmUoXCIuL2dlb21ldHJ5L0dlb21ldHJ5U3lzdGVtLmpzXCIpLCBNYXNrU3lzdGVtID0gcmVxdWlyZShcIi4vbWFzay9NYXNrU3lzdGVtLmpzXCIpLCBTY2lzc29yU3lzdGVtID0gcmVxdWlyZShcIi4vbWFzay9TY2lzc29yU3lzdGVtLmpzXCIpLCBTdGVuY2lsU3lzdGVtID0gcmVxdWlyZShcIi4vbWFzay9TdGVuY2lsU3lzdGVtLmpzXCIpLCBQbHVnaW5TeXN0ZW0gPSByZXF1aXJlKFwiLi9wbHVnaW4vUGx1Z2luU3lzdGVtLmpzXCIpLCBQcm9qZWN0aW9uU3lzdGVtID0gcmVxdWlyZShcIi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uU3lzdGVtLmpzXCIpLCBHZW5lcmF0ZVRleHR1cmVTeXN0ZW0gPSByZXF1aXJlKFwiLi9yZW5kZXJUZXh0dXJlL0dlbmVyYXRlVGV4dHVyZVN5c3RlbS5qc1wiKSwgUmVuZGVyVGV4dHVyZVN5c3RlbSA9IHJlcXVpcmUoXCIuL3JlbmRlclRleHR1cmUvUmVuZGVyVGV4dHVyZVN5c3RlbS5qc1wiKSwgU2hhZGVyU3lzdGVtID0gcmVxdWlyZShcIi4vc2hhZGVyL1NoYWRlclN5c3RlbS5qc1wiKSwgU3RhcnR1cFN5c3RlbSA9IHJlcXVpcmUoXCIuL3N0YXJ0dXAvU3RhcnR1cFN5c3RlbS5qc1wiKSwgU3RhdGVTeXN0ZW0gPSByZXF1aXJlKFwiLi9zdGF0ZS9TdGF0ZVN5c3RlbS5qc1wiKSwgU3lzdGVtTWFuYWdlciA9IHJlcXVpcmUoXCIuL3N5c3RlbS9TeXN0ZW1NYW5hZ2VyLmpzXCIpLCBUZXh0dXJlR0NTeXN0ZW0gPSByZXF1aXJlKFwiLi90ZXh0dXJlcy9UZXh0dXJlR0NTeXN0ZW0uanNcIiksIFRleHR1cmVTeXN0ZW0gPSByZXF1aXJlKFwiLi90ZXh0dXJlcy9UZXh0dXJlU3lzdGVtLmpzXCIpLCBUcmFuc2Zvcm1GZWVkYmFja1N5c3RlbSA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybUZlZWRiYWNrL1RyYW5zZm9ybUZlZWRiYWNrU3lzdGVtLmpzXCIpLCBWaWV3U3lzdGVtID0gcmVxdWlyZShcIi4vdmlldy9WaWV3U3lzdGVtLmpzXCIpO1xuZXhwb3J0cy5CYWNrZ3JvdW5kU3lzdGVtID0gQmFja2dyb3VuZFN5c3RlbS5CYWNrZ3JvdW5kU3lzdGVtO1xuZXhwb3J0cy5CYXRjaFN5c3RlbSA9IEJhdGNoU3lzdGVtLkJhdGNoU3lzdGVtO1xuZXhwb3J0cy5Db250ZXh0U3lzdGVtID0gQ29udGV4dFN5c3RlbS5Db250ZXh0U3lzdGVtO1xuZXhwb3J0cy5GaWx0ZXJTeXN0ZW0gPSBGaWx0ZXJTeXN0ZW0uRmlsdGVyU3lzdGVtO1xuZXhwb3J0cy5GcmFtZWJ1ZmZlclN5c3RlbSA9IEZyYW1lYnVmZmVyU3lzdGVtLkZyYW1lYnVmZmVyU3lzdGVtO1xuZXhwb3J0cy5HZW9tZXRyeVN5c3RlbSA9IEdlb21ldHJ5U3lzdGVtLkdlb21ldHJ5U3lzdGVtO1xuZXhwb3J0cy5NYXNrU3lzdGVtID0gTWFza1N5c3RlbS5NYXNrU3lzdGVtO1xuZXhwb3J0cy5TY2lzc29yU3lzdGVtID0gU2Npc3NvclN5c3RlbS5TY2lzc29yU3lzdGVtO1xuZXhwb3J0cy5TdGVuY2lsU3lzdGVtID0gU3RlbmNpbFN5c3RlbS5TdGVuY2lsU3lzdGVtO1xuZXhwb3J0cy5QbHVnaW5TeXN0ZW0gPSBQbHVnaW5TeXN0ZW0uUGx1Z2luU3lzdGVtO1xuZXhwb3J0cy5Qcm9qZWN0aW9uU3lzdGVtID0gUHJvamVjdGlvblN5c3RlbS5Qcm9qZWN0aW9uU3lzdGVtO1xuZXhwb3J0cy5HZW5lcmF0ZVRleHR1cmVTeXN0ZW0gPSBHZW5lcmF0ZVRleHR1cmVTeXN0ZW0uR2VuZXJhdGVUZXh0dXJlU3lzdGVtO1xuZXhwb3J0cy5SZW5kZXJUZXh0dXJlU3lzdGVtID0gUmVuZGVyVGV4dHVyZVN5c3RlbS5SZW5kZXJUZXh0dXJlU3lzdGVtO1xuZXhwb3J0cy5TaGFkZXJTeXN0ZW0gPSBTaGFkZXJTeXN0ZW0uU2hhZGVyU3lzdGVtO1xuZXhwb3J0cy5TdGFydHVwU3lzdGVtID0gU3RhcnR1cFN5c3RlbS5TdGFydHVwU3lzdGVtO1xuZXhwb3J0cy5TdGF0ZVN5c3RlbSA9IFN0YXRlU3lzdGVtLlN0YXRlU3lzdGVtO1xuZXhwb3J0cy5TeXN0ZW1NYW5hZ2VyID0gU3lzdGVtTWFuYWdlci5TeXN0ZW1NYW5hZ2VyO1xuZXhwb3J0cy5UZXh0dXJlR0NTeXN0ZW0gPSBUZXh0dXJlR0NTeXN0ZW0uVGV4dHVyZUdDU3lzdGVtO1xuZXhwb3J0cy5UZXh0dXJlU3lzdGVtID0gVGV4dHVyZVN5c3RlbS5UZXh0dXJlU3lzdGVtO1xuZXhwb3J0cy5UcmFuc2Zvcm1GZWVkYmFja1N5c3RlbSA9IFRyYW5zZm9ybUZlZWRiYWNrU3lzdGVtLlRyYW5zZm9ybUZlZWRiYWNrU3lzdGVtO1xuZXhwb3J0cy5WaWV3U3lzdGVtID0gVmlld1N5c3RlbS5WaWV3U3lzdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3lzdGVtcy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCJAcGl4aS9jb25zdGFudHNcIiksIHNldHRpbmdzID0gcmVxdWlyZShcIkBwaXhpL3NldHRpbmdzXCIpLCB1dGlscyA9IHJlcXVpcmUoXCJAcGl4aS91dGlsc1wiKSwgYXV0b0RldGVjdFJlc291cmNlID0gcmVxdWlyZShcIi4vcmVzb3VyY2VzL2F1dG9EZXRlY3RSZXNvdXJjZS5qc1wiKSwgQnVmZmVyUmVzb3VyY2UgPSByZXF1aXJlKFwiLi9yZXNvdXJjZXMvQnVmZmVyUmVzb3VyY2UuanNcIiksIFJlc291cmNlID0gcmVxdWlyZShcIi4vcmVzb3VyY2VzL1Jlc291cmNlLmpzXCIpO1xuY29uc3QgZGVmYXVsdEJ1ZmZlck9wdGlvbnMgPSB7XG4gIHNjYWxlTW9kZTogY29uc3RhbnRzLlNDQUxFX01PREVTLk5FQVJFU1QsXG4gIGFscGhhTW9kZTogY29uc3RhbnRzLkFMUEhBX01PREVTLk5QTVxufSwgX0Jhc2VUZXh0dXJlID0gY2xhc3MgX0Jhc2VUZXh0dXJlMiBleHRlbmRzIHV0aWxzLkV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1BJWEkuUmVzb3VyY2V8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEltYWdlQml0bWFwfElDYW52YXN8c3RyaW5nfSBbcmVzb3VyY2U9bnVsbF0gLVxuICAgKiAgICAgICAgVGhlIGN1cnJlbnQgcmVzb3VyY2UgdG8gdXNlLCBmb3IgdGhpbmdzIHRoYXQgYXJlbid0IFJlc291cmNlIG9iamVjdHMsIHdpbGwgYmUgY29udmVydGVkXG4gICAqICAgICAgICBpbnRvIGEgUmVzb3VyY2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQ29sbGVjdGlvbiBvZiBvcHRpb25zLCBkZWZhdWx0IG9wdGlvbnMgaW5oZXJpdGVkIGZyb20ge0BsaW5rIFBJWEkuQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnN9LlxuICAgKiBAcGFyYW0ge1BJWEkuTUlQTUFQX01PREVTfSBbb3B0aW9ucy5taXBtYXBdIC0gSWYgbWlwbWFwcGluZyBpcyBlbmFibGVkIGZvciB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5hbmlzb3Ryb3BpY0xldmVsXSAtIEFuaXNvdHJvcGljIGZpbHRlcmluZyBsZXZlbCBvZiB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7UElYSS5XUkFQX01PREVTfSBbb3B0aW9ucy53cmFwTW9kZV0gLSBXcmFwIG1vZGUgZm9yIHRleHR1cmVzXG4gICAqIEBwYXJhbSB7UElYSS5TQ0FMRV9NT0RFU30gW29wdGlvbnMuc2NhbGVNb2RlXSAtIERlZmF1bHQgc2NhbGUgbW9kZSwgbGluZWFyLCBuZWFyZXN0XG4gICAqIEBwYXJhbSB7UElYSS5GT1JNQVRTfSBbb3B0aW9ucy5mb3JtYXRdIC0gR0wgZm9ybWF0IHR5cGVcbiAgICogQHBhcmFtIHtQSVhJLlRZUEVTfSBbb3B0aW9ucy50eXBlXSAtIEdMIGRhdGEgdHlwZVxuICAgKiBAcGFyYW0ge1BJWEkuVEFSR0VUU30gW29wdGlvbnMudGFyZ2V0XSAtIEdMIHRleHR1cmUgdGFyZ2V0XG4gICAqIEBwYXJhbSB7UElYSS5BTFBIQV9NT0RFU30gW29wdGlvbnMuYWxwaGFNb2RlXSAtIFByZSBtdWx0aXBseSB0aGUgaW1hZ2UgYWxwaGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoPTBdIC0gV2lkdGggb2YgdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodD0wXSAtIEhlaWdodCBvZiB0aGUgdGV4dHVyZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvbj1QSVhJLnNldHRpbmdzLlJFU09MVVRJT05dIC0gUmVzb2x1dGlvbiBvZiB0aGUgYmFzZSB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5yZXNvdXJjZU9wdGlvbnNdIC0gT3B0aW9uYWwgcmVzb3VyY2Ugb3B0aW9ucyxcbiAgICogICAgICAgIHNlZSB7QGxpbmsgUElYSS5hdXRvRGV0ZWN0UmVzb3VyY2UgYXV0b0RldGVjdFJlc291cmNlfVxuICAgKi9cbiAgY29uc3RydWN0b3IocmVzb3VyY2UgPSBudWxsLCBvcHRpb25zID0gbnVsbCkge1xuICAgIHN1cGVyKCksIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBfQmFzZVRleHR1cmUyLmRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICBhbHBoYU1vZGUsXG4gICAgICBtaXBtYXAsXG4gICAgICBhbmlzb3Ryb3BpY0xldmVsLFxuICAgICAgc2NhbGVNb2RlLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB3cmFwTW9kZSxcbiAgICAgIGZvcm1hdCxcbiAgICAgIHR5cGUsXG4gICAgICB0YXJnZXQsXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgcmVzb3VyY2VPcHRpb25zXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgcmVzb3VyY2UgJiYgIShyZXNvdXJjZSBpbnN0YW5jZW9mIFJlc291cmNlLlJlc291cmNlKSAmJiAocmVzb3VyY2UgPSBhdXRvRGV0ZWN0UmVzb3VyY2UuYXV0b0RldGVjdFJlc291cmNlKHJlc291cmNlLCByZXNvdXJjZU9wdGlvbnMpLCByZXNvdXJjZS5pbnRlcm5hbCA9ICEwKSwgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBzZXR0aW5ncy5zZXR0aW5ncy5SRVNPTFVUSU9OLCB0aGlzLndpZHRoID0gTWF0aC5yb3VuZCgod2lkdGggfHwgMCkgKiB0aGlzLnJlc29sdXRpb24pIC8gdGhpcy5yZXNvbHV0aW9uLCB0aGlzLmhlaWdodCA9IE1hdGgucm91bmQoKGhlaWdodCB8fCAwKSAqIHRoaXMucmVzb2x1dGlvbikgLyB0aGlzLnJlc29sdXRpb24sIHRoaXMuX21pcG1hcCA9IG1pcG1hcCwgdGhpcy5hbmlzb3Ryb3BpY0xldmVsID0gYW5pc290cm9waWNMZXZlbCwgdGhpcy5fd3JhcE1vZGUgPSB3cmFwTW9kZSwgdGhpcy5fc2NhbGVNb2RlID0gc2NhbGVNb2RlLCB0aGlzLmZvcm1hdCA9IGZvcm1hdCwgdGhpcy50eXBlID0gdHlwZSwgdGhpcy50YXJnZXQgPSB0YXJnZXQsIHRoaXMuYWxwaGFNb2RlID0gYWxwaGFNb2RlLCB0aGlzLnVpZCA9IHV0aWxzLnVpZCgpLCB0aGlzLnRvdWNoZWQgPSAwLCB0aGlzLmlzUG93ZXJPZlR3byA9ICExLCB0aGlzLl9yZWZyZXNoUE9UKCksIHRoaXMuX2dsVGV4dHVyZXMgPSB7fSwgdGhpcy5kaXJ0eUlkID0gMCwgdGhpcy5kaXJ0eVN0eWxlSWQgPSAwLCB0aGlzLmNhY2hlSWQgPSBudWxsLCB0aGlzLnZhbGlkID0gd2lkdGggPiAwICYmIGhlaWdodCA+IDAsIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gW10sIHRoaXMuZGVzdHJveWVkID0gITEsIHRoaXMucmVzb3VyY2UgPSBudWxsLCB0aGlzLl9iYXRjaEVuYWJsZWQgPSAwLCB0aGlzLl9iYXRjaExvY2F0aW9uID0gMCwgdGhpcy5wYXJlbnRUZXh0dXJlQXJyYXkgPSBudWxsLCB0aGlzLnNldFJlc291cmNlKHJlc291cmNlKTtcbiAgfVxuICAvKipcbiAgICogUGl4ZWwgd2lkdGggb2YgdGhlIHNvdXJjZSBvZiB0aGlzIHRleHR1cmVcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcmVhbFdpZHRoKCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiB0aGlzLnJlc29sdXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBQaXhlbCBoZWlnaHQgb2YgdGhlIHNvdXJjZSBvZiB0aGlzIHRleHR1cmVcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcmVhbEhlaWdodCgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHRoaXMucmVzb2x1dGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIE1pcG1hcCBtb2RlIG9mIHRoZSB0ZXh0dXJlLCBhZmZlY3RzIGRvd25zY2FsZWQgaW1hZ2VzXG4gICAqIEBkZWZhdWx0IFBJWEkuTUlQTUFQX01PREVTLlBPVzJcbiAgICovXG4gIGdldCBtaXBtYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pcG1hcDtcbiAgfVxuICBzZXQgbWlwbWFwKHZhbHVlKSB7XG4gICAgdGhpcy5fbWlwbWFwICE9PSB2YWx1ZSAmJiAodGhpcy5fbWlwbWFwID0gdmFsdWUsIHRoaXMuZGlydHlTdHlsZUlkKyspO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2NhbGUgbW9kZSB0byBhcHBseSB3aGVuIHNjYWxpbmcgdGhpcyB0ZXh0dXJlXG4gICAqIEBkZWZhdWx0IFBJWEkuU0NBTEVfTU9ERVMuTElORUFSXG4gICAqL1xuICBnZXQgc2NhbGVNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9zY2FsZU1vZGU7XG4gIH1cbiAgc2V0IHNjYWxlTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuX3NjYWxlTW9kZSAhPT0gdmFsdWUgJiYgKHRoaXMuX3NjYWxlTW9kZSA9IHZhbHVlLCB0aGlzLmRpcnR5U3R5bGVJZCsrKTtcbiAgfVxuICAvKipcbiAgICogSG93IHRoZSB0ZXh0dXJlIHdyYXBzXG4gICAqIEBkZWZhdWx0IFBJWEkuV1JBUF9NT0RFUy5DTEFNUFxuICAgKi9cbiAgZ2V0IHdyYXBNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwTW9kZTtcbiAgfVxuICBzZXQgd3JhcE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLl93cmFwTW9kZSAhPT0gdmFsdWUgJiYgKHRoaXMuX3dyYXBNb2RlID0gdmFsdWUsIHRoaXMuZGlydHlTdHlsZUlkKyspO1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2VzIHN0eWxlIG9wdGlvbnMgb2YgQmFzZVRleHR1cmVcbiAgICogQHBhcmFtIHNjYWxlTW9kZSAtIFBpeGkgc2NhbGVtb2RlXG4gICAqIEBwYXJhbSBtaXBtYXAgLSBlbmFibGUgbWlwbWFwc1xuICAgKiBAcmV0dXJucyAtIHRoaXNcbiAgICovXG4gIHNldFN0eWxlKHNjYWxlTW9kZSwgbWlwbWFwKSB7XG4gICAgbGV0IGRpcnR5O1xuICAgIHJldHVybiBzY2FsZU1vZGUgIT09IHZvaWQgMCAmJiBzY2FsZU1vZGUgIT09IHRoaXMuc2NhbGVNb2RlICYmICh0aGlzLnNjYWxlTW9kZSA9IHNjYWxlTW9kZSwgZGlydHkgPSAhMCksIG1pcG1hcCAhPT0gdm9pZCAwICYmIG1pcG1hcCAhPT0gdGhpcy5taXBtYXAgJiYgKHRoaXMubWlwbWFwID0gbWlwbWFwLCBkaXJ0eSA9ICEwKSwgZGlydHkgJiYgdGhpcy5kaXJ0eVN0eWxlSWQrKywgdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyB3L2gvcmVzb2x1dGlvbi4gVGV4dHVyZSBiZWNvbWVzIHZhbGlkIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGdyZWF0ZXIgdGhhbiB6ZXJvLlxuICAgKiBAcGFyYW0gZGVzaXJlZFdpZHRoIC0gRGVzaXJlZCB2aXN1YWwgd2lkdGhcbiAgICogQHBhcmFtIGRlc2lyZWRIZWlnaHQgLSBEZXNpcmVkIHZpc3VhbCBoZWlnaHRcbiAgICogQHBhcmFtIHJlc29sdXRpb24gLSBPcHRpb25hbGx5IHNldCByZXNvbHV0aW9uXG4gICAqIEByZXR1cm5zIC0gdGhpc1xuICAgKi9cbiAgc2V0U2l6ZShkZXNpcmVkV2lkdGgsIGRlc2lyZWRIZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgdGhpcy5yZXNvbHV0aW9uLCB0aGlzLnNldFJlYWxTaXplKGRlc2lyZWRXaWR0aCAqIHJlc29sdXRpb24sIGRlc2lyZWRIZWlnaHQgKiByZXNvbHV0aW9uLCByZXNvbHV0aW9uKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyByZWFsIHNpemUgb2YgYmFzZVRleHR1cmUsIHByZXNlcnZlcyBjdXJyZW50IHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSByZWFsV2lkdGggLSBGdWxsIHJlbmRlcmVkIHdpZHRoXG4gICAqIEBwYXJhbSByZWFsSGVpZ2h0IC0gRnVsbCByZW5kZXJlZCBoZWlnaHRcbiAgICogQHBhcmFtIHJlc29sdXRpb24gLSBPcHRpb25hbGx5IHNldCByZXNvbHV0aW9uXG4gICAqIEByZXR1cm5zIC0gdGhpc1xuICAgKi9cbiAgc2V0UmVhbFNpemUocmVhbFdpZHRoLCByZWFsSGVpZ2h0LCByZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgdGhpcy5yZXNvbHV0aW9uLCB0aGlzLndpZHRoID0gTWF0aC5yb3VuZChyZWFsV2lkdGgpIC8gdGhpcy5yZXNvbHV0aW9uLCB0aGlzLmhlaWdodCA9IE1hdGgucm91bmQocmVhbEhlaWdodCkgLyB0aGlzLnJlc29sdXRpb24sIHRoaXMuX3JlZnJlc2hQT1QoKSwgdGhpcy51cGRhdGUoKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVmcmVzaCBjaGVjayBmb3IgaXNQb3dlck9mVHdvIHRleHR1cmUgYmFzZWQgb24gc2l6ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlZnJlc2hQT1QoKSB7XG4gICAgdGhpcy5pc1Bvd2VyT2ZUd28gPSB1dGlscy5pc1BvdzIodGhpcy5yZWFsV2lkdGgpICYmIHV0aWxzLmlzUG93Mih0aGlzLnJlYWxIZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2VzIHJlc29sdXRpb25cbiAgICogQHBhcmFtIHJlc29sdXRpb24gLSByZXNcbiAgICogQHJldHVybnMgLSB0aGlzXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgICBjb25zdCBvbGRSZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJldHVybiBvbGRSZXNvbHV0aW9uID09PSByZXNvbHV0aW9uID8gdGhpcyA6ICh0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uLCB0aGlzLnZhbGlkICYmICh0aGlzLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoICogb2xkUmVzb2x1dGlvbikgLyByZXNvbHV0aW9uLCB0aGlzLmhlaWdodCA9IE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiBvbGRSZXNvbHV0aW9uKSAvIHJlc29sdXRpb24sIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKSksIHRoaXMuX3JlZnJlc2hQT1QoKSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlc291cmNlIGlmIGl0IHdhc24ndCBzZXQuIFRocm93cyBlcnJvciBpZiByZXNvdXJjZSBhbHJlYWR5IHByZXNlbnRcbiAgICogQHBhcmFtIHJlc291cmNlIC0gdGhhdCBpcyBtYW5hZ2luZyB0aGlzIEJhc2VUZXh0dXJlXG4gICAqIEByZXR1cm5zIC0gdGhpc1xuICAgKi9cbiAgc2V0UmVzb3VyY2UocmVzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5yZXNvdXJjZSA9PT0gcmVzb3VyY2UpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5yZXNvdXJjZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc291cmNlIGNhbiBiZSBzZXQgb25seSBvbmNlXCIpO1xuICAgIHJldHVybiByZXNvdXJjZS5iaW5kKHRoaXMpLCB0aGlzLnJlc291cmNlID0gcmVzb3VyY2UsIHRoaXM7XG4gIH1cbiAgLyoqIEludmFsaWRhdGVzIHRoZSBvYmplY3QuIFRleHR1cmUgYmVjb21lcyB2YWxpZCBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBncmVhdGVyIHRoYW4gemVyby4gKi9cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMudmFsaWQgPyAodGhpcy5kaXJ0eUlkKyssIHRoaXMuZGlydHlTdHlsZUlkKyssIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKSkgOiB0aGlzLndpZHRoID4gMCAmJiB0aGlzLmhlaWdodCA+IDAgJiYgKHRoaXMudmFsaWQgPSAhMCwgdGhpcy5lbWl0KFwibG9hZGVkXCIsIHRoaXMpLCB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcykpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgZXJyb3JzIHdpdGggcmVzb3VyY2VzLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gZXZlbnQgLSBFcnJvciBldmVudCBlbWl0dGVkLlxuICAgKi9cbiAgb25FcnJvcihldmVudCkge1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIHRoaXMsIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhpcyBiYXNlIHRleHR1cmUuXG4gICAqIFRoZSBtZXRob2Qgc3RvcHMgaWYgcmVzb3VyY2UgZG9lc24ndCB3YW50IHRoaXMgdGV4dHVyZSB0byBiZSBkZXN0cm95ZWQuXG4gICAqIFJlbW92ZXMgdGV4dHVyZSBmcm9tIGFsbCBjYWNoZXMuXG4gICAqIEBmaXJlcyBQSVhJLkJhc2VUZXh0dXJlI2Rlc3Ryb3llZFxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlc291cmNlICYmICh0aGlzLnJlc291cmNlLnVuYmluZCh0aGlzKSwgdGhpcy5yZXNvdXJjZS5pbnRlcm5hbCAmJiB0aGlzLnJlc291cmNlLmRlc3Ryb3koKSwgdGhpcy5yZXNvdXJjZSA9IG51bGwpLCB0aGlzLmNhY2hlSWQgJiYgKGRlbGV0ZSB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW3RoaXMuY2FjaGVJZF0sIGRlbGV0ZSB1dGlscy5UZXh0dXJlQ2FjaGVbdGhpcy5jYWNoZUlkXSwgdGhpcy5jYWNoZUlkID0gbnVsbCksIHRoaXMudmFsaWQgPSAhMSwgdGhpcy5kaXNwb3NlKCksIF9CYXNlVGV4dHVyZTIucmVtb3ZlRnJvbUNhY2hlKHRoaXMpLCB0aGlzLnRleHR1cmVDYWNoZUlkcyA9IG51bGwsIHRoaXMuZGVzdHJveWVkID0gITAsIHRoaXMuZW1pdChcImRlc3Ryb3llZFwiLCB0aGlzKSwgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogRnJlZXMgdGhlIHRleHR1cmUgZnJvbSBXZWJHTCBtZW1vcnkgd2l0aG91dCBkZXN0cm95aW5nIHRoaXMgdGV4dHVyZSBvYmplY3QuXG4gICAqIFRoaXMgbWVhbnMgeW91IGNhbiBzdGlsbCB1c2UgdGhlIHRleHR1cmUgbGF0ZXIgd2hpY2ggd2lsbCB1cGxvYWQgaXQgdG8gR1BVXG4gICAqIG1lbW9yeSBhZ2Fpbi5cbiAgICogQGZpcmVzIFBJWEkuQmFzZVRleHR1cmUjZGlzcG9zZVxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmVtaXQoXCJkaXNwb3NlXCIsIHRoaXMpO1xuICB9XG4gIC8qKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBCYXNlVGV4dHVyZXxUZXh0dXJlIGNhc3QuICovXG4gIGNhc3RUb0Jhc2VUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgYmFzZSB0ZXh0dXJlIGJhc2VkIG9uIHRoZSBzb3VyY2UgeW91IHByb3ZpZGUuXG4gICAqIFRoZSBzb3VyY2UgY2FuIGJlIC0gaW1hZ2UgdXJsLCBpbWFnZSBlbGVtZW50LCBjYW52YXMgZWxlbWVudC4gSWYgdGhlXG4gICAqIHNvdXJjZSBpcyBhbiBpbWFnZSB1cmwgb3IgYW4gaW1hZ2UgZWxlbWVudCBhbmQgbm90IGluIHRoZSBiYXNlIHRleHR1cmVcbiAgICogY2FjaGUsIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgbG9hZGVkLlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEltYWdlQml0bWFwfFBJWEkuSUNhbnZhc3xzdHJpbmd8c3RyaW5nW119IHNvdXJjZSAtIFRoZVxuICAgKiAgICAgICAgc291cmNlIHRvIGNyZWF0ZSBiYXNlIHRleHR1cmUgZnJvbS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5waXhpSWRQcmVmaXg9cGl4aWlkXSAtIElmIGEgc291cmNlIGhhcyBubyBpZCwgdGhpcyBpcyB0aGUgcHJlZml4IG9mIHRoZSBnZW5lcmF0ZWQgaWRcbiAgICogQHBhcmFtIHtib29sZWFufSBbc3RyaWN0XSAtIEVuZm9yY2Ugc3RyaWN0LW1vZGUsIHNlZSB7QGxpbmsgUElYSS5zZXR0aW5ncy5TVFJJQ1RfVEVYVFVSRV9DQUNIRX0uXG4gICAqIEByZXR1cm5zIHtQSVhJLkJhc2VUZXh0dXJlfSBUaGUgbmV3IGJhc2UgdGV4dHVyZS5cbiAgICovXG4gIHN0YXRpYyBmcm9tKHNvdXJjZSwgb3B0aW9ucywgc3RyaWN0ID0gc2V0dGluZ3Muc2V0dGluZ3MuU1RSSUNUX1RFWFRVUkVfQ0FDSEUpIHtcbiAgICBjb25zdCBpc0ZyYW1lID0gdHlwZW9mIHNvdXJjZSA9PSBcInN0cmluZ1wiO1xuICAgIGxldCBjYWNoZUlkID0gbnVsbDtcbiAgICBpZiAoaXNGcmFtZSlcbiAgICAgIGNhY2hlSWQgPSBzb3VyY2U7XG4gICAgZWxzZSB7XG4gICAgICBpZiAoIXNvdXJjZS5fcGl4aUlkKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG9wdGlvbnM/LnBpeGlJZFByZWZpeCB8fCBcInBpeGlpZFwiO1xuICAgICAgICBzb3VyY2UuX3BpeGlJZCA9IGAke3ByZWZpeH1fJHt1dGlscy51aWQoKX1gO1xuICAgICAgfVxuICAgICAgY2FjaGVJZCA9IHNvdXJjZS5fcGl4aUlkO1xuICAgIH1cbiAgICBsZXQgYmFzZVRleHR1cmUgPSB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW2NhY2hlSWRdO1xuICAgIGlmIChpc0ZyYW1lICYmIHN0cmljdCAmJiAhYmFzZVRleHR1cmUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBjYWNoZUlkIFwiJHtjYWNoZUlkfVwiIGRvZXMgbm90IGV4aXN0IGluIEJhc2VUZXh0dXJlQ2FjaGUuYCk7XG4gICAgcmV0dXJuIGJhc2VUZXh0dXJlIHx8IChiYXNlVGV4dHVyZSA9IG5ldyBfQmFzZVRleHR1cmUyKHNvdXJjZSwgb3B0aW9ucyksIGJhc2VUZXh0dXJlLmNhY2hlSWQgPSBjYWNoZUlkLCBfQmFzZVRleHR1cmUyLmFkZFRvQ2FjaGUoYmFzZVRleHR1cmUsIGNhY2hlSWQpKSwgYmFzZVRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBUZXh0dXJlIHdpdGggYSBCdWZmZXJSZXNvdXJjZSBmcm9tIGEgdHlwZWQgYXJyYXkuXG4gICAqIEBwYXJhbSBidWZmZXIgLSBUaGUgb3B0aW9uYWwgYXJyYXkgdG8gdXNlLiBJZiBubyBkYXRhIGlzIHByb3ZpZGVkLCBhIG5ldyBGbG9hdDMyQXJyYXkgaXMgY3JlYXRlZC5cbiAgICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgdGhlIHJlc291cmNlXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIHJlc291cmNlXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gU2VlIHtAbGluayBQSVhJLkJhc2VUZXh0dXJlfSdzIGNvbnN0cnVjdG9yIGZvciBvcHRpb25zLlxuICAgKiAgICAgICAgRGVmYXVsdCBwcm9wZXJ0aWVzIGFyZSBkaWZmZXJlbnQgZnJvbSB0aGUgY29uc3RydWN0b3IncyBkZWZhdWx0cy5cbiAgICogQHBhcmFtIHtQSVhJLkZPUk1BVFN9IFtvcHRpb25zLmZvcm1hdF0gLSBUaGUgZm9ybWF0IGlzIG5vdCBnaXZlbiwgdGhlIHR5cGUgaXMgaW5mZXJyZWQgZnJvbSB0aGVcbiAgICogICAgICAgIHR5cGUgb2YgdGhlIGJ1ZmZlcjogYFJHQkFgIGlmIEZsb2F0MzJBcnJheSwgSW50OEFycmF5LCBVaW50OEFycmF5LCBvciBVaW50OENsYW1wZWRBcnJheSxcbiAgICogICAgICAgIG90aGVyd2lzZSBgUkdCQV9JTlRFR0VSYC5cbiAgICogQHBhcmFtIHtQSVhJLlRZUEVTfSBbb3B0aW9ucy50eXBlXSAtIFRoZSB0eXBlIGlzIG5vdCBnaXZlbiwgdGhlIHR5cGUgaXMgaW5mZXJyZWQgZnJvbSB0aGVcbiAgICogICAgICAgIHR5cGUgb2YgdGhlIGJ1ZmZlci4gTWFwcyBGbG9hdDMyQXJyYXkgdG8gYEZMT0FUYCwgSW50MzJBcnJheSB0byBgSU5UYCwgVWludDMyQXJyYXkgdG9cbiAgICogICAgICAgIGBVTlNJR05FRF9JTlRgLCBJbnQxNkFycmF5IHRvIGBTSE9SVGAsIFVpbnQxNkFycmF5IHRvIGBVTlNJR05FRF9TSE9SVGAsIEludDhBcnJheSB0byBgQllURWAsXG4gICAqICAgICAgICBVaW50OEFycmF5L1VpbnQ4Q2xhbXBlZEFycmF5IHRvIGBVTlNJR05FRF9CWVRFYC5cbiAgICogQHBhcmFtIHtQSVhJLkFMUEhBX01PREVTfSBbb3B0aW9ucy5hbHBoYU1vZGU9UElYSS5BTFBIQV9NT0RFUy5OUE1dXG4gICAqIEBwYXJhbSB7UElYSS5TQ0FMRV9NT0RFU30gW29wdGlvbnMuc2NhbGVNb2RlPVBJWEkuU0NBTEVfTU9ERVMuTkVBUkVTVF1cbiAgICogQHJldHVybnMgLSBUaGUgcmVzdWx0aW5nIG5ldyBCYXNlVGV4dHVyZVxuICAgKi9cbiAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyIHx8IG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICBjb25zdCByZXNvdXJjZSA9IG5ldyBCdWZmZXJSZXNvdXJjZS5CdWZmZXJSZXNvdXJjZShidWZmZXIsIHsgd2lkdGgsIGhlaWdodCwgLi4ub3B0aW9ucz8ucmVzb3VyY2VPcHRpb25zIH0pO1xuICAgIGxldCBmb3JtYXQsIHR5cGU7XG4gICAgcmV0dXJuIGJ1ZmZlciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSA/IChmb3JtYXQgPSBjb25zdGFudHMuRk9STUFUUy5SR0JBLCB0eXBlID0gY29uc3RhbnRzLlRZUEVTLkZMT0FUKSA6IGJ1ZmZlciBpbnN0YW5jZW9mIEludDMyQXJyYXkgPyAoZm9ybWF0ID0gY29uc3RhbnRzLkZPUk1BVFMuUkdCQV9JTlRFR0VSLCB0eXBlID0gY29uc3RhbnRzLlRZUEVTLklOVCkgOiBidWZmZXIgaW5zdGFuY2VvZiBVaW50MzJBcnJheSA/IChmb3JtYXQgPSBjb25zdGFudHMuRk9STUFUUy5SR0JBX0lOVEVHRVIsIHR5cGUgPSBjb25zdGFudHMuVFlQRVMuVU5TSUdORURfSU5UKSA6IGJ1ZmZlciBpbnN0YW5jZW9mIEludDE2QXJyYXkgPyAoZm9ybWF0ID0gY29uc3RhbnRzLkZPUk1BVFMuUkdCQV9JTlRFR0VSLCB0eXBlID0gY29uc3RhbnRzLlRZUEVTLlNIT1JUKSA6IGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQxNkFycmF5ID8gKGZvcm1hdCA9IGNvbnN0YW50cy5GT1JNQVRTLlJHQkFfSU5URUdFUiwgdHlwZSA9IGNvbnN0YW50cy5UWVBFUy5VTlNJR05FRF9TSE9SVCkgOiBidWZmZXIgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgPyAoZm9ybWF0ID0gY29uc3RhbnRzLkZPUk1BVFMuUkdCQSwgdHlwZSA9IGNvbnN0YW50cy5UWVBFUy5CWVRFKSA6IChmb3JtYXQgPSBjb25zdGFudHMuRk9STUFUUy5SR0JBLCB0eXBlID0gY29uc3RhbnRzLlRZUEVTLlVOU0lHTkVEX0JZVEUpLCByZXNvdXJjZS5pbnRlcm5hbCA9ICEwLCBuZXcgX0Jhc2VUZXh0dXJlMihyZXNvdXJjZSwgT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEJ1ZmZlck9wdGlvbnMsIHsgdHlwZSwgZm9ybWF0IH0sIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIEJhc2VUZXh0dXJlIHRvIHRoZSBnbG9iYWwgQmFzZVRleHR1cmVDYWNoZS4gVGhpcyBjYWNoZSBpcyBzaGFyZWQgYWNyb3NzIHRoZSB3aG9sZSBQSVhJIG9iamVjdC5cbiAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIFRoZSBCYXNlVGV4dHVyZSB0byBhZGQgdG8gdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgdGhhdCB0aGUgQmFzZVRleHR1cmUgd2lsbCBiZSBzdG9yZWQgYWdhaW5zdC5cbiAgICovXG4gIHN0YXRpYyBhZGRUb0NhY2hlKGJhc2VUZXh0dXJlLCBpZCkge1xuICAgIGlkICYmIChiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMuaW5jbHVkZXMoaWQpIHx8IGJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5wdXNoKGlkKSwgdXRpbHMuQmFzZVRleHR1cmVDYWNoZVtpZF0gJiYgdXRpbHMuQmFzZVRleHR1cmVDYWNoZVtpZF0gIT09IGJhc2VUZXh0dXJlICYmIGNvbnNvbGUud2FybihgQmFzZVRleHR1cmUgYWRkZWQgdG8gdGhlIGNhY2hlIHdpdGggYW4gaWQgWyR7aWR9XSB0aGF0IGFscmVhZHkgaGFkIGFuIGVudHJ5YCksIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbaWRdID0gYmFzZVRleHR1cmUpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYSBCYXNlVGV4dHVyZSBmcm9tIHRoZSBnbG9iYWwgQmFzZVRleHR1cmVDYWNoZS5cbiAgICogQHBhcmFtIHtzdHJpbmd8UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBpZCBvZiBhIEJhc2VUZXh0dXJlIHRvIGJlIHJlbW92ZWQsIG9yIGEgQmFzZVRleHR1cmUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKiBAcmV0dXJucyB7UElYSS5CYXNlVGV4dHVyZXxudWxsfSBUaGUgQmFzZVRleHR1cmUgdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICovXG4gIHN0YXRpYyByZW1vdmVGcm9tQ2FjaGUoYmFzZVRleHR1cmUpIHtcbiAgICBpZiAodHlwZW9mIGJhc2VUZXh0dXJlID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGJhc2VUZXh0dXJlRnJvbUNhY2hlID0gdXRpbHMuQmFzZVRleHR1cmVDYWNoZVtiYXNlVGV4dHVyZV07XG4gICAgICBpZiAoYmFzZVRleHR1cmVGcm9tQ2FjaGUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBiYXNlVGV4dHVyZUZyb21DYWNoZS50ZXh0dXJlQ2FjaGVJZHMuaW5kZXhPZihiYXNlVGV4dHVyZSk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xICYmIGJhc2VUZXh0dXJlRnJvbUNhY2hlLnRleHR1cmVDYWNoZUlkcy5zcGxpY2UoaW5kZXgsIDEpLCBkZWxldGUgdXRpbHMuQmFzZVRleHR1cmVDYWNoZVtiYXNlVGV4dHVyZV0sIGJhc2VUZXh0dXJlRnJvbUNhY2hlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYmFzZVRleHR1cmU/LnRleHR1cmVDYWNoZUlkcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMubGVuZ3RoOyArK2kpXG4gICAgICAgIGRlbGV0ZSB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW2Jhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkc1tpXV07XG4gICAgICByZXR1cm4gYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmxlbmd0aCA9IDAsIGJhc2VUZXh0dXJlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbl9CYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIElmIG1pcG1hcHBpbmcgaXMgZW5hYmxlZCBmb3IgdGV4dHVyZS5cbiAgICogQHR5cGUge1BJWEkuTUlQTUFQX01PREVTfVxuICAgKiBAZGVmYXVsdCBQSVhJLk1JUE1BUF9NT0RFUy5QT1cyXG4gICAqL1xuICBtaXBtYXA6IGNvbnN0YW50cy5NSVBNQVBfTU9ERVMuUE9XMixcbiAgLyoqIEFuaXNvdHJvcGljIGZpbHRlcmluZyBsZXZlbCBvZiB0ZXh0dXJlICovXG4gIGFuaXNvdHJvcGljTGV2ZWw6IDAsXG4gIC8qKlxuICAgKiBEZWZhdWx0IHNjYWxlIG1vZGUsIGxpbmVhciwgbmVhcmVzdC5cbiAgICogQHR5cGUge1BJWEkuU0NBTEVfTU9ERVN9XG4gICAqIEBkZWZhdWx0IFBJWEkuU0NBTEVfTU9ERVMuTElORUFSXG4gICAqL1xuICBzY2FsZU1vZGU6IGNvbnN0YW50cy5TQ0FMRV9NT0RFUy5MSU5FQVIsXG4gIC8qKlxuICAgKiBXcmFwIG1vZGUgZm9yIHRleHR1cmVzLlxuICAgKiBAdHlwZSB7UElYSS5XUkFQX01PREVTfVxuICAgKiBAZGVmYXVsdCBQSVhJLldSQVBfTU9ERVMuQ0xBTVBcbiAgICovXG4gIHdyYXBNb2RlOiBjb25zdGFudHMuV1JBUF9NT0RFUy5DTEFNUCxcbiAgLyoqXG4gICAqIFByZSBtdWx0aXBseSB0aGUgaW1hZ2UgYWxwaGFcbiAgICogQHR5cGUge1BJWEkuQUxQSEFfTU9ERVN9XG4gICAqIEBkZWZhdWx0IFBJWEkuQUxQSEFfTU9ERVMuVU5QQUNLXG4gICAqL1xuICBhbHBoYU1vZGU6IGNvbnN0YW50cy5BTFBIQV9NT0RFUy5VTlBBQ0ssXG4gIC8qKlxuICAgKiBHTCB0ZXh0dXJlIHRhcmdldFxuICAgKiBAdHlwZSB7UElYSS5UQVJHRVRTfVxuICAgKiBAZGVmYXVsdCBQSVhJLlRBUkdFVFMuVEVYVFVSRV8yRFxuICAgKi9cbiAgdGFyZ2V0OiBjb25zdGFudHMuVEFSR0VUUy5URVhUVVJFXzJELFxuICAvKipcbiAgICogR0wgZm9ybWF0IHR5cGVcbiAgICogQHR5cGUge1BJWEkuRk9STUFUU31cbiAgICogQGRlZmF1bHQgUElYSS5GT1JNQVRTLlJHQkFcbiAgICovXG4gIGZvcm1hdDogY29uc3RhbnRzLkZPUk1BVFMuUkdCQSxcbiAgLyoqXG4gICAqIEdMIGRhdGEgdHlwZVxuICAgKiBAdHlwZSB7UElYSS5UWVBFU31cbiAgICogQGRlZmF1bHQgUElYSS5UWVBFUy5VTlNJR05FRF9CWVRFXG4gICAqL1xuICB0eXBlOiBjb25zdGFudHMuVFlQRVMuVU5TSUdORURfQllURVxufSwgLyoqIEdsb2JhbCBudW1iZXIgb2YgdGhlIHRleHR1cmUgYmF0Y2gsIHVzZWQgYnkgbXVsdGktdGV4dHVyZSByZW5kZXJlcnMuICovXG5fQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoID0gMDtcbmxldCBCYXNlVGV4dHVyZSA9IF9CYXNlVGV4dHVyZTtcbmV4cG9ydHMuQmFzZVRleHR1cmUgPSBCYXNlVGV4dHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VUZXh0dXJlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKTtcbmNsYXNzIEdMVGV4dHVyZSB7XG4gIGNvbnN0cnVjdG9yKHRleHR1cmUpIHtcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlLCB0aGlzLndpZHRoID0gLTEsIHRoaXMuaGVpZ2h0ID0gLTEsIHRoaXMuZGlydHlJZCA9IC0xLCB0aGlzLmRpcnR5U3R5bGVJZCA9IC0xLCB0aGlzLm1pcG1hcCA9ICExLCB0aGlzLndyYXBNb2RlID0gMzMwNzEsIHRoaXMudHlwZSA9IGNvbnN0YW50cy5UWVBFUy5VTlNJR05FRF9CWVRFLCB0aGlzLmludGVybmFsRm9ybWF0ID0gY29uc3RhbnRzLkZPUk1BVFMuUkdCQSwgdGhpcy5zYW1wbGVyVHlwZSA9IDA7XG4gIH1cbn1cbmV4cG9ydHMuR0xUZXh0dXJlID0gR0xUZXh0dXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R0xUZXh0dXJlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbWF0aCA9IHJlcXVpcmUoXCJAcGl4aS9tYXRoXCIpLCBzZXR0aW5ncyA9IHJlcXVpcmUoXCJAcGl4aS9zZXR0aW5nc1wiKSwgdXRpbHMgPSByZXF1aXJlKFwiQHBpeGkvdXRpbHNcIiksIEJhc2VUZXh0dXJlID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmUuanNcIiksIEltYWdlUmVzb3VyY2UgPSByZXF1aXJlKFwiLi9yZXNvdXJjZXMvSW1hZ2VSZXNvdXJjZS5qc1wiKSwgVGV4dHVyZVV2cyA9IHJlcXVpcmUoXCIuL1RleHR1cmVVdnMuanNcIik7XG5jb25zdCBERUZBVUxUX1VWUyA9IG5ldyBUZXh0dXJlVXZzLlRleHR1cmVVdnMoKTtcbmZ1bmN0aW9uIHJlbW92ZUFsbEhhbmRsZXJzKHRleCkge1xuICB0ZXguZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB9LCB0ZXgub24gPSBmdW5jdGlvbigpIHtcbiAgfSwgdGV4Lm9uY2UgPSBmdW5jdGlvbigpIHtcbiAgfSwgdGV4LmVtaXQgPSBmdW5jdGlvbigpIHtcbiAgfTtcbn1cbmNsYXNzIFRleHR1cmUgZXh0ZW5kcyB1dGlscy5FdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIGJhc2VUZXh0dXJlIC0gVGhlIGJhc2UgdGV4dHVyZSBzb3VyY2UgdG8gY3JlYXRlIHRoZSB0ZXh0dXJlIGZyb21cbiAgICogQHBhcmFtIGZyYW1lIC0gVGhlIHJlY3RhbmdsZSBmcmFtZSBvZiB0aGUgdGV4dHVyZSB0byBzaG93XG4gICAqIEBwYXJhbSBvcmlnIC0gVGhlIGFyZWEgb2Ygb3JpZ2luYWwgdGV4dHVyZVxuICAgKiBAcGFyYW0gdHJpbSAtIFRyaW1tZWQgcmVjdGFuZ2xlIG9mIG9yaWdpbmFsIHRleHR1cmVcbiAgICogQHBhcmFtIHJvdGF0ZSAtIGluZGljYXRlcyBob3cgdGhlIHRleHR1cmUgd2FzIHJvdGF0ZWQgYnkgdGV4dHVyZSBwYWNrZXIuIFNlZSB7QGxpbmsgUElYSS5ncm91cEQ4fVxuICAgKiBAcGFyYW0gYW5jaG9yIC0gRGVmYXVsdCBhbmNob3IgcG9pbnQgdXNlZCBmb3Igc3ByaXRlIHBsYWNlbWVudCAvIHJvdGF0aW9uXG4gICAqIEBwYXJhbSBib3JkZXJzIC0gRGVmYXVsdCBib3JkZXJzIHVzZWQgZm9yIDktc2xpY2Ugc2NhbGluZy4gU2VlIHtAbGluayBQSVhJLk5pbmVTbGljZVBsYW5lfVxuICAgKi9cbiAgY29uc3RydWN0b3IoYmFzZVRleHR1cmUsIGZyYW1lLCBvcmlnLCB0cmltLCByb3RhdGUsIGFuY2hvciwgYm9yZGVycykge1xuICAgIGlmIChzdXBlcigpLCB0aGlzLm5vRnJhbWUgPSAhMSwgZnJhbWUgfHwgKHRoaXMubm9GcmFtZSA9ICEwLCBmcmFtZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgwLCAwLCAxLCAxKSksIGJhc2VUZXh0dXJlIGluc3RhbmNlb2YgVGV4dHVyZSAmJiAoYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZS5iYXNlVGV4dHVyZSksIHRoaXMuYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZSwgdGhpcy5fZnJhbWUgPSBmcmFtZSwgdGhpcy50cmltID0gdHJpbSwgdGhpcy52YWxpZCA9ICExLCB0aGlzLmRlc3Ryb3llZCA9ICExLCB0aGlzLl91dnMgPSBERUZBVUxUX1VWUywgdGhpcy51dk1hdHJpeCA9IG51bGwsIHRoaXMub3JpZyA9IG9yaWcgfHwgZnJhbWUsIHRoaXMuX3JvdGF0ZSA9IE51bWJlcihyb3RhdGUgfHwgMCksIHJvdGF0ZSA9PT0gITApXG4gICAgICB0aGlzLl9yb3RhdGUgPSAyO1xuICAgIGVsc2UgaWYgKHRoaXMuX3JvdGF0ZSAlIDIgIT09IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdHRlbXB0IHRvIHVzZSBkaWFtb25kLXNoYXBlZCBVVnMuIElmIHlvdSBhcmUgc3VyZSwgc2V0IHJvdGF0aW9uIG1hbnVhbGx5XCIpO1xuICAgIHRoaXMuZGVmYXVsdEFuY2hvciA9IGFuY2hvciA/IG5ldyBtYXRoLlBvaW50KGFuY2hvci54LCBhbmNob3IueSkgOiBuZXcgbWF0aC5Qb2ludCgwLCAwKSwgdGhpcy5kZWZhdWx0Qm9yZGVycyA9IGJvcmRlcnMsIHRoaXMuX3VwZGF0ZUlEID0gMCwgdGhpcy50ZXh0dXJlQ2FjaGVJZHMgPSBbXSwgYmFzZVRleHR1cmUudmFsaWQgPyB0aGlzLm5vRnJhbWUgPyBiYXNlVGV4dHVyZS52YWxpZCAmJiB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkKGJhc2VUZXh0dXJlKSA6IHRoaXMuZnJhbWUgPSBmcmFtZSA6IGJhc2VUZXh0dXJlLm9uY2UoXCJsb2FkZWRcIiwgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCwgdGhpcyksIHRoaXMubm9GcmFtZSAmJiBiYXNlVGV4dHVyZS5vbihcInVwZGF0ZVwiLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIHRleHR1cmUgb24gdGhlIGdwdS5cbiAgICpcbiAgICogQ2FsbHMgdGhlIFRleHR1cmVSZXNvdXJjZSB1cGRhdGUuXG4gICAqXG4gICAqIElmIHlvdSBhZGp1c3RlZCBgZnJhbWVgIG1hbnVhbGx5LCBwbGVhc2UgY2FsbCBgdXBkYXRlVXZzKClgIGluc3RlYWQuXG4gICAqL1xuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5iYXNlVGV4dHVyZS5yZXNvdXJjZSAmJiB0aGlzLmJhc2VUZXh0dXJlLnJlc291cmNlLnVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgYmFzZSB0ZXh0dXJlIGlzIHVwZGF0ZWRcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gYmFzZVRleHR1cmUgLSBUaGUgYmFzZSB0ZXh0dXJlLlxuICAgKi9cbiAgb25CYXNlVGV4dHVyZVVwZGF0ZWQoYmFzZVRleHR1cmUpIHtcbiAgICBpZiAodGhpcy5ub0ZyYW1lKSB7XG4gICAgICBpZiAoIXRoaXMuYmFzZVRleHR1cmUudmFsaWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX2ZyYW1lLndpZHRoID0gYmFzZVRleHR1cmUud2lkdGgsIHRoaXMuX2ZyYW1lLmhlaWdodCA9IGJhc2VUZXh0dXJlLmhlaWdodCwgdGhpcy52YWxpZCA9ICEwLCB0aGlzLnVwZGF0ZVV2cygpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5mcmFtZSA9IHRoaXMuX2ZyYW1lO1xuICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhpcyB0ZXh0dXJlXG4gICAqIEBwYXJhbSBbZGVzdHJveUJhc2U9ZmFsc2VdIC0gV2hldGhlciB0byBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgYXMgd2VsbFxuICAgKiBAZmlyZXMgUElYSS5UZXh0dXJlI2Rlc3Ryb3llZFxuICAgKi9cbiAgZGVzdHJveShkZXN0cm95QmFzZSkge1xuICAgIGlmICh0aGlzLmJhc2VUZXh0dXJlKSB7XG4gICAgICBpZiAoZGVzdHJveUJhc2UpIHtcbiAgICAgICAgY29uc3QgeyByZXNvdXJjZSB9ID0gdGhpcy5iYXNlVGV4dHVyZTtcbiAgICAgICAgcmVzb3VyY2U/LnVybCAmJiB1dGlscy5UZXh0dXJlQ2FjaGVbcmVzb3VyY2UudXJsXSAmJiBUZXh0dXJlLnJlbW92ZUZyb21DYWNoZShyZXNvdXJjZS51cmwpLCB0aGlzLmJhc2VUZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYmFzZVRleHR1cmUub2ZmKFwibG9hZGVkXCIsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQsIHRoaXMpLCB0aGlzLmJhc2VUZXh0dXJlLm9mZihcInVwZGF0ZVwiLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCB0aGlzKSwgdGhpcy5iYXNlVGV4dHVyZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX2ZyYW1lID0gbnVsbCwgdGhpcy5fdXZzID0gbnVsbCwgdGhpcy50cmltID0gbnVsbCwgdGhpcy5vcmlnID0gbnVsbCwgdGhpcy52YWxpZCA9ICExLCBUZXh0dXJlLnJlbW92ZUZyb21DYWNoZSh0aGlzKSwgdGhpcy50ZXh0dXJlQ2FjaGVJZHMgPSBudWxsLCB0aGlzLmRlc3Ryb3llZCA9ICEwLCB0aGlzLmVtaXQoXCJkZXN0cm95ZWRcIiwgdGhpcyksIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdGV4dHVyZSBvYmplY3QgdGhhdCBhY3RzIHRoZSBzYW1lIGFzIHRoaXMgb25lLlxuICAgKiBAcmV0dXJucyAtIFRoZSBuZXcgdGV4dHVyZVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmVkRnJhbWUgPSB0aGlzLl9mcmFtZS5jbG9uZSgpLCBjbG9uZWRPcmlnID0gdGhpcy5fZnJhbWUgPT09IHRoaXMub3JpZyA/IGNsb25lZEZyYW1lIDogdGhpcy5vcmlnLmNsb25lKCksIGNsb25lZFRleHR1cmUgPSBuZXcgVGV4dHVyZShcbiAgICAgIHRoaXMuYmFzZVRleHR1cmUsXG4gICAgICAhdGhpcy5ub0ZyYW1lICYmIGNsb25lZEZyYW1lLFxuICAgICAgY2xvbmVkT3JpZyxcbiAgICAgIHRoaXMudHJpbT8uY2xvbmUoKSxcbiAgICAgIHRoaXMucm90YXRlLFxuICAgICAgdGhpcy5kZWZhdWx0QW5jaG9yLFxuICAgICAgdGhpcy5kZWZhdWx0Qm9yZGVyc1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXMubm9GcmFtZSAmJiAoY2xvbmVkVGV4dHVyZS5fZnJhbWUgPSBjbG9uZWRGcmFtZSksIGNsb25lZFRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIFdlYkdMIFVWIGNhY2hlLiBVc2UgaXQgYWZ0ZXIgeW91IGNoYW5nZSBgZnJhbWVgIG9yIGB0cmltYCBvZiB0aGUgdGV4dHVyZS5cbiAgICogQ2FsbCBpdCBhZnRlciBjaGFuZ2luZyB0aGUgZnJhbWVcbiAgICovXG4gIHVwZGF0ZVV2cygpIHtcbiAgICB0aGlzLl91dnMgPT09IERFRkFVTFRfVVZTICYmICh0aGlzLl91dnMgPSBuZXcgVGV4dHVyZVV2cy5UZXh0dXJlVXZzKCkpLCB0aGlzLl91dnMuc2V0KHRoaXMuX2ZyYW1lLCB0aGlzLmJhc2VUZXh0dXJlLCB0aGlzLnJvdGF0ZSksIHRoaXMuX3VwZGF0ZUlEKys7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgVGV4dHVyZSBiYXNlZCBvbiB0aGUgc291cmNlIHlvdSBwcm92aWRlLlxuICAgKiBUaGUgc291cmNlIGNhbiBiZSAtIGZyYW1lIGlkLCBpbWFnZSB1cmwsIHZpZGVvIHVybCwgY2FudmFzIGVsZW1lbnQsIHZpZGVvIGVsZW1lbnQsIGJhc2UgdGV4dHVyZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xQSVhJLkJhc2VUZXh0dXJlfEhUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxJbWFnZUJpdG1hcHxQSVhJLklDYW52YXN9IHNvdXJjZSAtXG4gICAqICAgICAgICBTb3VyY2Ugb3IgYXJyYXkgb2Ygc291cmNlcyB0byBjcmVhdGUgdGV4dHVyZSBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gU2VlIHtAbGluayBQSVhJLkJhc2VUZXh0dXJlfSdzIGNvbnN0cnVjdG9yIGZvciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGl4aUlkUHJlZml4PXBpeGlpZF0gLSBJZiBhIHNvdXJjZSBoYXMgbm8gaWQsIHRoaXMgaXMgdGhlIHByZWZpeCBvZiB0aGUgZ2VuZXJhdGVkIGlkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0cmljdF0gLSBFbmZvcmNlIHN0cmljdC1tb2RlLCBzZWUge0BsaW5rIFBJWEkuc2V0dGluZ3MuU1RSSUNUX1RFWFRVUkVfQ0FDSEV9LlxuICAgKiBAcmV0dXJucyB7UElYSS5UZXh0dXJlfSBUaGUgbmV3bHkgY3JlYXRlZCB0ZXh0dXJlXG4gICAqL1xuICBzdGF0aWMgZnJvbShzb3VyY2UsIG9wdGlvbnMgPSB7fSwgc3RyaWN0ID0gc2V0dGluZ3Muc2V0dGluZ3MuU1RSSUNUX1RFWFRVUkVfQ0FDSEUpIHtcbiAgICBjb25zdCBpc0ZyYW1lID0gdHlwZW9mIHNvdXJjZSA9PSBcInN0cmluZ1wiO1xuICAgIGxldCBjYWNoZUlkID0gbnVsbDtcbiAgICBpZiAoaXNGcmFtZSlcbiAgICAgIGNhY2hlSWQgPSBzb3VyY2U7XG4gICAgZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgQmFzZVRleHR1cmUuQmFzZVRleHR1cmUpIHtcbiAgICAgIGlmICghc291cmNlLmNhY2hlSWQpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gb3B0aW9ucz8ucGl4aUlkUHJlZml4IHx8IFwicGl4aWlkXCI7XG4gICAgICAgIHNvdXJjZS5jYWNoZUlkID0gYCR7cHJlZml4fS0ke3V0aWxzLnVpZCgpfWAsIEJhc2VUZXh0dXJlLkJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUoc291cmNlLCBzb3VyY2UuY2FjaGVJZCk7XG4gICAgICB9XG4gICAgICBjYWNoZUlkID0gc291cmNlLmNhY2hlSWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghc291cmNlLl9waXhpSWQpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gb3B0aW9ucz8ucGl4aUlkUHJlZml4IHx8IFwicGl4aWlkXCI7XG4gICAgICAgIHNvdXJjZS5fcGl4aUlkID0gYCR7cHJlZml4fV8ke3V0aWxzLnVpZCgpfWA7XG4gICAgICB9XG4gICAgICBjYWNoZUlkID0gc291cmNlLl9waXhpSWQ7XG4gICAgfVxuICAgIGxldCB0ZXh0dXJlID0gdXRpbHMuVGV4dHVyZUNhY2hlW2NhY2hlSWRdO1xuICAgIGlmIChpc0ZyYW1lICYmIHN0cmljdCAmJiAhdGV4dHVyZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGNhY2hlSWQgXCIke2NhY2hlSWR9XCIgZG9lcyBub3QgZXhpc3QgaW4gVGV4dHVyZUNhY2hlLmApO1xuICAgIHJldHVybiAhdGV4dHVyZSAmJiAhKHNvdXJjZSBpbnN0YW5jZW9mIEJhc2VUZXh0dXJlLkJhc2VUZXh0dXJlKSA/IChvcHRpb25zLnJlc29sdXRpb24gfHwgKG9wdGlvbnMucmVzb2x1dGlvbiA9IHV0aWxzLmdldFJlc29sdXRpb25PZlVybChzb3VyY2UpKSwgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKG5ldyBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZShzb3VyY2UsIG9wdGlvbnMpKSwgdGV4dHVyZS5iYXNlVGV4dHVyZS5jYWNoZUlkID0gY2FjaGVJZCwgQmFzZVRleHR1cmUuQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBjYWNoZUlkKSwgVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUsIGNhY2hlSWQpKSA6ICF0ZXh0dXJlICYmIHNvdXJjZSBpbnN0YW5jZW9mIEJhc2VUZXh0dXJlLkJhc2VUZXh0dXJlICYmICh0ZXh0dXJlID0gbmV3IFRleHR1cmUoc291cmNlKSwgVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUsIGNhY2hlSWQpKSwgdGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVXNlZnVsIGZvciBsb2FkaW5nIHRleHR1cmVzIHZpYSBVUkxzLiBVc2UgaW5zdGVhZCBvZiBgVGV4dHVyZS5mcm9tYCBiZWNhdXNlXG4gICAqIGl0IGRvZXMgYSBiZXR0ZXIgam9iIG9mIGhhbmRsaW5nIGZhaWxlZCBVUkxzIG1vcmUgZWZmZWN0aXZlbHkuIFRoaXMgYWxzbyBpZ25vcmVzXG4gICAqIGBQSVhJLnNldHRpbmdzLlNUUklDVF9URVhUVVJFX0NBQ0hFYC4gV29ya3MgZm9yIFZpZGVvcywgU1ZHcywgSW1hZ2VzLlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIHJlbW90ZSBVUkwgb3IgYXJyYXkgb2YgVVJMcyB0byBsb2FkLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIG9wdGlvbnMgdG8gaW5jbHVkZVxuICAgKiBAcmV0dXJucyAtIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgVGV4dHVyZS5cbiAgICovXG4gIHN0YXRpYyBmcm9tVVJMKHVybCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc291cmNlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBhdXRvTG9hZDogITEgfSwgb3B0aW9ucz8ucmVzb3VyY2VPcHRpb25zKSwgdGV4dHVyZSA9IFRleHR1cmUuZnJvbSh1cmwsIE9iamVjdC5hc3NpZ24oeyByZXNvdXJjZU9wdGlvbnMgfSwgb3B0aW9ucyksICExKSwgcmVzb3VyY2UgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlLnJlc291cmNlO1xuICAgIHJldHVybiB0ZXh0dXJlLmJhc2VUZXh0dXJlLnZhbGlkID8gUHJvbWlzZS5yZXNvbHZlKHRleHR1cmUpIDogcmVzb3VyY2UubG9hZCgpLnRoZW4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHRleHR1cmUpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFRleHR1cmUgd2l0aCBhIEJ1ZmZlclJlc291cmNlIGZyb20gYSB0eXBlZCBhcnJheS5cbiAgICogQHBhcmFtIGJ1ZmZlciAtIFRoZSBvcHRpb25hbCBhcnJheSB0byB1c2UuIElmIG5vIGRhdGEgaXMgcHJvdmlkZWQsIGEgbmV3IEZsb2F0MzJBcnJheSBpcyBjcmVhdGVkLlxuICAgKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiB0aGUgcmVzb3VyY2VcbiAgICogQHBhcmFtIGhlaWdodCAtIEhlaWdodCBvZiB0aGUgcmVzb3VyY2VcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXG4gICAqICAgICAgICBEZWZhdWx0IHByb3BlcnRpZXMgYXJlIGRpZmZlcmVudCBmcm9tIHRoZSBjb25zdHJ1Y3RvcidzIGRlZmF1bHRzLlxuICAgKiBAcGFyYW0ge1BJWEkuRk9STUFUU30gW29wdGlvbnMuZm9ybWF0XSAtIFRoZSBmb3JtYXQgaXMgbm90IGdpdmVuLCB0aGUgdHlwZSBpcyBpbmZlcnJlZCBmcm9tIHRoZVxuICAgKiAgICAgICAgdHlwZSBvZiB0aGUgYnVmZmVyOiBgUkdCQWAgaWYgRmxvYXQzMkFycmF5LCBJbnQ4QXJyYXksIFVpbnQ4QXJyYXksIG9yIFVpbnQ4Q2xhbXBlZEFycmF5LFxuICAgKiAgICAgICAgb3RoZXJ3aXNlIGBSR0JBX0lOVEVHRVJgLlxuICAgKiBAcGFyYW0ge1BJWEkuVFlQRVN9IFtvcHRpb25zLnR5cGVdIC0gVGhlIHR5cGUgaXMgbm90IGdpdmVuLCB0aGUgdHlwZSBpcyBpbmZlcnJlZCBmcm9tIHRoZVxuICAgKiAgICAgICAgdHlwZSBvZiB0aGUgYnVmZmVyLiBNYXBzIEZsb2F0MzJBcnJheSB0byBgRkxPQVRgLCBJbnQzMkFycmF5IHRvIGBJTlRgLCBVaW50MzJBcnJheSB0b1xuICAgKiAgICAgICAgYFVOU0lHTkVEX0lOVGAsIEludDE2QXJyYXkgdG8gYFNIT1JUYCwgVWludDE2QXJyYXkgdG8gYFVOU0lHTkVEX1NIT1JUYCwgSW50OEFycmF5IHRvIGBCWVRFYCxcbiAgICogICAgICAgIFVpbnQ4QXJyYXkvVWludDhDbGFtcGVkQXJyYXkgdG8gYFVOU0lHTkVEX0JZVEVgLlxuICAgKiBAcGFyYW0ge1BJWEkuQUxQSEFfTU9ERVN9IFtvcHRpb25zLmFscGhhTW9kZT1QSVhJLkFMUEhBX01PREVTLk5QTV1cbiAgICogQHBhcmFtIHtQSVhJLlNDQUxFX01PREVTfSBbb3B0aW9ucy5zY2FsZU1vZGU9UElYSS5TQ0FMRV9NT0RFUy5ORUFSRVNUXVxuICAgKiBAcmV0dXJucyAtIFRoZSByZXN1bHRpbmcgbmV3IEJhc2VUZXh0dXJlXG4gICAqL1xuICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRleHR1cmUoQmFzZVRleHR1cmUuQmFzZVRleHR1cmUuZnJvbUJ1ZmZlcihidWZmZXIsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgdGV4dHVyZSBmcm9tIGEgc291cmNlIGFuZCBhZGQgdG8gdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxJbWFnZUJpdG1hcHxQSVhJLklDYW52YXN8c3RyaW5nfSBzb3VyY2UgLSBUaGUgaW5wdXQgc291cmNlLlxuICAgKiBAcGFyYW0gaW1hZ2VVcmwgLSBGaWxlIG5hbWUgb2YgdGV4dHVyZSwgZm9yIGNhY2hlIGFuZCByZXNvbHZpbmcgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIG5hbWUgLSBIdW1hbiByZWFkYWJsZSBuYW1lIGZvciB0aGUgdGV4dHVyZSBjYWNoZS4gSWYgbm8gbmFtZSBpc1xuICAgKiAgICAgICAgc3BlY2lmaWVkLCBvbmx5IGBpbWFnZVVybGAgd2lsbCBiZSB1c2VkIGFzIHRoZSBjYWNoZSBJRC5cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHJldHVybnMgLSBPdXRwdXQgdGV4dHVyZVxuICAgKi9cbiAgc3RhdGljIGZyb21Mb2FkZXIoc291cmNlLCBpbWFnZVVybCwgbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJhc2VUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlLkJhc2VUZXh0dXJlKHNvdXJjZSwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBzY2FsZU1vZGU6IEJhc2VUZXh0dXJlLkJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLnNjYWxlTW9kZSxcbiAgICAgIHJlc29sdXRpb246IHV0aWxzLmdldFJlc29sdXRpb25PZlVybChpbWFnZVVybClcbiAgICB9LCBvcHRpb25zKSksIHsgcmVzb3VyY2UgfSA9IGJhc2VUZXh0dXJlO1xuICAgIHJlc291cmNlIGluc3RhbmNlb2YgSW1hZ2VSZXNvdXJjZS5JbWFnZVJlc291cmNlICYmIChyZXNvdXJjZS51cmwgPSBpbWFnZVVybCk7XG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGJhc2VUZXh0dXJlKTtcbiAgICByZXR1cm4gbmFtZSB8fCAobmFtZSA9IGltYWdlVXJsKSwgQmFzZVRleHR1cmUuQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBuYW1lKSwgVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUsIG5hbWUpLCBuYW1lICE9PSBpbWFnZVVybCAmJiAoQmFzZVRleHR1cmUuQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBpbWFnZVVybCksIFRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLCBpbWFnZVVybCkpLCB0ZXh0dXJlLmJhc2VUZXh0dXJlLnZhbGlkID8gUHJvbWlzZS5yZXNvbHZlKHRleHR1cmUpIDogbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUub25jZShcImxvYWRlZFwiLCAoKSA9PiByZXNvbHZlKHRleHR1cmUpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIFRleHR1cmUgdG8gdGhlIGdsb2JhbCBUZXh0dXJlQ2FjaGUuIFRoaXMgY2FjaGUgaXMgc2hhcmVkIGFjcm9zcyB0aGUgd2hvbGUgUElYSSBvYmplY3QuXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gVGhlIFRleHR1cmUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIGlkIC0gVGhlIGlkIHRoYXQgdGhlIFRleHR1cmUgd2lsbCBiZSBzdG9yZWQgYWdhaW5zdC5cbiAgICovXG4gIHN0YXRpYyBhZGRUb0NhY2hlKHRleHR1cmUsIGlkKSB7XG4gICAgaWQgJiYgKHRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmluY2x1ZGVzKGlkKSB8fCB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5wdXNoKGlkKSwgdXRpbHMuVGV4dHVyZUNhY2hlW2lkXSAmJiB1dGlscy5UZXh0dXJlQ2FjaGVbaWRdICE9PSB0ZXh0dXJlICYmIGNvbnNvbGUud2FybihgVGV4dHVyZSBhZGRlZCB0byB0aGUgY2FjaGUgd2l0aCBhbiBpZCBbJHtpZH1dIHRoYXQgYWxyZWFkeSBoYWQgYW4gZW50cnlgKSwgdXRpbHMuVGV4dHVyZUNhY2hlW2lkXSA9IHRleHR1cmUpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYSBUZXh0dXJlIGZyb20gdGhlIGdsb2JhbCBUZXh0dXJlQ2FjaGUuXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gaWQgb2YgYSBUZXh0dXJlIHRvIGJlIHJlbW92ZWQsIG9yIGEgVGV4dHVyZSBpbnN0YW5jZSBpdHNlbGZcbiAgICogQHJldHVybnMgLSBUaGUgVGV4dHVyZSB0aGF0IHdhcyByZW1vdmVkXG4gICAqL1xuICBzdGF0aWMgcmVtb3ZlRnJvbUNhY2hlKHRleHR1cmUpIHtcbiAgICBpZiAodHlwZW9mIHRleHR1cmUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgdGV4dHVyZUZyb21DYWNoZSA9IHV0aWxzLlRleHR1cmVDYWNoZVt0ZXh0dXJlXTtcbiAgICAgIGlmICh0ZXh0dXJlRnJvbUNhY2hlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGV4dHVyZUZyb21DYWNoZS50ZXh0dXJlQ2FjaGVJZHMuaW5kZXhPZih0ZXh0dXJlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgJiYgdGV4dHVyZUZyb21DYWNoZS50ZXh0dXJlQ2FjaGVJZHMuc3BsaWNlKGluZGV4LCAxKSwgZGVsZXRlIHV0aWxzLlRleHR1cmVDYWNoZVt0ZXh0dXJlXSwgdGV4dHVyZUZyb21DYWNoZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRleHR1cmU/LnRleHR1cmVDYWNoZUlkcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGg7ICsraSlcbiAgICAgICAgdXRpbHMuVGV4dHVyZUNhY2hlW3RleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXSA9PT0gdGV4dHVyZSAmJiBkZWxldGUgdXRpbHMuVGV4dHVyZUNhY2hlW3RleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXTtcbiAgICAgIHJldHVybiB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGggPSAwLCB0ZXh0dXJlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyByZXNvbHV0aW9uIG9mIGJhc2VUZXh0dXJlXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIGZyYW1lIHNwZWNpZmllcyB0aGUgcmVnaW9uIG9mIHRoZSBiYXNlIHRleHR1cmUgdGhhdCB0aGlzIHRleHR1cmUgdXNlcy5cbiAgICogUGxlYXNlIGNhbGwgYHVwZGF0ZVV2cygpYCBhZnRlciB5b3UgY2hhbmdlIGNvb3JkaW5hdGVzIG9mIGBmcmFtZWAgbWFudWFsbHkuXG4gICAqL1xuICBnZXQgZnJhbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZyYW1lO1xuICB9XG4gIHNldCBmcmFtZShmcmFtZSkge1xuICAgIHRoaXMuX2ZyYW1lID0gZnJhbWUsIHRoaXMubm9GcmFtZSA9ICExO1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gZnJhbWUsIHhOb3RGaXQgPSB4ICsgd2lkdGggPiB0aGlzLmJhc2VUZXh0dXJlLndpZHRoLCB5Tm90Rml0ID0geSArIGhlaWdodCA+IHRoaXMuYmFzZVRleHR1cmUuaGVpZ2h0O1xuICAgIGlmICh4Tm90Rml0IHx8IHlOb3RGaXQpIHtcbiAgICAgIGNvbnN0IHJlbGF0aW9uc2hpcCA9IHhOb3RGaXQgJiYgeU5vdEZpdCA/IFwiYW5kXCIgOiBcIm9yXCIsIGVycm9yWCA9IGBYOiAke3h9ICsgJHt3aWR0aH0gPSAke3ggKyB3aWR0aH0gPiAke3RoaXMuYmFzZVRleHR1cmUud2lkdGh9YCwgZXJyb3JZID0gYFk6ICR7eX0gKyAke2hlaWdodH0gPSAke3kgKyBoZWlnaHR9ID4gJHt0aGlzLmJhc2VUZXh0dXJlLmhlaWdodH1gO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZXh0dXJlIEVycm9yOiBmcmFtZSBkb2VzIG5vdCBmaXQgaW5zaWRlIHRoZSBiYXNlIFRleHR1cmUgZGltZW5zaW9uczogJHtlcnJvclh9ICR7cmVsYXRpb25zaGlwfSAke2Vycm9yWX1gKTtcbiAgICB9XG4gICAgdGhpcy52YWxpZCA9IHdpZHRoICYmIGhlaWdodCAmJiB0aGlzLmJhc2VUZXh0dXJlLnZhbGlkLCAhdGhpcy50cmltICYmICF0aGlzLnJvdGF0ZSAmJiAodGhpcy5vcmlnID0gZnJhbWUpLCB0aGlzLnZhbGlkICYmIHRoaXMudXBkYXRlVXZzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0ZXh0dXJlIGlzIHJvdGF0ZWQgaW5zaWRlIHRoZSBhdGxhc1xuICAgKiBzZXQgdG8gMiB0byBjb21wZW5zYXRlIGZvciB0ZXh0dXJlIHBhY2tlciByb3RhdGlvblxuICAgKiBzZXQgdG8gNiB0byBjb21wZW5zYXRlIGZvciBzcGluZSBwYWNrZXIgcm90YXRpb25cbiAgICogY2FuIGJlIHVzZWQgdG8gcm90YXRlIG9yIG1pcnJvciBzcHJpdGVzXG4gICAqIFNlZSB7QGxpbmsgUElYSS5ncm91cEQ4fSBmb3IgZXhwbGFuYXRpb25cbiAgICovXG4gIGdldCByb3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdGF0ZTtcbiAgfVxuICBzZXQgcm90YXRlKHJvdGF0ZSkge1xuICAgIHRoaXMuX3JvdGF0ZSA9IHJvdGF0ZSwgdGhpcy52YWxpZCAmJiB0aGlzLnVwZGF0ZVV2cygpO1xuICB9XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIFRleHR1cmUgaW4gcGl4ZWxzLiAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZy53aWR0aDtcbiAgfVxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgVGV4dHVyZSBpbiBwaXhlbHMuICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZy5oZWlnaHQ7XG4gIH1cbiAgLyoqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIEJhc2VUZXh0dXJlfFRleHR1cmUgY2FzdC4gKi9cbiAgY2FzdFRvQmFzZVRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVRleHR1cmU7XG4gIH1cbiAgLyoqIEFuIGVtcHR5IHRleHR1cmUsIHVzZWQgb2Z0ZW4gdG8gbm90IGhhdmUgdG8gY3JlYXRlIG11bHRpcGxlIGVtcHR5IHRleHR1cmVzLiBDYW4gbm90IGJlIGRlc3Ryb3llZC4gKi9cbiAgc3RhdGljIGdldCBFTVBUWSgpIHtcbiAgICByZXR1cm4gVGV4dHVyZS5fRU1QVFkgfHwgKFRleHR1cmUuX0VNUFRZID0gbmV3IFRleHR1cmUobmV3IEJhc2VUZXh0dXJlLkJhc2VUZXh0dXJlKCkpLCByZW1vdmVBbGxIYW5kbGVycyhUZXh0dXJlLl9FTVBUWSksIHJlbW92ZUFsbEhhbmRsZXJzKFRleHR1cmUuX0VNUFRZLmJhc2VUZXh0dXJlKSksIFRleHR1cmUuX0VNUFRZO1xuICB9XG4gIC8qKiBBIHdoaXRlIHRleHR1cmUgb2YgMTZ4MTYgc2l6ZSwgdXNlZCBmb3IgZ3JhcGhpY3MgYW5kIG90aGVyIHRoaW5ncyBDYW4gbm90IGJlIGRlc3Ryb3llZC4gKi9cbiAgc3RhdGljIGdldCBXSElURSgpIHtcbiAgICBpZiAoIVRleHR1cmUuX1dISVRFKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBzZXR0aW5ncy5zZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygxNiwgMTYpLCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IDE2LCBjYW52YXMuaGVpZ2h0ID0gMTYsIGNvbnRleHQuZmlsbFN0eWxlID0gXCJ3aGl0ZVwiLCBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIDE2LCAxNiksIFRleHR1cmUuX1dISVRFID0gbmV3IFRleHR1cmUoQmFzZVRleHR1cmUuQmFzZVRleHR1cmUuZnJvbShjYW52YXMpKSwgcmVtb3ZlQWxsSGFuZGxlcnMoVGV4dHVyZS5fV0hJVEUpLCByZW1vdmVBbGxIYW5kbGVycyhUZXh0dXJlLl9XSElURS5iYXNlVGV4dHVyZSk7XG4gICAgfVxuICAgIHJldHVybiBUZXh0dXJlLl9XSElURTtcbiAgfVxufVxuZXhwb3J0cy5UZXh0dXJlID0gVGV4dHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmUuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiQHBpeGkvY29uc3RhbnRzXCIpLCBleHRlbnNpb25zID0gcmVxdWlyZShcIkBwaXhpL2V4dGVuc2lvbnNcIik7XG5jb25zdCBfVGV4dHVyZUdDU3lzdGVtID0gY2xhc3MgX1RleHR1cmVHQ1N5c3RlbTIge1xuICAvKiogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci4gKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXIsIHRoaXMuY291bnQgPSAwLCB0aGlzLmNoZWNrQ291bnQgPSAwLCB0aGlzLm1heElkbGUgPSBfVGV4dHVyZUdDU3lzdGVtMi5kZWZhdWx0TWF4SWRsZSwgdGhpcy5jaGVja0NvdW50TWF4ID0gX1RleHR1cmVHQ1N5c3RlbTIuZGVmYXVsdENoZWNrQ291bnRNYXgsIHRoaXMubW9kZSA9IF9UZXh0dXJlR0NTeXN0ZW0yLmRlZmF1bHRNb2RlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgdG8gc2VlIHdoZW4gdGhlIGxhc3QgdGltZSBhIHRleHR1cmUgd2FzIHVzZWQuXG4gICAqIElmIHRoZSB0ZXh0dXJlIGhhcyBub3QgYmVlbiB1c2VkIGZvciBhIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSwgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEdQVS5cbiAgICovXG4gIHBvc3RyZW5kZXIoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5vYmplY3RSZW5kZXJlci5yZW5kZXJpbmdUb1NjcmVlbiAmJiAodGhpcy5jb3VudCsrLCB0aGlzLm1vZGUgIT09IGNvbnN0YW50cy5HQ19NT0RFUy5NQU5VQUwgJiYgKHRoaXMuY2hlY2tDb3VudCsrLCB0aGlzLmNoZWNrQ291bnQgPiB0aGlzLmNoZWNrQ291bnRNYXggJiYgKHRoaXMuY2hlY2tDb3VudCA9IDAsIHRoaXMucnVuKCkpKSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB0byBzZWUgd2hlbiB0aGUgbGFzdCB0aW1lIGEgdGV4dHVyZSB3YXMgdXNlZC5cbiAgICogSWYgdGhlIHRleHR1cmUgaGFzIG5vdCBiZWVuIHVzZWQgZm9yIGEgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lLCBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgR1BVLlxuICAgKi9cbiAgcnVuKCkge1xuICAgIGNvbnN0IHRtID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlLCBtYW5hZ2VkVGV4dHVyZXMgPSB0bS5tYW5hZ2VkVGV4dHVyZXM7XG4gICAgbGV0IHdhc1JlbW92ZWQgPSAhMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hbmFnZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IG1hbmFnZWRUZXh0dXJlc1tpXTtcbiAgICAgIHRleHR1cmUucmVzb3VyY2UgJiYgdGhpcy5jb3VudCAtIHRleHR1cmUudG91Y2hlZCA+IHRoaXMubWF4SWRsZSAmJiAodG0uZGVzdHJveVRleHR1cmUodGV4dHVyZSwgITApLCBtYW5hZ2VkVGV4dHVyZXNbaV0gPSBudWxsLCB3YXNSZW1vdmVkID0gITApO1xuICAgIH1cbiAgICBpZiAod2FzUmVtb3ZlZCkge1xuICAgICAgbGV0IGogPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYW5hZ2VkVGV4dHVyZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIG1hbmFnZWRUZXh0dXJlc1tpXSAhPT0gbnVsbCAmJiAobWFuYWdlZFRleHR1cmVzW2orK10gPSBtYW5hZ2VkVGV4dHVyZXNbaV0pO1xuICAgICAgbWFuYWdlZFRleHR1cmVzLmxlbmd0aCA9IGo7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCB0aGUgdGV4dHVyZXMgd2l0aGluIHRoZSBzcGVjaWZpZWQgZGlzcGxheU9iamVjdCBhbmQgaXRzIGNoaWxkcmVuIGZyb20gdGhlIEdQVS5cbiAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGRpc3BsYXlPYmplY3QgLSB0aGUgZGlzcGxheU9iamVjdCB0byByZW1vdmUgdGhlIHRleHR1cmVzIGZyb20uXG4gICAqL1xuICB1bmxvYWQoZGlzcGxheU9iamVjdCkge1xuICAgIGNvbnN0IHRtID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlLCB0ZXh0dXJlID0gZGlzcGxheU9iamVjdC5fdGV4dHVyZTtcbiAgICB0ZXh0dXJlICYmICF0ZXh0dXJlLmZyYW1lYnVmZmVyICYmIHRtLmRlc3Ryb3lUZXh0dXJlKHRleHR1cmUpO1xuICAgIGZvciAobGV0IGkgPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgdGhpcy51bmxvYWQoZGlzcGxheU9iamVjdC5jaGlsZHJlbltpXSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufTtcbl9UZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE1vZGUgPSBjb25zdGFudHMuR0NfTU9ERVMuQVVUTywgLyoqXG4qIERlZmF1bHQgbWF4aW11bSBpZGxlIGZyYW1lcyBiZWZvcmUgYSB0ZXh0dXJlIGlzIGRlc3Ryb3llZCBieSBnYXJiYWdlIGNvbGxlY3Rpb24uXG4qIEBzdGF0aWNcbiogQGRlZmF1bHQgMzYwMFxuKiBAc2VlIFBJWEkuVGV4dHVyZUdDU3lzdGVtI21heElkbGVcbiovXG5fVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNYXhJZGxlID0gNjAgKiA2MCwgLyoqXG4qIERlZmF1bHQgZnJhbWVzIGJldHdlZW4gdHdvIGdhcmJhZ2UgY29sbGVjdGlvbnMuXG4qIEBzdGF0aWNcbiogQGRlZmF1bHQgNjAwXG4qIEBzZWUgUElYSS5UZXh0dXJlR0NTeXN0ZW0jY2hlY2tDb3VudE1heFxuKi9cbl9UZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdENoZWNrQ291bnRNYXggPSA2MCAqIDEwLCAvKiogQGlnbm9yZSAqL1xuX1RleHR1cmVHQ1N5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJ0ZXh0dXJlR0NcIlxufTtcbmxldCBUZXh0dXJlR0NTeXN0ZW0gPSBfVGV4dHVyZUdDU3lzdGVtO1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChUZXh0dXJlR0NTeXN0ZW0pO1xuZXhwb3J0cy5UZXh0dXJlR0NTeXN0ZW0gPSBUZXh0dXJlR0NTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0dXJlR0NTeXN0ZW0uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtYXRoID0gcmVxdWlyZShcIkBwaXhpL21hdGhcIik7XG5jb25zdCB0ZW1wTWF0ID0gbmV3IG1hdGguTWF0cml4KCk7XG5jbGFzcyBUZXh0dXJlTWF0cml4IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gb2JzZXJ2ZWQgdGV4dHVyZVxuICAgKiBAcGFyYW0gY2xhbXBNYXJnaW4gLSBDaGFuZ2VzIGZyYW1lIGNsYW1waW5nLCAwLjUgYnkgZGVmYXVsdC4gVXNlIC0wLjUgZm9yIGV4dHJhIGJvcmRlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRleHR1cmUsIGNsYW1wTWFyZ2luKSB7XG4gICAgdGhpcy5fdGV4dHVyZSA9IHRleHR1cmUsIHRoaXMubWFwQ29vcmQgPSBuZXcgbWF0aC5NYXRyaXgoKSwgdGhpcy51Q2xhbXBGcmFtZSA9IG5ldyBGbG9hdDMyQXJyYXkoNCksIHRoaXMudUNsYW1wT2Zmc2V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKSwgdGhpcy5fdGV4dHVyZUlEID0gLTEsIHRoaXMuX3VwZGF0ZUlEID0gMCwgdGhpcy5jbGFtcE9mZnNldCA9IDAsIHRoaXMuY2xhbXBNYXJnaW4gPSB0eXBlb2YgY2xhbXBNYXJnaW4gPiBcInVcIiA/IDAuNSA6IGNsYW1wTWFyZ2luLCB0aGlzLmlzU2ltcGxlID0gITE7XG4gIH1cbiAgLyoqIFRleHR1cmUgcHJvcGVydHkuICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0dXJlO1xuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy5fdGV4dHVyZSA9IHZhbHVlLCB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgfVxuICAvKipcbiAgICogTXVsdGlwbGllcyB1dnMgYXJyYXkgdG8gdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB1dnMgLSBtZXNoIHV2c1xuICAgKiBAcGFyYW0gW291dD11dnNdIC0gb3V0cHV0XG4gICAqIEByZXR1cm5zIC0gb3V0cHV0XG4gICAqL1xuICBtdWx0aXBseVV2cyh1dnMsIG91dCkge1xuICAgIG91dCA9PT0gdm9pZCAwICYmIChvdXQgPSB1dnMpO1xuICAgIGNvbnN0IG1hdCA9IHRoaXMubWFwQ29vcmQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSB1dnNbaV0sIHkgPSB1dnNbaSArIDFdO1xuICAgICAgb3V0W2ldID0geCAqIG1hdC5hICsgeSAqIG1hdC5jICsgbWF0LnR4LCBvdXRbaSArIDFdID0geCAqIG1hdC5iICsgeSAqIG1hdC5kICsgbWF0LnR5O1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIG1hdHJpY2VzIGlmIHRleHR1cmUgd2FzIGNoYW5nZWQuXG4gICAqIEBwYXJhbSBbZm9yY2VVcGRhdGU9ZmFsc2VdIC0gaWYgdHJ1ZSwgbWF0cmljZXMgd2lsbCBiZSB1cGRhdGVkIGFueSBjYXNlXG4gICAqIEByZXR1cm5zIC0gV2hldGhlciBvciBub3QgaXQgd2FzIHVwZGF0ZWRcbiAgICovXG4gIHVwZGF0ZShmb3JjZVVwZGF0ZSkge1xuICAgIGNvbnN0IHRleCA9IHRoaXMuX3RleHR1cmU7XG4gICAgaWYgKCF0ZXggfHwgIXRleC52YWxpZCB8fCAhZm9yY2VVcGRhdGUgJiYgdGhpcy5fdGV4dHVyZUlEID09PSB0ZXguX3VwZGF0ZUlEKVxuICAgICAgcmV0dXJuICExO1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IHRleC5fdXBkYXRlSUQsIHRoaXMuX3VwZGF0ZUlEKys7XG4gICAgY29uc3QgdXZzID0gdGV4Ll91dnM7XG4gICAgdGhpcy5tYXBDb29yZC5zZXQodXZzLngxIC0gdXZzLngwLCB1dnMueTEgLSB1dnMueTAsIHV2cy54MyAtIHV2cy54MCwgdXZzLnkzIC0gdXZzLnkwLCB1dnMueDAsIHV2cy55MCk7XG4gICAgY29uc3Qgb3JpZyA9IHRleC5vcmlnLCB0cmltID0gdGV4LnRyaW07XG4gICAgdHJpbSAmJiAodGVtcE1hdC5zZXQoXG4gICAgICBvcmlnLndpZHRoIC8gdHJpbS53aWR0aCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgb3JpZy5oZWlnaHQgLyB0cmltLmhlaWdodCxcbiAgICAgIC10cmltLnggLyB0cmltLndpZHRoLFxuICAgICAgLXRyaW0ueSAvIHRyaW0uaGVpZ2h0XG4gICAgKSwgdGhpcy5tYXBDb29yZC5hcHBlbmQodGVtcE1hdCkpO1xuICAgIGNvbnN0IHRleEJhc2UgPSB0ZXguYmFzZVRleHR1cmUsIGZyYW1lID0gdGhpcy51Q2xhbXBGcmFtZSwgbWFyZ2luID0gdGhpcy5jbGFtcE1hcmdpbiAvIHRleEJhc2UucmVzb2x1dGlvbiwgb2Zmc2V0ID0gdGhpcy5jbGFtcE9mZnNldDtcbiAgICByZXR1cm4gZnJhbWVbMF0gPSAodGV4Ll9mcmFtZS54ICsgbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2Uud2lkdGgsIGZyYW1lWzFdID0gKHRleC5fZnJhbWUueSArIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLmhlaWdodCwgZnJhbWVbMl0gPSAodGV4Ll9mcmFtZS54ICsgdGV4Ll9mcmFtZS53aWR0aCAtIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLndpZHRoLCBmcmFtZVszXSA9ICh0ZXguX2ZyYW1lLnkgKyB0ZXguX2ZyYW1lLmhlaWdodCAtIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLmhlaWdodCwgdGhpcy51Q2xhbXBPZmZzZXRbMF0gPSBvZmZzZXQgLyB0ZXhCYXNlLnJlYWxXaWR0aCwgdGhpcy51Q2xhbXBPZmZzZXRbMV0gPSBvZmZzZXQgLyB0ZXhCYXNlLnJlYWxIZWlnaHQsIHRoaXMuaXNTaW1wbGUgPSB0ZXguX2ZyYW1lLndpZHRoID09PSB0ZXhCYXNlLndpZHRoICYmIHRleC5fZnJhbWUuaGVpZ2h0ID09PSB0ZXhCYXNlLmhlaWdodCAmJiB0ZXgucm90YXRlID09PSAwLCAhMDtcbiAgfVxufVxuZXhwb3J0cy5UZXh0dXJlTWF0cml4ID0gVGV4dHVyZU1hdHJpeDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVNYXRyaXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiQHBpeGkvY29uc3RhbnRzXCIpLCBleHRlbnNpb25zID0gcmVxdWlyZShcIkBwaXhpL2V4dGVuc2lvbnNcIiksIHV0aWxzID0gcmVxdWlyZShcIkBwaXhpL3V0aWxzXCIpLCBCYXNlVGV4dHVyZSA9IHJlcXVpcmUoXCIuL0Jhc2VUZXh0dXJlLmpzXCIpLCBHTFRleHR1cmUgPSByZXF1aXJlKFwiLi9HTFRleHR1cmUuanNcIiksIG1hcEludGVybmFsRm9ybWF0VG9TYW1wbGVyVHlwZSA9IHJlcXVpcmUoXCIuL3V0aWxzL21hcEludGVybmFsRm9ybWF0VG9TYW1wbGVyVHlwZS5qc1wiKSwgbWFwVHlwZUFuZEZvcm1hdFRvSW50ZXJuYWxGb3JtYXQgPSByZXF1aXJlKFwiLi91dGlscy9tYXBUeXBlQW5kRm9ybWF0VG9JbnRlcm5hbEZvcm1hdC5qc1wiKTtcbmNsYXNzIFRleHR1cmVTeXN0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgc3lzdGVtIHdvcmtzIGZvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyLCB0aGlzLmJvdW5kVGV4dHVyZXMgPSBbXSwgdGhpcy5jdXJyZW50TG9jYXRpb24gPSAtMSwgdGhpcy5tYW5hZ2VkVGV4dHVyZXMgPSBbXSwgdGhpcy5fdW5rbm93bkJvdW5kVGV4dHVyZXMgPSAhMSwgdGhpcy51bmtub3duVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZSgpLCB0aGlzLmhhc0ludGVnZXJUZXh0dXJlcyA9ICExO1xuICB9XG4gIC8qKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy4gKi9cbiAgY29udGV4dENoYW5nZSgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgIHRoaXMuQ09OVEVYVF9VSUQgPSB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlELCB0aGlzLndlYkdMVmVyc2lvbiA9IHRoaXMucmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24sIHRoaXMuaW50ZXJuYWxGb3JtYXRzID0gbWFwVHlwZUFuZEZvcm1hdFRvSW50ZXJuYWxGb3JtYXQubWFwVHlwZUFuZEZvcm1hdFRvSW50ZXJuYWxGb3JtYXQoZ2wpLCB0aGlzLnNhbXBsZXJUeXBlcyA9IG1hcEludGVybmFsRm9ybWF0VG9TYW1wbGVyVHlwZS5tYXBJbnRlcm5hbEZvcm1hdFRvU2FtcGxlclR5cGUoZ2wpO1xuICAgIGNvbnN0IG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcbiAgICB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoID0gbWF4VGV4dHVyZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKVxuICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW2ldID0gbnVsbDtcbiAgICB0aGlzLmVtcHR5VGV4dHVyZXMgPSB7fTtcbiAgICBjb25zdCBlbXB0eVRleHR1cmUyRCA9IG5ldyBHTFRleHR1cmUuR0xUZXh0dXJlKGdsLmNyZWF0ZVRleHR1cmUoKSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZW1wdHlUZXh0dXJlMkQudGV4dHVyZSksIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbmV3IFVpbnQ4QXJyYXkoNCkpLCB0aGlzLmVtcHR5VGV4dHVyZXNbZ2wuVEVYVFVSRV8yRF0gPSBlbXB0eVRleHR1cmUyRCwgdGhpcy5lbXB0eVRleHR1cmVzW2dsLlRFWFRVUkVfQ1VCRV9NQVBdID0gbmV3IEdMVGV4dHVyZS5HTFRleHR1cmUoZ2wuY3JlYXRlVGV4dHVyZSgpKSwgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy5lbXB0eVRleHR1cmVzW2dsLlRFWFRVUkVfQ1VCRV9NQVBdLnRleHR1cmUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbC5SR0JBLCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKSwgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLmJpbmQobnVsbCwgaSk7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmQgYSB0ZXh0dXJlIHRvIGEgc3BlY2lmaWMgbG9jYXRpb25cbiAgICpcbiAgICogSWYgeW91IHdhbnQgdG8gdW5iaW5kIHNvbWV0aGluZywgcGxlYXNlIHVzZSBgdW5iaW5kKHRleHR1cmUpYCBpbnN0ZWFkIG9mIGBiaW5kKG51bGwsIHRleHR1cmVMb2NhdGlvbilgXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gVGV4dHVyZSB0byBiaW5kXG4gICAqIEBwYXJhbSBbbG9jYXRpb249MF0gLSBMb2NhdGlvbiB0byBiaW5kIGF0XG4gICAqL1xuICBiaW5kKHRleHR1cmUsIGxvY2F0aW9uID0gMCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgaWYgKHRleHR1cmUgPSB0ZXh0dXJlPy5jYXN0VG9CYXNlVGV4dHVyZSgpLCB0ZXh0dXJlPy52YWxpZCAmJiAhdGV4dHVyZS5wYXJlbnRUZXh0dXJlQXJyYXkpIHtcbiAgICAgIHRleHR1cmUudG91Y2hlZCA9IHRoaXMucmVuZGVyZXIudGV4dHVyZUdDLmNvdW50O1xuICAgICAgY29uc3QgZ2xUZXh0dXJlID0gdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXSB8fCB0aGlzLmluaXRUZXh0dXJlKHRleHR1cmUpO1xuICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW2xvY2F0aW9uXSAhPT0gdGV4dHVyZSAmJiAodGhpcy5jdXJyZW50TG9jYXRpb24gIT09IGxvY2F0aW9uICYmICh0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGxvY2F0aW9uLCBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgbG9jYXRpb24pKSwgZ2wuYmluZFRleHR1cmUodGV4dHVyZS50YXJnZXQsIGdsVGV4dHVyZS50ZXh0dXJlKSksIGdsVGV4dHVyZS5kaXJ0eUlkICE9PSB0ZXh0dXJlLmRpcnR5SWQgPyAodGhpcy5jdXJyZW50TG9jYXRpb24gIT09IGxvY2F0aW9uICYmICh0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGxvY2F0aW9uLCBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgbG9jYXRpb24pKSwgdGhpcy51cGRhdGVUZXh0dXJlKHRleHR1cmUpKSA6IGdsVGV4dHVyZS5kaXJ0eVN0eWxlSWQgIT09IHRleHR1cmUuZGlydHlTdHlsZUlkICYmIHRoaXMudXBkYXRlVGV4dHVyZVN0eWxlKHRleHR1cmUpLCB0aGlzLmJvdW5kVGV4dHVyZXNbbG9jYXRpb25dID0gdGV4dHVyZTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uICE9PSBsb2NhdGlvbiAmJiAodGhpcy5jdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvbiwgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGxvY2F0aW9uKSksIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFXzJEXS50ZXh0dXJlKSwgdGhpcy5ib3VuZFRleHR1cmVzW2xvY2F0aW9uXSA9IG51bGw7XG4gIH1cbiAgLyoqIFJlc2V0cyB0ZXh0dXJlIGxvY2F0aW9uIGFuZCBib3VuZCB0ZXh0dXJlcyBBY3R1YWwgYGJpbmQobnVsbCwgaSlgIGNhbGxzIHdpbGwgYmUgcGVyZm9ybWVkIGF0IG5leHQgYHVuYmluZCgpYCBjYWxsICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gITAsIHRoaXMuaGFzSW50ZWdlclRleHR1cmVzID0gITEsIHRoaXMuY3VycmVudExvY2F0aW9uID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLmJvdW5kVGV4dHVyZXNbaV0gPSB0aGlzLnVua25vd25UZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBVbmJpbmQgYSB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIFRleHR1cmUgdG8gYmluZFxuICAgKi9cbiAgdW5iaW5kKHRleHR1cmUpIHtcbiAgICBjb25zdCB7IGdsLCBib3VuZFRleHR1cmVzIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLl91bmtub3duQm91bmRUZXh0dXJlcykge1xuICAgICAgdGhpcy5fdW5rbm93bkJvdW5kVGV4dHVyZXMgPSAhMTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgYm91bmRUZXh0dXJlc1tpXSA9PT0gdGhpcy51bmtub3duVGV4dHVyZSAmJiB0aGlzLmJpbmQobnVsbCwgaSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkrKylcbiAgICAgIGJvdW5kVGV4dHVyZXNbaV0gPT09IHRleHR1cmUgJiYgKHRoaXMuY3VycmVudExvY2F0aW9uICE9PSBpICYmIChnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgaSksIHRoaXMuY3VycmVudExvY2F0aW9uID0gaSksIGdsLmJpbmRUZXh0dXJlKHRleHR1cmUudGFyZ2V0LCB0aGlzLmVtcHR5VGV4dHVyZXNbdGV4dHVyZS50YXJnZXRdLnRleHR1cmUpLCBib3VuZFRleHR1cmVzW2ldID0gbnVsbCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhhdCBjdXJyZW50IGJvdW5kVGV4dHVyZXMgYWxsIGhhdmUgRkxPQVQgc2FtcGxlciB0eXBlLFxuICAgKiBzZWUge0BsaW5rIFBJWEkuU0FNUExFUl9UWVBFU30gZm9yIGV4cGxhbmF0aW9uLlxuICAgKiBAcGFyYW0gbWF4VGV4dHVyZXMgLSBudW1iZXIgb2YgbG9jYXRpb25zIHRvIGNoZWNrXG4gICAqL1xuICBlbnN1cmVTYW1wbGVyVHlwZShtYXhUZXh0dXJlcykge1xuICAgIGNvbnN0IHsgYm91bmRUZXh0dXJlcywgaGFzSW50ZWdlclRleHR1cmVzLCBDT05URVhUX1VJRCB9ID0gdGhpcztcbiAgICBpZiAoaGFzSW50ZWdlclRleHR1cmVzKVxuICAgICAgZm9yIChsZXQgaSA9IG1heFRleHR1cmVzIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgdGV4ID0gYm91bmRUZXh0dXJlc1tpXTtcbiAgICAgICAgdGV4ICYmIHRleC5fZ2xUZXh0dXJlc1tDT05URVhUX1VJRF0uc2FtcGxlclR5cGUgIT09IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FUICYmIHRoaXMucmVuZGVyZXIudGV4dHVyZS51bmJpbmQodGV4KTtcbiAgICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIHRleHR1cmVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHRleHR1cmUgLSBUZXh0dXJlIHRvIGluaXRpYWxpemVcbiAgICovXG4gIGluaXRUZXh0dXJlKHRleHR1cmUpIHtcbiAgICBjb25zdCBnbFRleHR1cmUgPSBuZXcgR0xUZXh0dXJlLkdMVGV4dHVyZSh0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKSk7XG4gICAgcmV0dXJuIGdsVGV4dHVyZS5kaXJ0eUlkID0gLTEsIHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0gPSBnbFRleHR1cmUsIHRoaXMubWFuYWdlZFRleHR1cmVzLnB1c2godGV4dHVyZSksIHRleHR1cmUub24oXCJkaXNwb3NlXCIsIHRoaXMuZGVzdHJveVRleHR1cmUsIHRoaXMpLCBnbFRleHR1cmU7XG4gIH1cbiAgaW5pdFRleHR1cmVUeXBlKHRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCA9IHRoaXMuaW50ZXJuYWxGb3JtYXRzW3RleHR1cmUudHlwZV0/Llt0ZXh0dXJlLmZvcm1hdF0gPz8gdGV4dHVyZS5mb3JtYXQsIGdsVGV4dHVyZS5zYW1wbGVyVHlwZSA9IHRoaXMuc2FtcGxlclR5cGVzW2dsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdF0gPz8gY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsIHRoaXMud2ViR0xWZXJzaW9uID09PSAyICYmIHRleHR1cmUudHlwZSA9PT0gY29uc3RhbnRzLlRZUEVTLkhBTEZfRkxPQVQgPyBnbFRleHR1cmUudHlwZSA9IHRoaXMuZ2wuSEFMRl9GTE9BVCA6IGdsVGV4dHVyZS50eXBlID0gdGV4dHVyZS50eXBlO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgYSB0ZXh0dXJlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gdGV4dHVyZSAtIFRleHR1cmUgdG8gaW5pdGlhbGl6ZVxuICAgKi9cbiAgdXBkYXRlVGV4dHVyZSh0ZXh0dXJlKSB7XG4gICAgY29uc3QgZ2xUZXh0dXJlID0gdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICBpZiAoIWdsVGV4dHVyZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgaWYgKHRoaXMuaW5pdFRleHR1cmVUeXBlKHRleHR1cmUsIGdsVGV4dHVyZSksIHRleHR1cmUucmVzb3VyY2U/LnVwbG9hZChyZW5kZXJlciwgdGV4dHVyZSwgZ2xUZXh0dXJlKSlcbiAgICAgIGdsVGV4dHVyZS5zYW1wbGVyVHlwZSAhPT0gY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQgJiYgKHRoaXMuaGFzSW50ZWdlclRleHR1cmVzID0gITApO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3Qgd2lkdGggPSB0ZXh0dXJlLnJlYWxXaWR0aCwgaGVpZ2h0ID0gdGV4dHVyZS5yZWFsSGVpZ2h0LCBnbCA9IHJlbmRlcmVyLmdsO1xuICAgICAgKGdsVGV4dHVyZS53aWR0aCAhPT0gd2lkdGggfHwgZ2xUZXh0dXJlLmhlaWdodCAhPT0gaGVpZ2h0IHx8IGdsVGV4dHVyZS5kaXJ0eUlkIDwgMCkgJiYgKGdsVGV4dHVyZS53aWR0aCA9IHdpZHRoLCBnbFRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0LCBnbC50ZXhJbWFnZTJEKFxuICAgICAgICB0ZXh0dXJlLnRhcmdldCxcbiAgICAgICAgMCxcbiAgICAgICAgZ2xUZXh0dXJlLmludGVybmFsRm9ybWF0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICAwLFxuICAgICAgICB0ZXh0dXJlLmZvcm1hdCxcbiAgICAgICAgZ2xUZXh0dXJlLnR5cGUsXG4gICAgICAgIG51bGxcbiAgICAgICkpO1xuICAgIH1cbiAgICB0ZXh0dXJlLmRpcnR5U3R5bGVJZCAhPT0gZ2xUZXh0dXJlLmRpcnR5U3R5bGVJZCAmJiB0aGlzLnVwZGF0ZVRleHR1cmVTdHlsZSh0ZXh0dXJlKSwgZ2xUZXh0dXJlLmRpcnR5SWQgPSB0ZXh0dXJlLmRpcnR5SWQ7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIHRleHR1cmUgZnJvbSBXZWJHTFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIHRoZSB0ZXh0dXJlIHRvIGRlc3Ryb3lcbiAgICogQHBhcmFtIFtza2lwUmVtb3ZlPWZhbHNlXSAtIFdoZXRoZXIgdG8gc2tpcCByZW1vdmluZyB0aGUgdGV4dHVyZSBmcm9tIHRoZSBUZXh0dXJlTWFuYWdlci5cbiAgICovXG4gIGRlc3Ryb3lUZXh0dXJlKHRleHR1cmUsIHNraXBSZW1vdmUpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIGlmICh0ZXh0dXJlID0gdGV4dHVyZS5jYXN0VG9CYXNlVGV4dHVyZSgpLCB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdICYmICh0aGlzLnVuYmluZCh0ZXh0dXJlKSwgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLnRleHR1cmUpLCB0ZXh0dXJlLm9mZihcImRpc3Bvc2VcIiwgdGhpcy5kZXN0cm95VGV4dHVyZSwgdGhpcyksIGRlbGV0ZSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLCAhc2tpcFJlbW92ZSkpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLm1hbmFnZWRUZXh0dXJlcy5pbmRleE9mKHRleHR1cmUpO1xuICAgICAgaSAhPT0gLTEgJiYgdXRpbHMucmVtb3ZlSXRlbXModGhpcy5tYW5hZ2VkVGV4dHVyZXMsIGksIDEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRleHR1cmUgc3R5bGUgc3VjaCBhcyBtaXBtYXAgZmxhZ1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IHRleHR1cmUgLSBUZXh0dXJlIHRvIHVwZGF0ZVxuICAgKi9cbiAgdXBkYXRlVGV4dHVyZVN0eWxlKHRleHR1cmUpIHtcbiAgICBjb25zdCBnbFRleHR1cmUgPSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgIGdsVGV4dHVyZSAmJiAoKHRleHR1cmUubWlwbWFwID09PSBjb25zdGFudHMuTUlQTUFQX01PREVTLlBPVzIgfHwgdGhpcy53ZWJHTFZlcnNpb24gIT09IDIpICYmICF0ZXh0dXJlLmlzUG93ZXJPZlR3byA/IGdsVGV4dHVyZS5taXBtYXAgPSAhMSA6IGdsVGV4dHVyZS5taXBtYXAgPSB0ZXh0dXJlLm1pcG1hcCA+PSAxLCB0aGlzLndlYkdMVmVyc2lvbiAhPT0gMiAmJiAhdGV4dHVyZS5pc1Bvd2VyT2ZUd28gPyBnbFRleHR1cmUud3JhcE1vZGUgPSBjb25zdGFudHMuV1JBUF9NT0RFUy5DTEFNUCA6IGdsVGV4dHVyZS53cmFwTW9kZSA9IHRleHR1cmUud3JhcE1vZGUsIHRleHR1cmUucmVzb3VyY2U/LnN0eWxlKHRoaXMucmVuZGVyZXIsIHRleHR1cmUsIGdsVGV4dHVyZSkgfHwgdGhpcy5zZXRTdHlsZSh0ZXh0dXJlLCBnbFRleHR1cmUpLCBnbFRleHR1cmUuZGlydHlTdHlsZUlkID0gdGV4dHVyZS5kaXJ0eVN0eWxlSWQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgc3R5bGUgZm9yIHRleHR1cmVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHRleHR1cmUgLSBUZXh0dXJlIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gZ2xUZXh0dXJlXG4gICAqL1xuICBzZXRTdHlsZSh0ZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgaWYgKGdsVGV4dHVyZS5taXBtYXAgJiYgdGV4dHVyZS5taXBtYXAgIT09IGNvbnN0YW50cy5NSVBNQVBfTU9ERVMuT05fTUFOVUFMICYmIGdsLmdlbmVyYXRlTWlwbWFwKHRleHR1cmUudGFyZ2V0KSwgZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlLnRhcmdldCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsVGV4dHVyZS53cmFwTW9kZSksIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbFRleHR1cmUud3JhcE1vZGUpLCBnbFRleHR1cmUubWlwbWFwKSB7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmUudGFyZ2V0LCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBjb25zdGFudHMuU0NBTEVfTU9ERVMuTElORUFSID8gZ2wuTElORUFSX01JUE1BUF9MSU5FQVIgOiBnbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUKTtcbiAgICAgIGNvbnN0IGFuaXNvdHJvcGljRXh0ID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMuYW5pc290cm9waWNGaWx0ZXJpbmc7XG4gICAgICBpZiAoYW5pc290cm9waWNFeHQgJiYgdGV4dHVyZS5hbmlzb3Ryb3BpY0xldmVsID4gMCAmJiB0ZXh0dXJlLnNjYWxlTW9kZSA9PT0gY29uc3RhbnRzLlNDQUxFX01PREVTLkxJTkVBUikge1xuICAgICAgICBjb25zdCBsZXZlbCA9IE1hdGgubWluKHRleHR1cmUuYW5pc290cm9waWNMZXZlbCwgZ2wuZ2V0UGFyYW1ldGVyKGFuaXNvdHJvcGljRXh0Lk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCkpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJmKHRleHR1cmUudGFyZ2V0LCBhbmlzb3Ryb3BpY0V4dC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgbGV2ZWwpO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlLnRhcmdldCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0ZXh0dXJlLnNjYWxlTW9kZSA9PT0gY29uc3RhbnRzLlNDQUxFX01PREVTLkxJTkVBUiA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPT09IGNvbnN0YW50cy5TQ0FMRV9NT0RFUy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5UZXh0dXJlU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcInRleHR1cmVcIlxufTtcbmV4dGVuc2lvbnMuZXh0ZW5zaW9ucy5hZGQoVGV4dHVyZVN5c3RlbSk7XG5leHBvcnRzLlRleHR1cmVTeXN0ZW0gPSBUZXh0dXJlU3lzdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZVN5c3RlbS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1hdGggPSByZXF1aXJlKFwiQHBpeGkvbWF0aFwiKTtcbmNsYXNzIFRleHR1cmVVdnMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLngwID0gMCwgdGhpcy55MCA9IDAsIHRoaXMueDEgPSAxLCB0aGlzLnkxID0gMCwgdGhpcy54MiA9IDEsIHRoaXMueTIgPSAxLCB0aGlzLngzID0gMCwgdGhpcy55MyA9IDEsIHRoaXMudXZzRmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleHR1cmUgVXZzIGJhc2VkIG9uIHRoZSBnaXZlbiBmcmFtZSBpbmZvcm1hdGlvbi5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gZnJhbWUgLSBUaGUgZnJhbWUgb2YgdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIGJhc2VGcmFtZSAtIFRoZSBiYXNlIGZyYW1lIG9mIHRoZSB0ZXh0dXJlXG4gICAqIEBwYXJhbSByb3RhdGUgLSBSb3RhdGlvbiBvZiBmcmFtZSwgc2VlIHtAbGluayBQSVhJLmdyb3VwRDh9XG4gICAqL1xuICBzZXQoZnJhbWUsIGJhc2VGcmFtZSwgcm90YXRlKSB7XG4gICAgY29uc3QgdHcgPSBiYXNlRnJhbWUud2lkdGgsIHRoID0gYmFzZUZyYW1lLmhlaWdodDtcbiAgICBpZiAocm90YXRlKSB7XG4gICAgICBjb25zdCB3MiA9IGZyYW1lLndpZHRoIC8gMiAvIHR3LCBoMiA9IGZyYW1lLmhlaWdodCAvIDIgLyB0aCwgY1ggPSBmcmFtZS54IC8gdHcgKyB3MiwgY1kgPSBmcmFtZS55IC8gdGggKyBoMjtcbiAgICAgIHJvdGF0ZSA9IG1hdGguZ3JvdXBEOC5hZGQocm90YXRlLCBtYXRoLmdyb3VwRDguTlcpLCB0aGlzLngwID0gY1ggKyB3MiAqIG1hdGguZ3JvdXBEOC51WChyb3RhdGUpLCB0aGlzLnkwID0gY1kgKyBoMiAqIG1hdGguZ3JvdXBEOC51WShyb3RhdGUpLCByb3RhdGUgPSBtYXRoLmdyb3VwRDguYWRkKHJvdGF0ZSwgMiksIHRoaXMueDEgPSBjWCArIHcyICogbWF0aC5ncm91cEQ4LnVYKHJvdGF0ZSksIHRoaXMueTEgPSBjWSArIGgyICogbWF0aC5ncm91cEQ4LnVZKHJvdGF0ZSksIHJvdGF0ZSA9IG1hdGguZ3JvdXBEOC5hZGQocm90YXRlLCAyKSwgdGhpcy54MiA9IGNYICsgdzIgKiBtYXRoLmdyb3VwRDgudVgocm90YXRlKSwgdGhpcy55MiA9IGNZICsgaDIgKiBtYXRoLmdyb3VwRDgudVkocm90YXRlKSwgcm90YXRlID0gbWF0aC5ncm91cEQ4LmFkZChyb3RhdGUsIDIpLCB0aGlzLngzID0gY1ggKyB3MiAqIG1hdGguZ3JvdXBEOC51WChyb3RhdGUpLCB0aGlzLnkzID0gY1kgKyBoMiAqIG1hdGguZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy54MCA9IGZyYW1lLnggLyB0dywgdGhpcy55MCA9IGZyYW1lLnkgLyB0aCwgdGhpcy54MSA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gdHcsIHRoaXMueTEgPSBmcmFtZS55IC8gdGgsIHRoaXMueDIgPSAoZnJhbWUueCArIGZyYW1lLndpZHRoKSAvIHR3LCB0aGlzLnkyID0gKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpIC8gdGgsIHRoaXMueDMgPSBmcmFtZS54IC8gdHcsIHRoaXMueTMgPSAoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgLyB0aDtcbiAgICB0aGlzLnV2c0Zsb2F0MzJbMF0gPSB0aGlzLngwLCB0aGlzLnV2c0Zsb2F0MzJbMV0gPSB0aGlzLnkwLCB0aGlzLnV2c0Zsb2F0MzJbMl0gPSB0aGlzLngxLCB0aGlzLnV2c0Zsb2F0MzJbM10gPSB0aGlzLnkxLCB0aGlzLnV2c0Zsb2F0MzJbNF0gPSB0aGlzLngyLCB0aGlzLnV2c0Zsb2F0MzJbNV0gPSB0aGlzLnkyLCB0aGlzLnV2c0Zsb2F0MzJbNl0gPSB0aGlzLngzLCB0aGlzLnV2c0Zsb2F0MzJbN10gPSB0aGlzLnkzO1xuICB9XG59XG5UZXh0dXJlVXZzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYFtAcGl4aS9jb3JlOlRleHR1cmVVdnMgeDA9JHt0aGlzLngwfSB5MD0ke3RoaXMueTB9IHgxPSR7dGhpcy54MX0geTE9JHt0aGlzLnkxfSB4Mj0ke3RoaXMueDJ9IHkyPSR7dGhpcy55Mn0geDM9JHt0aGlzLngzfSB5Mz0ke3RoaXMueTN9XWA7XG59O1xuZXhwb3J0cy5UZXh0dXJlVXZzID0gVGV4dHVyZVV2cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVVdnMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBCYXNlVGV4dHVyZSA9IHJlcXVpcmUoXCIuLi9CYXNlVGV4dHVyZS5qc1wiKSwgYXV0b0RldGVjdFJlc291cmNlID0gcmVxdWlyZShcIi4vYXV0b0RldGVjdFJlc291cmNlLmpzXCIpLCBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuL1Jlc291cmNlLmpzXCIpO1xuY2xhc3MgQWJzdHJhY3RNdWx0aVJlc291cmNlIGV4dGVuZHMgUmVzb3VyY2UuUmVzb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIGxlbmd0aFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gZm9yIFJlc291cmNlIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gLSBXaWR0aCBvZiB0aGUgcmVzb3VyY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gLSBIZWlnaHQgb2YgdGhlIHJlc291cmNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG9wdGlvbnMgfHwge307XG4gICAgc3VwZXIod2lkdGgsIGhlaWdodCksIHRoaXMuaXRlbXMgPSBbXSwgdGhpcy5pdGVtRGlydHlJZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0VGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZS5CYXNlVGV4dHVyZSgpO1xuICAgICAgdGhpcy5pdGVtcy5wdXNoKHBhcnRUZXh0dXJlKSwgdGhpcy5pdGVtRGlydHlJZHMucHVzaCgtMik7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoLCB0aGlzLl9sb2FkID0gbnVsbCwgdGhpcy5iYXNlVGV4dHVyZSA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgZnJvbSBBcnJheVJlc291cmNlIGFuZCBDdWJlUmVzb3VyY2UgY29uc3RydWN0b3JzLlxuICAgKiBAcGFyYW0gcmVzb3VyY2VzIC0gQ2FuIGJlIHJlc291cmNlcywgaW1hZ2UgZWxlbWVudHMsIGNhbnZhcywgZXRjLiAsXG4gICAqICBsZW5ndGggc2hvdWxkIGJlIHNhbWUgYXMgY29uc3RydWN0b3IgbGVuZ3RoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gRGV0ZWN0IG9wdGlvbnMgZm9yIHJlc291cmNlc1xuICAgKi9cbiAgaW5pdEZyb21BcnJheShyZXNvdXJjZXMsIG9wdGlvbnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICByZXNvdXJjZXNbaV0gJiYgKHJlc291cmNlc1tpXS5jYXN0VG9CYXNlVGV4dHVyZSA/IHRoaXMuYWRkQmFzZVRleHR1cmVBdChyZXNvdXJjZXNbaV0uY2FzdFRvQmFzZVRleHR1cmUoKSwgaSkgOiByZXNvdXJjZXNbaV0gaW5zdGFuY2VvZiBSZXNvdXJjZS5SZXNvdXJjZSA/IHRoaXMuYWRkUmVzb3VyY2VBdChyZXNvdXJjZXNbaV0sIGkpIDogdGhpcy5hZGRSZXNvdXJjZUF0KGF1dG9EZXRlY3RSZXNvdXJjZS5hdXRvRGV0ZWN0UmVzb3VyY2UocmVzb3VyY2VzW2ldLCBvcHRpb25zKSwgaSkpO1xuICB9XG4gIC8qKiBEZXN0cm95IHRoaXMgQmFzZUltYWdlUmVzb3VyY2UuICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspXG4gICAgICB0aGlzLml0ZW1zW2ldLmRlc3Ryb3koKTtcbiAgICB0aGlzLml0ZW1zID0gbnVsbCwgdGhpcy5pdGVtRGlydHlJZHMgPSBudWxsLCB0aGlzLl9sb2FkID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgcmVzb3VyY2UgYnkgSURcbiAgICogQHBhcmFtIHJlc291cmNlXG4gICAqIEBwYXJhbSBpbmRleCAtIFplcm8tYmFzZWQgaW5kZXggb2YgcmVzb3VyY2UgdG8gc2V0XG4gICAqIEByZXR1cm5zIC0gSW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAqL1xuICBhZGRSZXNvdXJjZUF0KHJlc291cmNlLCBpbmRleCkge1xuICAgIGlmICghdGhpcy5pdGVtc1tpbmRleF0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEluZGV4ICR7aW5kZXh9IGlzIG91dCBvZiBib3VuZHNgKTtcbiAgICByZXR1cm4gcmVzb3VyY2UudmFsaWQgJiYgIXRoaXMudmFsaWQgJiYgdGhpcy5yZXNpemUocmVzb3VyY2Uud2lkdGgsIHJlc291cmNlLmhlaWdodCksIHRoaXMuaXRlbXNbaW5kZXhdLnNldFJlc291cmNlKHJlc291cmNlKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBwYXJlbnQgYmFzZSB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gYmFzZVRleHR1cmVcbiAgICovXG4gIGJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICBpZiAodGhpcy5iYXNlVGV4dHVyZSAhPT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGJhc2UgdGV4dHVyZSBwZXIgVGV4dHVyZUFycmF5IGlzIGFsbG93ZWRcIik7XG4gICAgc3VwZXIuYmluZChiYXNlVGV4dHVyZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5pdGVtc1tpXS5wYXJlbnRUZXh0dXJlQXJyYXkgPSBiYXNlVGV4dHVyZSwgdGhpcy5pdGVtc1tpXS5vbihcInVwZGF0ZVwiLCBiYXNlVGV4dHVyZS51cGRhdGUsIGJhc2VUZXh0dXJlKTtcbiAgfVxuICAvKipcbiAgICogVW5zZXQgdGhlIHBhcmVudCBiYXNlIHRleHR1cmUuXG4gICAqIEBwYXJhbSBiYXNlVGV4dHVyZVxuICAgKi9cbiAgdW5iaW5kKGJhc2VUZXh0dXJlKSB7XG4gICAgc3VwZXIudW5iaW5kKGJhc2VUZXh0dXJlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLml0ZW1zW2ldLnBhcmVudFRleHR1cmVBcnJheSA9IG51bGwsIHRoaXMuaXRlbXNbaV0ub2ZmKFwidXBkYXRlXCIsIGJhc2VUZXh0dXJlLnVwZGF0ZSwgYmFzZVRleHR1cmUpO1xuICB9XG4gIC8qKlxuICAgKiBMb2FkIGFsbCB0aGUgcmVzb3VyY2VzIHNpbXVsdGFuZW91c2x5XG4gICAqIEByZXR1cm5zIC0gV2hlbiBsb2FkIGlzIHJlc29sdmVkXG4gICAqL1xuICBsb2FkKCkge1xuICAgIGlmICh0aGlzLl9sb2FkKVxuICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLml0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5yZXNvdXJjZSkuZmlsdGVyKChpdGVtKSA9PiBpdGVtKS5tYXAoKGl0ZW0pID0+IGl0ZW0ubG9hZCgpKTtcbiAgICByZXR1cm4gdGhpcy5fbG9hZCA9IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKFxuICAgICAgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlYWxXaWR0aCwgcmVhbEhlaWdodCB9ID0gdGhpcy5pdGVtc1swXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKHJlYWxXaWR0aCwgcmVhbEhlaWdodCksIHRoaXMudXBkYXRlKCksIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICAgIH1cbiAgICApLCB0aGlzLl9sb2FkO1xuICB9XG59XG5leHBvcnRzLkFic3RyYWN0TXVsdGlSZXNvdXJjZSA9IEFic3RyYWN0TXVsdGlSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFic3RyYWN0TXVsdGlSZXNvdXJjZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCJAcGl4aS9jb25zdGFudHNcIiksIEFic3RyYWN0TXVsdGlSZXNvdXJjZSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0TXVsdGlSZXNvdXJjZS5qc1wiKTtcbmNsYXNzIEFycmF5UmVzb3VyY2UgZXh0ZW5kcyBBYnN0cmFjdE11bHRpUmVzb3VyY2UuQWJzdHJhY3RNdWx0aVJlc291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBzb3VyY2UgLSBOdW1iZXIgb2YgaXRlbXMgaW4gYXJyYXkgb3IgdGhlIGNvbGxlY3Rpb25cbiAgICogICAgICAgIG9mIGltYWdlIFVSTHMgdG8gdXNlLiBDYW4gYWxzbyBiZSByZXNvdXJjZXMsIGltYWdlIGVsZW1lbnRzLCBjYW52YXMsIGV0Yy5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGFwcGx5IHRvIHtAbGluayBQSVhJLmF1dG9EZXRlY3RSZXNvdXJjZX1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoXSAtIFdpZHRoIG9mIHRoZSByZXNvdXJjZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSAtIEhlaWdodCBvZiB0aGUgcmVzb3VyY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgdXJscywgbGVuZ3RoO1xuICAgIEFycmF5LmlzQXJyYXkoc291cmNlKSA/ICh1cmxzID0gc291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoKSA6IGxlbmd0aCA9IHNvdXJjZSwgc3VwZXIobGVuZ3RoLCB7IHdpZHRoLCBoZWlnaHQgfSksIHVybHMgJiYgdGhpcy5pbml0RnJvbUFycmF5KHVybHMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSBiYXNlVGV4dHVyZSBieSBJRCxcbiAgICogQXJyYXlSZXNvdXJjZSBqdXN0IHRha2VzIHJlc291cmNlIGZyb20gaXQsIG5vdGhpbmcgbW9yZVxuICAgKiBAcGFyYW0gYmFzZVRleHR1cmVcbiAgICogQHBhcmFtIGluZGV4IC0gWmVyby1iYXNlZCBpbmRleCBvZiByZXNvdXJjZSB0byBzZXRcbiAgICogQHJldHVybnMgLSBJbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICovXG4gIGFkZEJhc2VUZXh0dXJlQXQoYmFzZVRleHR1cmUsIGluZGV4KSB7XG4gICAgaWYgKGJhc2VUZXh0dXJlLnJlc291cmNlKVxuICAgICAgdGhpcy5hZGRSZXNvdXJjZUF0KGJhc2VUZXh0dXJlLnJlc291cmNlLCBpbmRleCk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlSZXNvdXJjZSBkb2VzIG5vdCBzdXBwb3J0IFJlbmRlclRleHR1cmVcIik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBiaW5kaW5nXG4gICAqIEBwYXJhbSBiYXNlVGV4dHVyZVxuICAgKi9cbiAgYmluZChiYXNlVGV4dHVyZSkge1xuICAgIHN1cGVyLmJpbmQoYmFzZVRleHR1cmUpLCBiYXNlVGV4dHVyZS50YXJnZXQgPSBjb25zdGFudHMuVEFSR0VUUy5URVhUVVJFXzJEX0FSUkFZO1xuICB9XG4gIC8qKlxuICAgKiBVcGxvYWQgdGhlIHJlc291cmNlcyB0byB0aGUgR1BVLlxuICAgKiBAcGFyYW0gcmVuZGVyZXJcbiAgICogQHBhcmFtIHRleHR1cmVcbiAgICogQHBhcmFtIGdsVGV4dHVyZVxuICAgKiBAcmV0dXJucyAtIHdoZXRoZXIgdGV4dHVyZSB3YXMgdXBsb2FkZWRcbiAgICovXG4gIHVwbG9hZChyZW5kZXJlciwgdGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgY29uc3QgeyBsZW5ndGgsIGl0ZW1EaXJ0eUlkcywgaXRlbXMgfSA9IHRoaXMsIHsgZ2wgfSA9IHJlbmRlcmVyO1xuICAgIGdsVGV4dHVyZS5kaXJ0eUlkIDwgMCAmJiBnbC50ZXhJbWFnZTNEKFxuICAgICAgZ2wuVEVYVFVSRV8yRF9BUlJBWSxcbiAgICAgIDAsXG4gICAgICBnbFRleHR1cmUuaW50ZXJuYWxGb3JtYXQsXG4gICAgICB0aGlzLl93aWR0aCxcbiAgICAgIHRoaXMuX2hlaWdodCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIDAsXG4gICAgICB0ZXh0dXJlLmZvcm1hdCxcbiAgICAgIGdsVGV4dHVyZS50eXBlLFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgaXRlbURpcnR5SWRzW2ldIDwgaXRlbS5kaXJ0eUlkICYmIChpdGVtRGlydHlJZHNbaV0gPSBpdGVtLmRpcnR5SWQsIGl0ZW0udmFsaWQgJiYgZ2wudGV4U3ViSW1hZ2UzRChcbiAgICAgICAgZ2wuVEVYVFVSRV8yRF9BUlJBWSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgLy8geG9mZnNldFxuICAgICAgICAwLFxuICAgICAgICAvLyB5b2Zmc2V0XG4gICAgICAgIGksXG4gICAgICAgIC8vIHpvZmZzZXRcbiAgICAgICAgaXRlbS5yZXNvdXJjZS53aWR0aCxcbiAgICAgICAgaXRlbS5yZXNvdXJjZS5oZWlnaHQsXG4gICAgICAgIDEsXG4gICAgICAgIHRleHR1cmUuZm9ybWF0LFxuICAgICAgICBnbFRleHR1cmUudHlwZSxcbiAgICAgICAgaXRlbS5yZXNvdXJjZS5zb3VyY2VcbiAgICAgICkpO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH1cbn1cbmV4cG9ydHMuQXJyYXlSZXNvdXJjZSA9IEFycmF5UmVzb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJheVJlc291cmNlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKSwgdXRpbHMgPSByZXF1aXJlKFwiQHBpeGkvdXRpbHNcIiksIFJlc291cmNlID0gcmVxdWlyZShcIi4vUmVzb3VyY2UuanNcIik7XG5jbGFzcyBCYXNlSW1hZ2VSZXNvdXJjZSBleHRlbmRzIFJlc291cmNlLlJlc291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEltYWdlQml0bWFwfFBJWEkuSUNhbnZhc30gc291cmNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICBjb25zdCBzb3VyY2VBbnkgPSBzb3VyY2UsIHdpZHRoID0gc291cmNlQW55Lm5hdHVyYWxXaWR0aCB8fCBzb3VyY2VBbnkudmlkZW9XaWR0aCB8fCBzb3VyY2VBbnkud2lkdGgsIGhlaWdodCA9IHNvdXJjZUFueS5uYXR1cmFsSGVpZ2h0IHx8IHNvdXJjZUFueS52aWRlb0hlaWdodCB8fCBzb3VyY2VBbnkuaGVpZ2h0O1xuICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQpLCB0aGlzLnNvdXJjZSA9IHNvdXJjZSwgdGhpcy5ub1N1YkltYWdlID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBjcm9zcyBvcmlnaW4gYmFzZWQgZGV0ZWN0aW5nIHRoZSB1cmwgYW5kIHRoZSBjcm9zc29yaWdpblxuICAgKiBAcGFyYW0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgY3Jvc3NPcmlnaW5cbiAgICogQHBhcmFtIHVybCAtIFVSTCB0byBjaGVja1xuICAgKiBAcGFyYW0gY3Jvc3NvcmlnaW4gLSBDcm9zcyBvcmlnaW4gdmFsdWUgdG8gdXNlXG4gICAqL1xuICBzdGF0aWMgY3Jvc3NPcmlnaW4oZWxlbWVudCwgdXJsLCBjcm9zc29yaWdpbikge1xuICAgIGNyb3Nzb3JpZ2luID09PSB2b2lkIDAgJiYgIXVybC5zdGFydHNXaXRoKFwiZGF0YTpcIikgPyBlbGVtZW50LmNyb3NzT3JpZ2luID0gdXRpbHMuZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4odXJsKSA6IGNyb3Nzb3JpZ2luICE9PSAhMSAmJiAoZWxlbWVudC5jcm9zc09yaWdpbiA9IHR5cGVvZiBjcm9zc29yaWdpbiA9PSBcInN0cmluZ1wiID8gY3Jvc3NvcmlnaW4gOiBcImFub255bW91c1wiKTtcbiAgfVxuICAvKipcbiAgICogVXBsb2FkIHRoZSB0ZXh0dXJlIHRvIHRoZSBHUFUuXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFVwbG9hZCB0byB0aGUgcmVuZGVyZXJcbiAgICogQHBhcmFtIGJhc2VUZXh0dXJlIC0gUmVmZXJlbmNlIHRvIHBhcmVudCB0ZXh0dXJlXG4gICAqIEBwYXJhbSBnbFRleHR1cmVcbiAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8SW1hZ2VCaXRtYXB8UElYSS5JQ2FudmFzfSBbc291cmNlXSAtIChvcHRpb25hbClcbiAgICogQHJldHVybnMgLSB0cnVlIGlzIHN1Y2Nlc3NcbiAgICovXG4gIHVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSwgc291cmNlKSB7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbCwgd2lkdGggPSBiYXNlVGV4dHVyZS5yZWFsV2lkdGgsIGhlaWdodCA9IGJhc2VUZXh0dXJlLnJlYWxIZWlnaHQ7XG4gICAgaWYgKHNvdXJjZSA9IHNvdXJjZSB8fCB0aGlzLnNvdXJjZSwgdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgPCBcInVcIiAmJiBzb3VyY2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICBpZiAoIXNvdXJjZS5jb21wbGV0ZSB8fCBzb3VyY2UubmF0dXJhbFdpZHRoID09PSAwKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgSFRNTFZpZGVvRWxlbWVudCA8IFwidVwiICYmIHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgJiYgc291cmNlLnJlYWR5U3RhdGUgPD0gMSlcbiAgICAgIHJldHVybiAhMTtcbiAgICByZXR1cm4gZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBiYXNlVGV4dHVyZS5hbHBoYU1vZGUgPT09IGNvbnN0YW50cy5BTFBIQV9NT0RFUy5VTlBBQ0spLCAhdGhpcy5ub1N1YkltYWdlICYmIGJhc2VUZXh0dXJlLnRhcmdldCA9PT0gZ2wuVEVYVFVSRV8yRCAmJiBnbFRleHR1cmUud2lkdGggPT09IHdpZHRoICYmIGdsVGV4dHVyZS5oZWlnaHQgPT09IGhlaWdodCA/IGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgc291cmNlKSA6IChnbFRleHR1cmUud2lkdGggPSB3aWR0aCwgZ2xUZXh0dXJlLmhlaWdodCA9IGhlaWdodCwgZ2wudGV4SW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgYmFzZVRleHR1cmUuZm9ybWF0LCBnbFRleHR1cmUudHlwZSwgc291cmNlKSksICEwO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgc291cmNlIHdpZHRoL2hlaWdodCB3YXMgY2hhbmdlZCwgcmVzaXplIGNhbiBjYXVzZSBleHRyYSBiYXNlVGV4dHVyZSB1cGRhdGUuXG4gICAqIFRyaWdnZXJzIG9uZSB1cGRhdGUgaW4gYW55IGNhc2UuXG4gICAqL1xuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlLCB3aWR0aCA9IHNvdXJjZS5uYXR1cmFsV2lkdGggfHwgc291cmNlLnZpZGVvV2lkdGggfHwgc291cmNlLndpZHRoLCBoZWlnaHQgPSBzb3VyY2UubmF0dXJhbEhlaWdodCB8fCBzb3VyY2UudmlkZW9IZWlnaHQgfHwgc291cmNlLmhlaWdodDtcbiAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSwgc3VwZXIudXBkYXRlKCk7XG4gIH1cbiAgLyoqIERlc3Ryb3kgdGhpcyB7QGxpbmsgUElYSS5CYXNlSW1hZ2VSZXNvdXJjZX0gKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIH1cbn1cbmV4cG9ydHMuQmFzZUltYWdlUmVzb3VyY2UgPSBCYXNlSW1hZ2VSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VJbWFnZVJlc291cmNlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKSwgUmVzb3VyY2UgPSByZXF1aXJlKFwiLi9SZXNvdXJjZS5qc1wiKTtcbmNsYXNzIEJ1ZmZlclJlc291cmNlIGV4dGVuZHMgUmVzb3VyY2UuUmVzb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHNvdXJjZSAtIFNvdXJjZSBidWZmZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLndpZHRoIC0gV2lkdGggb2YgdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7MXwyfDR8OH0gW29wdGlvbnMudW5wYWNrQWxpZ25tZW50PTRdIC0gVGhlIGFsaWdubWVudCBvZiB0aGUgcGl4ZWwgcm93cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXJSZXNvdXJjZSB3aWR0aCBvciBoZWlnaHQgaW52YWxpZFwiKTtcbiAgICBzdXBlcih3aWR0aCwgaGVpZ2h0KSwgdGhpcy5kYXRhID0gc291cmNlLCB0aGlzLnVucGFja0FsaWdubWVudCA9IG9wdGlvbnMudW5wYWNrQWxpZ25tZW50ID8/IDQ7XG4gIH1cbiAgLyoqXG4gICAqIFVwbG9hZCB0aGUgdGV4dHVyZSB0byB0aGUgR1BVLlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBVcGxvYWQgdG8gdGhlIHJlbmRlcmVyXG4gICAqIEBwYXJhbSBiYXNlVGV4dHVyZSAtIFJlZmVyZW5jZSB0byBwYXJlbnQgdGV4dHVyZVxuICAgKiBAcGFyYW0gZ2xUZXh0dXJlIC0gZ2xUZXh0dXJlXG4gICAqIEByZXR1cm5zIC0gdHJ1ZSBpcyBzdWNjZXNzXG4gICAqL1xuICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdsO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19BTElHTk1FTlQsIHRoaXMudW5wYWNrQWxpZ25tZW50KSwgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBiYXNlVGV4dHVyZS5hbHBoYU1vZGUgPT09IGNvbnN0YW50cy5BTFBIQV9NT0RFUy5VTlBBQ0spO1xuICAgIGNvbnN0IHdpZHRoID0gYmFzZVRleHR1cmUucmVhbFdpZHRoLCBoZWlnaHQgPSBiYXNlVGV4dHVyZS5yZWFsSGVpZ2h0O1xuICAgIHJldHVybiBnbFRleHR1cmUud2lkdGggPT09IHdpZHRoICYmIGdsVGV4dHVyZS5oZWlnaHQgPT09IGhlaWdodCA/IGdsLnRleFN1YkltYWdlMkQoXG4gICAgICBiYXNlVGV4dHVyZS50YXJnZXQsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGJhc2VUZXh0dXJlLmZvcm1hdCxcbiAgICAgIGdsVGV4dHVyZS50eXBlLFxuICAgICAgdGhpcy5kYXRhXG4gICAgKSA6IChnbFRleHR1cmUud2lkdGggPSB3aWR0aCwgZ2xUZXh0dXJlLmhlaWdodCA9IGhlaWdodCwgZ2wudGV4SW1hZ2UyRChcbiAgICAgIGJhc2VUZXh0dXJlLnRhcmdldCxcbiAgICAgIDAsXG4gICAgICBnbFRleHR1cmUuaW50ZXJuYWxGb3JtYXQsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIDAsXG4gICAgICBiYXNlVGV4dHVyZS5mb3JtYXQsXG4gICAgICBnbFRleHR1cmUudHlwZSxcbiAgICAgIHRoaXMuZGF0YVxuICAgICkpLCAhMDtcbiAgfVxuICAvKiogRGVzdHJveSBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVXNlZCB0byBhdXRvLWRldGVjdCB0aGUgdHlwZSBvZiByZXNvdXJjZS5cbiAgICogQHBhcmFtIHsqfSBzb3VyY2UgLSBUaGUgc291cmNlIG9iamVjdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGJ1ZmZlciBzb3VyY2VcbiAgICovXG4gIHN0YXRpYyB0ZXN0KHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2UgPT09IG51bGwgfHwgc291cmNlIGluc3RhbmNlb2YgSW50OEFycmF5IHx8IHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgfHwgc291cmNlIGluc3RhbmNlb2YgSW50MTZBcnJheSB8fCBzb3VyY2UgaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fCBzb3VyY2UgaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8IHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8IHNvdXJjZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheTtcbiAgfVxufVxuZXhwb3J0cy5CdWZmZXJSZXNvdXJjZSA9IEJ1ZmZlclJlc291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVmZmVyUmVzb3VyY2UuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBCYXNlSW1hZ2VSZXNvdXJjZSA9IHJlcXVpcmUoXCIuL0Jhc2VJbWFnZVJlc291cmNlLmpzXCIpO1xuY2xhc3MgQ2FudmFzUmVzb3VyY2UgZXh0ZW5kcyBCYXNlSW1hZ2VSZXNvdXJjZS5CYXNlSW1hZ2VSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gc291cmNlIC0gQ2FudmFzIGVsZW1lbnQgdG8gdXNlXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZWxlc3MtY29uc3RydWN0b3JcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgc3VwZXIoc291cmNlKTtcbiAgfVxuICAvKipcbiAgICogVXNlZCB0byBhdXRvLWRldGVjdCB0aGUgdHlwZSBvZiByZXNvdXJjZS5cbiAgICogQHBhcmFtIHsqfSBzb3VyY2UgLSBUaGUgc291cmNlIG9iamVjdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHNvdXJjZSBpcyBIVE1MQ2FudmFzRWxlbWVudCBvciBPZmZzY3JlZW5DYW52YXNcbiAgICovXG4gIHN0YXRpYyB0ZXN0KHNvdXJjZSkge1xuICAgIGNvbnN0IHsgT2Zmc2NyZWVuQ2FudmFzIH0gPSBnbG9iYWxUaGlzO1xuICAgIHJldHVybiBPZmZzY3JlZW5DYW52YXMgJiYgc291cmNlIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzID8gITAgOiBnbG9iYWxUaGlzLkhUTUxDYW52YXNFbGVtZW50ICYmIHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50O1xuICB9XG59XG5leHBvcnRzLkNhbnZhc1Jlc291cmNlID0gQ2FudmFzUmVzb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNSZXNvdXJjZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCJAcGl4aS9jb25zdGFudHNcIiksIEFic3RyYWN0TXVsdGlSZXNvdXJjZSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0TXVsdGlSZXNvdXJjZS5qc1wiKTtcbmNvbnN0IF9DdWJlUmVzb3VyY2UgPSBjbGFzcyBfQ3ViZVJlc291cmNlMiBleHRlbmRzIEFic3RyYWN0TXVsdGlSZXNvdXJjZS5BYnN0cmFjdE11bHRpUmVzb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmd8UElYSS5SZXNvdXJjZT59IFtzb3VyY2VdIC0gQ29sbGVjdGlvbiBvZiBVUkxzIG9yIHJlc291cmNlc1xuICAgKiAgICAgICAgdG8gdXNlIGFzIHRoZSBzaWRlcyBvZiB0aGUgY3ViZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBJbWFnZVJlc291cmNlIG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoXSAtIFdpZHRoIG9mIHJlc291cmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIC0gSGVpZ2h0IG9mIHJlc291cmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5hdXRvTG9hZD10cnVlXSAtIFdoZXRoZXIgdG8gYXV0by1sb2FkIHJlc291cmNlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGlua0Jhc2VUZXh0dXJlPXRydWVdIC0gSW4gY2FzZSBCYXNlVGV4dHVyZXMgYXJlIHN1cHBsaWVkLFxuICAgKiAgIHdoZXRoZXIgdG8gY29weSB0aGVtIG9yIHVzZVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBhdXRvTG9hZCwgbGlua0Jhc2VUZXh0dXJlIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChzb3VyY2UgJiYgc291cmNlLmxlbmd0aCAhPT0gX0N1YmVSZXNvdXJjZTIuU0lERVMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbGVuZ3RoLiBHb3QgJHtzb3VyY2UubGVuZ3RofSwgZXhwZWN0ZWQgNmApO1xuICAgIHN1cGVyKDYsIHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9DdWJlUmVzb3VyY2UyLlNJREVTOyBpKyspXG4gICAgICB0aGlzLml0ZW1zW2ldLnRhcmdldCA9IGNvbnN0YW50cy5UQVJHRVRTLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGk7XG4gICAgdGhpcy5saW5rQmFzZVRleHR1cmUgPSBsaW5rQmFzZVRleHR1cmUgIT09ICExLCBzb3VyY2UgJiYgdGhpcy5pbml0RnJvbUFycmF5KHNvdXJjZSwgb3B0aW9ucyksIGF1dG9Mb2FkICE9PSAhMSAmJiB0aGlzLmxvYWQoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGJpbmRpbmcuXG4gICAqIEBwYXJhbSBiYXNlVGV4dHVyZSAtIHBhcmVudCBiYXNlIHRleHR1cmVcbiAgICovXG4gIGJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICBzdXBlci5iaW5kKGJhc2VUZXh0dXJlKSwgYmFzZVRleHR1cmUudGFyZ2V0ID0gY29uc3RhbnRzLlRBUkdFVFMuVEVYVFVSRV9DVUJFX01BUDtcbiAgfVxuICBhZGRCYXNlVGV4dHVyZUF0KGJhc2VUZXh0dXJlLCBpbmRleCwgbGlua0Jhc2VUZXh0dXJlKSB7XG4gICAgaWYgKGxpbmtCYXNlVGV4dHVyZSA9PT0gdm9pZCAwICYmIChsaW5rQmFzZVRleHR1cmUgPSB0aGlzLmxpbmtCYXNlVGV4dHVyZSksICF0aGlzLml0ZW1zW2luZGV4XSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5kZXggJHtpbmRleH0gaXMgb3V0IG9mIGJvdW5kc2ApO1xuICAgIGlmICghdGhpcy5saW5rQmFzZVRleHR1cmUgfHwgYmFzZVRleHR1cmUucGFyZW50VGV4dHVyZUFycmF5IHx8IE9iamVjdC5rZXlzKGJhc2VUZXh0dXJlLl9nbFRleHR1cmVzKS5sZW5ndGggPiAwKVxuICAgICAgaWYgKGJhc2VUZXh0dXJlLnJlc291cmNlKVxuICAgICAgICB0aGlzLmFkZFJlc291cmNlQXQoYmFzZVRleHR1cmUucmVzb3VyY2UsIGluZGV4KTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3ViZVJlc291cmNlIGRvZXMgbm90IHN1cHBvcnQgY29weWluZyBvZiByZW5kZXJUZXh0dXJlLlwiKTtcbiAgICBlbHNlXG4gICAgICBiYXNlVGV4dHVyZS50YXJnZXQgPSBjb25zdGFudHMuVEFSR0VUUy5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpbmRleCwgYmFzZVRleHR1cmUucGFyZW50VGV4dHVyZUFycmF5ID0gdGhpcy5iYXNlVGV4dHVyZSwgdGhpcy5pdGVtc1tpbmRleF0gPSBiYXNlVGV4dHVyZTtcbiAgICByZXR1cm4gYmFzZVRleHR1cmUudmFsaWQgJiYgIXRoaXMudmFsaWQgJiYgdGhpcy5yZXNpemUoYmFzZVRleHR1cmUucmVhbFdpZHRoLCBiYXNlVGV4dHVyZS5yZWFsSGVpZ2h0KSwgdGhpcy5pdGVtc1tpbmRleF0gPSBiYXNlVGV4dHVyZSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogVXBsb2FkIHRoZSByZXNvdXJjZVxuICAgKiBAcGFyYW0gcmVuZGVyZXJcbiAgICogQHBhcmFtIF9iYXNlVGV4dHVyZVxuICAgKiBAcGFyYW0gZ2xUZXh0dXJlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlzIHN1Y2Nlc3NcbiAgICovXG4gIHVwbG9hZChyZW5kZXJlciwgX2Jhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBjb25zdCBkaXJ0eSA9IHRoaXMuaXRlbURpcnR5SWRzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX0N1YmVSZXNvdXJjZTIuU0lERVM7IGkrKykge1xuICAgICAgY29uc3Qgc2lkZSA9IHRoaXMuaXRlbXNbaV07XG4gICAgICAoZGlydHlbaV0gPCBzaWRlLmRpcnR5SWQgfHwgZ2xUZXh0dXJlLmRpcnR5SWQgPCBfYmFzZVRleHR1cmUuZGlydHlJZCkgJiYgKHNpZGUudmFsaWQgJiYgc2lkZS5yZXNvdXJjZSA/IChzaWRlLnJlc291cmNlLnVwbG9hZChyZW5kZXJlciwgc2lkZSwgZ2xUZXh0dXJlKSwgZGlydHlbaV0gPSBzaWRlLmRpcnR5SWQpIDogZGlydHlbaV0gPCAtMSAmJiAocmVuZGVyZXIuZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgc2lkZS50YXJnZXQsXG4gICAgICAgIDAsXG4gICAgICAgIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgX2Jhc2VUZXh0dXJlLnJlYWxXaWR0aCxcbiAgICAgICAgX2Jhc2VUZXh0dXJlLnJlYWxIZWlnaHQsXG4gICAgICAgIDAsXG4gICAgICAgIF9iYXNlVGV4dHVyZS5mb3JtYXQsXG4gICAgICAgIGdsVGV4dHVyZS50eXBlLFxuICAgICAgICBudWxsXG4gICAgICApLCBkaXJ0eVtpXSA9IC0xKSk7XG4gICAgfVxuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogVXNlZCB0byBhdXRvLWRldGVjdCB0aGUgdHlwZSBvZiByZXNvdXJjZS5cbiAgICogQHBhcmFtIHsqfSBzb3VyY2UgLSBUaGUgc291cmNlIG9iamVjdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHNvdXJjZSBpcyBhbiBhcnJheSBvZiA2IGVsZW1lbnRzXG4gICAqL1xuICBzdGF0aWMgdGVzdChzb3VyY2UpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShzb3VyY2UpICYmIHNvdXJjZS5sZW5ndGggPT09IF9DdWJlUmVzb3VyY2UyLlNJREVTO1xuICB9XG59O1xuX0N1YmVSZXNvdXJjZS5TSURFUyA9IDY7XG5sZXQgQ3ViZVJlc291cmNlID0gX0N1YmVSZXNvdXJjZTtcbmV4cG9ydHMuQ3ViZVJlc291cmNlID0gQ3ViZVJlc291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3ViZVJlc291cmNlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKSwgc2V0dGluZ3MgPSByZXF1aXJlKFwiQHBpeGkvc2V0dGluZ3NcIiksIEJhc2VJbWFnZVJlc291cmNlID0gcmVxdWlyZShcIi4vQmFzZUltYWdlUmVzb3VyY2UuanNcIik7XG5jbGFzcyBJbWFnZUJpdG1hcFJlc291cmNlIGV4dGVuZHMgQmFzZUltYWdlUmVzb3VyY2UuQmFzZUltYWdlUmVzb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHNvdXJjZSAtIEltYWdlQml0bWFwIG9yIFVSTCB0byB1c2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byB1c2UuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgYmFzZVNvdXJjZSwgdXJsLCBvd25zSW1hZ2VCaXRtYXA7XG4gICAgdHlwZW9mIHNvdXJjZSA9PSBcInN0cmluZ1wiID8gKGJhc2VTb3VyY2UgPSBJbWFnZUJpdG1hcFJlc291cmNlLkVNUFRZLCB1cmwgPSBzb3VyY2UsIG93bnNJbWFnZUJpdG1hcCA9ICEwKSA6IChiYXNlU291cmNlID0gc291cmNlLCB1cmwgPSBudWxsLCBvd25zSW1hZ2VCaXRtYXAgPSAhMSksIHN1cGVyKGJhc2VTb3VyY2UpLCB0aGlzLnVybCA9IHVybCwgdGhpcy5jcm9zc09yaWdpbiA9IG9wdGlvbnMuY3Jvc3NPcmlnaW4gPz8gITAsIHRoaXMuYWxwaGFNb2RlID0gdHlwZW9mIG9wdGlvbnMuYWxwaGFNb2RlID09IFwibnVtYmVyXCIgPyBvcHRpb25zLmFscGhhTW9kZSA6IG51bGwsIHRoaXMub3duc0ltYWdlQml0bWFwID0gb3B0aW9ucy5vd25zSW1hZ2VCaXRtYXAgPz8gb3duc0ltYWdlQml0bWFwLCB0aGlzLl9sb2FkID0gbnVsbCwgb3B0aW9ucy5hdXRvTG9hZCAhPT0gITEgJiYgdGhpcy5sb2FkKCk7XG4gIH1cbiAgbG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZCA/IHRoaXMuX2xvYWQgOiAodGhpcy5fbG9hZCA9IG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLnVybCA9PT0gbnVsbCkge1xuICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNldHRpbmdzLnNldHRpbmdzLkFEQVBURVIuZmV0Y2godGhpcy51cmwsIHtcbiAgICAgICAgICBtb2RlOiB0aGlzLmNyb3NzT3JpZ2luID8gXCJjb3JzXCIgOiBcIm5vLWNvcnNcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaW1hZ2VCbG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlQmxvYiwge1xuICAgICAgICAgIHByZW11bHRpcGx5QWxwaGE6IHRoaXMuYWxwaGFNb2RlID09PSBudWxsIHx8IHRoaXMuYWxwaGFNb2RlID09PSBjb25zdGFudHMuQUxQSEFfTU9ERVMuVU5QQUNLID8gXCJwcmVtdWx0aXBseVwiIDogXCJub25lXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgIGltYWdlQml0bWFwLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc291cmNlID0gaW1hZ2VCaXRtYXAsIHRoaXMudXBkYXRlKCksIHJlc29sdmUodGhpcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJlamVjdChlKSwgdGhpcy5vbkVycm9yLmVtaXQoZSk7XG4gICAgICB9XG4gICAgfSksIHRoaXMuX2xvYWQpO1xuICB9XG4gIC8qKlxuICAgKiBVcGxvYWQgdGhlIGltYWdlIGJpdG1hcCByZXNvdXJjZSB0byBHUFUuXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIFJlbmRlcmVyIHRvIHVwbG9hZCB0b1xuICAgKiBAcGFyYW0gYmFzZVRleHR1cmUgLSBCYXNlVGV4dHVyZSBmb3IgdGhpcyByZXNvdXJjZVxuICAgKiBAcGFyYW0gZ2xUZXh0dXJlIC0gR0xUZXh0dXJlIHRvIHVzZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpcyBzdWNjZXNzXG4gICAqL1xuICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCA/ICh0eXBlb2YgdGhpcy5hbHBoYU1vZGUgPT0gXCJudW1iZXJcIiAmJiAoYmFzZVRleHR1cmUuYWxwaGFNb2RlID0gdGhpcy5hbHBoYU1vZGUpLCBzdXBlci51cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpKSA6ICh0aGlzLmxvYWQoKSwgITEpO1xuICB9XG4gIC8qKiBEZXN0cm95cyB0aGlzIHJlc291cmNlLiAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMub3duc0ltYWdlQml0bWFwICYmIHRoaXMuc291cmNlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAgJiYgdGhpcy5zb3VyY2UuY2xvc2UoKSwgc3VwZXIuZGlzcG9zZSgpLCB0aGlzLl9sb2FkID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVXNlZCB0byBhdXRvLWRldGVjdCB0aGUgdHlwZSBvZiByZXNvdXJjZS5cbiAgICogQHBhcmFtIHsqfSBzb3VyY2UgLSBUaGUgc291cmNlIG9iamVjdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGN1cnJlbnQgZW52aXJvbm1lbnQgc3VwcG9ydCBJbWFnZUJpdG1hcCwgYW5kIHNvdXJjZSBpcyBzdHJpbmcgb3IgSW1hZ2VCaXRtYXBcbiAgICovXG4gIHN0YXRpYyB0ZXN0KHNvdXJjZSkge1xuICAgIHJldHVybiAhIWdsb2JhbFRoaXMuY3JlYXRlSW1hZ2VCaXRtYXAgJiYgdHlwZW9mIEltYWdlQml0bWFwIDwgXCJ1XCIgJiYgKHR5cGVvZiBzb3VyY2UgPT0gXCJzdHJpbmdcIiB8fCBzb3VyY2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCk7XG4gIH1cbiAgLyoqXG4gICAqIEltYWdlQml0bWFwIGNhbm5vdCBiZSBjcmVhdGVkIHN5bmNocm9ub3VzbHksIHNvIGEgZW1wdHkgcGxhY2Vob2xkZXIgY2FudmFzIGlzIG5lZWRlZCB3aGVuIGxvYWRpbmcgZnJvbSBVUkxzLlxuICAgKiBPbmx5IGZvciBpbnRlcm5hbCB1c2FnZS5cbiAgICogQHJldHVybnMgVGhlIGNhY2hlZCBwbGFjZWhvbGRlciBjYW52YXMuXG4gICAqL1xuICBzdGF0aWMgZ2V0IEVNUFRZKCkge1xuICAgIHJldHVybiBJbWFnZUJpdG1hcFJlc291cmNlLl9FTVBUWSA9IEltYWdlQml0bWFwUmVzb3VyY2UuX0VNUFRZID8/IHNldHRpbmdzLnNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKDAsIDApLCBJbWFnZUJpdG1hcFJlc291cmNlLl9FTVBUWTtcbiAgfVxufVxuZXhwb3J0cy5JbWFnZUJpdG1hcFJlc291cmNlID0gSW1hZ2VCaXRtYXBSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltYWdlQml0bWFwUmVzb3VyY2UuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiQHBpeGkvY29uc3RhbnRzXCIpLCBzZXR0aW5ncyA9IHJlcXVpcmUoXCJAcGl4aS9zZXR0aW5nc1wiKSwgQmFzZUltYWdlUmVzb3VyY2UgPSByZXF1aXJlKFwiLi9CYXNlSW1hZ2VSZXNvdXJjZS5qc1wiKTtcbmNsYXNzIEltYWdlUmVzb3VyY2UgZXh0ZW5kcyBCYXNlSW1hZ2VSZXNvdXJjZS5CYXNlSW1hZ2VSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gc291cmNlIC0gaW1hZ2Ugc291cmNlIG9yIFVSTFxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9Mb2FkPXRydWVdIC0gc3RhcnQgbG9hZGluZyBwcm9jZXNzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3JlYXRlQml0bWFwPVBJWEkuc2V0dGluZ3MuQ1JFQVRFX0lNQUdFX0JJVE1BUF0gLSB3aGV0aGVyIGl0cyByZXF1aXJlZCB0byBjcmVhdGVcbiAgICogICAgICAgIGEgYml0bWFwIGJlZm9yZSB1cGxvYWRcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc29yaWdpbj10cnVlXSAtIExvYWQgaW1hZ2UgdXNpbmcgY3Jvc3Mgb3JpZ2luXG4gICAqIEBwYXJhbSB7UElYSS5BTFBIQV9NT0RFU30gW29wdGlvbnMuYWxwaGFNb2RlPVBJWEkuQUxQSEFfTU9ERVMuVU5QQUNLXSAtIFByZW11bHRpcGx5IGltYWdlIGFscGhhIGluIGJpdG1hcFxuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9LCB0eXBlb2Ygc291cmNlID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgICAgQmFzZUltYWdlUmVzb3VyY2UuQmFzZUltYWdlUmVzb3VyY2UuY3Jvc3NPcmlnaW4oaW1hZ2VFbGVtZW50LCBzb3VyY2UsIG9wdGlvbnMuY3Jvc3NvcmlnaW4pLCBpbWFnZUVsZW1lbnQuc3JjID0gc291cmNlLCBzb3VyY2UgPSBpbWFnZUVsZW1lbnQ7XG4gICAgfVxuICAgIHN1cGVyKHNvdXJjZSksICFzb3VyY2UuY29tcGxldGUgJiYgdGhpcy5fd2lkdGggJiYgdGhpcy5faGVpZ2h0ICYmICh0aGlzLl93aWR0aCA9IDAsIHRoaXMuX2hlaWdodCA9IDApLCB0aGlzLnVybCA9IHNvdXJjZS5zcmMsIHRoaXMuX3Byb2Nlc3MgPSBudWxsLCB0aGlzLnByZXNlcnZlQml0bWFwID0gITEsIHRoaXMuY3JlYXRlQml0bWFwID0gKG9wdGlvbnMuY3JlYXRlQml0bWFwID8/IHNldHRpbmdzLnNldHRpbmdzLkNSRUFURV9JTUFHRV9CSVRNQVApICYmICEhZ2xvYmFsVGhpcy5jcmVhdGVJbWFnZUJpdG1hcCwgdGhpcy5hbHBoYU1vZGUgPSB0eXBlb2Ygb3B0aW9ucy5hbHBoYU1vZGUgPT0gXCJudW1iZXJcIiA/IG9wdGlvbnMuYWxwaGFNb2RlIDogbnVsbCwgdGhpcy5iaXRtYXAgPSBudWxsLCB0aGlzLl9sb2FkID0gbnVsbCwgb3B0aW9ucy5hdXRvTG9hZCAhPT0gITEgJiYgdGhpcy5sb2FkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHdoZW4gaW1hZ2Ugd2lsbCBiZSBsb2FkZWQgYW5kIHByb2Nlc3NlZC5cbiAgICogQHBhcmFtIGNyZWF0ZUJpdG1hcCAtIHdoZXRoZXIgcHJvY2VzcyBpbWFnZSBpbnRvIGJpdG1hcFxuICAgKi9cbiAgbG9hZChjcmVhdGVCaXRtYXApIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZCA/IHRoaXMuX2xvYWQgOiAoY3JlYXRlQml0bWFwICE9PSB2b2lkIDAgJiYgKHRoaXMuY3JlYXRlQml0bWFwID0gY3JlYXRlQml0bWFwKSwgdGhpcy5fbG9hZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgdGhpcy51cmwgPSBzb3VyY2Uuc3JjO1xuICAgICAgY29uc3QgY29tcGxldGVkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCB8fCAoc291cmNlLm9ubG9hZCA9IG51bGwsIHNvdXJjZS5vbmVycm9yID0gbnVsbCwgdGhpcy51cGRhdGUoKSwgdGhpcy5fbG9hZCA9IG51bGwsIHRoaXMuY3JlYXRlQml0bWFwID8gcmVzb2x2ZSh0aGlzLnByb2Nlc3MoKSkgOiByZXNvbHZlKHRoaXMpKTtcbiAgICAgIH07XG4gICAgICBzb3VyY2UuY29tcGxldGUgJiYgc291cmNlLnNyYyA/IGNvbXBsZXRlZCgpIDogKHNvdXJjZS5vbmxvYWQgPSBjb21wbGV0ZWQsIHNvdXJjZS5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHJlamVjdChldmVudCksIHRoaXMub25FcnJvci5lbWl0KGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0pLCB0aGlzLl9sb2FkKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gd2UgbmVlZCB0byBjb252ZXJ0IGltYWdlIGludG8gQml0bWFwSW1hZ2UuXG4gICAqIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIHJlYWwgcHJvbWlzZSBpcyBjYWNoZWQgaW5zaWRlLlxuICAgKiBAcmV0dXJucyAtIENhY2hlZCBwcm9taXNlIHRvIGZpbGwgdGhhdCBiaXRtYXBcbiAgICovXG4gIHByb2Nlc3MoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3MgIT09IG51bGwpXG4gICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcztcbiAgICBpZiAodGhpcy5iaXRtYXAgIT09IG51bGwgfHwgIWdsb2JhbFRoaXMuY3JlYXRlSW1hZ2VCaXRtYXApXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIGNvbnN0IGNyZWF0ZUltYWdlQml0bWFwID0gZ2xvYmFsVGhpcy5jcmVhdGVJbWFnZUJpdG1hcCwgY29ycyA9ICFzb3VyY2UuY3Jvc3NPcmlnaW4gfHwgc291cmNlLmNyb3NzT3JpZ2luID09PSBcImFub255bW91c1wiO1xuICAgIHJldHVybiB0aGlzLl9wcm9jZXNzID0gZmV0Y2goXG4gICAgICBzb3VyY2Uuc3JjLFxuICAgICAge1xuICAgICAgICBtb2RlOiBjb3JzID8gXCJjb3JzXCIgOiBcIm5vLWNvcnNcIlxuICAgICAgfVxuICAgICkudGhlbigocikgPT4gci5ibG9iKCkpLnRoZW4oKGJsb2IpID0+IGNyZWF0ZUltYWdlQml0bWFwKFxuICAgICAgYmxvYixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgc291cmNlLndpZHRoLFxuICAgICAgc291cmNlLmhlaWdodCxcbiAgICAgIHtcbiAgICAgICAgcHJlbXVsdGlwbHlBbHBoYTogdGhpcy5hbHBoYU1vZGUgPT09IG51bGwgfHwgdGhpcy5hbHBoYU1vZGUgPT09IGNvbnN0YW50cy5BTFBIQV9NT0RFUy5VTlBBQ0sgPyBcInByZW11bHRpcGx5XCIgOiBcIm5vbmVcIlxuICAgICAgfVxuICAgICkpLnRoZW4oKGJpdG1hcCkgPT4gdGhpcy5kZXN0cm95ZWQgPyBQcm9taXNlLnJlamVjdCgpIDogKHRoaXMuYml0bWFwID0gYml0bWFwLCB0aGlzLnVwZGF0ZSgpLCB0aGlzLl9wcm9jZXNzID0gbnVsbCwgUHJvbWlzZS5yZXNvbHZlKHRoaXMpKSksIHRoaXMuX3Byb2Nlc3M7XG4gIH1cbiAgLyoqXG4gICAqIFVwbG9hZCB0aGUgaW1hZ2UgcmVzb3VyY2UgdG8gR1BVLlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBSZW5kZXJlciB0byB1cGxvYWQgdG9cbiAgICogQHBhcmFtIGJhc2VUZXh0dXJlIC0gQmFzZVRleHR1cmUgZm9yIHRoaXMgcmVzb3VyY2VcbiAgICogQHBhcmFtIGdsVGV4dHVyZSAtIEdMVGV4dHVyZSB0byB1c2VcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaXMgc3VjY2Vzc1xuICAgKi9cbiAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmFscGhhTW9kZSA9PSBcIm51bWJlclwiICYmIChiYXNlVGV4dHVyZS5hbHBoYU1vZGUgPSB0aGlzLmFscGhhTW9kZSksICF0aGlzLmNyZWF0ZUJpdG1hcClcbiAgICAgIHJldHVybiBzdXBlci51cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpO1xuICAgIGlmICghdGhpcy5iaXRtYXAgJiYgKHRoaXMucHJvY2VzcygpLCAhdGhpcy5iaXRtYXApKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmIChzdXBlci51cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUsIHRoaXMuYml0bWFwKSwgIXRoaXMucHJlc2VydmVCaXRtYXApIHtcbiAgICAgIGxldCBmbGFnID0gITA7XG4gICAgICBjb25zdCBnbFRleHR1cmVzID0gYmFzZVRleHR1cmUuX2dsVGV4dHVyZXM7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBnbFRleHR1cmVzKSB7XG4gICAgICAgIGNvbnN0IG90aGVyVGV4ID0gZ2xUZXh0dXJlc1trZXldO1xuICAgICAgICBpZiAob3RoZXJUZXggIT09IGdsVGV4dHVyZSAmJiBvdGhlclRleC5kaXJ0eUlkICE9PSBiYXNlVGV4dHVyZS5kaXJ0eUlkKSB7XG4gICAgICAgICAgZmxhZyA9ICExO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbGFnICYmICh0aGlzLmJpdG1hcC5jbG9zZSAmJiB0aGlzLmJpdG1hcC5jbG9zZSgpLCB0aGlzLmJpdG1hcCA9IG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoaXMgcmVzb3VyY2UuICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5zb3VyY2Uub25sb2FkID0gbnVsbCwgdGhpcy5zb3VyY2Uub25lcnJvciA9IG51bGwsIHN1cGVyLmRpc3Bvc2UoKSwgdGhpcy5iaXRtYXAgJiYgKHRoaXMuYml0bWFwLmNsb3NlKCksIHRoaXMuYml0bWFwID0gbnVsbCksIHRoaXMuX3Byb2Nlc3MgPSBudWxsLCB0aGlzLl9sb2FkID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVXNlZCB0byBhdXRvLWRldGVjdCB0aGUgdHlwZSBvZiByZXNvdXJjZS5cbiAgICogQHBhcmFtIHsqfSBzb3VyY2UgLSBUaGUgc291cmNlIG9iamVjdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGN1cnJlbnQgZW52aXJvbm1lbnQgc3VwcG9ydCBIVE1MSW1hZ2VFbGVtZW50LCBhbmQgc291cmNlIGlzIHN0cmluZyBvciBIVE1MSW1hZ2VFbGVtZW50XG4gICAqL1xuICBzdGF0aWMgdGVzdChzb3VyY2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgPCBcInVcIiAmJiAodHlwZW9mIHNvdXJjZSA9PSBcInN0cmluZ1wiIHx8IHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpO1xuICB9XG59XG5leHBvcnRzLkltYWdlUmVzb3VyY2UgPSBJbWFnZVJlc291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1hZ2VSZXNvdXJjZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJ1bm5lciA9IHJlcXVpcmUoXCJAcGl4aS9ydW5uZXJcIik7XG5jbGFzcyBSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiB0aGUgcmVzb3VyY2VcbiAgICogQHBhcmFtIGhlaWdodCAtIEhlaWdodCBvZiB0aGUgcmVzb3VyY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdpZHRoID0gMCwgaGVpZ2h0ID0gMCkge1xuICAgIHRoaXMuX3dpZHRoID0gd2lkdGgsIHRoaXMuX2hlaWdodCA9IGhlaWdodCwgdGhpcy5kZXN0cm95ZWQgPSAhMSwgdGhpcy5pbnRlcm5hbCA9ICExLCB0aGlzLm9uUmVzaXplID0gbmV3IHJ1bm5lci5SdW5uZXIoXCJzZXRSZWFsU2l6ZVwiKSwgdGhpcy5vblVwZGF0ZSA9IG5ldyBydW5uZXIuUnVubmVyKFwidXBkYXRlXCIpLCB0aGlzLm9uRXJyb3IgPSBuZXcgcnVubmVyLlJ1bm5lcihcIm9uRXJyb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmQgdG8gYSBwYXJlbnQgQmFzZVRleHR1cmVcbiAgICogQHBhcmFtIGJhc2VUZXh0dXJlIC0gUGFyZW50IHRleHR1cmVcbiAgICovXG4gIGJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICB0aGlzLm9uUmVzaXplLmFkZChiYXNlVGV4dHVyZSksIHRoaXMub25VcGRhdGUuYWRkKGJhc2VUZXh0dXJlKSwgdGhpcy5vbkVycm9yLmFkZChiYXNlVGV4dHVyZSksICh0aGlzLl93aWR0aCB8fCB0aGlzLl9oZWlnaHQpICYmIHRoaXMub25SZXNpemUuZW1pdCh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogVW5iaW5kIHRvIGEgcGFyZW50IEJhc2VUZXh0dXJlXG4gICAqIEBwYXJhbSBiYXNlVGV4dHVyZSAtIFBhcmVudCB0ZXh0dXJlXG4gICAqL1xuICB1bmJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICB0aGlzLm9uUmVzaXplLnJlbW92ZShiYXNlVGV4dHVyZSksIHRoaXMub25VcGRhdGUucmVtb3ZlKGJhc2VUZXh0dXJlKSwgdGhpcy5vbkVycm9yLnJlbW92ZShiYXNlVGV4dHVyZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRyaWdnZXIgYSByZXNpemUgZXZlbnRcbiAgICogQHBhcmFtIHdpZHRoIC0gWCBkaW1lbnNpb25cbiAgICogQHBhcmFtIGhlaWdodCAtIFkgZGltZW5zaW9uXG4gICAqL1xuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICh3aWR0aCAhPT0gdGhpcy5fd2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLl9oZWlnaHQpICYmICh0aGlzLl93aWR0aCA9IHdpZHRoLCB0aGlzLl9oZWlnaHQgPSBoZWlnaHQsIHRoaXMub25SZXNpemUuZW1pdCh3aWR0aCwgaGVpZ2h0KSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhcyBiZWVuIHZhbGlkYXRlZFxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB2YWxpZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl93aWR0aCAmJiAhIXRoaXMuX2hlaWdodDtcbiAgfVxuICAvKiogSGFzIGJlZW4gdXBkYXRlZCB0cmlnZ2VyIGV2ZW50LiAqL1xuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgfHwgdGhpcy5vblVwZGF0ZS5lbWl0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gdG8gc3RhcnQgcHJlbG9hZGluZyBhIHJlc291cmNlXG4gICAqIG9yIGRvIGFueSBvdGhlciBwcmVwYXJlIHN0ZXAuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybnMgSGFuZGxlIHRoZSB2YWxpZGF0ZSBldmVudFxuICAgKi9cbiAgbG9hZCgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGhlIHJlc291cmNlLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBoZWlnaHQgb2YgdGhlIHJlc291cmNlLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBzdHlsZSwgb3B0aW9uYWwgdG8gb3ZlcnJpZGVcbiAgICogQHBhcmFtIF9yZW5kZXJlciAtIHllYWgsIHJlbmRlcmVyIVxuICAgKiBAcGFyYW0gX2Jhc2VUZXh0dXJlIC0gdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIF9nbFRleHR1cmUgLSB0ZXh0dXJlIGluc3RhbmNlIGZvciB0aGlzIHdlYmdsIGNvbnRleHRcbiAgICogQHJldHVybnMgLSBgdHJ1ZWAgaXMgc3VjY2Vzc1xuICAgKi9cbiAgc3R5bGUoX3JlbmRlcmVyLCBfYmFzZVRleHR1cmUsIF9nbFRleHR1cmUpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgLyoqIENsZWFuIHVwIGFueXRoaW5nLCB0aGlzIGhhcHBlbnMgd2hlbiBkZXN0cm95aW5nIGlzIHJlYWR5LiAqL1xuICBkaXNwb3NlKCkge1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHdoZW4gZGVzdHJveWluZyByZXNvdXJjZSwgdW5iaW5kIGFueSBCYXNlVGV4dHVyZSBvYmplY3RcbiAgICogYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QsIGFzIHJlZmVyZW5jZSBjb3VudHMgYXJlIG1haW50YWluZWRcbiAgICogaW50ZXJuYWxseS5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgfHwgKHRoaXMuZGVzdHJveWVkID0gITAsIHRoaXMuZGlzcG9zZSgpLCB0aGlzLm9uRXJyb3IucmVtb3ZlQWxsKCksIHRoaXMub25FcnJvciA9IG51bGwsIHRoaXMub25SZXNpemUucmVtb3ZlQWxsKCksIHRoaXMub25SZXNpemUgPSBudWxsLCB0aGlzLm9uVXBkYXRlLnJlbW92ZUFsbCgpLCB0aGlzLm9uVXBkYXRlID0gbnVsbCk7XG4gIH1cbiAgLyoqXG4gICAqIEFic3RyYWN0LCB1c2VkIHRvIGF1dG8tZGV0ZWN0IHJlc291cmNlIHR5cGUuXG4gICAqIEBwYXJhbSB7Kn0gX3NvdXJjZSAtIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfZXh0ZW5zaW9uIC0gVGhlIGV4dGVuc2lvbiBvZiBzb3VyY2UsIGlmIHNldFxuICAgKi9cbiAgc3RhdGljIHRlc3QoX3NvdXJjZSwgX2V4dGVuc2lvbikge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZXhwb3J0cy5SZXNvdXJjZSA9IFJlc291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVzb3VyY2UuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBzZXR0aW5ncyA9IHJlcXVpcmUoXCJAcGl4aS9zZXR0aW5nc1wiKSwgdXRpbHMgPSByZXF1aXJlKFwiQHBpeGkvdXRpbHNcIiksIEJhc2VJbWFnZVJlc291cmNlID0gcmVxdWlyZShcIi4vQmFzZUltYWdlUmVzb3VyY2UuanNcIik7XG5jb25zdCBfU1ZHUmVzb3VyY2UgPSBjbGFzcyBfU1ZHUmVzb3VyY2UyIGV4dGVuZHMgQmFzZUltYWdlUmVzb3VyY2UuQmFzZUltYWdlUmVzb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHNvdXJjZUJhc2U2NCAtIEJhc2U2NCBlbmNvZGVkIFNWRyBlbGVtZW50IG9yIFVSTCBmb3IgU1ZHIGZpbGUuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIHRvIHVzZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2NhbGU9MV0gLSBTY2FsZSB0byBhcHBseSB0byBTVkcuIE92ZXJyaWRkZW4gYnkuLi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoXSAtIFJhc3Rlcml6ZSBTVkcgdGhpcyB3aWRlLiBBc3BlY3QgcmF0aW8gcHJlc2VydmVkIGlmIGhlaWdodCBub3Qgc3BlY2lmaWVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSAtIFJhc3Rlcml6ZSBTVkcgdGhpcyBoaWdoLiBBc3BlY3QgcmF0aW8gcHJlc2VydmVkIGlmIHdpZHRoIG5vdCBzcGVjaWZpZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0b0xvYWQ9dHJ1ZV0gLSBTdGFydCBsb2FkaW5nIHJpZ2h0IGF3YXkuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VCYXNlNjQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fSwgc3VwZXIoc2V0dGluZ3Muc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoKSksIHRoaXMuX3dpZHRoID0gMCwgdGhpcy5faGVpZ2h0ID0gMCwgdGhpcy5zdmcgPSBzb3VyY2VCYXNlNjQsIHRoaXMuc2NhbGUgPSBvcHRpb25zLnNjYWxlIHx8IDEsIHRoaXMuX292ZXJyaWRlV2lkdGggPSBvcHRpb25zLndpZHRoLCB0aGlzLl9vdmVycmlkZUhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0LCB0aGlzLl9yZXNvbHZlID0gbnVsbCwgdGhpcy5fY3Jvc3NvcmlnaW4gPSBvcHRpb25zLmNyb3Nzb3JpZ2luLCB0aGlzLl9sb2FkID0gbnVsbCwgb3B0aW9ucy5hdXRvTG9hZCAhPT0gITEgJiYgdGhpcy5sb2FkKCk7XG4gIH1cbiAgbG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZCA/IHRoaXMuX2xvYWQgOiAodGhpcy5fbG9hZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAodGhpcy5fcmVzb2x2ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGUoKSwgcmVzb2x2ZSh0aGlzKTtcbiAgICAgIH0sIF9TVkdSZXNvdXJjZTIuU1ZHX1hNTC50ZXN0KHRoaXMuc3ZnLnRyaW0oKSkpIHtcbiAgICAgICAgaWYgKCFidG9hKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgYmFzZTY0IGNvbnZlcnNpb25zLlwiKTtcbiAgICAgICAgdGhpcy5zdmcgPSBgZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwke2J0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuc3ZnKSkpfWA7XG4gICAgICB9XG4gICAgICB0aGlzLl9sb2FkU3ZnKCk7XG4gICAgfSksIHRoaXMuX2xvYWQpO1xuICB9XG4gIC8qKiBMb2FkcyBhbiBTVkcgaW1hZ2UgZnJvbSBgaW1hZ2VVcmxgIG9yIGBkYXRhIFVSTGAuICovXG4gIF9sb2FkU3ZnKCkge1xuICAgIGNvbnN0IHRlbXBJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIEJhc2VJbWFnZVJlc291cmNlLkJhc2VJbWFnZVJlc291cmNlLmNyb3NzT3JpZ2luKHRlbXBJbWFnZSwgdGhpcy5zdmcsIHRoaXMuX2Nyb3Nzb3JpZ2luKSwgdGVtcEltYWdlLnNyYyA9IHRoaXMuc3ZnLCB0ZW1wSW1hZ2Uub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZSAmJiAodGVtcEltYWdlLm9uZXJyb3IgPSBudWxsLCB0aGlzLm9uRXJyb3IuZW1pdChldmVudCkpO1xuICAgIH0sIHRlbXBJbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3Jlc29sdmUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHN2Z1dpZHRoID0gdGVtcEltYWdlLndpZHRoLCBzdmdIZWlnaHQgPSB0ZW1wSW1hZ2UuaGVpZ2h0O1xuICAgICAgaWYgKCFzdmdXaWR0aCB8fCAhc3ZnSGVpZ2h0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgU1ZHIGltYWdlIG11c3QgaGF2ZSB3aWR0aCBhbmQgaGVpZ2h0IGRlZmluZWQgKGluIHBpeGVscyksIGNhbnZhcyBBUEkgbmVlZHMgdGhlbS5cIik7XG4gICAgICBsZXQgd2lkdGggPSBzdmdXaWR0aCAqIHRoaXMuc2NhbGUsIGhlaWdodCA9IHN2Z0hlaWdodCAqIHRoaXMuc2NhbGU7XG4gICAgICAodGhpcy5fb3ZlcnJpZGVXaWR0aCB8fCB0aGlzLl9vdmVycmlkZUhlaWdodCkgJiYgKHdpZHRoID0gdGhpcy5fb3ZlcnJpZGVXaWR0aCB8fCB0aGlzLl9vdmVycmlkZUhlaWdodCAvIHN2Z0hlaWdodCAqIHN2Z1dpZHRoLCBoZWlnaHQgPSB0aGlzLl9vdmVycmlkZUhlaWdodCB8fCB0aGlzLl9vdmVycmlkZVdpZHRoIC8gc3ZnV2lkdGggKiBzdmdIZWlnaHQpLCB3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpLCBoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLnNvdXJjZTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoLCBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0LCBjYW52YXMuX3BpeGlJZCA9IGBjYW52YXNfJHt1dGlscy51aWQoKX1gLCBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLmRyYXdJbWFnZSh0ZW1wSW1hZ2UsIDAsIDAsIHN2Z1dpZHRoLCBzdmdIZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpLCB0aGlzLl9yZXNvbHZlKCksIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBzaXplIGZyb20gYW4gc3ZnIHN0cmluZyB1c2luZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICogQHBhcmFtIHN2Z1N0cmluZyAtIGEgc2VyaWFsaXplZCBzdmcgZWxlbWVudFxuICAgKiBAcmV0dXJucyAtIGltYWdlIGV4dGVuc2lvblxuICAgKi9cbiAgc3RhdGljIGdldFNpemUoc3ZnU3RyaW5nKSB7XG4gICAgY29uc3Qgc2l6ZU1hdGNoID0gX1NWR1Jlc291cmNlMi5TVkdfU0laRS5leGVjKHN2Z1N0cmluZyksIHNpemUgPSB7fTtcbiAgICByZXR1cm4gc2l6ZU1hdGNoICYmIChzaXplW3NpemVNYXRjaFsxXV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoc2l6ZU1hdGNoWzNdKSksIHNpemVbc2l6ZU1hdGNoWzVdXSA9IE1hdGgucm91bmQocGFyc2VGbG9hdChzaXplTWF0Y2hbN10pKSksIHNpemU7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZS4gKi9cbiAgZGlzcG9zZSgpIHtcbiAgICBzdXBlci5kaXNwb3NlKCksIHRoaXMuX3Jlc29sdmUgPSBudWxsLCB0aGlzLl9jcm9zc29yaWdpbiA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgdG8gYXV0by1kZXRlY3QgdGhlIHR5cGUgb2YgcmVzb3VyY2UuXG4gICAqIEBwYXJhbSB7Kn0gc291cmNlIC0gVGhlIHNvdXJjZSBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4dGVuc2lvbiAtIFRoZSBleHRlbnNpb24gb2Ygc291cmNlLCBpZiBzZXRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gSWYgdGhlIHNvdXJjZSBpcyBhIFNWRyBzb3VyY2Ugb3IgZGF0YSBmaWxlXG4gICAqL1xuICBzdGF0aWMgdGVzdChzb3VyY2UsIGV4dGVuc2lvbikge1xuICAgIHJldHVybiBleHRlbnNpb24gPT09IFwic3ZnXCIgfHwgdHlwZW9mIHNvdXJjZSA9PSBcInN0cmluZ1wiICYmIHNvdXJjZS5zdGFydHNXaXRoKFwiZGF0YTppbWFnZS9zdmcreG1sXCIpIHx8IHR5cGVvZiBzb3VyY2UgPT0gXCJzdHJpbmdcIiAmJiBfU1ZHUmVzb3VyY2UyLlNWR19YTUwudGVzdChzb3VyY2UpO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxufTtcbl9TVkdSZXNvdXJjZS5TVkdfWE1MID0gL14oPFxcP3htbFteP10rXFw/Pik/XFxzKig8IS0tW14oLS0+KV0qLS0+KT9cXHMqXFw8c3ZnL20sIC8qKlxuKiBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIFNWRyBzaXplLlxuKiBAZXhhbXBsZSAmbHQ7c3ZnIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCImZ3Q7Jmx0Oy9zdmcmZ3Q7XG4qIEByZWFkb25seVxuKi9cbl9TVkdSZXNvdXJjZS5TVkdfU0laRSA9IC88c3ZnW14+XSooPzpcXHMod2lkdGh8aGVpZ2h0KT0oJ3xcIikoXFxkKig/OlxcLlxcZCspPykoPzpweCk/KCd8XCIpKVtePl0qKD86XFxzKHdpZHRofGhlaWdodCk9KCd8XCIpKFxcZCooPzpcXC5cXGQrKT8pKD86cHgpPygnfFwiKSlbXj5dKj4vaTtcbmxldCBTVkdSZXNvdXJjZSA9IF9TVkdSZXNvdXJjZTtcbmV4cG9ydHMuU1ZHUmVzb3VyY2UgPSBTVkdSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNWR1Jlc291cmNlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdGlja2VyID0gcmVxdWlyZShcIkBwaXhpL3RpY2tlclwiKSwgQmFzZUltYWdlUmVzb3VyY2UgPSByZXF1aXJlKFwiLi9CYXNlSW1hZ2VSZXNvdXJjZS5qc1wiKTtcbmNvbnN0IF9WaWRlb1Jlc291cmNlID0gY2xhc3MgX1ZpZGVvUmVzb3VyY2UyIGV4dGVuZHMgQmFzZUltYWdlUmVzb3VyY2UuQmFzZUltYWdlUmVzb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fG9iamVjdHxzdHJpbmd8QXJyYXk8c3RyaW5nfG9iamVjdD59IHNvdXJjZSAtIFZpZGVvIGVsZW1lbnQgdG8gdXNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyB0byB1c2VcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdXRvTG9hZD10cnVlXSAtIFN0YXJ0IGxvYWRpbmcgdGhlIHZpZGVvIGltbWVkaWF0ZWx5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0b1BsYXk9dHJ1ZV0gLSBTdGFydCBwbGF5aW5nIHZpZGVvIGltbWVkaWF0ZWx5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy51cGRhdGVGUFM9MF0gLSBIb3cgbWFueSB0aW1lcyBhIHNlY29uZCB0byB1cGRhdGUgdGhlIHRleHR1cmUgZnJvbSB0aGUgdmlkZW8uXG4gICAqIExlYXZlIGF0IDAgdG8gdXBkYXRlIGF0IGV2ZXJ5IHJlbmRlci5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc29yaWdpbj10cnVlXSAtIExvYWQgaW1hZ2UgdXNpbmcgY3Jvc3Mgb3JpZ2luXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubG9vcD1mYWxzZV0gLSBMb29wcyB0aGUgdmlkZW9cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5tdXRlZD1mYWxzZV0gLSBNdXRlcyB0aGUgdmlkZW8gYXVkaW8sIHVzZWZ1bCBmb3IgYXV0b3BsYXlcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wbGF5c2lubGluZT10cnVlXSAtIFByZXZlbnRzIG9wZW5pbmcgdGhlIHZpZGVvIG9uIG1vYmlsZSBkZXZpY2VzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9IG9wdGlvbnMgfHwge30sICEoc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcbiAgICAgIG9wdGlvbnMuYXV0b0xvYWQgIT09ICExICYmIHZpZGVvRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwcmVsb2FkXCIsIFwiYXV0b1wiKSwgb3B0aW9ucy5wbGF5c2lubGluZSAhPT0gITEgJiYgKHZpZGVvRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ3ZWJraXQtcGxheXNpbmxpbmVcIiwgXCJcIiksIHZpZGVvRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwbGF5c2lubGluZVwiLCBcIlwiKSksIG9wdGlvbnMubXV0ZWQgPT09ICEwICYmICh2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKFwibXV0ZWRcIiwgXCJcIiksIHZpZGVvRWxlbWVudC5tdXRlZCA9ICEwKSwgb3B0aW9ucy5sb29wID09PSAhMCAmJiB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKFwibG9vcFwiLCBcIlwiKSwgb3B0aW9ucy5hdXRvUGxheSAhPT0gITEgJiYgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZShcImF1dG9wbGF5XCIsIFwiXCIpLCB0eXBlb2Ygc291cmNlID09IFwic3RyaW5nXCIgJiYgKHNvdXJjZSA9IFtzb3VyY2VdKTtcbiAgICAgIGNvbnN0IGZpcnN0U3JjID0gc291cmNlWzBdLnNyYyB8fCBzb3VyY2VbMF07XG4gICAgICBCYXNlSW1hZ2VSZXNvdXJjZS5CYXNlSW1hZ2VSZXNvdXJjZS5jcm9zc09yaWdpbih2aWRlb0VsZW1lbnQsIGZpcnN0U3JjLCBvcHRpb25zLmNyb3Nzb3JpZ2luKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIpO1xuICAgICAgICBsZXQgeyBzcmMsIG1pbWUgfSA9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKHNyYyA9IHNyYyB8fCBzb3VyY2VbaV0sIHNyYy5zdGFydHNXaXRoKFwiZGF0YTpcIikpXG4gICAgICAgICAgbWltZSA9IHNyYy5zbGljZSg1LCBzcmMuaW5kZXhPZihcIjtcIikpO1xuICAgICAgICBlbHNlIGlmICghc3JjLnN0YXJ0c1dpdGgoXCJibG9iOlwiKSkge1xuICAgICAgICAgIGNvbnN0IGJhc2VTcmMgPSBzcmMuc3BsaXQoXCI/XCIpLnNoaWZ0KCkudG9Mb3dlckNhc2UoKSwgZXh0ID0gYmFzZVNyYy5zbGljZShiYXNlU3JjLmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xuICAgICAgICAgIG1pbWUgPSBtaW1lIHx8IF9WaWRlb1Jlc291cmNlMi5NSU1FX1RZUEVTW2V4dF0gfHwgYHZpZGVvLyR7ZXh0fWA7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlRWxlbWVudC5zcmMgPSBzcmMsIG1pbWUgJiYgKHNvdXJjZUVsZW1lbnQudHlwZSA9IG1pbWUpLCB2aWRlb0VsZW1lbnQuYXBwZW5kQ2hpbGQoc291cmNlRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBzb3VyY2UgPSB2aWRlb0VsZW1lbnQ7XG4gICAgfVxuICAgIHN1cGVyKHNvdXJjZSksIHRoaXMubm9TdWJJbWFnZSA9ICEwLCB0aGlzLl9hdXRvVXBkYXRlID0gITAsIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSAhMSwgdGhpcy5fdXBkYXRlRlBTID0gb3B0aW9ucy51cGRhdGVGUFMgfHwgMCwgdGhpcy5fbXNUb05leHRVcGRhdGUgPSAwLCB0aGlzLmF1dG9QbGF5ID0gb3B0aW9ucy5hdXRvUGxheSAhPT0gITEsIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2sgPSB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrLmJpbmQodGhpcyksIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUgPSBudWxsLCB0aGlzLl9sb2FkID0gbnVsbCwgdGhpcy5fcmVzb2x2ZSA9IG51bGwsIHRoaXMuX3JlamVjdCA9IG51bGwsIHRoaXMuX29uQ2FuUGxheSA9IHRoaXMuX29uQ2FuUGxheS5iaW5kKHRoaXMpLCB0aGlzLl9vbkVycm9yID0gdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpLCB0aGlzLl9vblBsYXlTdGFydCA9IHRoaXMuX29uUGxheVN0YXJ0LmJpbmQodGhpcyksIHRoaXMuX29uUGxheVN0b3AgPSB0aGlzLl9vblBsYXlTdG9wLmJpbmQodGhpcyksIHRoaXMuX29uU2Vla2VkID0gdGhpcy5fb25TZWVrZWQuYmluZCh0aGlzKSwgb3B0aW9ucy5hdXRvTG9hZCAhPT0gITEgJiYgdGhpcy5sb2FkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRyaWdnZXIgdXBkYXRpbmcgb2YgdGhlIHRleHR1cmUuXG4gICAqIEBwYXJhbSBfZGVsdGFUaW1lIC0gdGltZSBkZWx0YSBzaW5jZSBsYXN0IHRpY2tcbiAgICovXG4gIHVwZGF0ZShfZGVsdGFUaW1lID0gMCkge1xuICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIGlmICh0aGlzLl91cGRhdGVGUFMpIHtcbiAgICAgICAgY29uc3QgZWxhcHNlZE1TID0gdGlja2VyLlRpY2tlci5zaGFyZWQuZWxhcHNlZE1TICogdGhpcy5zb3VyY2UucGxheWJhY2tSYXRlO1xuICAgICAgICB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IE1hdGguZmxvb3IodGhpcy5fbXNUb05leHRVcGRhdGUgLSBlbGFwc2VkTVMpO1xuICAgICAgfVxuICAgICAgKCF0aGlzLl91cGRhdGVGUFMgfHwgdGhpcy5fbXNUb05leHRVcGRhdGUgPD0gMCkgJiYgKHN1cGVyLnVwZGF0ZShcbiAgICAgICAgLyogZGVsdGFUaW1lKi9cbiAgICAgICksIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gdGhpcy5fdXBkYXRlRlBTID8gTWF0aC5mbG9vcigxZTMgLyB0aGlzLl91cGRhdGVGUFMpIDogMCk7XG4gICAgfVxuICB9XG4gIF92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrKCkge1xuICAgIHRoaXMudXBkYXRlKCksIHRoaXMuZGVzdHJveWVkID8gdGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSA9IG51bGwgOiB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlID0gdGhpcy5zb3VyY2UucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayhcbiAgICAgIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBwcmVsb2FkaW5nIHRoZSB2aWRlbyByZXNvdXJjZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEhhbmRsZSB0aGUgdmFsaWRhdGUgZXZlbnRcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuX2xvYWQpXG4gICAgICByZXR1cm4gdGhpcy5fbG9hZDtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICByZXR1cm4gKHNvdXJjZS5yZWFkeVN0YXRlID09PSBzb3VyY2UuSEFWRV9FTk9VR0hfREFUQSB8fCBzb3VyY2UucmVhZHlTdGF0ZSA9PT0gc291cmNlLkhBVkVfRlVUVVJFX0RBVEEpICYmIHNvdXJjZS53aWR0aCAmJiBzb3VyY2UuaGVpZ2h0ICYmIChzb3VyY2UuY29tcGxldGUgPSAhMCksIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwicGxheVwiLCB0aGlzLl9vblBsYXlTdGFydCksIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwicGF1c2VcIiwgdGhpcy5fb25QbGF5U3RvcCksIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsIHRoaXMuX29uU2Vla2VkKSwgdGhpcy5faXNTb3VyY2VSZWFkeSgpID8gdGhpcy5fb25DYW5QbGF5KCkgOiAoc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIHRoaXMuX29uQ2FuUGxheSksIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fb25DYW5QbGF5KSwgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9vbkVycm9yLCAhMCkpLCB0aGlzLl9sb2FkID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy52YWxpZCA/IHJlc29sdmUodGhpcykgOiAodGhpcy5fcmVzb2x2ZSA9IHJlc29sdmUsIHRoaXMuX3JlamVjdCA9IHJlamVjdCwgc291cmNlLmxvYWQoKSk7XG4gICAgfSksIHRoaXMuX2xvYWQ7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSB2aWRlbyBlcnJvciBldmVudHMuXG4gICAqIEBwYXJhbSBldmVudFxuICAgKi9cbiAgX29uRXJyb3IoZXZlbnQpIHtcbiAgICB0aGlzLnNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5fb25FcnJvciwgITApLCB0aGlzLm9uRXJyb3IuZW1pdChldmVudCksIHRoaXMuX3JlamVjdCAmJiAodGhpcy5fcmVqZWN0KGV2ZW50KSwgdGhpcy5fcmVqZWN0ID0gbnVsbCwgdGhpcy5fcmVzb2x2ZSA9IG51bGwpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHVuZGVybHlpbmcgc291cmNlIGlzIHBsYXlpbmcuXG4gICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiBwbGF5aW5nLlxuICAgKi9cbiAgX2lzU291cmNlUGxheWluZygpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICByZXR1cm4gIXNvdXJjZS5wYXVzZWQgJiYgIXNvdXJjZS5lbmRlZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBpcyByZWFkeSBmb3IgcGxheWluZy5cbiAgICogQHJldHVybnMgLSBUcnVlIGlmIHJlYWR5LlxuICAgKi9cbiAgX2lzU291cmNlUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLnJlYWR5U3RhdGUgPiAyO1xuICB9XG4gIC8qKiBSdW5zIHRoZSB1cGRhdGUgbG9vcCB3aGVuIHRoZSB2aWRlbyBpcyByZWFkeSB0byBwbGF5LiAqL1xuICBfb25QbGF5U3RhcnQoKSB7XG4gICAgdGhpcy52YWxpZCB8fCB0aGlzLl9vbkNhblBsYXkoKSwgdGhpcy5fY29uZmlndXJlQXV0b1VwZGF0ZSgpO1xuICB9XG4gIC8qKiBGaXJlZCB3aGVuIGEgcGF1c2UgZXZlbnQgaXMgdHJpZ2dlcmVkLCBzdG9wcyB0aGUgdXBkYXRlIGxvb3AuICovXG4gIF9vblBsYXlTdG9wKCkge1xuICAgIHRoaXMuX2NvbmZpZ3VyZUF1dG9VcGRhdGUoKTtcbiAgfVxuICAvKiogRmlyZWQgd2hlbiB0aGUgdmlkZW8gaXMgY29tcGxldGVkIHNlZWtpbmcgdG8gdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24uICovXG4gIF9vblNlZWtlZCgpIHtcbiAgICB0aGlzLl9hdXRvVXBkYXRlICYmICF0aGlzLl9pc1NvdXJjZVBsYXlpbmcoKSAmJiAodGhpcy5fbXNUb05leHRVcGRhdGUgPSAwLCB0aGlzLnVwZGF0ZSgpLCB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IDApO1xuICB9XG4gIC8qKiBGaXJlZCB3aGVuIHRoZSB2aWRlbyBpcyBsb2FkZWQgYW5kIHJlYWR5IHRvIHBsYXkuICovXG4gIF9vbkNhblBsYXkoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIHRoaXMuX29uQ2FuUGxheSksIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fb25DYW5QbGF5KTtcbiAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWQ7XG4gICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSAwLCB0aGlzLnVwZGF0ZSgpLCB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IDAsICF2YWxpZCAmJiB0aGlzLl9yZXNvbHZlICYmICh0aGlzLl9yZXNvbHZlKHRoaXMpLCB0aGlzLl9yZXNvbHZlID0gbnVsbCwgdGhpcy5fcmVqZWN0ID0gbnVsbCksIHRoaXMuX2lzU291cmNlUGxheWluZygpID8gdGhpcy5fb25QbGF5U3RhcnQoKSA6IHRoaXMuYXV0b1BsYXkgJiYgc291cmNlLnBsYXkoKTtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhpcyB0ZXh0dXJlLiAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2NvbmZpZ3VyZUF1dG9VcGRhdGUoKTtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICBzb3VyY2UgJiYgKHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicGxheVwiLCB0aGlzLl9vblBsYXlTdGFydCksIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicGF1c2VcIiwgdGhpcy5fb25QbGF5U3RvcCksIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsIHRoaXMuX29uU2Vla2VkKSwgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIHRoaXMuX29uQ2FuUGxheSksIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fb25DYW5QbGF5KSwgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9vbkVycm9yLCAhMCksIHNvdXJjZS5wYXVzZSgpLCBzb3VyY2Uuc3JjID0gXCJcIiwgc291cmNlLmxvYWQoKSksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICAvKiogU2hvdWxkIHRoZSBiYXNlIHRleHR1cmUgYXV0b21hdGljYWxseSB1cGRhdGUgaXRzZWxmLCBzZXQgdG8gdHJ1ZSBieSBkZWZhdWx0LiAqL1xuICBnZXQgYXV0b1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b1VwZGF0ZTtcbiAgfVxuICBzZXQgYXV0b1VwZGF0ZSh2YWx1ZSkge1xuICAgIHZhbHVlICE9PSB0aGlzLl9hdXRvVXBkYXRlICYmICh0aGlzLl9hdXRvVXBkYXRlID0gdmFsdWUsIHRoaXMuX2NvbmZpZ3VyZUF1dG9VcGRhdGUoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEhvdyBtYW55IHRpbWVzIGEgc2Vjb25kIHRvIHVwZGF0ZSB0aGUgdGV4dHVyZSBmcm9tIHRoZSB2aWRlby4gTGVhdmUgYXQgMCB0byB1cGRhdGUgYXQgZXZlcnkgcmVuZGVyLlxuICAgKiBBIGxvd2VyIGZwcyBjYW4gaGVscCBwZXJmb3JtYW5jZSwgYXMgdXBkYXRpbmcgdGhlIHRleHR1cmUgYXQgNjBmcHMgb24gYSAzMHBzIHZpZGVvIG1heSBub3QgYmUgZWZmaWNpZW50LlxuICAgKi9cbiAgZ2V0IHVwZGF0ZUZQUygpIHtcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlRlBTO1xuICB9XG4gIHNldCB1cGRhdGVGUFModmFsdWUpIHtcbiAgICB2YWx1ZSAhPT0gdGhpcy5fdXBkYXRlRlBTICYmICh0aGlzLl91cGRhdGVGUFMgPSB2YWx1ZSwgdGhpcy5fY29uZmlndXJlQXV0b1VwZGF0ZSgpKTtcbiAgfVxuICBfY29uZmlndXJlQXV0b1VwZGF0ZSgpIHtcbiAgICB0aGlzLl9hdXRvVXBkYXRlICYmIHRoaXMuX2lzU291cmNlUGxheWluZygpID8gIXRoaXMuX3VwZGF0ZUZQUyAmJiB0aGlzLnNvdXJjZS5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrID8gKHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgJiYgKHRpY2tlci5UaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyksIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSAhMSwgdGhpcy5fbXNUb05leHRVcGRhdGUgPSAwKSwgdGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSA9PT0gbnVsbCAmJiAodGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSA9IHRoaXMuc291cmNlLnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soXG4gICAgICB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrXG4gICAgKSkpIDogKHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUgIT09IG51bGwgJiYgKHRoaXMuc291cmNlLmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayh0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlKSwgdGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSA9IG51bGwpLCB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyIHx8ICh0aWNrZXIuVGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMpLCB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gITAsIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMCkpIDogKHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUgIT09IG51bGwgJiYgKHRoaXMuc291cmNlLmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayh0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlKSwgdGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSA9IG51bGwpLCB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyICYmICh0aWNrZXIuVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpLCB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gITEsIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMCkpO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIHRvIGF1dG8tZGV0ZWN0IHRoZSB0eXBlIG9mIHJlc291cmNlLlxuICAgKiBAcGFyYW0geyp9IHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHRlbnNpb24gLSBUaGUgZXh0ZW5zaW9uIG9mIHNvdXJjZSwgaWYgc2V0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdmlkZW8gc291cmNlXG4gICAqL1xuICBzdGF0aWMgdGVzdChzb3VyY2UsIGV4dGVuc2lvbikge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLkhUTUxWaWRlb0VsZW1lbnQgJiYgc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCB8fCBfVmlkZW9SZXNvdXJjZTIuVFlQRVMuaW5jbHVkZXMoZXh0ZW5zaW9uKTtcbiAgfVxufTtcbl9WaWRlb1Jlc291cmNlLlRZUEVTID0gW1wibXA0XCIsIFwibTR2XCIsIFwid2VibVwiLCBcIm9nZ1wiLCBcIm9ndlwiLCBcImgyNjRcIiwgXCJhdmlcIiwgXCJtb3ZcIl0sIC8qKlxuKiBNYXAgb2YgdmlkZW8gTUlNRSB0eXBlcyB0aGF0IGNhbid0IGJlIGRpcmVjdGx5IGRlcml2ZWQgZnJvbSBmaWxlIGV4dGVuc2lvbnMuXG4qIEByZWFkb25seVxuKi9cbl9WaWRlb1Jlc291cmNlLk1JTUVfVFlQRVMgPSB7XG4gIG9ndjogXCJ2aWRlby9vZ2dcIixcbiAgbW92OiBcInZpZGVvL3F1aWNrdGltZVwiLFxuICBtNHY6IFwidmlkZW8vbXA0XCJcbn07XG5sZXQgVmlkZW9SZXNvdXJjZSA9IF9WaWRlb1Jlc291cmNlO1xuZXhwb3J0cy5WaWRlb1Jlc291cmNlID0gVmlkZW9SZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZGVvUmVzb3VyY2UuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IElOU1RBTExFRCA9IFtdO1xuZnVuY3Rpb24gYXV0b0RldGVjdFJlc291cmNlKHNvdXJjZSwgb3B0aW9ucykge1xuICBpZiAoIXNvdXJjZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IGV4dGVuc2lvbiA9IFwiXCI7XG4gIGlmICh0eXBlb2Ygc291cmNlID09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCByZXN1bHQgPSAvXFwuKFxcd3szLDR9KSg/OiR8XFw/fCMpL2kuZXhlYyhzb3VyY2UpO1xuICAgIHJlc3VsdCAmJiAoZXh0ZW5zaW9uID0gcmVzdWx0WzFdLnRvTG93ZXJDYXNlKCkpO1xuICB9XG4gIGZvciAobGV0IGkgPSBJTlNUQUxMRUQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBjb25zdCBSZXNvdXJjZVBsdWdpbiA9IElOU1RBTExFRFtpXTtcbiAgICBpZiAoUmVzb3VyY2VQbHVnaW4udGVzdCAmJiBSZXNvdXJjZVBsdWdpbi50ZXN0KHNvdXJjZSwgZXh0ZW5zaW9uKSlcbiAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VQbHVnaW4oc291cmNlLCBvcHRpb25zKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgc291cmNlIHR5cGUgdG8gYXV0by1kZXRlY3QgUmVzb3VyY2VcIik7XG59XG5leHBvcnRzLklOU1RBTExFRCA9IElOU1RBTExFRDtcbmV4cG9ydHMuYXV0b0RldGVjdFJlc291cmNlID0gYXV0b0RldGVjdFJlc291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0b0RldGVjdFJlc291cmNlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXJyYXlSZXNvdXJjZSA9IHJlcXVpcmUoXCIuL0FycmF5UmVzb3VyY2UuanNcIiksIGF1dG9EZXRlY3RSZXNvdXJjZSA9IHJlcXVpcmUoXCIuL2F1dG9EZXRlY3RSZXNvdXJjZS5qc1wiKSwgQnVmZmVyUmVzb3VyY2UgPSByZXF1aXJlKFwiLi9CdWZmZXJSZXNvdXJjZS5qc1wiKSwgQ2FudmFzUmVzb3VyY2UgPSByZXF1aXJlKFwiLi9DYW52YXNSZXNvdXJjZS5qc1wiKSwgQ3ViZVJlc291cmNlID0gcmVxdWlyZShcIi4vQ3ViZVJlc291cmNlLmpzXCIpLCBJbWFnZUJpdG1hcFJlc291cmNlID0gcmVxdWlyZShcIi4vSW1hZ2VCaXRtYXBSZXNvdXJjZS5qc1wiKSwgSW1hZ2VSZXNvdXJjZSA9IHJlcXVpcmUoXCIuL0ltYWdlUmVzb3VyY2UuanNcIiksIFNWR1Jlc291cmNlID0gcmVxdWlyZShcIi4vU1ZHUmVzb3VyY2UuanNcIiksIFZpZGVvUmVzb3VyY2UgPSByZXF1aXJlKFwiLi9WaWRlb1Jlc291cmNlLmpzXCIpLCBCYXNlSW1hZ2VSZXNvdXJjZSA9IHJlcXVpcmUoXCIuL0Jhc2VJbWFnZVJlc291cmNlLmpzXCIpLCBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuL1Jlc291cmNlLmpzXCIpLCBBYnN0cmFjdE11bHRpUmVzb3VyY2UgPSByZXF1aXJlKFwiLi9BYnN0cmFjdE11bHRpUmVzb3VyY2UuanNcIik7XG5hdXRvRGV0ZWN0UmVzb3VyY2UuSU5TVEFMTEVELnB1c2goXG4gIEltYWdlQml0bWFwUmVzb3VyY2UuSW1hZ2VCaXRtYXBSZXNvdXJjZSxcbiAgSW1hZ2VSZXNvdXJjZS5JbWFnZVJlc291cmNlLFxuICBDYW52YXNSZXNvdXJjZS5DYW52YXNSZXNvdXJjZSxcbiAgVmlkZW9SZXNvdXJjZS5WaWRlb1Jlc291cmNlLFxuICBTVkdSZXNvdXJjZS5TVkdSZXNvdXJjZSxcbiAgQnVmZmVyUmVzb3VyY2UuQnVmZmVyUmVzb3VyY2UsXG4gIEN1YmVSZXNvdXJjZS5DdWJlUmVzb3VyY2UsXG4gIEFycmF5UmVzb3VyY2UuQXJyYXlSZXNvdXJjZVxuKTtcbmV4cG9ydHMuQXJyYXlSZXNvdXJjZSA9IEFycmF5UmVzb3VyY2UuQXJyYXlSZXNvdXJjZTtcbmV4cG9ydHMuSU5TVEFMTEVEID0gYXV0b0RldGVjdFJlc291cmNlLklOU1RBTExFRDtcbmV4cG9ydHMuYXV0b0RldGVjdFJlc291cmNlID0gYXV0b0RldGVjdFJlc291cmNlLmF1dG9EZXRlY3RSZXNvdXJjZTtcbmV4cG9ydHMuQnVmZmVyUmVzb3VyY2UgPSBCdWZmZXJSZXNvdXJjZS5CdWZmZXJSZXNvdXJjZTtcbmV4cG9ydHMuQ2FudmFzUmVzb3VyY2UgPSBDYW52YXNSZXNvdXJjZS5DYW52YXNSZXNvdXJjZTtcbmV4cG9ydHMuQ3ViZVJlc291cmNlID0gQ3ViZVJlc291cmNlLkN1YmVSZXNvdXJjZTtcbmV4cG9ydHMuSW1hZ2VCaXRtYXBSZXNvdXJjZSA9IEltYWdlQml0bWFwUmVzb3VyY2UuSW1hZ2VCaXRtYXBSZXNvdXJjZTtcbmV4cG9ydHMuSW1hZ2VSZXNvdXJjZSA9IEltYWdlUmVzb3VyY2UuSW1hZ2VSZXNvdXJjZTtcbmV4cG9ydHMuU1ZHUmVzb3VyY2UgPSBTVkdSZXNvdXJjZS5TVkdSZXNvdXJjZTtcbmV4cG9ydHMuVmlkZW9SZXNvdXJjZSA9IFZpZGVvUmVzb3VyY2UuVmlkZW9SZXNvdXJjZTtcbmV4cG9ydHMuQmFzZUltYWdlUmVzb3VyY2UgPSBCYXNlSW1hZ2VSZXNvdXJjZS5CYXNlSW1hZ2VSZXNvdXJjZTtcbmV4cG9ydHMuUmVzb3VyY2UgPSBSZXNvdXJjZS5SZXNvdXJjZTtcbmV4cG9ydHMuQWJzdHJhY3RNdWx0aVJlc291cmNlID0gQWJzdHJhY3RNdWx0aVJlc291cmNlLkFic3RyYWN0TXVsdGlSZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKTtcbmZ1bmN0aW9uIG1hcEludGVybmFsRm9ybWF0VG9TYW1wbGVyVHlwZShnbCkge1xuICBsZXQgdGFibGU7XG4gIHJldHVybiBcIldlYkdMMlJlbmRlcmluZ0NvbnRleHRcIiBpbiBnbG9iYWxUaGlzICYmIGdsIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWJHTDJSZW5kZXJpbmdDb250ZXh0ID8gdGFibGUgPSB7XG4gICAgW2dsLlJHQl06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SR0JBXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLkFMUEhBXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLkxVTUlOQU5DRV06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5MVU1JTkFOQ0VfQUxQSEFdOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUjhdOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUjhfU05PUk1dOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUkc4XTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLlJHOF9TTk9STV06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SR0I4XTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLlJHQjhfU05PUk1dOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUkdCNTY1XTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLlJHQkE0XTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLlJHQjVfQTFdOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUkdCQThdOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUkdCQThfU05PUk1dOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUkdCMTBfQTJdOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUkdCMTBfQTJVSV06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5TUkdCOF06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5TUkdCOF9BTFBIQThdOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUjE2Rl06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SRzE2Rl06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SR0IxNkZdOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUkdCQTE2Rl06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SMzJGXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLlJHMzJGXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLlJHQjMyRl06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SR0JBMzJGXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLlIxMUZfRzExRl9CMTBGXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLlJHQjlfRTVdOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuUjhJXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuSU5ULFxuICAgIFtnbC5SOFVJXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuVUlOVCxcbiAgICBbZ2wuUjE2SV06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLklOVCxcbiAgICBbZ2wuUjE2VUldOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5VSU5ULFxuICAgIFtnbC5SMzJJXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuSU5ULFxuICAgIFtnbC5SMzJVSV06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLlVJTlQsXG4gICAgW2dsLlJHOEldOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5JTlQsXG4gICAgW2dsLlJHOFVJXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuVUlOVCxcbiAgICBbZ2wuUkcxNkldOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5JTlQsXG4gICAgW2dsLlJHMTZVSV06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLlVJTlQsXG4gICAgW2dsLlJHMzJJXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuSU5ULFxuICAgIFtnbC5SRzMyVUldOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5VSU5ULFxuICAgIFtnbC5SR0I4SV06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLklOVCxcbiAgICBbZ2wuUkdCOFVJXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuVUlOVCxcbiAgICBbZ2wuUkdCMTZJXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuSU5ULFxuICAgIFtnbC5SR0IxNlVJXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuVUlOVCxcbiAgICBbZ2wuUkdCMzJJXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuSU5ULFxuICAgIFtnbC5SR0IzMlVJXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuVUlOVCxcbiAgICBbZ2wuUkdCQThJXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuSU5ULFxuICAgIFtnbC5SR0JBOFVJXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuVUlOVCxcbiAgICBbZ2wuUkdCQTE2SV06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLklOVCxcbiAgICBbZ2wuUkdCQTE2VUldOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5VSU5ULFxuICAgIFtnbC5SR0JBMzJJXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuSU5ULFxuICAgIFtnbC5SR0JBMzJVSV06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLlVJTlQsXG4gICAgW2dsLkRFUFRIX0NPTVBPTkVOVDE2XTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLkRFUFRIX0NPTVBPTkVOVDI0XTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLkRFUFRIX0NPTVBPTkVOVDMyRl06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5ERVBUSF9TVEVOQ0lMXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLkRFUFRIMjRfU1RFTkNJTDhdOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuREVQVEgzMkZfU1RFTkNJTDhdOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5GTE9BVFxuICB9IDogdGFibGUgPSB7XG4gICAgW2dsLlJHQl06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5SR0JBXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLkFMUEhBXTogY29uc3RhbnRzLlNBTVBMRVJfVFlQRVMuRkxPQVQsXG4gICAgW2dsLkxVTUlOQU5DRV06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FULFxuICAgIFtnbC5MVU1JTkFOQ0VfQUxQSEFdOiBjb25zdGFudHMuU0FNUExFUl9UWVBFUy5GTE9BVCxcbiAgICBbZ2wuREVQVEhfU1RFTkNJTF06IGNvbnN0YW50cy5TQU1QTEVSX1RZUEVTLkZMT0FUXG4gIH0sIHRhYmxlO1xufVxuZXhwb3J0cy5tYXBJbnRlcm5hbEZvcm1hdFRvU2FtcGxlclR5cGUgPSBtYXBJbnRlcm5hbEZvcm1hdFRvU2FtcGxlclR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBJbnRlcm5hbEZvcm1hdFRvU2FtcGxlclR5cGUuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiQHBpeGkvY29uc3RhbnRzXCIpO1xuZnVuY3Rpb24gbWFwVHlwZUFuZEZvcm1hdFRvSW50ZXJuYWxGb3JtYXQoZ2wpIHtcbiAgbGV0IHRhYmxlO1xuICByZXR1cm4gXCJXZWJHTDJSZW5kZXJpbmdDb250ZXh0XCIgaW4gZ2xvYmFsVGhpcyAmJiBnbCBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA/IHRhYmxlID0ge1xuICAgIFtjb25zdGFudHMuVFlQRVMuVU5TSUdORURfQllURV06IHtcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JBXTogZ2wuUkdCQTgsXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCXTogZ2wuUkdCOCxcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR106IGdsLlJHOCxcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SRURdOiBnbC5SOCxcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JBX0lOVEVHRVJdOiBnbC5SR0JBOFVJLFxuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQl9JTlRFR0VSXTogZ2wuUkdCOFVJLFxuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHX0lOVEVHRVJdOiBnbC5SRzhVSSxcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SRURfSU5URUdFUl06IGdsLlI4VUksXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuQUxQSEFdOiBnbC5BTFBIQSxcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5MVU1JTkFOQ0VdOiBnbC5MVU1JTkFOQ0UsXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuTFVNSU5BTkNFX0FMUEhBXTogZ2wuTFVNSU5BTkNFX0FMUEhBXG4gICAgfSxcbiAgICBbY29uc3RhbnRzLlRZUEVTLkJZVEVdOiB7XG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCQV06IGdsLlJHQkE4X1NOT1JNLFxuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQl06IGdsLlJHQjhfU05PUk0sXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkddOiBnbC5SRzhfU05PUk0sXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkVEXTogZ2wuUjhfU05PUk0sXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCQV9JTlRFR0VSXTogZ2wuUkdCQThJLFxuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQl9JTlRFR0VSXTogZ2wuUkdCOEksXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdfSU5URUdFUl06IGdsLlJHOEksXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkVEX0lOVEVHRVJdOiBnbC5SOElcbiAgICB9LFxuICAgIFtjb25zdGFudHMuVFlQRVMuVU5TSUdORURfU0hPUlRdOiB7XG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCQV9JTlRFR0VSXTogZ2wuUkdCQTE2VUksXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCX0lOVEVHRVJdOiBnbC5SR0IxNlVJLFxuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHX0lOVEVHRVJdOiBnbC5SRzE2VUksXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkVEX0lOVEVHRVJdOiBnbC5SMTZVSSxcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5ERVBUSF9DT01QT05FTlRdOiBnbC5ERVBUSF9DT01QT05FTlQxNlxuICAgIH0sXG4gICAgW2NvbnN0YW50cy5UWVBFUy5TSE9SVF06IHtcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JBX0lOVEVHRVJdOiBnbC5SR0JBMTZJLFxuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQl9JTlRFR0VSXTogZ2wuUkdCMTZJLFxuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHX0lOVEVHRVJdOiBnbC5SRzE2SSxcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SRURfSU5URUdFUl06IGdsLlIxNklcbiAgICB9LFxuICAgIFtjb25zdGFudHMuVFlQRVMuVU5TSUdORURfSU5UXToge1xuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQkFfSU5URUdFUl06IGdsLlJHQkEzMlVJLFxuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQl9JTlRFR0VSXTogZ2wuUkdCMzJVSSxcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR19JTlRFR0VSXTogZ2wuUkczMlVJLFxuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJFRF9JTlRFR0VSXTogZ2wuUjMyVUksXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuREVQVEhfQ09NUE9ORU5UXTogZ2wuREVQVEhfQ09NUE9ORU5UMjRcbiAgICB9LFxuICAgIFtjb25zdGFudHMuVFlQRVMuSU5UXToge1xuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQkFfSU5URUdFUl06IGdsLlJHQkEzMkksXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCX0lOVEVHRVJdOiBnbC5SR0IzMkksXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdfSU5URUdFUl06IGdsLlJHMzJJLFxuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJFRF9JTlRFR0VSXTogZ2wuUjMySVxuICAgIH0sXG4gICAgW2NvbnN0YW50cy5UWVBFUy5GTE9BVF06IHtcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JBXTogZ2wuUkdCQTMyRixcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JdOiBnbC5SR0IzMkYsXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkddOiBnbC5SRzMyRixcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SRURdOiBnbC5SMzJGLFxuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLkRFUFRIX0NPTVBPTkVOVF06IGdsLkRFUFRIX0NPTVBPTkVOVDMyRlxuICAgIH0sXG4gICAgW2NvbnN0YW50cy5UWVBFUy5IQUxGX0ZMT0FUXToge1xuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQkFdOiBnbC5SR0JBMTZGLFxuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQl06IGdsLlJHQjE2RixcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR106IGdsLlJHMTZGLFxuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJFRF06IGdsLlIxNkZcbiAgICB9LFxuICAgIFtjb25zdGFudHMuVFlQRVMuVU5TSUdORURfU0hPUlRfNV82XzVdOiB7XG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCXTogZ2wuUkdCNTY1XG4gICAgfSxcbiAgICBbY29uc3RhbnRzLlRZUEVTLlVOU0lHTkVEX1NIT1JUXzRfNF80XzRdOiB7XG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCQV06IGdsLlJHQkE0XG4gICAgfSxcbiAgICBbY29uc3RhbnRzLlRZUEVTLlVOU0lHTkVEX1NIT1JUXzVfNV81XzFdOiB7XG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCQV06IGdsLlJHQjVfQTFcbiAgICB9LFxuICAgIFtjb25zdGFudHMuVFlQRVMuVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWXToge1xuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQkFdOiBnbC5SR0IxMF9BMixcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JBX0lOVEVHRVJdOiBnbC5SR0IxMF9BMlVJXG4gICAgfSxcbiAgICBbY29uc3RhbnRzLlRZUEVTLlVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVZdOiB7XG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCXTogZ2wuUjExRl9HMTFGX0IxMEZcbiAgICB9LFxuICAgIFtjb25zdGFudHMuVFlQRVMuVU5TSUdORURfSU5UXzVfOV85XzlfUkVWXToge1xuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQl06IGdsLlJHQjlfRTVcbiAgICB9LFxuICAgIFtjb25zdGFudHMuVFlQRVMuVU5TSUdORURfSU5UXzI0XzhdOiB7XG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuREVQVEhfU1RFTkNJTF06IGdsLkRFUFRIMjRfU1RFTkNJTDhcbiAgICB9LFxuICAgIFtjb25zdGFudHMuVFlQRVMuRkxPQVRfMzJfVU5TSUdORURfSU5UXzI0XzhfUkVWXToge1xuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLkRFUFRIX1NURU5DSUxdOiBnbC5ERVBUSDMyRl9TVEVOQ0lMOFxuICAgIH1cbiAgfSA6IHRhYmxlID0ge1xuICAgIFtjb25zdGFudHMuVFlQRVMuVU5TSUdORURfQllURV06IHtcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JBXTogZ2wuUkdCQSxcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5SR0JdOiBnbC5SR0IsXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuQUxQSEFdOiBnbC5BTFBIQSxcbiAgICAgIFtjb25zdGFudHMuRk9STUFUUy5MVU1JTkFOQ0VdOiBnbC5MVU1JTkFOQ0UsXG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuTFVNSU5BTkNFX0FMUEhBXTogZ2wuTFVNSU5BTkNFX0FMUEhBXG4gICAgfSxcbiAgICBbY29uc3RhbnRzLlRZUEVTLlVOU0lHTkVEX1NIT1JUXzVfNl81XToge1xuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQl06IGdsLlJHQlxuICAgIH0sXG4gICAgW2NvbnN0YW50cy5UWVBFUy5VTlNJR05FRF9TSE9SVF80XzRfNF80XToge1xuICAgICAgW2NvbnN0YW50cy5GT1JNQVRTLlJHQkFdOiBnbC5SR0JBXG4gICAgfSxcbiAgICBbY29uc3RhbnRzLlRZUEVTLlVOU0lHTkVEX1NIT1JUXzVfNV81XzFdOiB7XG4gICAgICBbY29uc3RhbnRzLkZPUk1BVFMuUkdCQV06IGdsLlJHQkFcbiAgICB9XG4gIH0sIHRhYmxlO1xufVxuZXhwb3J0cy5tYXBUeXBlQW5kRm9ybWF0VG9JbnRlcm5hbEZvcm1hdCA9IG1hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwVHlwZUFuZEZvcm1hdFRvSW50ZXJuYWxGb3JtYXQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBydW5uZXIgPSByZXF1aXJlKFwiQHBpeGkvcnVubmVyXCIpO1xuY2xhc3MgVHJhbnNmb3JtRmVlZGJhY2sge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9nbFRyYW5zZm9ybUZlZWRiYWNrcyA9IHt9LCB0aGlzLmJ1ZmZlcnMgPSBbXSwgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IHJ1bm5lci5SdW5uZXIoXCJkaXNwb3NlVHJhbnNmb3JtRmVlZGJhY2tcIik7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmQgYnVmZmVyIHRvIFRyYW5zZm9ybUZlZWRiYWNrXG4gICAqIEBwYXJhbSBpbmRleCAtIGluZGV4IHRvIGJpbmRcbiAgICogQHBhcmFtIGJ1ZmZlciAtIGJ1ZmZlciB0byBiaW5kXG4gICAqL1xuICBiaW5kQnVmZmVyKGluZGV4LCBidWZmZXIpIHtcbiAgICB0aGlzLmJ1ZmZlcnNbaW5kZXhdID0gYnVmZmVyO1xuICB9XG4gIC8qKiBEZXN0cm95IFdlYkdMIHJlc291cmNlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhpcyBUcmFuc2Zvcm1GZWVkYmFjay4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRpc3Bvc2VSdW5uZXIuZW1pdCh0aGlzLCAhMSk7XG4gIH1cbn1cbmV4cG9ydHMuVHJhbnNmb3JtRmVlZGJhY2sgPSBUcmFuc2Zvcm1GZWVkYmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zZm9ybUZlZWRiYWNrLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXh0ZW5zaW9ucyA9IHJlcXVpcmUoXCJAcGl4aS9leHRlbnNpb25zXCIpO1xuY2xhc3MgVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIC8qKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy4gKi9cbiAgY29udGV4dENoYW5nZSgpIHtcbiAgICB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbCwgdGhpcy5DT05URVhUX1VJRCA9IHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQ7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmQgVHJhbnNmb3JtRmVlZGJhY2sgYW5kIGJ1ZmZlcnNcbiAgICogQHBhcmFtIHRyYW5zZm9ybUZlZWRiYWNrIC0gVHJhbnNmb3JtRmVlZGJhY2sgdG8gYmluZFxuICAgKi9cbiAgYmluZCh0cmFuc2Zvcm1GZWVkYmFjaykge1xuICAgIGNvbnN0IHsgZ2wsIENPTlRFWFRfVUlEIH0gPSB0aGlzLCBnbFRyYW5zZm9ybUZlZWRiYWNrID0gdHJhbnNmb3JtRmVlZGJhY2suX2dsVHJhbnNmb3JtRmVlZGJhY2tzW0NPTlRFWFRfVUlEXSB8fCB0aGlzLmNyZWF0ZUdMVHJhbnNmb3JtRmVlZGJhY2sodHJhbnNmb3JtRmVlZGJhY2spO1xuICAgIGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhnbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIGdsVHJhbnNmb3JtRmVlZGJhY2spO1xuICB9XG4gIC8qKiBVbmJpbmQgVHJhbnNmb3JtRmVlZGJhY2sgKi9cbiAgdW5iaW5kKCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKGdsLlRSQU5TRk9STV9GRUVEQkFDSywgbnVsbCk7XG4gIH1cbiAgLyoqXG4gICAqIEJlZ2luIFRyYW5zZm9ybUZlZWRiYWNrXG4gICAqIEBwYXJhbSBkcmF3TW9kZSAtIERyYXdNb2RlIGZvciBUcmFuc2Zvcm1GZWVkYmFja1xuICAgKiBAcGFyYW0gc2hhZGVyIC0gQSBTaGFkZXIgdXNlZCBieSBUcmFuc2Zvcm1GZWVkYmFjay4gQ3VycmVudCBib3VuZCBzaGFkZXIgd2lsbCBiZSB1c2VkIGlmIG5vdCBwcm92aWRlZC5cbiAgICovXG4gIGJlZ2luVHJhbnNmb3JtRmVlZGJhY2soZHJhd01vZGUsIHNoYWRlcikge1xuICAgIGNvbnN0IHsgZ2wsIHJlbmRlcmVyIH0gPSB0aGlzO1xuICAgIHNoYWRlciAmJiByZW5kZXJlci5zaGFkZXIuYmluZChzaGFkZXIpLCBnbC5iZWdpblRyYW5zZm9ybUZlZWRiYWNrKGRyYXdNb2RlKTtcbiAgfVxuICAvKiogRW5kIFRyYW5zZm9ybUZlZWRiYWNrICovXG4gIGVuZFRyYW5zZm9ybUZlZWRiYWNrKCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgZ2wuZW5kVHJhbnNmb3JtRmVlZGJhY2soKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIFRyYW5zZm9ybUZlZWRiYWNrIGFuZCBiaW5kIGJ1ZmZlcnNcbiAgICogQHBhcmFtIHRmIC0gVHJhbnNmb3JtRmVlZGJhY2tcbiAgICogQHJldHVybnMgV2ViR0xUcmFuc2Zvcm1GZWVkYmFja1xuICAgKi9cbiAgY3JlYXRlR0xUcmFuc2Zvcm1GZWVkYmFjayh0Zikge1xuICAgIGNvbnN0IHsgZ2wsIHJlbmRlcmVyLCBDT05URVhUX1VJRCB9ID0gdGhpcywgZ2xUcmFuc2Zvcm1GZWVkYmFjayA9IGdsLmNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrKCk7XG4gICAgdGYuX2dsVHJhbnNmb3JtRmVlZGJhY2tzW0NPTlRFWFRfVUlEXSA9IGdsVHJhbnNmb3JtRmVlZGJhY2ssIGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhnbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIGdsVHJhbnNmb3JtRmVlZGJhY2spO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGYuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYnVmZmVyID0gdGYuYnVmZmVyc1tpXTtcbiAgICAgIGJ1ZmZlciAmJiAocmVuZGVyZXIuYnVmZmVyLnVwZGF0ZShidWZmZXIpLCBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0ucmVmQ291bnQrKywgZ2wuYmluZEJ1ZmZlckJhc2UoZ2wuVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUiwgaSwgYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdLmJ1ZmZlciB8fCBudWxsKSk7XG4gICAgfVxuICAgIHJldHVybiBnbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soZ2wuVFJBTlNGT1JNX0ZFRURCQUNLLCBudWxsKSwgdGYuZGlzcG9zZVJ1bm5lci5hZGQodGhpcyksIGdsVHJhbnNmb3JtRmVlZGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIERpc3Bvc2VzIFRyYW5zZnJvbUZlZWRiYWNrXG4gICAqIEBwYXJhbSB7UElYSS5UcmFuc2Zvcm1GZWVkYmFja30gdGYgLSBUcmFuc2Zvcm1GZWVkYmFja1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb250ZXh0TG9zdD1mYWxzZV0gLSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBkZWxldGUgVHJhbnNmb3JtRmVlZGJhY2tcbiAgICovXG4gIGRpc3Bvc2VUcmFuc2Zvcm1GZWVkYmFjayh0ZiwgY29udGV4dExvc3QpIHtcbiAgICBjb25zdCBnbFRGID0gdGYuX2dsVHJhbnNmb3JtRmVlZGJhY2tzW3RoaXMuQ09OVEVYVF9VSURdLCBnbCA9IHRoaXMuZ2w7XG4gICAgdGYuZGlzcG9zZVJ1bm5lci5yZW1vdmUodGhpcyk7XG4gICAgY29uc3QgYnVmZmVyU3lzdGVtID0gdGhpcy5yZW5kZXJlci5idWZmZXI7XG4gICAgaWYgKGJ1ZmZlclN5c3RlbSlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGYuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB0Zi5idWZmZXJzW2ldO1xuICAgICAgICBpZiAoIWJ1ZmZlcilcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgYnVmID0gYnVmZmVyLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgIGJ1ZiAmJiAoYnVmLnJlZkNvdW50LS0sIGJ1Zi5yZWZDb3VudCA9PT0gMCAmJiAhY29udGV4dExvc3QgJiYgYnVmZmVyU3lzdGVtLmRpc3Bvc2UoYnVmZmVyLCBjb250ZXh0TG9zdCkpO1xuICAgICAgfVxuICAgIGdsVEYgJiYgKGNvbnRleHRMb3N0IHx8IGdsLmRlbGV0ZVRyYW5zZm9ybUZlZWRiYWNrKGdsVEYpLCBkZWxldGUgdGYuX2dsVHJhbnNmb3JtRmVlZGJhY2tzW3RoaXMuQ09OVEVYVF9VSURdKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5UcmFuc2Zvcm1GZWVkYmFja1N5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJ0cmFuc2Zvcm1GZWVkYmFja1wiXG59O1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChUcmFuc2Zvcm1GZWVkYmFja1N5c3RlbSk7XG5leHBvcnRzLlRyYW5zZm9ybUZlZWRiYWNrU3lzdGVtID0gVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2Zvcm1GZWVkYmFja1N5c3RlbS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIEdlb21ldHJ5ID0gcmVxdWlyZShcIi4uL2dlb21ldHJ5L0dlb21ldHJ5LmpzXCIpO1xuY2xhc3MgUXVhZCBleHRlbmRzIEdlb21ldHJ5Lkdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5hZGRBdHRyaWJ1dGUoXCJhVmVydGV4UG9zaXRpb25cIiwgbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMVxuICAgIF0pKS5hZGRJbmRleChbMCwgMSwgMywgMl0pO1xuICB9XG59XG5leHBvcnRzLlF1YWQgPSBRdWFkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVhZC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoXCIuLi9nZW9tZXRyeS9CdWZmZXIuanNcIiksIEdlb21ldHJ5ID0gcmVxdWlyZShcIi4uL2dlb21ldHJ5L0dlb21ldHJ5LmpzXCIpO1xuY2xhc3MgUXVhZFV2IGV4dGVuZHMgR2VvbWV0cnkuR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpLCB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAtMSxcbiAgICAgIC0xLFxuICAgICAgMSxcbiAgICAgIC0xLFxuICAgICAgMSxcbiAgICAgIDEsXG4gICAgICAtMSxcbiAgICAgIDFcbiAgICBdKSwgdGhpcy51dnMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAxXG4gICAgXSksIHRoaXMudmVydGV4QnVmZmVyID0gbmV3IEJ1ZmZlci5CdWZmZXIodGhpcy52ZXJ0aWNlcyksIHRoaXMudXZCdWZmZXIgPSBuZXcgQnVmZmVyLkJ1ZmZlcih0aGlzLnV2cyksIHRoaXMuYWRkQXR0cmlidXRlKFwiYVZlcnRleFBvc2l0aW9uXCIsIHRoaXMudmVydGV4QnVmZmVyKS5hZGRBdHRyaWJ1dGUoXCJhVGV4dHVyZUNvb3JkXCIsIHRoaXMudXZCdWZmZXIpLmFkZEluZGV4KFswLCAxLCAyLCAwLCAyLCAzXSk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcHMgdHdvIFJlY3RhbmdsZSB0byB0aGUgcXVhZC5cbiAgICogQHBhcmFtIHRhcmdldFRleHR1cmVGcmFtZSAtIFRoZSBmaXJzdCByZWN0YW5nbGVcbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uRnJhbWUgLSBUaGUgc2Vjb25kIHJlY3RhbmdsZVxuICAgKiBAcmV0dXJucyAtIFJldHVybnMgaXRzZWxmLlxuICAgKi9cbiAgbWFwKHRhcmdldFRleHR1cmVGcmFtZSwgZGVzdGluYXRpb25GcmFtZSkge1xuICAgIGxldCB4ID0gMCwgeSA9IDA7XG4gICAgcmV0dXJuIHRoaXMudXZzWzBdID0geCwgdGhpcy51dnNbMV0gPSB5LCB0aGlzLnV2c1syXSA9IHggKyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoIC8gdGFyZ2V0VGV4dHVyZUZyYW1lLndpZHRoLCB0aGlzLnV2c1szXSA9IHksIHRoaXMudXZzWzRdID0geCArIGRlc3RpbmF0aW9uRnJhbWUud2lkdGggLyB0YXJnZXRUZXh0dXJlRnJhbWUud2lkdGgsIHRoaXMudXZzWzVdID0geSArIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0IC8gdGFyZ2V0VGV4dHVyZUZyYW1lLmhlaWdodCwgdGhpcy51dnNbNl0gPSB4LCB0aGlzLnV2c1s3XSA9IHkgKyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAvIHRhcmdldFRleHR1cmVGcmFtZS5oZWlnaHQsIHggPSBkZXN0aW5hdGlvbkZyYW1lLngsIHkgPSBkZXN0aW5hdGlvbkZyYW1lLnksIHRoaXMudmVydGljZXNbMF0gPSB4LCB0aGlzLnZlcnRpY2VzWzFdID0geSwgdGhpcy52ZXJ0aWNlc1syXSA9IHggKyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoLCB0aGlzLnZlcnRpY2VzWzNdID0geSwgdGhpcy52ZXJ0aWNlc1s0XSA9IHggKyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoLCB0aGlzLnZlcnRpY2VzWzVdID0geSArIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0LCB0aGlzLnZlcnRpY2VzWzZdID0geCwgdGhpcy52ZXJ0aWNlc1s3XSA9IHkgKyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCwgdGhpcy5pbnZhbGlkYXRlKCksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIExlZ2FjeSB1cGxvYWQgbWV0aG9kLCBqdXN0IG1hcmtzIGJ1ZmZlcnMgZGlydHkuXG4gICAqIEByZXR1cm5zIC0gUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBpbnZhbGlkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnZlcnRleEJ1ZmZlci5fdXBkYXRlSUQrKywgdGhpcy51dkJ1ZmZlci5fdXBkYXRlSUQrKywgdGhpcztcbiAgfVxufVxuZXhwb3J0cy5RdWFkVXYgPSBRdWFkVXY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWFkVXYuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBleHRlbnNpb25zID0gcmVxdWlyZShcIkBwaXhpL2V4dGVuc2lvbnNcIiksIG1hdGggPSByZXF1aXJlKFwiQHBpeGkvbWF0aFwiKSwgc2V0dGluZ3MgPSByZXF1aXJlKFwiQHBpeGkvc2V0dGluZ3NcIik7XG5jbGFzcyBWaWV3U3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIGluaXRpYXRlcyB0aGUgdmlldyBzeXN0ZW1cbiAgICogQHBhcmFtIHtQSVhJLlZpZXdPcHRpb25zfSBvcHRpb25zIC0gdGhlIG9wdGlvbnMgZm9yIHRoZSB2aWV3XG4gICAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLnNjcmVlbiA9IG5ldyBtYXRoLlJlY3RhbmdsZSgwLCAwLCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCksIHRoaXMuZWxlbWVudCA9IG9wdGlvbnMudmlldyB8fCBzZXR0aW5ncy5zZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpLCB0aGlzLnJlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb24gfHwgc2V0dGluZ3Muc2V0dGluZ3MuUkVTT0xVVElPTiwgdGhpcy5hdXRvRGVuc2l0eSA9ICEhb3B0aW9ucy5hdXRvRGVuc2l0eTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplcyB0aGUgc2NyZWVuIGFuZCBjYW52YXMgdG8gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25zLlxuICAgKiBAcGFyYW0gZGVzaXJlZFNjcmVlbldpZHRoIC0gVGhlIG5ldyB3aWR0aCBvZiB0aGUgc2NyZWVuLlxuICAgKiBAcGFyYW0gZGVzaXJlZFNjcmVlbkhlaWdodCAtIFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBzY3JlZW4uXG4gICAqL1xuICByZXNpemVWaWV3KGRlc2lyZWRTY3JlZW5XaWR0aCwgZGVzaXJlZFNjcmVlbkhlaWdodCkge1xuICAgIHRoaXMuZWxlbWVudC53aWR0aCA9IE1hdGgucm91bmQoZGVzaXJlZFNjcmVlbldpZHRoICogdGhpcy5yZXNvbHV0aW9uKSwgdGhpcy5lbGVtZW50LmhlaWdodCA9IE1hdGgucm91bmQoZGVzaXJlZFNjcmVlbkhlaWdodCAqIHRoaXMucmVzb2x1dGlvbik7XG4gICAgY29uc3Qgc2NyZWVuV2lkdGggPSB0aGlzLmVsZW1lbnQud2lkdGggLyB0aGlzLnJlc29sdXRpb24sIHNjcmVlbkhlaWdodCA9IHRoaXMuZWxlbWVudC5oZWlnaHQgLyB0aGlzLnJlc29sdXRpb247XG4gICAgdGhpcy5zY3JlZW4ud2lkdGggPSBzY3JlZW5XaWR0aCwgdGhpcy5zY3JlZW4uaGVpZ2h0ID0gc2NyZWVuSGVpZ2h0LCB0aGlzLmF1dG9EZW5zaXR5ICYmICh0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHtzY3JlZW5XaWR0aH1weGAsIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHtzY3JlZW5IZWlnaHR9cHhgKSwgdGhpcy5yZW5kZXJlci5lbWl0KFwicmVzaXplXCIsIHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpLCB0aGlzLnJlbmRlcmVyLnJ1bm5lcnMucmVzaXplLmVtaXQodGhpcy5zY3JlZW4ud2lkdGgsIHRoaXMuc2NyZWVuLmhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoaXMgU3lzdGVtIGFuZCBvcHRpb25hbGx5IHJlbW92ZXMgdGhlIGNhbnZhcyBmcm9tIHRoZSBkb20uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZVZpZXc9ZmFsc2VdIC0gV2hldGhlciB0byByZW1vdmUgdGhlIGNhbnZhcyBmcm9tIHRoZSBET00uXG4gICAqL1xuICBkZXN0cm95KHJlbW92ZVZpZXcpIHtcbiAgICByZW1vdmVWaWV3ICYmIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpLCB0aGlzLnJlbmRlcmVyID0gbnVsbCwgdGhpcy5lbGVtZW50ID0gbnVsbCwgdGhpcy5zY3JlZW4gPSBudWxsO1xuICB9XG59XG5WaWV3U3lzdGVtLmRlZmF1bHRPcHRpb25zID0ge1xuICAvKipcbiAgICoge0BsaW5rIFBJWEkuSVJlbmRlcmVyT3B0aW9ucy53aWR0aH1cbiAgICogQGRlZmF1bHQgODAwXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzLlJFTkRFUl9PUFRJT05TXG4gICAqL1xuICB3aWR0aDogODAwLFxuICAvKipcbiAgICoge0BsaW5rIFBJWEkuSVJlbmRlcmVyT3B0aW9ucy5oZWlnaHR9XG4gICAqIEBkZWZhdWx0IDYwMFxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5ncy5SRU5ERVJfT1BUSU9OU1xuICAgKi9cbiAgaGVpZ2h0OiA2MDAsXG4gIC8qKlxuICAgKiB7QGxpbmsgUElYSS5JUmVuZGVyZXJPcHRpb25zLnJlc29sdXRpb259XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IFBJWEkuc2V0dGluZ3MuUkVTT0xVVElPTlxuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5ncy5SRU5ERVJfT1BUSU9OU1xuICAgKi9cbiAgcmVzb2x1dGlvbjogdm9pZCAwLFxuICAvKipcbiAgICoge0BsaW5rIFBJWEkuSVJlbmRlcmVyT3B0aW9ucy5hdXRvRGVuc2l0eX1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3MuUkVOREVSX09QVElPTlNcbiAgICovXG4gIGF1dG9EZW5zaXR5OiAhMVxufSwgLyoqIEBpZ25vcmUgKi9cblZpZXdTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICAgIGV4dGVuc2lvbnMuRXh0ZW5zaW9uVHlwZS5DYW52YXNSZW5kZXJlclN5c3RlbVxuICBdLFxuICBuYW1lOiBcIl92aWV3XCJcbn07XG5leHRlbnNpb25zLmV4dGVuc2lvbnMuYWRkKFZpZXdTeXN0ZW0pO1xuZXhwb3J0cy5WaWV3U3lzdGVtID0gVmlld1N5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZXdTeXN0ZW0uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIik7XG5jbGFzcyBCb3VuZHMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1pblggPSAxIC8gMCwgdGhpcy5taW5ZID0gMSAvIDAsIHRoaXMubWF4WCA9IC0xIC8gMCwgdGhpcy5tYXhZID0gLTEgLyAwLCB0aGlzLnJlY3QgPSBudWxsLCB0aGlzLnVwZGF0ZUlEID0gLTE7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBib3VuZHMgYXJlIGVtcHR5LlxuICAgKiBAcmV0dXJucyAtIFRydWUgaWYgZW1wdHkuXG4gICAqL1xuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLm1pblggPiB0aGlzLm1heFggfHwgdGhpcy5taW5ZID4gdGhpcy5tYXhZO1xuICB9XG4gIC8qKiBDbGVhcnMgdGhlIGJvdW5kcyBhbmQgcmVzZXRzLiAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLm1pblggPSAxIC8gMCwgdGhpcy5taW5ZID0gMSAvIDAsIHRoaXMubWF4WCA9IC0xIC8gMCwgdGhpcy5tYXhZID0gLTEgLyAwO1xuICB9XG4gIC8qKlxuICAgKiBDYW4gcmV0dXJuIFJlY3RhbmdsZS5FTVBUWSBjb25zdGFudCwgZWl0aGVyIGNvbnN0cnVjdCBuZXcgcmVjdGFuZ2xlLCBlaXRoZXIgdXNlIHlvdXIgcmVjdGFuZ2xlXG4gICAqIEl0IGlzIG5vdCBndWFyYW50ZWVkIHRoYXQgaXQgd2lsbCByZXR1cm4gdGVtcFJlY3RcbiAgICogQHBhcmFtIHJlY3QgLSBUZW1wb3Jhcnkgb2JqZWN0IHdpbGwgYmUgdXNlZCBpZiBBQUJCIGlzIG5vdCBlbXB0eVxuICAgKiBAcmV0dXJucyAtIEEgcmVjdGFuZ2xlIG9mIHRoZSBib3VuZHNcbiAgICovXG4gIGdldFJlY3RhbmdsZShyZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMubWluWCA+IHRoaXMubWF4WCB8fCB0aGlzLm1pblkgPiB0aGlzLm1heFkgPyBjb3JlLlJlY3RhbmdsZS5FTVBUWSA6IChyZWN0ID0gcmVjdCB8fCBuZXcgY29yZS5SZWN0YW5nbGUoMCwgMCwgMSwgMSksIHJlY3QueCA9IHRoaXMubWluWCwgcmVjdC55ID0gdGhpcy5taW5ZLCByZWN0LndpZHRoID0gdGhpcy5tYXhYIC0gdGhpcy5taW5YLCByZWN0LmhlaWdodCA9IHRoaXMubWF4WSAtIHRoaXMubWluWSwgcmVjdCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGlubGluZWQgd2hlbiBpdHMgcG9zc2libGUuXG4gICAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCB0byBhZGQuXG4gICAqL1xuICBhZGRQb2ludChwb2ludCkge1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgcG9pbnQueCksIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgcG9pbnQueCksIHRoaXMubWluWSA9IE1hdGgubWluKHRoaXMubWluWSwgcG9pbnQueSksIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgcG9pbnQueSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBwb2ludCwgYWZ0ZXIgdHJhbnNmb3JtZWQuIFRoaXMgc2hvdWxkIGJlIGlubGluZWQgd2hlbiBpdHMgcG9zc2libGUuXG4gICAqIEBwYXJhbSBtYXRyaXhcbiAgICogQHBhcmFtIHBvaW50XG4gICAqL1xuICBhZGRQb2ludE1hdHJpeChtYXRyaXgsIHBvaW50KSB7XG4gICAgY29uc3QgeyBhLCBiLCBjLCBkLCB0eCwgdHkgfSA9IG1hdHJpeCwgeCA9IGEgKiBwb2ludC54ICsgYyAqIHBvaW50LnkgKyB0eCwgeSA9IGIgKiBwb2ludC54ICsgZCAqIHBvaW50LnkgKyB0eTtcbiAgICB0aGlzLm1pblggPSBNYXRoLm1pbih0aGlzLm1pblgsIHgpLCB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIHgpLCB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHkpLCB0aGlzLm1heFkgPSBNYXRoLm1heCh0aGlzLm1heFksIHkpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcXVhZCwgbm90IHRyYW5zZm9ybWVkXG4gICAqIEBwYXJhbSB2ZXJ0aWNlcyAtIFRoZSB2ZXJ0cyB0byBhZGQuXG4gICAqL1xuICBhZGRRdWFkKHZlcnRpY2VzKSB7XG4gICAgbGV0IG1pblggPSB0aGlzLm1pblgsIG1pblkgPSB0aGlzLm1pblksIG1heFggPSB0aGlzLm1heFgsIG1heFkgPSB0aGlzLm1heFksIHggPSB2ZXJ0aWNlc1swXSwgeSA9IHZlcnRpY2VzWzFdO1xuICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YLCBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWSwgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFgsIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZLCB4ID0gdmVydGljZXNbMl0sIHkgPSB2ZXJ0aWNlc1szXSwgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblgsIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZLCBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WCwgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFksIHggPSB2ZXJ0aWNlc1s0XSwgeSA9IHZlcnRpY2VzWzVdLCBtaW5YID0geCA8IG1pblggPyB4IDogbWluWCwgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblksIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYLCBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WSwgeCA9IHZlcnRpY2VzWzZdLCB5ID0gdmVydGljZXNbN10sIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YLCBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWSwgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFgsIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZLCB0aGlzLm1pblggPSBtaW5YLCB0aGlzLm1pblkgPSBtaW5ZLCB0aGlzLm1heFggPSBtYXhYLCB0aGlzLm1heFkgPSBtYXhZO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHNwcml0ZSBmcmFtZSwgdHJhbnNmb3JtZWQuXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSB0cmFuc2Zvcm0gdG8gYXBwbHlcbiAgICogQHBhcmFtIHgwIC0gbGVmdCBYIG9mIGZyYW1lXG4gICAqIEBwYXJhbSB5MCAtIHRvcCBZIG9mIGZyYW1lXG4gICAqIEBwYXJhbSB4MSAtIHJpZ2h0IFggb2YgZnJhbWVcbiAgICogQHBhcmFtIHkxIC0gYm90dG9tIFkgb2YgZnJhbWVcbiAgICovXG4gIGFkZEZyYW1lKHRyYW5zZm9ybSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICB0aGlzLmFkZEZyYW1lTWF0cml4KHRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSwgeDAsIHkwLCB4MSwgeTEpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHNwcml0ZSBmcmFtZSwgbXVsdGlwbGllZCBieSBtYXRyaXhcbiAgICogQHBhcmFtIG1hdHJpeCAtIG1hdHJpeCB0byBhcHBseVxuICAgKiBAcGFyYW0geDAgLSBsZWZ0IFggb2YgZnJhbWVcbiAgICogQHBhcmFtIHkwIC0gdG9wIFkgb2YgZnJhbWVcbiAgICogQHBhcmFtIHgxIC0gcmlnaHQgWCBvZiBmcmFtZVxuICAgKiBAcGFyYW0geTEgLSBib3R0b20gWSBvZiBmcmFtZVxuICAgKi9cbiAgYWRkRnJhbWVNYXRyaXgobWF0cml4LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGNvbnN0IGEgPSBtYXRyaXguYSwgYiA9IG1hdHJpeC5iLCBjID0gbWF0cml4LmMsIGQgPSBtYXRyaXguZCwgdHggPSBtYXRyaXgudHgsIHR5ID0gbWF0cml4LnR5O1xuICAgIGxldCBtaW5YID0gdGhpcy5taW5YLCBtaW5ZID0gdGhpcy5taW5ZLCBtYXhYID0gdGhpcy5tYXhYLCBtYXhZID0gdGhpcy5tYXhZLCB4ID0gYSAqIHgwICsgYyAqIHkwICsgdHgsIHkgPSBiICogeDAgKyBkICogeTAgKyB0eTtcbiAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWCwgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblksIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYLCBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WSwgeCA9IGEgKiB4MSArIGMgKiB5MCArIHR4LCB5ID0gYiAqIHgxICsgZCAqIHkwICsgdHksIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YLCBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWSwgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFgsIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZLCB4ID0gYSAqIHgwICsgYyAqIHkxICsgdHgsIHkgPSBiICogeDAgKyBkICogeTEgKyB0eSwgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblgsIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZLCBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WCwgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFksIHggPSBhICogeDEgKyBjICogeTEgKyB0eCwgeSA9IGIgKiB4MSArIGQgKiB5MSArIHR5LCBtaW5YID0geCA8IG1pblggPyB4IDogbWluWCwgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblksIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYLCBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WSwgdGhpcy5taW5YID0gbWluWCwgdGhpcy5taW5ZID0gbWluWSwgdGhpcy5tYXhYID0gbWF4WCwgdGhpcy5tYXhZID0gbWF4WTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBzY3JlZW4gdmVydGljZXMgZnJvbSBhcnJheVxuICAgKiBAcGFyYW0gdmVydGV4RGF0YSAtIGNhbGN1bGF0ZWQgdmVydGljZXNcbiAgICogQHBhcmFtIGJlZ2luT2Zmc2V0IC0gYmVnaW4gb2Zmc2V0XG4gICAqIEBwYXJhbSBlbmRPZmZzZXQgLSBlbmQgb2Zmc2V0LCBleGNsdWRlZFxuICAgKi9cbiAgYWRkVmVydGV4RGF0YSh2ZXJ0ZXhEYXRhLCBiZWdpbk9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgbGV0IG1pblggPSB0aGlzLm1pblgsIG1pblkgPSB0aGlzLm1pblksIG1heFggPSB0aGlzLm1heFgsIG1heFkgPSB0aGlzLm1heFk7XG4gICAgZm9yIChsZXQgaSA9IGJlZ2luT2Zmc2V0OyBpIDwgZW5kT2Zmc2V0OyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSB2ZXJ0ZXhEYXRhW2ldLCB5ID0gdmVydGV4RGF0YVtpICsgMV07XG4gICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWCwgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblksIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYLCBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICB9XG4gICAgdGhpcy5taW5YID0gbWluWCwgdGhpcy5taW5ZID0gbWluWSwgdGhpcy5tYXhYID0gbWF4WCwgdGhpcy5tYXhZID0gbWF4WTtcbiAgfVxuICAvKipcbiAgICogQWRkIGFuIGFycmF5IG9mIG1lc2ggdmVydGljZXNcbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIG1lc2ggdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB2ZXJ0aWNlcyAtIG1lc2ggY29vcmRpbmF0ZXMgaW4gYXJyYXlcbiAgICogQHBhcmFtIGJlZ2luT2Zmc2V0IC0gYmVnaW4gb2Zmc2V0XG4gICAqIEBwYXJhbSBlbmRPZmZzZXQgLSBlbmQgb2Zmc2V0LCBleGNsdWRlZFxuICAgKi9cbiAgYWRkVmVydGljZXModHJhbnNmb3JtLCB2ZXJ0aWNlcywgYmVnaW5PZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIHRoaXMuYWRkVmVydGljZXNNYXRyaXgodHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLCB2ZXJ0aWNlcywgYmVnaW5PZmZzZXQsIGVuZE9mZnNldCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhbiBhcnJheSBvZiBtZXNoIHZlcnRpY2VzLlxuICAgKiBAcGFyYW0gbWF0cml4IC0gbWVzaCBtYXRyaXhcbiAgICogQHBhcmFtIHZlcnRpY2VzIC0gbWVzaCBjb29yZGluYXRlcyBpbiBhcnJheVxuICAgKiBAcGFyYW0gYmVnaW5PZmZzZXQgLSBiZWdpbiBvZmZzZXRcbiAgICogQHBhcmFtIGVuZE9mZnNldCAtIGVuZCBvZmZzZXQsIGV4Y2x1ZGVkXG4gICAqIEBwYXJhbSBwYWRYIC0geCBwYWRkaW5nXG4gICAqIEBwYXJhbSBwYWRZIC0geSBwYWRkaW5nXG4gICAqL1xuICBhZGRWZXJ0aWNlc01hdHJpeChtYXRyaXgsIHZlcnRpY2VzLCBiZWdpbk9mZnNldCwgZW5kT2Zmc2V0LCBwYWRYID0gMCwgcGFkWSA9IHBhZFgpIHtcbiAgICBjb25zdCBhID0gbWF0cml4LmEsIGIgPSBtYXRyaXguYiwgYyA9IG1hdHJpeC5jLCBkID0gbWF0cml4LmQsIHR4ID0gbWF0cml4LnR4LCB0eSA9IG1hdHJpeC50eTtcbiAgICBsZXQgbWluWCA9IHRoaXMubWluWCwgbWluWSA9IHRoaXMubWluWSwgbWF4WCA9IHRoaXMubWF4WCwgbWF4WSA9IHRoaXMubWF4WTtcbiAgICBmb3IgKGxldCBpID0gYmVnaW5PZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkgKz0gMikge1xuICAgICAgY29uc3QgcmF3WCA9IHZlcnRpY2VzW2ldLCByYXdZID0gdmVydGljZXNbaSArIDFdLCB4ID0gYSAqIHJhd1ggKyBjICogcmF3WSArIHR4LCB5ID0gZCAqIHJhd1kgKyBiICogcmF3WCArIHR5O1xuICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHggLSBwYWRYKSwgbWF4WCA9IE1hdGgubWF4KG1heFgsIHggKyBwYWRYKSwgbWluWSA9IE1hdGgubWluKG1pblksIHkgLSBwYWRZKSwgbWF4WSA9IE1hdGgubWF4KG1heFksIHkgKyBwYWRZKTtcbiAgICB9XG4gICAgdGhpcy5taW5YID0gbWluWCwgdGhpcy5taW5ZID0gbWluWSwgdGhpcy5tYXhYID0gbWF4WCwgdGhpcy5tYXhZID0gbWF4WTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvdGhlciB7QGxpbmsgUElYSS5Cb3VuZHN9LlxuICAgKiBAcGFyYW0gYm91bmRzIC0gVGhlIEJvdW5kcyB0byBiZSBhZGRlZFxuICAgKi9cbiAgYWRkQm91bmRzKGJvdW5kcykge1xuICAgIGNvbnN0IG1pblggPSB0aGlzLm1pblgsIG1pblkgPSB0aGlzLm1pblksIG1heFggPSB0aGlzLm1heFgsIG1heFkgPSB0aGlzLm1heFk7XG4gICAgdGhpcy5taW5YID0gYm91bmRzLm1pblggPCBtaW5YID8gYm91bmRzLm1pblggOiBtaW5YLCB0aGlzLm1pblkgPSBib3VuZHMubWluWSA8IG1pblkgPyBib3VuZHMubWluWSA6IG1pblksIHRoaXMubWF4WCA9IGJvdW5kcy5tYXhYID4gbWF4WCA/IGJvdW5kcy5tYXhYIDogbWF4WCwgdGhpcy5tYXhZID0gYm91bmRzLm1heFkgPiBtYXhZID8gYm91bmRzLm1heFkgOiBtYXhZO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG90aGVyIEJvdW5kcywgbWFza2VkIHdpdGggQm91bmRzLlxuICAgKiBAcGFyYW0gYm91bmRzIC0gVGhlIEJvdW5kcyB0byBiZSBhZGRlZC5cbiAgICogQHBhcmFtIG1hc2sgLSBUT0RPXG4gICAqL1xuICBhZGRCb3VuZHNNYXNrKGJvdW5kcywgbWFzaykge1xuICAgIGNvbnN0IF9taW5YID0gYm91bmRzLm1pblggPiBtYXNrLm1pblggPyBib3VuZHMubWluWCA6IG1hc2subWluWCwgX21pblkgPSBib3VuZHMubWluWSA+IG1hc2subWluWSA/IGJvdW5kcy5taW5ZIDogbWFzay5taW5ZLCBfbWF4WCA9IGJvdW5kcy5tYXhYIDwgbWFzay5tYXhYID8gYm91bmRzLm1heFggOiBtYXNrLm1heFgsIF9tYXhZID0gYm91bmRzLm1heFkgPCBtYXNrLm1heFkgPyBib3VuZHMubWF4WSA6IG1hc2subWF4WTtcbiAgICBpZiAoX21pblggPD0gX21heFggJiYgX21pblkgPD0gX21heFkpIHtcbiAgICAgIGNvbnN0IG1pblggPSB0aGlzLm1pblgsIG1pblkgPSB0aGlzLm1pblksIG1heFggPSB0aGlzLm1heFgsIG1heFkgPSB0aGlzLm1heFk7XG4gICAgICB0aGlzLm1pblggPSBfbWluWCA8IG1pblggPyBfbWluWCA6IG1pblgsIHRoaXMubWluWSA9IF9taW5ZIDwgbWluWSA/IF9taW5ZIDogbWluWSwgdGhpcy5tYXhYID0gX21heFggPiBtYXhYID8gX21heFggOiBtYXhYLCB0aGlzLm1heFkgPSBfbWF4WSA+IG1heFkgPyBfbWF4WSA6IG1heFk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGRzIG90aGVyIEJvdW5kcywgbXVsdGlwbGllZCBieSBtYXRyaXguIEJvdW5kcyBzaG91bGRuJ3QgYmUgZW1wdHkuXG4gICAqIEBwYXJhbSBib3VuZHMgLSBvdGhlciBib3VuZHNcbiAgICogQHBhcmFtIG1hdHJpeCAtIG11bHRpcGxpY2F0b3JcbiAgICovXG4gIGFkZEJvdW5kc01hdHJpeChib3VuZHMsIG1hdHJpeCkge1xuICAgIHRoaXMuYWRkRnJhbWVNYXRyaXgobWF0cml4LCBib3VuZHMubWluWCwgYm91bmRzLm1pblksIGJvdW5kcy5tYXhYLCBib3VuZHMubWF4WSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3RoZXIgQm91bmRzLCBtYXNrZWQgd2l0aCBSZWN0YW5nbGUuXG4gICAqIEBwYXJhbSBib3VuZHMgLSBUT0RPXG4gICAqIEBwYXJhbSBhcmVhIC0gVE9ET1xuICAgKi9cbiAgYWRkQm91bmRzQXJlYShib3VuZHMsIGFyZWEpIHtcbiAgICBjb25zdCBfbWluWCA9IGJvdW5kcy5taW5YID4gYXJlYS54ID8gYm91bmRzLm1pblggOiBhcmVhLngsIF9taW5ZID0gYm91bmRzLm1pblkgPiBhcmVhLnkgPyBib3VuZHMubWluWSA6IGFyZWEueSwgX21heFggPSBib3VuZHMubWF4WCA8IGFyZWEueCArIGFyZWEud2lkdGggPyBib3VuZHMubWF4WCA6IGFyZWEueCArIGFyZWEud2lkdGgsIF9tYXhZID0gYm91bmRzLm1heFkgPCBhcmVhLnkgKyBhcmVhLmhlaWdodCA/IGJvdW5kcy5tYXhZIDogYXJlYS55ICsgYXJlYS5oZWlnaHQ7XG4gICAgaWYgKF9taW5YIDw9IF9tYXhYICYmIF9taW5ZIDw9IF9tYXhZKSB7XG4gICAgICBjb25zdCBtaW5YID0gdGhpcy5taW5YLCBtaW5ZID0gdGhpcy5taW5ZLCBtYXhYID0gdGhpcy5tYXhYLCBtYXhZID0gdGhpcy5tYXhZO1xuICAgICAgdGhpcy5taW5YID0gX21pblggPCBtaW5YID8gX21pblggOiBtaW5YLCB0aGlzLm1pblkgPSBfbWluWSA8IG1pblkgPyBfbWluWSA6IG1pblksIHRoaXMubWF4WCA9IF9tYXhYID4gbWF4WCA/IF9tYXhYIDogbWF4WCwgdGhpcy5tYXhZID0gX21heFkgPiBtYXhZID8gX21heFkgOiBtYXhZO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGFkcyBib3VuZHMgb2JqZWN0LCBtYWtpbmcgaXQgZ3JvdyBpbiBhbGwgZGlyZWN0aW9ucy5cbiAgICogSWYgcGFkZGluZ1kgaXMgb21pdHRlZCwgYm90aCBwYWRkaW5nWCBhbmQgcGFkZGluZ1kgd2lsbCBiZSBzZXQgdG8gcGFkZGluZ1guXG4gICAqIEBwYXJhbSBwYWRkaW5nWCAtIFRoZSBob3Jpem9udGFsIHBhZGRpbmcgYW1vdW50LlxuICAgKiBAcGFyYW0gcGFkZGluZ1kgLSBUaGUgdmVydGljYWwgcGFkZGluZyBhbW91bnQuXG4gICAqL1xuICBwYWQocGFkZGluZ1ggPSAwLCBwYWRkaW5nWSA9IHBhZGRpbmdYKSB7XG4gICAgdGhpcy5pc0VtcHR5KCkgfHwgKHRoaXMubWluWCAtPSBwYWRkaW5nWCwgdGhpcy5tYXhYICs9IHBhZGRpbmdYLCB0aGlzLm1pblkgLT0gcGFkZGluZ1ksIHRoaXMubWF4WSArPSBwYWRkaW5nWSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgcGFkZGVkIGZyYW1lLiAoeDAsIHkwKSBzaG91bGQgYmUgc3RyaWN0bHkgbGVzcyB0aGFuICh4MSwgeTEpXG4gICAqIEBwYXJhbSB4MCAtIGxlZnQgWCBvZiBmcmFtZVxuICAgKiBAcGFyYW0geTAgLSB0b3AgWSBvZiBmcmFtZVxuICAgKiBAcGFyYW0geDEgLSByaWdodCBYIG9mIGZyYW1lXG4gICAqIEBwYXJhbSB5MSAtIGJvdHRvbSBZIG9mIGZyYW1lXG4gICAqIEBwYXJhbSBwYWRYIC0gcGFkZGluZyBYXG4gICAqIEBwYXJhbSBwYWRZIC0gcGFkZGluZyBZXG4gICAqL1xuICBhZGRGcmFtZVBhZCh4MCwgeTAsIHgxLCB5MSwgcGFkWCwgcGFkWSkge1xuICAgIHgwIC09IHBhZFgsIHkwIC09IHBhZFksIHgxICs9IHBhZFgsIHkxICs9IHBhZFksIHRoaXMubWluWCA9IHRoaXMubWluWCA8IHgwID8gdGhpcy5taW5YIDogeDAsIHRoaXMubWF4WCA9IHRoaXMubWF4WCA+IHgxID8gdGhpcy5tYXhYIDogeDEsIHRoaXMubWluWSA9IHRoaXMubWluWSA8IHkwID8gdGhpcy5taW5ZIDogeTAsIHRoaXMubWF4WSA9IHRoaXMubWF4WSA+IHkxID8gdGhpcy5tYXhZIDogeTE7XG4gIH1cbn1cbmV4cG9ydHMuQm91bmRzID0gQm91bmRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm91bmRzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCBEaXNwbGF5T2JqZWN0ID0gcmVxdWlyZShcIi4vRGlzcGxheU9iamVjdC5qc1wiKTtcbmNvbnN0IHRlbXBNYXRyaXggPSBuZXcgY29yZS5NYXRyaXgoKTtcbmZ1bmN0aW9uIHNvcnRDaGlsZHJlbihhLCBiKSB7XG4gIHJldHVybiBhLnpJbmRleCA9PT0gYi56SW5kZXggPyBhLl9sYXN0U29ydGVkSW5kZXggLSBiLl9sYXN0U29ydGVkSW5kZXggOiBhLnpJbmRleCAtIGIuekluZGV4O1xufVxuY29uc3QgX0NvbnRhaW5lciA9IGNsYXNzIF9Db250YWluZXIyIGV4dGVuZHMgRGlzcGxheU9iamVjdC5EaXNwbGF5T2JqZWN0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5jaGlsZHJlbiA9IFtdLCB0aGlzLnNvcnRhYmxlQ2hpbGRyZW4gPSBfQ29udGFpbmVyMi5kZWZhdWx0U29ydGFibGVDaGlsZHJlbiwgdGhpcy5zb3J0RGlydHkgPSAhMTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgbWV0aG9kIHRoYXQgY2FuIGJlIHVzZWQgYnkgQ29udGFpbmVyIHN1YmNsYXNzZXMgd2hlbmV2ZXIgdGhlIGNoaWxkcmVuIGFycmF5IGlzIG1vZGlmaWVkLlxuICAgKiBAcGFyYW0gX2xlbmd0aFxuICAgKi9cbiAgb25DaGlsZHJlbkNoYW5nZShfbGVuZ3RoKSB7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb25lIG9yIG1vcmUgY2hpbGRyZW4gdG8gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogTXVsdGlwbGUgaXRlbXMgY2FuIGJlIGFkZGVkIGxpa2Ugc286IGBteUNvbnRhaW5lci5hZGRDaGlsZCh0aGluZ09uZSwgdGhpbmdUd28sIHRoaW5nVGhyZWUpYFxuICAgKiBAcGFyYW0gey4uLlBJWEkuRGlzcGxheU9iamVjdH0gY2hpbGRyZW4gLSBUaGUgRGlzcGxheU9iamVjdChzKSB0byBhZGQgdG8gdGhlIGNvbnRhaW5lclxuICAgKiBAcmV0dXJucyB7UElYSS5EaXNwbGF5T2JqZWN0fSAtIFRoZSBmaXJzdCBjaGlsZCB0aGF0IHdhcyBhZGRlZC5cbiAgICovXG4gIGFkZENoaWxkKC4uLmNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzLmFkZENoaWxkKGNoaWxkcmVuW2ldKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgICBjaGlsZC5wYXJlbnQgJiYgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKSwgY2hpbGQucGFyZW50ID0gdGhpcywgdGhpcy5zb3J0RGlydHkgPSAhMCwgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xLCB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpLCB0aGlzLl9ib3VuZHNJRCsrLCB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UodGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSwgdGhpcy5lbWl0KFwiY2hpbGRBZGRlZFwiLCBjaGlsZCwgdGhpcywgdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSwgY2hpbGQuZW1pdChcImFkZGVkXCIsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW5bMF07XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGlsZCB0byB0aGUgY29udGFpbmVyIGF0IGEgc3BlY2lmaWVkIGluZGV4LiBJZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcyBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICogSWYgdGhlIGNoaWxkIGlzIGFscmVhZHkgaW4gdGhpcyBjb250YWluZXIsIGl0IHdpbGwgYmUgbW92ZWQgdG8gdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIGNoaWxkIHRvIGFkZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGFic29sdXRlIGluZGV4IHdoZXJlIHRoZSBjaGlsZCB3aWxsIGJlIHBvc2l0aW9uZWQgYXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgYWRkZWQuXG4gICAqL1xuICBhZGRDaGlsZEF0KGNoaWxkLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjaGlsZH1hZGRDaGlsZEF0OiBUaGUgaW5kZXggJHtpbmRleH0gc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyAke3RoaXMuY2hpbGRyZW4ubGVuZ3RofWApO1xuICAgIHJldHVybiBjaGlsZC5wYXJlbnQgJiYgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKSwgY2hpbGQucGFyZW50ID0gdGhpcywgdGhpcy5zb3J0RGlydHkgPSAhMCwgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xLCB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpLCB0aGlzLl9ib3VuZHNJRCsrLCB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpLCBjaGlsZC5lbWl0KFwiYWRkZWRcIiwgdGhpcyksIHRoaXMuZW1pdChcImNoaWxkQWRkZWRcIiwgY2hpbGQsIHRoaXMsIGluZGV4KSwgY2hpbGQ7XG4gIH1cbiAgLyoqXG4gICAqIFN3YXBzIHRoZSBwb3NpdGlvbiBvZiAyIERpc3BsYXkgT2JqZWN0cyB3aXRoaW4gdGhpcyBjb250YWluZXIuXG4gICAqIEBwYXJhbSBjaGlsZCAtIEZpcnN0IGRpc3BsYXkgb2JqZWN0IHRvIHN3YXBcbiAgICogQHBhcmFtIGNoaWxkMiAtIFNlY29uZCBkaXNwbGF5IG9iamVjdCB0byBzd2FwXG4gICAqL1xuICBzd2FwQ2hpbGRyZW4oY2hpbGQsIGNoaWxkMikge1xuICAgIGlmIChjaGlsZCA9PT0gY2hpbGQyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGluZGV4MSA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZCksIGluZGV4MiA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZDIpO1xuICAgIHRoaXMuY2hpbGRyZW5baW5kZXgxXSA9IGNoaWxkMiwgdGhpcy5jaGlsZHJlbltpbmRleDJdID0gY2hpbGQsIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleDEgPCBpbmRleDIgPyBpbmRleDEgOiBpbmRleDIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBwb3NpdGlvbiBvZiBhIGNoaWxkIERpc3BsYXlPYmplY3QgaW5zdGFuY2VcbiAgICogQHBhcmFtIGNoaWxkIC0gVGhlIERpc3BsYXlPYmplY3QgaW5zdGFuY2UgdG8gaWRlbnRpZnlcbiAgICogQHJldHVybnMgLSBUaGUgaW5kZXggcG9zaXRpb24gb2YgdGhlIGNoaWxkIGRpc3BsYXkgb2JqZWN0IHRvIGlkZW50aWZ5XG4gICAqL1xuICBnZXRDaGlsZEluZGV4KGNoaWxkKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3VwcGxpZWQgRGlzcGxheU9iamVjdCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIGNhbGxlclwiKTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIGFuIGV4aXN0aW5nIGNoaWxkIGluIHRoZSBkaXNwbGF5IG9iamVjdCBjb250YWluZXJcbiAgICogQHBhcmFtIGNoaWxkIC0gVGhlIGNoaWxkIERpc3BsYXlPYmplY3QgaW5zdGFuY2UgZm9yIHdoaWNoIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgaW5kZXggbnVtYmVyXG4gICAqIEBwYXJhbSBpbmRleCAtIFRoZSByZXN1bHRpbmcgaW5kZXggbnVtYmVyIGZvciB0aGUgY2hpbGQgZGlzcGxheSBvYmplY3RcbiAgICovXG4gIHNldENoaWxkSW5kZXgoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGluZGV4ICR7aW5kZXh9IHN1cHBsaWVkIGlzIG91dCBvZiBib3VuZHMgJHt0aGlzLmNoaWxkcmVuLmxlbmd0aH1gKTtcbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgIGNvcmUudXRpbHMucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgY3VycmVudEluZGV4LCAxKSwgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKSwgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggdG8gZ2V0IHRoZSBjaGlsZCBhdFxuICAgKiBAcmV0dXJucyAtIFRoZSBjaGlsZCBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGFueS5cbiAgICovXG4gIGdldENoaWxkQXQoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBnZXRDaGlsZEF0OiBJbmRleCAoJHtpbmRleH0pIGRvZXMgbm90IGV4aXN0LmApO1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2luZGV4XTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBvbmUgb3IgbW9yZSBjaGlsZHJlbiBmcm9tIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7Li4uUElYSS5EaXNwbGF5T2JqZWN0fSBjaGlsZHJlbiAtIFRoZSBEaXNwbGF5T2JqZWN0KHMpIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJucyB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgZmlyc3QgY2hpbGQgdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZUNoaWxkKC4uLmNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGNoaWxkcmVuW2ldKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF0sIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2hpbGQucGFyZW50ID0gbnVsbCwgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xLCBjb3JlLnV0aWxzLnJlbW92ZUl0ZW1zKHRoaXMuY2hpbGRyZW4sIGluZGV4LCAxKSwgdGhpcy5fYm91bmRzSUQrKywgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KSwgY2hpbGQuZW1pdChcInJlbW92ZWRcIiwgdGhpcyksIHRoaXMuZW1pdChcImNoaWxkUmVtb3ZlZFwiLCBjaGlsZCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW5bMF07XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjaGlsZCBmcm9tIHRoZSBzcGVjaWZpZWQgaW5kZXggcG9zaXRpb24uXG4gICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB0byBnZXQgdGhlIGNoaWxkIGZyb21cbiAgICogQHJldHVybnMgVGhlIGNoaWxkIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmVDaGlsZEF0KGluZGV4KSB7XG4gICAgY29uc3QgY2hpbGQgPSB0aGlzLmdldENoaWxkQXQoaW5kZXgpO1xuICAgIHJldHVybiBjaGlsZC5wYXJlbnQgPSBudWxsLCBjaGlsZC50cmFuc2Zvcm0uX3BhcmVudElEID0gLTEsIGNvcmUudXRpbHMucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgaW5kZXgsIDEpLCB0aGlzLl9ib3VuZHNJRCsrLCB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpLCBjaGlsZC5lbWl0KFwicmVtb3ZlZFwiLCB0aGlzKSwgdGhpcy5lbWl0KFwiY2hpbGRSZW1vdmVkXCIsIGNoaWxkLCB0aGlzLCBpbmRleCksIGNoaWxkO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoaXMgY29udGFpbmVyIHRoYXQgYXJlIHdpdGhpbiB0aGUgYmVnaW4gYW5kIGVuZCBpbmRleGVzLlxuICAgKiBAcGFyYW0gYmVnaW5JbmRleCAtIFRoZSBiZWdpbm5pbmcgcG9zaXRpb24uXG4gICAqIEBwYXJhbSBlbmRJbmRleCAtIFRoZSBlbmRpbmcgcG9zaXRpb24uIERlZmF1bHQgdmFsdWUgaXMgc2l6ZSBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcmV0dXJucyAtIExpc3Qgb2YgcmVtb3ZlZCBjaGlsZHJlblxuICAgKi9cbiAgcmVtb3ZlQ2hpbGRyZW4oYmVnaW5JbmRleCA9IDAsIGVuZEluZGV4ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjb25zdCBiZWdpbiA9IGJlZ2luSW5kZXgsIGVuZCA9IGVuZEluZGV4LCByYW5nZSA9IGVuZCAtIGJlZ2luO1xuICAgIGxldCByZW1vdmVkO1xuICAgIGlmIChyYW5nZSA+IDAgJiYgcmFuZ2UgPD0gZW5kKSB7XG4gICAgICByZW1vdmVkID0gdGhpcy5jaGlsZHJlbi5zcGxpY2UoYmVnaW4sIHJhbmdlKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgcmVtb3ZlZFtpXS5wYXJlbnQgPSBudWxsLCByZW1vdmVkW2ldLnRyYW5zZm9ybSAmJiAocmVtb3ZlZFtpXS50cmFuc2Zvcm0uX3BhcmVudElEID0gLTEpO1xuICAgICAgdGhpcy5fYm91bmRzSUQrKywgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGJlZ2luSW5kZXgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgKytpKVxuICAgICAgICByZW1vdmVkW2ldLmVtaXQoXCJyZW1vdmVkXCIsIHRoaXMpLCB0aGlzLmVtaXQoXCJjaGlsZFJlbW92ZWRcIiwgcmVtb3ZlZFtpXSwgdGhpcywgaSk7XG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9IGVsc2UgaWYgKHJhbmdlID09PSAwICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwicmVtb3ZlQ2hpbGRyZW46IG51bWVyaWMgdmFsdWVzIGFyZSBvdXRzaWRlIHRoZSBhY2NlcHRhYmxlIHJhbmdlLlwiKTtcbiAgfVxuICAvKiogU29ydHMgY2hpbGRyZW4gYnkgekluZGV4LiBQcmV2aW91cyBvcmRlciBpcyBtYWludGFpbmVkIGZvciAyIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUgekluZGV4LiAqL1xuICBzb3J0Q2hpbGRyZW4oKSB7XG4gICAgbGV0IHNvcnRSZXF1aXJlZCA9ICExO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGNoaWxkLl9sYXN0U29ydGVkSW5kZXggPSBpLCAhc29ydFJlcXVpcmVkICYmIGNoaWxkLnpJbmRleCAhPT0gMCAmJiAoc29ydFJlcXVpcmVkID0gITApO1xuICAgIH1cbiAgICBzb3J0UmVxdWlyZWQgJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAxICYmIHRoaXMuY2hpbGRyZW4uc29ydChzb3J0Q2hpbGRyZW4pLCB0aGlzLnNvcnREaXJ0eSA9ICExO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSB0cmFuc2Zvcm0gb24gYWxsIGNoaWxkcmVuIG9mIHRoaXMgY29udGFpbmVyIGZvciByZW5kZXJpbmcuICovXG4gIHVwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICB0aGlzLnNvcnRhYmxlQ2hpbGRyZW4gJiYgdGhpcy5zb3J0RGlydHkgJiYgdGhpcy5zb3J0Q2hpbGRyZW4oKSwgdGhpcy5fYm91bmRzSUQrKywgdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMucGFyZW50LnRyYW5zZm9ybSksIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGNoaWxkLnZpc2libGUgJiYgY2hpbGQudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZWNhbGN1bGF0ZXMgdGhlIGJvdW5kcyBvZiB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIHdpbGwgYXV0b21hdGljYWxseSBmaXQgdGhlIGNoaWxkcmVuJ3MgYm91bmRzIGludG8gdGhlIGNhbGN1bGF0aW9uLiBFYWNoIGNoaWxkJ3MgYm91bmRzXG4gICAqIGlzIGxpbWl0ZWQgdG8gaXRzIG1hc2sncyBib3VuZHMgb3IgZmlsdGVyQXJlYSwgaWYgYW55IGlzIGFwcGxpZWQuXG4gICAqL1xuICBjYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgdGhpcy5fYm91bmRzLmNsZWFyKCksIHRoaXMuX2NhbGN1bGF0ZUJvdW5kcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKCEoIWNoaWxkLnZpc2libGUgfHwgIWNoaWxkLnJlbmRlcmFibGUpKVxuICAgICAgICBpZiAoY2hpbGQuY2FsY3VsYXRlQm91bmRzKCksIGNoaWxkLl9tYXNrKSB7XG4gICAgICAgICAgY29uc3QgbWFza09iamVjdCA9IGNoaWxkLl9tYXNrLmlzTWFza0RhdGEgPyBjaGlsZC5fbWFzay5tYXNrT2JqZWN0IDogY2hpbGQuX21hc2s7XG4gICAgICAgICAgbWFza09iamVjdCA/IChtYXNrT2JqZWN0LmNhbGN1bGF0ZUJvdW5kcygpLCB0aGlzLl9ib3VuZHMuYWRkQm91bmRzTWFzayhjaGlsZC5fYm91bmRzLCBtYXNrT2JqZWN0Ll9ib3VuZHMpKSA6IHRoaXMuX2JvdW5kcy5hZGRCb3VuZHMoY2hpbGQuX2JvdW5kcyk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGNoaWxkLmZpbHRlckFyZWEgPyB0aGlzLl9ib3VuZHMuYWRkQm91bmRzQXJlYShjaGlsZC5fYm91bmRzLCBjaGlsZC5maWx0ZXJBcmVhKSA6IHRoaXMuX2JvdW5kcy5hZGRCb3VuZHMoY2hpbGQuX2JvdW5kcyk7XG4gICAgfVxuICAgIHRoaXMuX2JvdW5kcy51cGRhdGVJRCA9IHRoaXMuX2JvdW5kc0lEO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgZGlzcGxheU9iamVjdCBhcyBhIHJlY3RhbmdsZSBvYmplY3QuXG4gICAqXG4gICAqIENhbGxpbmcgYGdldExvY2FsQm91bmRzYCBtYXkgaW52YWxpZGF0ZSB0aGUgYF9ib3VuZHNgIG9mIHRoZSB3aG9sZSBzdWJ0cmVlIGJlbG93LiBJZiB1c2luZyBpdCBpbnNpZGUgYSByZW5kZXIoKVxuICAgKiBjYWxsLCBpdCBpcyBhZHZpc2VkIHRvIGNhbGwgYGdldEJvdW5kcygpYCBpbW1lZGlhdGVseSBhZnRlciB0byByZWNhbGN1bGF0ZSB0aGUgd29ybGQgYm91bmRzIG9mIHRoZSBzdWJ0cmVlLlxuICAgKiBAcGFyYW0gcmVjdCAtIE9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBib3VuZHMgY2FsY3VsYXRpb24uXG4gICAqIEBwYXJhbSBza2lwQ2hpbGRyZW5VcGRhdGUgLSBTZXR0aW5nIHRvIGB0cnVlYCB3aWxsIHN0b3AgcmUtY2FsY3VsYXRpb24gb2YgY2hpbGRyZW4gdHJhbnNmb3JtcyxcbiAgICogIGl0IHdhcyBkZWZhdWx0IGJlaGF2aW91ciBvZiBwaXhpIDQuMC01LjIgYW5kIGNhdXNlZCBtYW55IHByb2JsZW1zIHRvIHVzZXJzLlxuICAgKiBAcmV0dXJucyAtIFRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhLlxuICAgKi9cbiAgZ2V0TG9jYWxCb3VuZHMocmVjdCwgc2tpcENoaWxkcmVuVXBkYXRlID0gITEpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5nZXRMb2NhbEJvdW5kcyhyZWN0KTtcbiAgICBpZiAoIXNraXBDaGlsZHJlblVwZGF0ZSlcbiAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBjaGlsZC52aXNpYmxlICYmIGNoaWxkLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlY2FsY3VsYXRlcyB0aGUgY29udGVudCBib3VuZHMgb2YgdGhpcyBvYmplY3QuIFRoaXMgc2hvdWxkIGJlIG92ZXJyaWRlbiB0b1xuICAgKiBjYWxjdWxhdGUgdGhlIGJvdW5kcyBvZiB0aGlzIHNwZWNpZmljIG9iamVjdCAobm90IGluY2x1ZGluZyBjaGlsZHJlbikuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBvYmplY3QgYW5kIGl0cyBjaGlsZHJlbiB3aXRoIGN1bGxpbmcuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgKi9cbiAgX3JlbmRlcldpdGhDdWxsaW5nKHJlbmRlcmVyKSB7XG4gICAgY29uc3Qgc291cmNlRnJhbWUgPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlLnNvdXJjZUZyYW1lO1xuICAgIGlmICghKHNvdXJjZUZyYW1lLndpZHRoID4gMCAmJiBzb3VyY2VGcmFtZS5oZWlnaHQgPiAwKSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgYm91bmRzLCB0cmFuc2Zvcm07XG4gICAgdGhpcy5jdWxsQXJlYSA/IChib3VuZHMgPSB0aGlzLmN1bGxBcmVhLCB0cmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtKSA6IHRoaXMuX3JlbmRlciAhPT0gX0NvbnRhaW5lcjIucHJvdG90eXBlLl9yZW5kZXIgJiYgKGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCEwKSk7XG4gICAgY29uc3QgcHJvamVjdGlvblRyYW5zZm9ybSA9IHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtO1xuICAgIGlmIChwcm9qZWN0aW9uVHJhbnNmb3JtICYmICh0cmFuc2Zvcm0gPyAodHJhbnNmb3JtID0gdGVtcE1hdHJpeC5jb3B5RnJvbSh0cmFuc2Zvcm0pLCB0cmFuc2Zvcm0ucHJlcGVuZChwcm9qZWN0aW9uVHJhbnNmb3JtKSkgOiB0cmFuc2Zvcm0gPSBwcm9qZWN0aW9uVHJhbnNmb3JtKSwgYm91bmRzICYmIHNvdXJjZUZyYW1lLmludGVyc2VjdHMoYm91bmRzLCB0cmFuc2Zvcm0pKVxuICAgICAgdGhpcy5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgICBlbHNlIGlmICh0aGlzLmN1bGxBcmVhKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgY2hpbGRDdWxsYWJsZSA9IGNoaWxkLmN1bGxhYmxlO1xuICAgICAgY2hpbGQuY3VsbGFibGUgPSBjaGlsZEN1bGxhYmxlIHx8ICF0aGlzLmN1bGxBcmVhLCBjaGlsZC5yZW5kZXIocmVuZGVyZXIpLCBjaGlsZC5jdWxsYWJsZSA9IGNoaWxkQ3VsbGFibGU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyLlxuICAgKlxuICAgKiBUaGUgW19yZW5kZXJde0BsaW5rIFBJWEkuQ29udGFpbmVyI19yZW5kZXJ9IG1ldGhvZCBpcyBiZSBvdmVycmlkZW4gZm9yIHJlbmRlcmluZyB0aGUgY29udGVudHMgb2YgdGhlXG4gICAqIGNvbnRhaW5lciBpdHNlbGYuIFRoaXMgYHJlbmRlcmAgbWV0aG9kIHdpbGwgaW52b2tlIGl0LCBhbmQgYWxzbyBpbnZva2UgdGhlIGByZW5kZXJgIG1ldGhvZHMgb2YgYWxsXG4gICAqIGNoaWxkcmVuIGFmdGVyd2FyZC5cbiAgICpcbiAgICogSWYgYHJlbmRlcmFibGVgIG9yIGB2aXNpYmxlYCBpcyBmYWxzZSBvciBpZiBgd29ybGRBbHBoYWAgaXMgbm90IHBvc2l0aXZlIG9yIGlmIGBjdWxsYWJsZWAgaXMgdHJ1ZSBhbmRcbiAgICogdGhlIGJvdW5kcyBvZiB0aGlzIG9iamVjdCBhcmUgb3V0IG9mIGZyYW1lLCB0aGlzIGltcGxlbWVudGF0aW9uIHdpbGwgZW50aXJlbHkgc2tpcCByZW5kZXJpbmcuXG4gICAqIFNlZSB7QGxpbmsgUElYSS5EaXNwbGF5T2JqZWN0fSBmb3IgY2hvb3NpbmcgYmV0d2VlbiBgcmVuZGVyYWJsZWAgb3IgYHZpc2libGVgLiBHZW5lcmFsbHksXG4gICAqIHNldHRpbmcgYWxwaGEgdG8gemVybyBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHB1cmVseSBza2lwcGluZyByZW5kZXJpbmcuXG4gICAqXG4gICAqIFdoZW4geW91ciBzY2VuZSBiZWNvbWVzIGxhcmdlIChlc3BlY2lhbGx5IHdoZW4gaXQgaXMgbGFyZ2VyIHRoYW4gY2FuIGJlIHZpZXdlZCBpbiBhIHNpbmdsZSBzY3JlZW4pLCBpdCBpc1xuICAgKiBhZHZpc2VkIHRvIGVtcGxveSAqKmN1bGxpbmcqKiB0byBhdXRvbWF0aWNhbGx5IHNraXAgcmVuZGVyaW5nIG9iamVjdHMgb3V0c2lkZSBvZiB0aGUgY3VycmVudCBzY3JlZW4uXG4gICAqIFNlZSBbY3VsbGFibGVde0BsaW5rIFBJWEkuRGlzcGxheU9iamVjdCNjdWxsYWJsZX0gYW5kIFtjdWxsQXJlYV17QGxpbmsgUElYSS5EaXNwbGF5T2JqZWN0I2N1bGxBcmVhfS5cbiAgICogT3RoZXIgY3VsbGluZyBtZXRob2RzIG1pZ2h0IGJlIGJldHRlciBzdWl0ZWQgZm9yIGEgbGFyZ2UgbnVtYmVyIHN0YXRpYyBvYmplY3RzOyBzZWVcbiAgICogW0BwaXhpLWVzc2VudGlhbHMvY3VsbF17QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQHBpeGktZXNzZW50aWFscy9jdWxsfSBhbmRcbiAgICogW3BpeGktY3VsbF17QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGl4aS1jdWxsfS5cbiAgICpcbiAgICogVGhlIFtyZW5kZXJBZHZhbmNlZF17QGxpbmsgUElYSS5Db250YWluZXIjcmVuZGVyQWR2YW5jZWR9IG1ldGhvZCBpcyBpbnRlcm5hbGx5IHVzZWQgd2hlbiB3aGVuIG1hc2tpbmcgb3JcbiAgICogZmlsdGVyaW5nIGlzIGFwcGxpZWQgb24gYSBjb250YWluZXIuIFRoaXMgZG9lcywgaG93ZXZlciwgYnJlYWsgYmF0Y2hpbmcgYW5kIGNhbiBhZmZlY3QgcGVyZm9ybWFuY2Ugd2hlblxuICAgKiBtYXNraW5nIGFuZCBmaWx0ZXJpbmcgaXMgYXBwbGllZCBleHRlbnNpdmVseSB0aHJvdWdob3V0IHRoZSBzY2VuZSBncmFwaC5cbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIpIHtcbiAgICBpZiAoISghdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUpKVxuICAgICAgaWYgKHRoaXMuX21hc2sgfHwgdGhpcy5maWx0ZXJzPy5sZW5ndGgpXG4gICAgICAgIHRoaXMucmVuZGVyQWR2YW5jZWQocmVuZGVyZXIpO1xuICAgICAgZWxzZSBpZiAodGhpcy5jdWxsYWJsZSlcbiAgICAgICAgdGhpcy5fcmVuZGVyV2l0aEN1bGxpbmcocmVuZGVyZXIpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcihyZW5kZXJlcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpXG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXIgYW5kIGFkdmFuY2VkIGZlYXR1cmVzLlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICovXG4gIHJlbmRlckFkdmFuY2VkKHJlbmRlcmVyKSB7XG4gICAgY29uc3QgZmlsdGVycyA9IHRoaXMuZmlsdGVycywgbWFzayA9IHRoaXMuX21hc2s7XG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWRGaWx0ZXJzIHx8ICh0aGlzLl9lbmFibGVkRmlsdGVycyA9IFtdKSwgdGhpcy5fZW5hYmxlZEZpbHRlcnMubGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgZmlsdGVyc1tpXS5lbmFibGVkICYmIHRoaXMuX2VuYWJsZWRGaWx0ZXJzLnB1c2goZmlsdGVyc1tpXSk7XG4gICAgfVxuICAgIGNvbnN0IGZsdXNoID0gZmlsdGVycyAmJiB0aGlzLl9lbmFibGVkRmlsdGVycz8ubGVuZ3RoIHx8IG1hc2sgJiYgKCFtYXNrLmlzTWFza0RhdGEgfHwgbWFzay5lbmFibGVkICYmIChtYXNrLmF1dG9EZXRlY3QgfHwgbWFzay50eXBlICE9PSBjb3JlLk1BU0tfVFlQRVMuTk9ORSkpO1xuICAgIGlmIChmbHVzaCAmJiByZW5kZXJlci5iYXRjaC5mbHVzaCgpLCBmaWx0ZXJzICYmIHRoaXMuX2VuYWJsZWRGaWx0ZXJzPy5sZW5ndGggJiYgcmVuZGVyZXIuZmlsdGVyLnB1c2godGhpcywgdGhpcy5fZW5hYmxlZEZpbHRlcnMpLCBtYXNrICYmIHJlbmRlcmVyLm1hc2sucHVzaCh0aGlzLCB0aGlzLl9tYXNrKSwgdGhpcy5jdWxsYWJsZSlcbiAgICAgIHRoaXMuX3JlbmRlcldpdGhDdWxsaW5nKHJlbmRlcmVyKTtcbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlcihyZW5kZXJlcik7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKVxuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnJlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuICAgIGZsdXNoICYmIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCksIG1hc2sgJiYgcmVuZGVyZXIubWFzay5wb3AodGhpcyksIGZpbHRlcnMgJiYgdGhpcy5fZW5hYmxlZEZpbHRlcnM/Lmxlbmd0aCAmJiByZW5kZXJlci5maWx0ZXIucG9wKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRvIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHN1YmNsYXNzZXMuXG4gICAqIEBwYXJhbSBfcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICovXG4gIF9yZW5kZXIoX3JlbmRlcmVyKSB7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGludGVybmFsIHJlZmVyZW5jZXMgYW5kIGxpc3RlbmVycyBhcyB3ZWxsIGFzIHJlbW92ZXMgY2hpbGRyZW4gZnJvbSB0aGUgZGlzcGxheSBsaXN0LlxuICAgKiBEbyBub3QgdXNlIGEgQ29udGFpbmVyIGFmdGVyIGNhbGxpbmcgYGRlc3Ryb3lgLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoaWxkcmVuPWZhbHNlXSAtIGlmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZSB0aGVpciBkZXN0cm95XG4gICAqICBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAqICBTaG91bGQgaXQgZGVzdHJveSB0aGUgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcbiAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgKi9cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpLCB0aGlzLnNvcnREaXJ0eSA9ICExO1xuICAgIGNvbnN0IGRlc3Ryb3lDaGlsZHJlbiA9IHR5cGVvZiBvcHRpb25zID09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6IG9wdGlvbnM/LmNoaWxkcmVuLCBvbGRDaGlsZHJlbiA9IHRoaXMucmVtb3ZlQ2hpbGRyZW4oMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIGlmIChkZXN0cm95Q2hpbGRyZW4pXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9sZENoaWxkcmVuLmxlbmd0aDsgKytpKVxuICAgICAgICBvbGRDaGlsZHJlbltpXS5kZXN0cm95KG9wdGlvbnMpO1xuICB9XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIENvbnRhaW5lciwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXQuICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZS54ICogdGhpcy5nZXRMb2NhbEJvdW5kcygpLndpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLndpZHRoO1xuICAgIHdpZHRoICE9PSAwID8gdGhpcy5zY2FsZS54ID0gdmFsdWUgLyB3aWR0aCA6IHRoaXMuc2NhbGUueCA9IDEsIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gIH1cbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIENvbnRhaW5lciwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXQuICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGUueSAqIHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5oZWlnaHQ7XG4gICAgaGVpZ2h0ICE9PSAwID8gdGhpcy5zY2FsZS55ID0gdmFsdWUgLyBoZWlnaHQgOiB0aGlzLnNjYWxlLnkgPSAxLCB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgfVxufTtcbl9Db250YWluZXIuZGVmYXVsdFNvcnRhYmxlQ2hpbGRyZW4gPSAhMTtcbmxldCBDb250YWluZXIgPSBfQ29udGFpbmVyO1xuQ29udGFpbmVyLnByb3RvdHlwZS5jb250YWluZXJVcGRhdGVUcmFuc2Zvcm0gPSBDb250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybTtcbmV4cG9ydHMuQ29udGFpbmVyID0gQ29udGFpbmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udGFpbmVyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCBCb3VuZHMgPSByZXF1aXJlKFwiLi9Cb3VuZHMuanNcIik7XG5jbGFzcyBEaXNwbGF5T2JqZWN0IGV4dGVuZHMgY29yZS51dGlscy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpLCB0aGlzLnRlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID0gbnVsbCwgdGhpcy50cmFuc2Zvcm0gPSBuZXcgY29yZS5UcmFuc2Zvcm0oKSwgdGhpcy5hbHBoYSA9IDEsIHRoaXMudmlzaWJsZSA9ICEwLCB0aGlzLnJlbmRlcmFibGUgPSAhMCwgdGhpcy5jdWxsYWJsZSA9ICExLCB0aGlzLmN1bGxBcmVhID0gbnVsbCwgdGhpcy5wYXJlbnQgPSBudWxsLCB0aGlzLndvcmxkQWxwaGEgPSAxLCB0aGlzLl9sYXN0U29ydGVkSW5kZXggPSAwLCB0aGlzLl96SW5kZXggPSAwLCB0aGlzLmZpbHRlckFyZWEgPSBudWxsLCB0aGlzLmZpbHRlcnMgPSBudWxsLCB0aGlzLl9lbmFibGVkRmlsdGVycyA9IG51bGwsIHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMuQm91bmRzKCksIHRoaXMuX2xvY2FsQm91bmRzID0gbnVsbCwgdGhpcy5fYm91bmRzSUQgPSAwLCB0aGlzLl9ib3VuZHNSZWN0ID0gbnVsbCwgdGhpcy5fbG9jYWxCb3VuZHNSZWN0ID0gbnVsbCwgdGhpcy5fbWFzayA9IG51bGwsIHRoaXMuX21hc2tSZWZDb3VudCA9IDAsIHRoaXMuX2Rlc3Ryb3llZCA9ICExLCB0aGlzLmlzU3ByaXRlID0gITEsIHRoaXMuaXNNYXNrID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIE1peGVzIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZnJvbSBhIHNvdXJjZSBvYmplY3QgdG8gRGlzcGxheU9iamVjdC5cbiAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2YgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0byBtaXggaW4uXG4gICAqL1xuICBzdGF0aWMgbWl4aW4oc291cmNlKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBrZXlzW2ldO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICBEaXNwbGF5T2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgcHJvcGVydHlOYW1lLFxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgcHJvcGVydHlOYW1lKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhpcyBEaXNwbGF5T2JqZWN0IGlzIGFkZGVkIHRvIGEgQ29udGFpbmVyLlxuICAgKiBAaW5zdGFuY2VcbiAgICogQGV2ZW50IGFkZGVkXG4gICAqIEBwYXJhbSB7UElYSS5Db250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgYWRkZWQgdG8uXG4gICAqL1xuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGlzIERpc3BsYXlPYmplY3QgaXMgcmVtb3ZlZCBmcm9tIGEgQ29udGFpbmVyLlxuICAgKiBAaW5zdGFuY2VcbiAgICogQGV2ZW50IHJlbW92ZWRcbiAgICogQHBhcmFtIHtQSVhJLkNvbnRhaW5lcn0gY29udGFpbmVyIC0gVGhlIGNvbnRhaW5lciByZW1vdmVkIGZyb20uXG4gICAqL1xuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGlzIERpc3BsYXlPYmplY3QgaXMgZGVzdHJveWVkLiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgb25jZVxuICAgKiBkZXN0cm95IGlzIGZpbmlzaGVkLlxuICAgKiBAaW5zdGFuY2VcbiAgICogQGV2ZW50IGRlc3Ryb3llZFxuICAgKi9cbiAgLyoqIFJlYWRvbmx5IGZsYWcgZm9yIGRlc3Ryb3llZCBkaXNwbGF5IG9iamVjdHMuICovXG4gIGdldCBkZXN0cm95ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rlc3Ryb3llZDtcbiAgfVxuICAvKiogUmVjdXJzaXZlbHkgdXBkYXRlcyB0cmFuc2Zvcm0gb2YgYWxsIG9iamVjdHMgZnJvbSB0aGUgcm9vdCB0byB0aGlzIG9uZSBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgdG9Mb2NhbCgpICovXG4gIF9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCkge1xuICAgIHRoaXMucGFyZW50ID8gKHRoaXMucGFyZW50Ll9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCksIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLnBhcmVudC50cmFuc2Zvcm0pKSA6IHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudC50cmFuc2Zvcm0pO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmcuIFRPRE8gLSBPcHRpbWl6YXRpb24gcGFzcyEgKi9cbiAgdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgIHRoaXMuX2JvdW5kc0lEKyssIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLnBhcmVudC50cmFuc2Zvcm0pLCB0aGlzLndvcmxkQWxwaGEgPSB0aGlzLmFscGhhICogdGhpcy5wYXJlbnQud29ybGRBbHBoYTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgKHdvcmxkKSBib3VuZHMgb2YgdGhlIGRpc3BsYXkgb2JqZWN0IGFzIGEgW1JlY3RhbmdsZV17QGxpbmsgUElYSS5SZWN0YW5nbGV9LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBleHBlbnNpdmUgb24gY29udGFpbmVycyB3aXRoIGEgbGFyZ2Ugc3VidHJlZSAobGlrZSB0aGUgc3RhZ2UpLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGJvdW5kc1xuICAgKiBvZiBhIGNvbnRhaW5lciBkZXBlbmQgb24gaXRzIGNoaWxkcmVuJ3MgYm91bmRzLCB3aGljaCByZWN1cnNpdmVseSBjYXVzZXMgYWxsIGJvdW5kcyBpbiB0aGUgc3VidHJlZSB0b1xuICAgKiBiZSByZWNhbGN1bGF0ZWQuIFRoZSB1cHNpZGUsIGhvd2V2ZXIsIGlzIHRoYXQgY2FsbGluZyBgZ2V0Qm91bmRzYCBvbmNlIG9uIGEgY29udGFpbmVyIHdpbGwgaW5kZWVkIHVwZGF0ZVxuICAgKiB0aGUgYm91bmRzIG9mIGFsbCBjaGlsZHJlbiAodGhlIHdob2xlIHN1YnRyZWUsIGluIGZhY3QpLiBUaGlzIHNpZGUgZWZmZWN0IHNob3VsZCBiZSBleHBsb2l0ZWQgYnkgdXNpbmdcbiAgICogYGRpc3BsYXlPYmplY3QuX2JvdW5kcy5nZXRSZWN0YW5nbGUoKWAgd2hlbiB0cmF2ZXJzaW5nIHRocm91Z2ggYWxsIHRoZSBib3VuZHMgaW4gYSBzY2VuZSBncmFwaC4gT3RoZXJ3aXNlLFxuICAgKiBjYWxsaW5nIGBnZXRCb3VuZHNgIG9uIGVhY2ggb2JqZWN0IGluIGEgc3VidHJlZSB3aWxsIGNhdXNlIHRoZSB0b3RhbCBjb3N0IHRvIGluY3JlYXNlIHF1YWRyYXRpY2FsbHkgYXNcbiAgICogaXRzIGhlaWdodCBpbmNyZWFzZXMuXG4gICAqXG4gICAqIFRoZSB0cmFuc2Zvcm1zIG9mIGFsbCBvYmplY3RzIGluIGEgY29udGFpbmVyJ3MgKipzdWJ0cmVlKiogYW5kIG9mIGFsbCAqKmFuY2VzdG9ycyoqIGFyZSB1cGRhdGVkLlxuICAgKiBUaGUgd29ybGQgYm91bmRzIG9mIGFsbCBkaXNwbGF5IG9iamVjdHMgaW4gYSBjb250YWluZXIncyAqKnN1YnRyZWUqKiB3aWxsIGFsc28gYmUgcmVjYWxjdWxhdGVkLlxuICAgKlxuICAgKiBUaGUgYF9ib3VuZHNgIG9iamVjdCBzdG9yZXMgdGhlIGxhc3QgY2FsY3VsYXRpb24gb2YgdGhlIGJvdW5kcy4gWW91IGNhbiB1c2UgdG8gZW50aXJlbHkgc2tpcCBib3VuZHNcbiAgICogY2FsY3VsYXRpb24gaWYgbmVlZGVkLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBsYXN0Q2FsY3VsYXRlZEJvdW5kcyA9IGRpc3BsYXlPYmplY3QuX2JvdW5kcy5nZXRSZWN0YW5nbGUob3B0aW9uYWxSZWN0KTtcbiAgICogYGBgXG4gICAqXG4gICAqIERvIGtub3cgdGhhdCB1c2FnZSBvZiBgZ2V0TG9jYWxCb3VuZHNgIGNhbiBjb3JydXB0IHRoZSBgX2JvdW5kc2Agb2YgY2hpbGRyZW4gKHRoZSB3aG9sZSBzdWJ0cmVlLCBhY3R1YWxseSkuIFRoaXNcbiAgICogaXMgYSBrbm93biBpc3N1ZSB0aGF0IGhhcyBub3QgYmVlbiBzb2x2ZWQuIFNlZSBbZ2V0TG9jYWxCb3VuZHNde0BsaW5rIFBJWEkuRGlzcGxheU9iamVjdCNnZXRMb2NhbEJvdW5kc30gZm9yIG1vcmVcbiAgICogZGV0YWlscy5cbiAgICpcbiAgICogYGdldEJvdW5kc2Agc2hvdWxkIGJlIGNhbGxlZCB3aXRoIGBza2lwVXBkYXRlYCBlcXVhbCB0byBgdHJ1ZWAgaW4gYSByZW5kZXIoKSBjYWxsLiBUaGlzIGlzIGJlY2F1c2UgdGhlIHRyYW5zZm9ybXNcbiAgICogYXJlIGd1YXJhbnRlZWQgdG8gYmUgdXBkYXRlLXRvLWRhdGUuIEluIGZhY3QsIHJlY2FsY3VsYXRpbmcgaW5zaWRlIGEgcmVuZGVyKCkgY2FsbCBtYXkgY2F1c2UgY29ycnVwdGlvbiBpbiBjZXJ0YWluXG4gICAqIGNhc2VzLlxuICAgKiBAcGFyYW0gc2tpcFVwZGF0ZSAtIFNldHRpbmcgdG8gYHRydWVgIHdpbGwgc3RvcCB0aGUgdHJhbnNmb3JtcyBvZiB0aGUgc2NlbmUgZ3JhcGggZnJvbVxuICAgKiAgYmVpbmcgdXBkYXRlZC4gVGhpcyBtZWFucyB0aGUgY2FsY3VsYXRpb24gcmV0dXJuZWQgTUFZIGJlIG91dCBvZiBkYXRlIEJVVCB3aWxsIGdpdmUgeW91IGFcbiAgICogIG5pY2UgcGVyZm9ybWFuY2UgYm9vc3QuXG4gICAqIEBwYXJhbSByZWN0IC0gT3B0aW9uYWwgcmVjdGFuZ2xlIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGJvdW5kcyBjYWxjdWxhdGlvbi5cbiAgICogQHJldHVybnMgLSBUaGUgbWluaW11bSBheGlzLWFsaWduZWQgcmVjdGFuZ2xlIGluIHdvcmxkIHNwYWNlIHRoYXQgZml0cyBhcm91bmQgdGhpcyBvYmplY3QuXG4gICAqL1xuICBnZXRCb3VuZHMoc2tpcFVwZGF0ZSwgcmVjdCkge1xuICAgIHJldHVybiBza2lwVXBkYXRlIHx8ICh0aGlzLnBhcmVudCA/ICh0aGlzLl9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCksIHRoaXMudXBkYXRlVHJhbnNmb3JtKCkpIDogKHRoaXMucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQsIHRoaXMudXBkYXRlVHJhbnNmb3JtKCksIHRoaXMucGFyZW50ID0gbnVsbCkpLCB0aGlzLl9ib3VuZHMudXBkYXRlSUQgIT09IHRoaXMuX2JvdW5kc0lEICYmICh0aGlzLmNhbGN1bGF0ZUJvdW5kcygpLCB0aGlzLl9ib3VuZHMudXBkYXRlSUQgPSB0aGlzLl9ib3VuZHNJRCksIHJlY3QgfHwgKHRoaXMuX2JvdW5kc1JlY3QgfHwgKHRoaXMuX2JvdW5kc1JlY3QgPSBuZXcgY29yZS5SZWN0YW5nbGUoKSksIHJlY3QgPSB0aGlzLl9ib3VuZHNSZWN0KSwgdGhpcy5fYm91bmRzLmdldFJlY3RhbmdsZShyZWN0KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3QgYXMgYSByZWN0YW5nbGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gcmVjdCAtIE9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBib3VuZHMgY2FsY3VsYXRpb24uXG4gICAqIEByZXR1cm5zIC0gVGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWEuXG4gICAqL1xuICBnZXRMb2NhbEJvdW5kcyhyZWN0KSB7XG4gICAgcmVjdCB8fCAodGhpcy5fbG9jYWxCb3VuZHNSZWN0IHx8ICh0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBuZXcgY29yZS5SZWN0YW5nbGUoKSksIHJlY3QgPSB0aGlzLl9sb2NhbEJvdW5kc1JlY3QpLCB0aGlzLl9sb2NhbEJvdW5kcyB8fCAodGhpcy5fbG9jYWxCb3VuZHMgPSBuZXcgQm91bmRzLkJvdW5kcygpKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1SZWYgPSB0aGlzLnRyYW5zZm9ybSwgcGFyZW50UmVmID0gdGhpcy5wYXJlbnQ7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsLCB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudC53b3JsZEFscGhhID0gcGFyZW50UmVmPy53b3JsZEFscGhhID8/IDEsIHRoaXMudHJhbnNmb3JtID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQudHJhbnNmb3JtO1xuICAgIGNvbnN0IHdvcmxkQm91bmRzID0gdGhpcy5fYm91bmRzLCB3b3JsZEJvdW5kc0lEID0gdGhpcy5fYm91bmRzSUQ7XG4gICAgdGhpcy5fYm91bmRzID0gdGhpcy5fbG9jYWxCb3VuZHM7XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoITEsIHJlY3QpO1xuICAgIHJldHVybiB0aGlzLnBhcmVudCA9IHBhcmVudFJlZiwgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1SZWYsIHRoaXMuX2JvdW5kcyA9IHdvcmxkQm91bmRzLCB0aGlzLl9ib3VuZHMudXBkYXRlSUQgKz0gdGhpcy5fYm91bmRzSUQgLSB3b3JsZEJvdW5kc0lELCBib3VuZHM7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGdsb2JhbCBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheSBvYmplY3QuXG4gICAqIEBwYXJhbSBwb3NpdGlvbiAtIFRoZSB3b3JsZCBvcmlnaW4gdG8gY2FsY3VsYXRlIGZyb20uXG4gICAqIEBwYXJhbSBwb2ludCAtIEEgUG9pbnQgb2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIHRoZSB2YWx1ZSwgb3B0aW9uYWxcbiAgICogIChvdGhlcndpc2Ugd2lsbCBjcmVhdGUgYSBuZXcgUG9pbnQpLlxuICAgKiBAcGFyYW0gc2tpcFVwZGF0ZSAtIFNob3VsZCB3ZSBza2lwIHRoZSB1cGRhdGUgdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyAtIEEgcG9pbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAqL1xuICB0b0dsb2JhbChwb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUgPSAhMSkge1xuICAgIHJldHVybiBza2lwVXBkYXRlIHx8ICh0aGlzLl9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCksIHRoaXMucGFyZW50ID8gdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCkgOiAodGhpcy5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudCwgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCksIHRoaXMucGFyZW50ID0gbnVsbCkpLCB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5KHBvc2l0aW9uLCBwb2ludCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGxvY2FsIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5IG9iamVjdCByZWxhdGl2ZSB0byBhbm90aGVyIHBvaW50LlxuICAgKiBAcGFyYW0gcG9zaXRpb24gLSBUaGUgd29ybGQgb3JpZ2luIHRvIGNhbGN1bGF0ZSBmcm9tLlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSBEaXNwbGF5T2JqZWN0IHRvIGNhbGN1bGF0ZSB0aGUgZ2xvYmFsIHBvc2l0aW9uIGZyb20uXG4gICAqIEBwYXJhbSBwb2ludCAtIEEgUG9pbnQgb2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIHRoZSB2YWx1ZSwgb3B0aW9uYWxcbiAgICogIChvdGhlcndpc2Ugd2lsbCBjcmVhdGUgYSBuZXcgUG9pbnQpLlxuICAgKiBAcGFyYW0gc2tpcFVwZGF0ZSAtIFNob3VsZCB3ZSBza2lwIHRoZSB1cGRhdGUgdHJhbnNmb3JtXG4gICAqIEByZXR1cm5zIC0gQSBwb2ludCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGlzIG9iamVjdFxuICAgKi9cbiAgdG9Mb2NhbChwb3NpdGlvbiwgZnJvbSwgcG9pbnQsIHNraXBVcGRhdGUpIHtcbiAgICByZXR1cm4gZnJvbSAmJiAocG9zaXRpb24gPSBmcm9tLnRvR2xvYmFsKHBvc2l0aW9uLCBwb2ludCwgc2tpcFVwZGF0ZSkpLCBza2lwVXBkYXRlIHx8ICh0aGlzLl9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCksIHRoaXMucGFyZW50ID8gdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCkgOiAodGhpcy5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudCwgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCksIHRoaXMucGFyZW50ID0gbnVsbCkpLCB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb3NpdGlvbiwgcG9pbnQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHBhcmVudCBDb250YWluZXIgb2YgdGhpcyBEaXNwbGF5T2JqZWN0LlxuICAgKiBAcGFyYW0gY29udGFpbmVyIC0gVGhlIENvbnRhaW5lciB0byBhZGQgdGhpcyBEaXNwbGF5T2JqZWN0IHRvLlxuICAgKiBAcmV0dXJucyAtIFRoZSBDb250YWluZXIgdGhhdCB0aGlzIERpc3BsYXlPYmplY3Qgd2FzIGFkZGVkIHRvLlxuICAgKi9cbiAgc2V0UGFyZW50KGNvbnRhaW5lcikge1xuICAgIGlmICghY29udGFpbmVyIHx8ICFjb250YWluZXIuYWRkQ2hpbGQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRQYXJlbnQ6IEFyZ3VtZW50IG11c3QgYmUgYSBDb250YWluZXJcIik7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5hZGRDaGlsZCh0aGlzKSwgY29udGFpbmVyO1xuICB9XG4gIC8qKiBSZW1vdmUgdGhlIERpc3BsYXlPYmplY3QgZnJvbSBpdHMgcGFyZW50IENvbnRhaW5lci4gSWYgdGhlIERpc3BsYXlPYmplY3QgaGFzIG5vIHBhcmVudCwgZG8gbm90aGluZy4gKi9cbiAgcmVtb3ZlRnJvbVBhcmVudCgpIHtcbiAgICB0aGlzLnBhcmVudD8ucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNldCB0aGUgcG9zaXRpb24sIHNjYWxlLCBza2V3IGFuZCBwaXZvdCBhdCBvbmNlLlxuICAgKiBAcGFyYW0geCAtIFRoZSBYIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgcG9zaXRpb25cbiAgICogQHBhcmFtIHNjYWxlWCAtIFRoZSBYIHNjYWxlIHZhbHVlXG4gICAqIEBwYXJhbSBzY2FsZVkgLSBUaGUgWSBzY2FsZSB2YWx1ZVxuICAgKiBAcGFyYW0gcm90YXRpb24gLSBUaGUgcm90YXRpb25cbiAgICogQHBhcmFtIHNrZXdYIC0gVGhlIFggc2tldyB2YWx1ZVxuICAgKiBAcGFyYW0gc2tld1kgLSBUaGUgWSBza2V3IHZhbHVlXG4gICAqIEBwYXJhbSBwaXZvdFggLSBUaGUgWCBwaXZvdCB2YWx1ZVxuICAgKiBAcGFyYW0gcGl2b3RZIC0gVGhlIFkgcGl2b3QgdmFsdWVcbiAgICogQHJldHVybnMgLSBUaGUgRGlzcGxheU9iamVjdCBpbnN0YW5jZVxuICAgKi9cbiAgc2V0VHJhbnNmb3JtKHggPSAwLCB5ID0gMCwgc2NhbGVYID0gMSwgc2NhbGVZID0gMSwgcm90YXRpb24gPSAwLCBza2V3WCA9IDAsIHNrZXdZID0gMCwgcGl2b3RYID0gMCwgcGl2b3RZID0gMCkge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnggPSB4LCB0aGlzLnBvc2l0aW9uLnkgPSB5LCB0aGlzLnNjYWxlLnggPSBzY2FsZVggfHwgMSwgdGhpcy5zY2FsZS55ID0gc2NhbGVZIHx8IDEsIHRoaXMucm90YXRpb24gPSByb3RhdGlvbiwgdGhpcy5za2V3LnggPSBza2V3WCwgdGhpcy5za2V3LnkgPSBza2V3WSwgdGhpcy5waXZvdC54ID0gcGl2b3RYLCB0aGlzLnBpdm90LnkgPSBwaXZvdFksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEJhc2UgZGVzdHJveSBtZXRob2QgZm9yIGdlbmVyaWMgZGlzcGxheSBvYmplY3RzLiBUaGlzIHdpbGwgYXV0b21hdGljYWxseVxuICAgKiByZW1vdmUgdGhlIGRpc3BsYXkgb2JqZWN0IGZyb20gaXRzIHBhcmVudCBDb250YWluZXIgYXMgd2VsbCBhcyByZW1vdmVcbiAgICogYWxsIGN1cnJlbnQgZXZlbnQgbGlzdGVuZXJzIGFuZCBpbnRlcm5hbCByZWZlcmVuY2VzLiBEbyBub3QgdXNlIGEgRGlzcGxheU9iamVjdFxuICAgKiBhZnRlciBjYWxsaW5nIGBkZXN0cm95KClgLlxuICAgKiBAcGFyYW0gX29wdGlvbnNcbiAgICovXG4gIGRlc3Ryb3koX29wdGlvbnMpIHtcbiAgICB0aGlzLnJlbW92ZUZyb21QYXJlbnQoKSwgdGhpcy5fZGVzdHJveWVkID0gITAsIHRoaXMudHJhbnNmb3JtID0gbnVsbCwgdGhpcy5wYXJlbnQgPSBudWxsLCB0aGlzLl9ib3VuZHMgPSBudWxsLCB0aGlzLm1hc2sgPSBudWxsLCB0aGlzLmN1bGxBcmVhID0gbnVsbCwgdGhpcy5maWx0ZXJzID0gbnVsbCwgdGhpcy5maWx0ZXJBcmVhID0gbnVsbCwgdGhpcy5oaXRBcmVhID0gbnVsbCwgdGhpcy5ldmVudE1vZGUgPSBcImF1dG9cIiwgdGhpcy5pbnRlcmFjdGl2ZUNoaWxkcmVuID0gITEsIHRoaXMuZW1pdChcImRlc3Ryb3llZFwiKSwgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAbWVtYmVyIHtQSVhJLkNvbnRhaW5lcn1cbiAgICovXG4gIGdldCBfdGVtcERpc3BsYXlPYmplY3RQYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPT09IG51bGwgJiYgKHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSBuZXcgVGVtcG9yYXJ5RGlzcGxheU9iamVjdCgpKSwgdGhpcy50ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgfVxuICAvKipcbiAgICogVXNlZCBpbiBSZW5kZXJlciwgY2FjaGVBc0JpdG1hcCBhbmQgb3RoZXIgcGxhY2VzIHdoZXJlIHlvdSBjYWxsIGFuIGB1cGRhdGVUcmFuc2Zvcm1gIG9uIHJvb3QuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNhY2hlUGFyZW50ID0gZWxlbS5lbmFibGVUZW1wUGFyZW50KCk7XG4gICAqIGVsZW0udXBkYXRlVHJhbnNmb3JtKCk7XG4gICAqIGVsZW0uZGlzYWJsZVRlbXBQYXJlbnQoY2FjaGVQYXJlbnQpO1xuICAgKiBgYGBcbiAgICogQHJldHVybnMgLSBDdXJyZW50IHBhcmVudFxuICAgKi9cbiAgZW5hYmxlVGVtcFBhcmVudCgpIHtcbiAgICBjb25zdCBteVBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgIHJldHVybiB0aGlzLnBhcmVudCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50LCBteVBhcmVudDtcbiAgfVxuICAvKipcbiAgICogUGFpciBtZXRob2QgZm9yIGBlbmFibGVUZW1wUGFyZW50YFxuICAgKiBAcGFyYW0gY2FjaGVQYXJlbnQgLSBBY3R1YWwgcGFyZW50IG9mIGVsZW1lbnRcbiAgICovXG4gIGRpc2FibGVUZW1wUGFyZW50KGNhY2hlUGFyZW50KSB7XG4gICAgdGhpcy5wYXJlbnQgPSBjYWNoZVBhcmVudDtcbiAgfVxuICAvKipcbiAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5T2JqZWN0IG9uIHRoZSB4IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAqIEFuIGFsaWFzIHRvIHBvc2l0aW9uLnhcbiAgICovXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XG4gIH1cbiAgc2V0IHgodmFsdWUpIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi54ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdCBvbiB0aGUgeSBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgKiBBbiBhbGlhcyB0byBwb3NpdGlvbi55XG4gICAqL1xuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xuICB9XG4gIHNldCB5KHZhbHVlKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0ucG9zaXRpb24ueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IHRyYW5zZm9ybSBvZiB0aGUgb2JqZWN0IGJhc2VkIG9uIHdvcmxkIChwYXJlbnQpIGZhY3RvcnMuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHdvcmxkVHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCB0cmFuc2Zvcm0gb2YgdGhlIG9iamVjdCBiYXNlZCBvbiBsb2NhbCBmYWN0b3JzOiBwb3NpdGlvbiwgc2NhbGUsIG90aGVyIHN0dWZmLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBsb2NhbFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubG9jYWxUcmFuc2Zvcm07XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKi9cbiAgZ2V0IHBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgfVxuICBzZXQgcG9zaXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5RnJvbSh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY2FsZSBmYWN0b3JzIG9mIHRoaXMgb2JqZWN0IGFsb25nIHRoZSBsb2NhbCBjb29yZGluYXRlIGF4ZXMuXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IHNjYWxlIGlzICgxLCAxKS5cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqL1xuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnNjYWxlO1xuICB9XG4gIHNldCBzY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtLnNjYWxlLmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGNlbnRlciBvZiByb3RhdGlvbiwgc2NhbGluZywgYW5kIHNrZXdpbmcgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QgaW4gaXRzIGxvY2FsIHNwYWNlLiBUaGUgYHBvc2l0aW9uYFxuICAgKiBpcyB0aGUgcHJvamVjdGlvbiBvZiBgcGl2b3RgIGluIHRoZSBwYXJlbnQncyBsb2NhbCBzcGFjZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHBpdm90IGlzIHRoZSBvcmlnaW4gKDAsIDApLlxuICAgKiBAc2luY2UgNC4wLjBcbiAgICovXG4gIGdldCBwaXZvdCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucGl2b3Q7XG4gIH1cbiAgc2V0IHBpdm90KHZhbHVlKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0ucGl2b3QuY29weUZyb20odmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2tldyBmYWN0b3IgZm9yIHRoZSBvYmplY3QgaW4gcmFkaWFucy5cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqL1xuICBnZXQgc2tldygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uc2tldztcbiAgfVxuICBzZXQgc2tldyh2YWx1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtLnNrZXcuY29weUZyb20odmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgKiAncm90YXRpb24nIGFuZCAnYW5nbGUnIGhhdmUgdGhlIHNhbWUgZWZmZWN0IG9uIGEgZGlzcGxheSBvYmplY3Q7IHJvdGF0aW9uIGlzIGluIHJhZGlhbnMsIGFuZ2xlIGlzIGluIGRlZ3JlZXMuXG4gICAqL1xuICBnZXQgcm90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uO1xuICB9XG4gIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbmdsZSBvZiB0aGUgb2JqZWN0IGluIGRlZ3JlZXMuXG4gICAqICdyb3RhdGlvbicgYW5kICdhbmdsZScgaGF2ZSB0aGUgc2FtZSBlZmZlY3Qgb24gYSBkaXNwbGF5IG9iamVjdDsgcm90YXRpb24gaXMgaW4gcmFkaWFucywgYW5nbGUgaXMgaW4gZGVncmVlcy5cbiAgICovXG4gIGdldCBhbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucm90YXRpb24gKiBjb3JlLlJBRF9UT19ERUc7XG4gIH1cbiAgc2V0IGFuZ2xlKHZhbHVlKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0ucm90YXRpb24gPSB2YWx1ZSAqIGNvcmUuREVHX1RPX1JBRDtcbiAgfVxuICAvKipcbiAgICogVGhlIHpJbmRleCBvZiB0aGUgZGlzcGxheU9iamVjdC5cbiAgICpcbiAgICogSWYgYSBjb250YWluZXIgaGFzIHRoZSBzb3J0YWJsZUNoaWxkcmVuIHByb3BlcnR5IHNldCB0byB0cnVlLCBjaGlsZHJlbiB3aWxsIGJlIGF1dG9tYXRpY2FsbHlcbiAgICogc29ydGVkIGJ5IHpJbmRleCB2YWx1ZTsgYSBoaWdoZXIgdmFsdWUgd2lsbCBtZWFuIGl0IHdpbGwgYmUgbW92ZWQgdG93YXJkcyB0aGUgZW5kIG9mIHRoZSBhcnJheSxcbiAgICogYW5kIHRodXMgcmVuZGVyZWQgb24gdG9wIG9mIG90aGVyIGRpc3BsYXkgb2JqZWN0cyB3aXRoaW4gdGhlIHNhbWUgY29udGFpbmVyLlxuICAgKiBAc2VlIFBJWEkuQ29udGFpbmVyI3NvcnRhYmxlQ2hpbGRyZW5cbiAgICovXG4gIGdldCB6SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pJbmRleDtcbiAgfVxuICBzZXQgekluZGV4KHZhbHVlKSB7XG4gICAgdGhpcy5fekluZGV4ID0gdmFsdWUsIHRoaXMucGFyZW50ICYmICh0aGlzLnBhcmVudC5zb3J0RGlydHkgPSAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgb2JqZWN0IGlzIGdsb2JhbGx5IHZpc2libGUuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHdvcmxkVmlzaWJsZSgpIHtcbiAgICBsZXQgaXRlbSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgaWYgKCFpdGVtLnZpc2libGUpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGl0ZW0gPSBpdGVtLnBhcmVudDtcbiAgICB9IHdoaWxlIChpdGVtKTtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYSBtYXNrIGZvciB0aGUgZGlzcGxheU9iamVjdC4gQSBtYXNrIGlzIGFuIG9iamVjdCB0aGF0IGxpbWl0cyB0aGUgdmlzaWJpbGl0eSBvZiBhblxuICAgKiBvYmplY3QgdG8gdGhlIHNoYXBlIG9mIHRoZSBtYXNrIGFwcGxpZWQgdG8gaXQuIEluIFBpeGlKUyBhIHJlZ3VsYXIgbWFzayBtdXN0IGJlIGFcbiAgICoge0BsaW5rIFBJWEkuR3JhcGhpY3N9IG9yIGEge0BsaW5rIFBJWEkuU3ByaXRlfSBvYmplY3QuIFRoaXMgYWxsb3dzIGZvciBtdWNoIGZhc3RlciBtYXNraW5nIGluIGNhbnZhcyBhcyBpdFxuICAgKiB1dGlsaXRpZXMgc2hhcGUgY2xpcHBpbmcuIEZ1cnRoZXJtb3JlLCBhIG1hc2sgb2YgYW4gb2JqZWN0IG11c3QgYmUgaW4gdGhlIHN1YnRyZWUgb2YgaXRzIHBhcmVudC5cbiAgICogT3RoZXJ3aXNlLCBgZ2V0TG9jYWxCb3VuZHNgIG1heSBjYWxjdWxhdGUgaW5jb3JyZWN0IGJvdW5kcywgd2hpY2ggbWFrZXMgdGhlIGNvbnRhaW5lcidzIHdpZHRoIGFuZCBoZWlnaHQgd3JvbmcuXG4gICAqIFRvIHJlbW92ZSBhIG1hc2ssIHNldCB0aGlzIHByb3BlcnR5IHRvIGBudWxsYC5cbiAgICpcbiAgICogRm9yIHNwcml0ZSBtYXNrIGJvdGggYWxwaGEgYW5kIHJlZCBjaGFubmVsIGFyZSB1c2VkLiBCbGFjayBtYXNrIGlzIHRoZSBzYW1lIGFzIHRyYW5zcGFyZW50IG1hc2suXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEdyYXBoaWNzLCBTcHJpdGUgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogY29uc3QgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3MoKTtcbiAgICogZ3JhcGhpY3MuYmVnaW5GaWxsKDB4RkYzMzAwKTtcbiAgICogZ3JhcGhpY3MuZHJhd1JlY3QoNTAsIDI1MCwgMTAwLCAxMDApO1xuICAgKiBncmFwaGljcy5lbmRGaWxsKCk7XG4gICAqXG4gICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gICAqIHNwcml0ZS5tYXNrID0gZ3JhcGhpY3M7XG4gICAqIEB0b2RvIEF0IHRoZSBtb21lbnQsIENhbnZhc1JlbmRlcmVyIGRvZXNuJ3Qgc3VwcG9ydCBTcHJpdGUgYXMgbWFzay5cbiAgICovXG4gIGdldCBtYXNrKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXNrO1xuICB9XG4gIHNldCBtYXNrKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX21hc2sgIT09IHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICBjb25zdCBtYXNrT2JqZWN0ID0gdGhpcy5fbWFzay5pc01hc2tEYXRhID8gdGhpcy5fbWFzay5tYXNrT2JqZWN0IDogdGhpcy5fbWFzaztcbiAgICAgICAgbWFza09iamVjdCAmJiAobWFza09iamVjdC5fbWFza1JlZkNvdW50LS0sIG1hc2tPYmplY3QuX21hc2tSZWZDb3VudCA9PT0gMCAmJiAobWFza09iamVjdC5yZW5kZXJhYmxlID0gITAsIG1hc2tPYmplY3QuaXNNYXNrID0gITEpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9tYXNrID0gdmFsdWUsIHRoaXMuX21hc2spIHtcbiAgICAgICAgY29uc3QgbWFza09iamVjdCA9IHRoaXMuX21hc2suaXNNYXNrRGF0YSA/IHRoaXMuX21hc2subWFza09iamVjdCA6IHRoaXMuX21hc2s7XG4gICAgICAgIG1hc2tPYmplY3QgJiYgKG1hc2tPYmplY3QuX21hc2tSZWZDb3VudCA9PT0gMCAmJiAobWFza09iamVjdC5yZW5kZXJhYmxlID0gITEsIG1hc2tPYmplY3QuaXNNYXNrID0gITApLCBtYXNrT2JqZWN0Ll9tYXNrUmVmQ291bnQrKyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBUZW1wb3JhcnlEaXNwbGF5T2JqZWN0IGV4dGVuZHMgRGlzcGxheU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuc29ydERpcnR5ID0gbnVsbDtcbiAgfVxufVxuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSA9IERpc3BsYXlPYmplY3QucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybTtcbmV4cG9ydHMuRGlzcGxheU9iamVjdCA9IERpc3BsYXlPYmplY3Q7XG5leHBvcnRzLlRlbXBvcmFyeURpc3BsYXlPYmplY3QgPSBUZW1wb3JhcnlEaXNwbGF5T2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGlzcGxheU9iamVjdC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xucmVxdWlyZShcIi4vc2V0dGluZ3MuanNcIik7XG52YXIgQm91bmRzID0gcmVxdWlyZShcIi4vQm91bmRzLmpzXCIpLCBDb250YWluZXIgPSByZXF1aXJlKFwiLi9Db250YWluZXIuanNcIiksIERpc3BsYXlPYmplY3QgPSByZXF1aXJlKFwiLi9EaXNwbGF5T2JqZWN0LmpzXCIpO1xuZXhwb3J0cy5Cb3VuZHMgPSBCb3VuZHMuQm91bmRzO1xuZXhwb3J0cy5Db250YWluZXIgPSBDb250YWluZXIuQ29udGFpbmVyO1xuZXhwb3J0cy5EaXNwbGF5T2JqZWN0ID0gRGlzcGxheU9iamVjdC5EaXNwbGF5T2JqZWN0O1xuZXhwb3J0cy5UZW1wb3JhcnlEaXNwbGF5T2JqZWN0ID0gRGlzcGxheU9iamVjdC5UZW1wb3JhcnlEaXNwbGF5T2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIENvbnRhaW5lciA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvcmUuc2V0dGluZ3MsIHtcbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb250YWluZXIgcHJvcGVydHkgJ3NvcnRhYmxlQ2hpbGRyZW4nLlxuICAgKiBAc3RhdGljXG4gICAqIEBuYW1lIFNPUlRBQkxFX0NISUxEUkVOXG4gICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAc2VlIFBJWEkuQ29udGFpbmVyLmRlZmF1bHRTb3J0YWJsZUNoaWxkcmVuXG4gICAqL1xuICBTT1JUQUJMRV9DSElMRFJFTjoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBDb250YWluZXIuQ29udGFpbmVyLmRlZmF1bHRTb3J0YWJsZUNoaWxkcmVuO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBjb3JlLnV0aWxzLmRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5TT1JUQUJMRV9DSElMRFJFTiBpcyBkZXByZWNhdGVkLCB1c2UgQ29udGFpbmVyLmRlZmF1bHRTb3J0YWJsZUNoaWxkcmVuXCIpLCBDb250YWluZXIuQ29udGFpbmVyLmRlZmF1bHRTb3J0YWJsZUNoaWxkcmVuID0gdmFsdWU7XG4gICAgfVxuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNldHRpbmdzXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcmUuc2V0dGluZ3M7XG4gIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0dGluZ3MuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIEV2ZW50VGlja2VyID0gcmVxdWlyZShcIi4vRXZlbnRUaWNrZXIuanNcIiksIEZlZGVyYXRlZE1vdXNlRXZlbnQgPSByZXF1aXJlKFwiLi9GZWRlcmF0ZWRNb3VzZUV2ZW50LmpzXCIpLCBGZWRlcmF0ZWRQb2ludGVyRXZlbnQgPSByZXF1aXJlKFwiLi9GZWRlcmF0ZWRQb2ludGVyRXZlbnQuanNcIiksIEZlZGVyYXRlZFdoZWVsRXZlbnQgPSByZXF1aXJlKFwiLi9GZWRlcmF0ZWRXaGVlbEV2ZW50LmpzXCIpO1xuY29uc3QgUFJPUEFHQVRJT05fTElNSVQgPSAyMDQ4LCB0ZW1wSGl0TG9jYXRpb24gPSBuZXcgY29yZS5Qb2ludCgpLCB0ZW1wTG9jYWxNYXBwaW5nID0gbmV3IGNvcmUuUG9pbnQoKTtcbmNsYXNzIEV2ZW50Qm91bmRhcnkge1xuICAvKipcbiAgICogQHBhcmFtIHJvb3RUYXJnZXQgLSBUaGUgaG9sZGVyIG9mIHRoZSBldmVudCBib3VuZGFyeS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3RUYXJnZXQpIHtcbiAgICB0aGlzLmRpc3BhdGNoID0gbmV3IGNvcmUudXRpbHMuRXZlbnRFbWl0dGVyKCksIHRoaXMubW92ZU9uQWxsID0gITEsIHRoaXMuZW5hYmxlR2xvYmFsTW92ZUV2ZW50cyA9ICEwLCB0aGlzLm1hcHBpbmdTdGF0ZSA9IHtcbiAgICAgIHRyYWNraW5nRGF0YToge31cbiAgICB9LCB0aGlzLmV2ZW50UG9vbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuX2FsbEludGVyYWN0aXZlRWxlbWVudHMgPSBbXSwgdGhpcy5faGl0RWxlbWVudHMgPSBbXSwgdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ID0gITEsIHRoaXMucm9vdFRhcmdldCA9IHJvb3RUYXJnZXQsIHRoaXMuaGl0UHJ1bmVGbiA9IHRoaXMuaGl0UHJ1bmVGbi5iaW5kKHRoaXMpLCB0aGlzLmhpdFRlc3RGbiA9IHRoaXMuaGl0VGVzdEZuLmJpbmQodGhpcyksIHRoaXMubWFwUG9pbnRlckRvd24gPSB0aGlzLm1hcFBvaW50ZXJEb3duLmJpbmQodGhpcyksIHRoaXMubWFwUG9pbnRlck1vdmUgPSB0aGlzLm1hcFBvaW50ZXJNb3ZlLmJpbmQodGhpcyksIHRoaXMubWFwUG9pbnRlck91dCA9IHRoaXMubWFwUG9pbnRlck91dC5iaW5kKHRoaXMpLCB0aGlzLm1hcFBvaW50ZXJPdmVyID0gdGhpcy5tYXBQb2ludGVyT3Zlci5iaW5kKHRoaXMpLCB0aGlzLm1hcFBvaW50ZXJVcCA9IHRoaXMubWFwUG9pbnRlclVwLmJpbmQodGhpcyksIHRoaXMubWFwUG9pbnRlclVwT3V0c2lkZSA9IHRoaXMubWFwUG9pbnRlclVwT3V0c2lkZS5iaW5kKHRoaXMpLCB0aGlzLm1hcFdoZWVsID0gdGhpcy5tYXBXaGVlbC5iaW5kKHRoaXMpLCB0aGlzLm1hcHBpbmdUYWJsZSA9IHt9LCB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJkb3duXCIsIHRoaXMubWFwUG9pbnRlckRvd24pLCB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJtb3ZlXCIsIHRoaXMubWFwUG9pbnRlck1vdmUpLCB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJvdXRcIiwgdGhpcy5tYXBQb2ludGVyT3V0KSwgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVybGVhdmVcIiwgdGhpcy5tYXBQb2ludGVyT3V0KSwgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVyb3ZlclwiLCB0aGlzLm1hcFBvaW50ZXJPdmVyKSwgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVydXBcIiwgdGhpcy5tYXBQb2ludGVyVXApLCB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJ1cG91dHNpZGVcIiwgdGhpcy5tYXBQb2ludGVyVXBPdXRzaWRlKSwgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJ3aGVlbFwiLCB0aGlzLm1hcFdoZWVsKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBldmVudCBtYXBwaW5nIGZvciB0aGUgZXZlbnQgYHR5cGVgIGhhbmRsZWQgYnkgYGZuYC5cbiAgICpcbiAgICogRXZlbnQgbWFwcGluZ3MgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IGFkZGl0aW9uYWwgb3IgY3VzdG9tIGV2ZW50cy4gVGhleSB0YWtlIGFuIGV2ZW50XG4gICAqIGNvbWluZyBmcm9tIHRoZSB1cHN0cmVhbSBzY2VuZSAob3IgZGlyZWN0bHkgZnJvbSB0aGUge0BsaW5rIFBJWEkuRXZlbnRTeXN0ZW19KSBhbmQgZGlzcGF0Y2ggbmV3IGRvd25zdHJlYW0gZXZlbnRzXG4gICAqIGdlbmVyYWxseSB0cmlja2xpbmcgZG93biBhbmQgYnViYmxpbmcgdXAgdG8ge0BsaW5rIFBJWEkuRXZlbnRCb3VuZGFyeS5yb290VGFyZ2V0IHRoaXMucm9vdFRhcmdldH0uXG4gICAqXG4gICAqIFRvIG1vZGlmeSB0aGUgc2VtYW50aWNzIG9mIGV4aXN0aW5nIGV2ZW50cywgdGhlIGJ1aWx0LWluIG1hcHBpbmcgbWV0aG9kcyBvZiBFdmVudEJvdW5kYXJ5IHNob3VsZCBiZSBvdmVycmlkZGVuXG4gICAqIGluc3RlYWQuXG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdXBzdHJlYW0gZXZlbnQgdG8gbWFwLlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbWFwcGluZyBtZXRob2QuIFRoZSBjb250ZXh0IG9mIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBib3VuZCBtYW51YWxseSwgaWYgZGVzaXJlZC5cbiAgICovXG4gIGFkZEV2ZW50TWFwcGluZyh0eXBlLCBmbikge1xuICAgIHRoaXMubWFwcGluZ1RhYmxlW3R5cGVdIHx8ICh0aGlzLm1hcHBpbmdUYWJsZVt0eXBlXSA9IFtdKSwgdGhpcy5tYXBwaW5nVGFibGVbdHlwZV0ucHVzaCh7XG4gICAgICBmbixcbiAgICAgIHByaW9yaXR5OiAwXG4gICAgfSksIHRoaXMubWFwcGluZ1RhYmxlW3R5cGVdLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcbiAgfVxuICAvKipcbiAgICogRGlzcGF0Y2hlcyB0aGUgZ2l2ZW4gZXZlbnRcbiAgICogQHBhcmFtIGVcbiAgICogQHBhcmFtIHR5cGVcbiAgICovXG4gIGRpc3BhdGNoRXZlbnQoZSwgdHlwZSkge1xuICAgIGUucHJvcGFnYXRpb25TdG9wcGVkID0gITEsIGUucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQgPSAhMSwgdGhpcy5wcm9wYWdhdGUoZSwgdHlwZSksIHRoaXMuZGlzcGF0Y2guZW1pdCh0eXBlIHx8IGUudHlwZSwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcHMgdGhlIGdpdmVuIHVwc3RyZWFtIGV2ZW50IHRocm91Z2ggdGhlIGV2ZW50IGJvdW5kYXJ5IGFuZCBwcm9wYWdhdGVzIGl0IGRvd25zdHJlYW0uXG4gICAqIEBwYXJhbSBlXG4gICAqL1xuICBtYXBFdmVudChlKSB7XG4gICAgaWYgKCF0aGlzLnJvb3RUYXJnZXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbWFwcGVycyA9IHRoaXMubWFwcGluZ1RhYmxlW2UudHlwZV07XG4gICAgaWYgKG1hcHBlcnMpXG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IG1hcHBlcnMubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICBtYXBwZXJzW2ldLmZuKGUpO1xuICAgIGVsc2VcbiAgICAgIGNvbnNvbGUud2FybihgW0V2ZW50Qm91bmRhcnldOiBFdmVudCBtYXBwaW5nIG5vdCBkZWZpbmVkIGZvciAke2UudHlwZX1gKTtcbiAgfVxuICAvKipcbiAgICogRmluZHMgdGhlIERpc3BsYXlPYmplY3QgdGhhdCBpcyB0aGUgdGFyZ2V0IG9mIGEgZXZlbnQgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAgKlxuICAgKiBUaGUgcGFzc2VkICh4LHkpIGNvb3JkaW5hdGVzIGFyZSBpbiB0aGUgd29ybGQgc3BhY2UgYWJvdmUgdGhpcyBldmVudCBib3VuZGFyeS5cbiAgICogQHBhcmFtIHhcbiAgICogQHBhcmFtIHlcbiAgICovXG4gIGhpdFRlc3QoeCwgeSkge1xuICAgIEV2ZW50VGlja2VyLkV2ZW50c1RpY2tlci5wYXVzZVVwZGF0ZSA9ICEwO1xuICAgIGNvbnN0IGZuID0gdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ICYmIHRoaXMuZW5hYmxlR2xvYmFsTW92ZUV2ZW50cyA/IFwiaGl0VGVzdE1vdmVSZWN1cnNpdmVcIiA6IFwiaGl0VGVzdFJlY3Vyc2l2ZVwiLCBpbnZlcnRlZFBhdGggPSB0aGlzW2ZuXShcbiAgICAgIHRoaXMucm9vdFRhcmdldCxcbiAgICAgIHRoaXMucm9vdFRhcmdldC5ldmVudE1vZGUsXG4gICAgICB0ZW1wSGl0TG9jYXRpb24uc2V0KHgsIHkpLFxuICAgICAgdGhpcy5oaXRUZXN0Rm4sXG4gICAgICB0aGlzLmhpdFBydW5lRm5cbiAgICApO1xuICAgIHJldHVybiBpbnZlcnRlZFBhdGggJiYgaW52ZXJ0ZWRQYXRoWzBdO1xuICB9XG4gIC8qKlxuICAgKiBQcm9wYWdhdGUgdGhlIHBhc3NlZCBldmVudCBmcm9tIGZyb20ge0BsaW5rIFBJWEkuRXZlbnRCb3VuZGFyeS5yb290VGFyZ2V0IHRoaXMucm9vdFRhcmdldH0gdG8gaXRzXG4gICAqIHRhcmdldCB7QGNvZGUgZS50YXJnZXR9LlxuICAgKiBAcGFyYW0gZSAtIFRoZSBldmVudCB0byBwcm9wYWdhdGUuXG4gICAqIEBwYXJhbSB0eXBlXG4gICAqL1xuICBwcm9wYWdhdGUoZSwgdHlwZSkge1xuICAgIGlmICghZS50YXJnZXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY29tcG9zZWRQYXRoID0gZS5jb21wb3NlZFBhdGgoKTtcbiAgICBlLmV2ZW50UGhhc2UgPSBlLkNBUFRVUklOR19QSEFTRTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGNvbXBvc2VkUGF0aC5sZW5ndGggLSAxOyBpIDwgajsgaSsrKVxuICAgICAgaWYgKGUuY3VycmVudFRhcmdldCA9IGNvbXBvc2VkUGF0aFtpXSwgdGhpcy5ub3RpZnlUYXJnZXQoZSwgdHlwZSksIGUucHJvcGFnYXRpb25TdG9wcGVkIHx8IGUucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZS5ldmVudFBoYXNlID0gZS5BVF9UQVJHRVQsIGUuY3VycmVudFRhcmdldCA9IGUudGFyZ2V0LCB0aGlzLm5vdGlmeVRhcmdldChlLCB0eXBlKSwgIShlLnByb3BhZ2F0aW9uU3RvcHBlZCB8fCBlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkKSkge1xuICAgICAgZS5ldmVudFBoYXNlID0gZS5CVUJCTElOR19QSEFTRTtcbiAgICAgIGZvciAobGV0IGkgPSBjb21wb3NlZFBhdGgubGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmIChlLmN1cnJlbnRUYXJnZXQgPSBjb21wb3NlZFBhdGhbaV0sIHRoaXMubm90aWZ5VGFyZ2V0KGUsIHR5cGUpLCBlLnByb3BhZ2F0aW9uU3RvcHBlZCB8fCBlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVtaXRzIHRoZSBldmVudCB7QGNvZGUgZX0gdG8gYWxsIGludGVyYWN0aXZlIGRpc3BsYXkgb2JqZWN0cy4gVGhlIGV2ZW50IGlzIHByb3BhZ2F0ZWQgaW4gdGhlIGJ1YmJsaW5nIHBoYXNlIGFsd2F5cy5cbiAgICpcbiAgICogVGhpcyBpcyB1c2VkIGluIHRoZSBgZ2xvYmFscG9pbnRlcm1vdmVgIGV2ZW50LlxuICAgKiBAcGFyYW0gZSAtIFRoZSBlbWl0dGVkIGV2ZW50LlxuICAgKiBAcGFyYW0gdHlwZSAtIFRoZSBsaXN0ZW5lcnMgdG8gbm90aWZ5LlxuICAgKiBAcGFyYW0gdGFyZ2V0cyAtIFRoZSB0YXJnZXRzIHRvIG5vdGlmeS5cbiAgICovXG4gIGFsbChlLCB0eXBlLCB0YXJnZXRzID0gdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cykge1xuICAgIGlmICh0YXJnZXRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBlLmV2ZW50UGhhc2UgPSBlLkJVQkJMSU5HX1BIQVNFO1xuICAgIGNvbnN0IGV2ZW50cyA9IEFycmF5LmlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xuICAgIGZvciAobGV0IGkgPSB0YXJnZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgIGUuY3VycmVudFRhcmdldCA9IHRhcmdldHNbaV0sIHRoaXMubm90aWZ5VGFyZ2V0KGUsIGV2ZW50KTtcbiAgICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgcHJvcGFnYXRpb24gcGF0aCBmcm9tIHtAbGluayBQSVhJLkV2ZW50Qm91bmRhcnkucm9vdFRhcmdldCByb290VGFyZ2V0fSB0byB0aGUgcGFzc2VkXG4gICAqIHtAY29kZSB0YXJnZXR9LiBUaGUgbGFzdCBlbGVtZW50IGluIHRoZSBwYXRoIGlzIHtAY29kZSB0YXJnZXR9LlxuICAgKiBAcGFyYW0gdGFyZ2V0XG4gICAqL1xuICBwcm9wYWdhdGlvblBhdGgodGFyZ2V0KSB7XG4gICAgY29uc3QgcHJvcGFnYXRpb25QYXRoID0gW3RhcmdldF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQUk9QQUdBVElPTl9MSU1JVCAmJiB0YXJnZXQgIT09IHRoaXMucm9vdFRhcmdldDsgaSsrKSB7XG4gICAgICBpZiAoIXRhcmdldC5wYXJlbnQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHByb3BhZ2F0aW9uIHBhdGggdG8gZGlzY29ubmVjdGVkIHRhcmdldFwiKTtcbiAgICAgIHByb3BhZ2F0aW9uUGF0aC5wdXNoKHRhcmdldC5wYXJlbnQpLCB0YXJnZXQgPSB0YXJnZXQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGFnYXRpb25QYXRoLnJldmVyc2UoKSwgcHJvcGFnYXRpb25QYXRoO1xuICB9XG4gIGhpdFRlc3RNb3ZlUmVjdXJzaXZlKGN1cnJlbnRUYXJnZXQsIGV2ZW50TW9kZSwgbG9jYXRpb24sIHRlc3RGbiwgcHJ1bmVGbiwgaWdub3JlID0gITEpIHtcbiAgICBsZXQgc2hvdWxkUmV0dXJuID0gITE7XG4gICAgaWYgKHRoaXMuX2ludGVyYWN0aXZlUHJ1bmUoY3VycmVudFRhcmdldCkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoKGN1cnJlbnRUYXJnZXQuZXZlbnRNb2RlID09PSBcImR5bmFtaWNcIiB8fCBldmVudE1vZGUgPT09IFwiZHluYW1pY1wiKSAmJiAoRXZlbnRUaWNrZXIuRXZlbnRzVGlja2VyLnBhdXNlVXBkYXRlID0gITEpLCBjdXJyZW50VGFyZ2V0LmludGVyYWN0aXZlQ2hpbGRyZW4gJiYgY3VycmVudFRhcmdldC5jaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjdXJyZW50VGFyZ2V0LmNoaWxkcmVuO1xuICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV0sIG5lc3RlZEhpdCA9IHRoaXMuaGl0VGVzdE1vdmVSZWN1cnNpdmUoXG4gICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgdGhpcy5faXNJbnRlcmFjdGl2ZShldmVudE1vZGUpID8gZXZlbnRNb2RlIDogY2hpbGQuZXZlbnRNb2RlLFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIHRlc3RGbixcbiAgICAgICAgICBwcnVuZUZuLFxuICAgICAgICAgIGlnbm9yZSB8fCBwcnVuZUZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKVxuICAgICAgICApO1xuICAgICAgICBpZiAobmVzdGVkSGl0KSB7XG4gICAgICAgICAgaWYgKG5lc3RlZEhpdC5sZW5ndGggPiAwICYmICFuZXN0ZWRIaXRbbmVzdGVkSGl0Lmxlbmd0aCAtIDFdLnBhcmVudClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IGlzSW50ZXJhY3RpdmUgPSBjdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKTtcbiAgICAgICAgICAobmVzdGVkSGl0Lmxlbmd0aCA+IDAgfHwgaXNJbnRlcmFjdGl2ZSkgJiYgKGlzSW50ZXJhY3RpdmUgJiYgdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cy5wdXNoKGN1cnJlbnRUYXJnZXQpLCBuZXN0ZWRIaXQucHVzaChjdXJyZW50VGFyZ2V0KSksIHRoaXMuX2hpdEVsZW1lbnRzLmxlbmd0aCA9PT0gMCAmJiAodGhpcy5faGl0RWxlbWVudHMgPSBuZXN0ZWRIaXQpLCBzaG91bGRSZXR1cm4gPSAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpc0ludGVyYWN0aXZlTW9kZSA9IHRoaXMuX2lzSW50ZXJhY3RpdmUoZXZlbnRNb2RlKSwgaXNJbnRlcmFjdGl2ZVRhcmdldCA9IGN1cnJlbnRUYXJnZXQuaXNJbnRlcmFjdGl2ZSgpO1xuICAgIHJldHVybiBpc0ludGVyYWN0aXZlTW9kZSAmJiBpc0ludGVyYWN0aXZlVGFyZ2V0ICYmIHRoaXMuX2FsbEludGVyYWN0aXZlRWxlbWVudHMucHVzaChjdXJyZW50VGFyZ2V0KSwgaWdub3JlIHx8IHRoaXMuX2hpdEVsZW1lbnRzLmxlbmd0aCA+IDAgPyBudWxsIDogc2hvdWxkUmV0dXJuID8gdGhpcy5faGl0RWxlbWVudHMgOiBpc0ludGVyYWN0aXZlTW9kZSAmJiAhcHJ1bmVGbihjdXJyZW50VGFyZ2V0LCBsb2NhdGlvbikgJiYgdGVzdEZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKSA/IGlzSW50ZXJhY3RpdmVUYXJnZXQgPyBbY3VycmVudFRhcmdldF0gOiBbXSA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBmb3Ige0BsaW5rIFBJWEkuRXZlbnRCb3VuZGFyeS5oaXRUZXN0IGhpdFRlc3R9LlxuICAgKiBAcGFyYW0gY3VycmVudFRhcmdldCAtIFRoZSBEaXNwbGF5T2JqZWN0IHRoYXQgaXMgdG8gYmUgaGl0IHRlc3RlZC5cbiAgICogQHBhcmFtIGV2ZW50TW9kZSAtIFRoZSBldmVudCBtb2RlIGZvciB0aGUgYGN1cnJlbnRUYXJnZXRgIG9yIG9uZSBvZiBpdHMgcGFyZW50cy5cbiAgICogQHBhcmFtIGxvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIHRoYXQgaXMgYmVpbmcgdGVzdGVkIGZvciBvdmVybGFwLlxuICAgKiBAcGFyYW0gdGVzdEZuIC0gQ2FsbGJhY2sgdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHRhcmdldCBwYXNzZXMgaGl0IHRlc3RpbmcuIFRoaXMgY2FsbGJhY2tcbiAgICogIGNhbiBhc3N1bWUgdGhhdCBgcHJ1bmVGbmAgZmFpbGVkIHRvIHBydW5lIHRoZSBkaXNwbGF5IG9iamVjdC5cbiAgICogQHBhcmFtIHBydW5lRm4gLSBDYWxsYmFjayB0aGF0IGRldGVybWluZXNzIHdoZXRoZXIgdGhlIHRhcmdldCBhbmQgYWxsIG9mIGl0cyBjaGlsZHJlblxuICAgKiAgY2Fubm90IHBhc3MgdGhlIGhpdCB0ZXN0LiBJdCBpcyB1c2VkIGFzIGEgcHJlbGltaW5hcnkgb3B0aW1pemF0aW9uIHRvIHBydW5lIGVudGlyZSBzdWJ0cmVlc1xuICAgKiAgb2YgdGhlIHNjZW5lIGdyYXBoLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBob2xkaW5nIHRoZSBoaXQgdGVzdGluZyB0YXJnZXQgYW5kIGFsbCBpdHMgYW5jZXN0b3JzIGluIG9yZGVyLiBUaGUgZmlyc3QgZWxlbWVudFxuICAgKiAgaXMgdGhlIHRhcmdldCBpdHNlbGYgYW5kIHRoZSBsYXN0IGlzIHtAbGluayBQSVhJLkV2ZW50Qm91bmRhcnkucm9vdFRhcmdldCByb290VGFyZ2V0fS4gVGhpcyBpcyB0aGUgb3Bwb3NpdGVcbiAgICogIG9yZGVyIHcuci50LiB0aGUgcHJvcGFnYXRpb24gcGF0aC4gSWYgbm8gaGl0IHRlc3RpbmcgdGFyZ2V0IGlzIGZvdW5kLCBudWxsIGlzIHJldHVybmVkLlxuICAgKi9cbiAgaGl0VGVzdFJlY3Vyc2l2ZShjdXJyZW50VGFyZ2V0LCBldmVudE1vZGUsIGxvY2F0aW9uLCB0ZXN0Rm4sIHBydW5lRm4pIHtcbiAgICBpZiAodGhpcy5faW50ZXJhY3RpdmVQcnVuZShjdXJyZW50VGFyZ2V0KSB8fCBwcnVuZUZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICgoY3VycmVudFRhcmdldC5ldmVudE1vZGUgPT09IFwiZHluYW1pY1wiIHx8IGV2ZW50TW9kZSA9PT0gXCJkeW5hbWljXCIpICYmIChFdmVudFRpY2tlci5FdmVudHNUaWNrZXIucGF1c2VVcGRhdGUgPSAhMSksIGN1cnJlbnRUYXJnZXQuaW50ZXJhY3RpdmVDaGlsZHJlbiAmJiBjdXJyZW50VGFyZ2V0LmNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGN1cnJlbnRUYXJnZXQuY2hpbGRyZW47XG4gICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXSwgbmVzdGVkSGl0ID0gdGhpcy5oaXRUZXN0UmVjdXJzaXZlKFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIHRoaXMuX2lzSW50ZXJhY3RpdmUoZXZlbnRNb2RlKSA/IGV2ZW50TW9kZSA6IGNoaWxkLmV2ZW50TW9kZSxcbiAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICB0ZXN0Rm4sXG4gICAgICAgICAgcHJ1bmVGblxuICAgICAgICApO1xuICAgICAgICBpZiAobmVzdGVkSGl0KSB7XG4gICAgICAgICAgaWYgKG5lc3RlZEhpdC5sZW5ndGggPiAwICYmICFuZXN0ZWRIaXRbbmVzdGVkSGl0Lmxlbmd0aCAtIDFdLnBhcmVudClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IGlzSW50ZXJhY3RpdmUgPSBjdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKTtcbiAgICAgICAgICByZXR1cm4gKG5lc3RlZEhpdC5sZW5ndGggPiAwIHx8IGlzSW50ZXJhY3RpdmUpICYmIG5lc3RlZEhpdC5wdXNoKGN1cnJlbnRUYXJnZXQpLCBuZXN0ZWRIaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaXNJbnRlcmFjdGl2ZU1vZGUgPSB0aGlzLl9pc0ludGVyYWN0aXZlKGV2ZW50TW9kZSksIGlzSW50ZXJhY3RpdmVUYXJnZXQgPSBjdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKTtcbiAgICByZXR1cm4gaXNJbnRlcmFjdGl2ZU1vZGUgJiYgdGVzdEZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKSA/IGlzSW50ZXJhY3RpdmVUYXJnZXQgPyBbY3VycmVudFRhcmdldF0gOiBbXSA6IG51bGw7XG4gIH1cbiAgX2lzSW50ZXJhY3RpdmUoaW50KSB7XG4gICAgcmV0dXJuIGludCA9PT0gXCJzdGF0aWNcIiB8fCBpbnQgPT09IFwiZHluYW1pY1wiO1xuICB9XG4gIF9pbnRlcmFjdGl2ZVBydW5lKGRpc3BsYXlPYmplY3QpIHtcbiAgICByZXR1cm4gISEoIWRpc3BsYXlPYmplY3QgfHwgZGlzcGxheU9iamVjdC5pc01hc2sgfHwgIWRpc3BsYXlPYmplY3QudmlzaWJsZSB8fCAhZGlzcGxheU9iamVjdC5yZW5kZXJhYmxlIHx8IGRpc3BsYXlPYmplY3QuZXZlbnRNb2RlID09PSBcIm5vbmVcIiB8fCBkaXNwbGF5T2JqZWN0LmV2ZW50TW9kZSA9PT0gXCJwYXNzaXZlXCIgJiYgIWRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmVDaGlsZHJlbiB8fCBkaXNwbGF5T2JqZWN0LmlzTWFzayk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCBvciBhbnkgb2YgaXRzIGNoaWxkcmVuIGNhbm5vdCBwYXNzIHRoZSBoaXQgdGVzdCBhdCBhbGwuXG4gICAqXG4gICAqIHtAbGluayBQSVhJLkV2ZW50Qm91bmRhcnl9J3MgaW1wbGVtZW50YXRpb24gdXNlcyB0aGUge0BsaW5rIFBJWEkuRGlzcGxheU9iamVjdC5oaXRBcmVhIGhpdEFyZWF9XG4gICAqIGFuZCB7QGxpbmsgUElYSS5EaXNwbGF5T2JqZWN0Ll9tYXNrfSBmb3IgcHJ1bmluZy5cbiAgICogQHBhcmFtIGRpc3BsYXlPYmplY3RcbiAgICogQHBhcmFtIGxvY2F0aW9uXG4gICAqL1xuICBoaXRQcnVuZUZuKGRpc3BsYXlPYmplY3QsIGxvY2F0aW9uKSB7XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuaGl0QXJlYSAmJiAoZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UobG9jYXRpb24sIHRlbXBMb2NhbE1hcHBpbmcpLCAhZGlzcGxheU9iamVjdC5oaXRBcmVhLmNvbnRhaW5zKHRlbXBMb2NhbE1hcHBpbmcueCwgdGVtcExvY2FsTWFwcGluZy55KSkpXG4gICAgICByZXR1cm4gITA7XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuX21hc2spIHtcbiAgICAgIGNvbnN0IG1hc2tPYmplY3QgPSBkaXNwbGF5T2JqZWN0Ll9tYXNrLmlzTWFza0RhdGEgPyBkaXNwbGF5T2JqZWN0Ll9tYXNrLm1hc2tPYmplY3QgOiBkaXNwbGF5T2JqZWN0Ll9tYXNrO1xuICAgICAgaWYgKG1hc2tPYmplY3QgJiYgIW1hc2tPYmplY3QuY29udGFpbnNQb2ludD8uKGxvY2F0aW9uKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCBwYXNzZXMgaGl0IHRlc3RpbmcgZm9yIHRoZSBnaXZlbiBsb2NhdGlvbi5cbiAgICogQHBhcmFtIGRpc3BsYXlPYmplY3RcbiAgICogQHBhcmFtIGxvY2F0aW9uXG4gICAqIEByZXR1cm5zIC0gV2hldGhlciBgZGlzcGxheU9iamVjdGAgcGFzc2VzIGhpdCB0ZXN0aW5nIGZvciBgbG9jYXRpb25gLlxuICAgKi9cbiAgaGl0VGVzdEZuKGRpc3BsYXlPYmplY3QsIGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlPYmplY3QuZXZlbnRNb2RlID09PSBcInBhc3NpdmVcIiA/ICExIDogZGlzcGxheU9iamVjdC5oaXRBcmVhID8gITAgOiBkaXNwbGF5T2JqZWN0LmNvbnRhaW5zUG9pbnQgPyBkaXNwbGF5T2JqZWN0LmNvbnRhaW5zUG9pbnQobG9jYXRpb24pIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIE5vdGlmeSBhbGwgdGhlIGxpc3RlbmVycyB0byB0aGUgZXZlbnQncyBgY3VycmVudFRhcmdldGAuXG4gICAqXG4gICAqIElmIHRoZSBgY3VycmVudFRhcmdldGAgY29udGFpbnMgdGhlIHByb3BlcnR5IGBvbjx0eXBlPmAsIHRoZW4gaXQgaXMgY2FsbGVkIGhlcmUsXG4gICAqIHNpbXVsYXRpbmcgdGhlIGJlaGF2aW9yIGZyb20gdmVyc2lvbiA2LnggYW5kIHByaW9yLlxuICAgKiBAcGFyYW0gZSAtIFRoZSBldmVudCBwYXNzZWQgdG8gdGhlIHRhcmdldC5cbiAgICogQHBhcmFtIHR5cGVcbiAgICovXG4gIG5vdGlmeVRhcmdldChlLCB0eXBlKSB7XG4gICAgdHlwZSA9IHR5cGUgPz8gZS50eXBlO1xuICAgIGNvbnN0IGhhbmRsZXJLZXkgPSBgb24ke3R5cGV9YDtcbiAgICBlLmN1cnJlbnRUYXJnZXRbaGFuZGxlcktleV0/LihlKTtcbiAgICBjb25zdCBrZXkgPSBlLmV2ZW50UGhhc2UgPT09IGUuQ0FQVFVSSU5HX1BIQVNFIHx8IGUuZXZlbnRQaGFzZSA9PT0gZS5BVF9UQVJHRVQgPyBgJHt0eXBlfWNhcHR1cmVgIDogdHlwZTtcbiAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhlLCBrZXkpLCBlLmV2ZW50UGhhc2UgPT09IGUuQVRfVEFSR0VUICYmIHRoaXMubm90aWZ5TGlzdGVuZXJzKGUsIHR5cGUpO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSB1cHN0cmVhbSBgcG9pbnRlcmRvd25gIGV2ZW50cyB0byBhIGRvd25zdHJlYW0gYHBvaW50ZXJkb3duYCBldmVudC5cbiAgICpcbiAgICogYHRvdWNoc3RhcnRgLCBgcmlnaHRkb3duYCwgYG1vdXNlZG93bmAgZXZlbnRzIGFyZSBhbHNvIGRpc3BhdGNoZWQgZm9yIHNwZWNpZmljIHBvaW50ZXIgdHlwZXMuXG4gICAqIEBwYXJhbSBmcm9tXG4gICAqL1xuICBtYXBQb2ludGVyRG93bihmcm9tKSB7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZFBvaW50ZXJFdmVudC5GZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJFdmVudEJvdW5kYXJ5IGNhbm5vdCBtYXAgYSBub24tcG9pbnRlciBldmVudCBhcyBhIHBvaW50ZXIgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGUgPSB0aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tKTtcbiAgICBpZiAodGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwicG9pbnRlcmRvd25cIiksIGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIilcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcInRvdWNoc3RhcnRcIik7XG4gICAgZWxzZSBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwicGVuXCIpIHtcbiAgICAgIGNvbnN0IGlzUmlnaHRCdXR0b24gPSBlLmJ1dHRvbiA9PT0gMjtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLCBpc1JpZ2h0QnV0dG9uID8gXCJyaWdodGRvd25cIiA6IFwibW91c2Vkb3duXCIpO1xuICAgIH1cbiAgICBjb25zdCB0cmFja2luZ0RhdGEgPSB0aGlzLnRyYWNraW5nRGF0YShmcm9tLnBvaW50ZXJJZCk7XG4gICAgdHJhY2tpbmdEYXRhLnByZXNzVGFyZ2V0c0J5QnV0dG9uW2Zyb20uYnV0dG9uXSA9IGUuY29tcG9zZWRQYXRoKCksIHRoaXMuZnJlZUV2ZW50KGUpO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSB1cHN0cmVhbSBgcG9pbnRlcm1vdmVgIHRvIGRvd25zdHJlYW0gYHBvaW50ZXJvdXRgLCBgcG9pbnRlcm92ZXJgLCBhbmQgYHBvaW50ZXJtb3ZlYCBldmVudHMsIGluIHRoYXQgb3JkZXIuXG4gICAqXG4gICAqIFRoZSB0cmFja2luZyBkYXRhIGZvciB0aGUgc3BlY2lmaWMgcG9pbnRlciBoYXMgYW4gdXBkYXRlZCBgb3ZlclRhcmdldGAuIGBtb3VzZW91dGAsIGBtb3VzZW92ZXJgLFxuICAgKiBgbW91c2Vtb3ZlYCwgYW5kIGB0b3VjaG1vdmVgIGV2ZW50cyBhcmUgZmlyZWQgYXMgd2VsbCBmb3Igc3BlY2lmaWMgcG9pbnRlciB0eXBlcy5cbiAgICogQHBhcmFtIGZyb20gLSBUaGUgdXBzdHJlYW0gYHBvaW50ZXJtb3ZlYCBldmVudC5cbiAgICovXG4gIG1hcFBvaW50ZXJNb3ZlKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50LkZlZGVyYXRlZFBvaW50ZXJFdmVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi1wb2ludGVyIGV2ZW50IGFzIGEgcG9pbnRlciBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cy5sZW5ndGggPSAwLCB0aGlzLl9oaXRFbGVtZW50cy5sZW5ndGggPSAwLCB0aGlzLl9pc1BvaW50ZXJNb3ZlRXZlbnQgPSAhMDtcbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ID0gITE7XG4gICAgY29uc3QgaXNNb3VzZSA9IGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiLCB0cmFja2luZ0RhdGEgPSB0aGlzLnRyYWNraW5nRGF0YShmcm9tLnBvaW50ZXJJZCksIG91dFRhcmdldCA9IHRoaXMuZmluZE1vdW50ZWRUYXJnZXQodHJhY2tpbmdEYXRhLm92ZXJUYXJnZXRzKTtcbiAgICBpZiAodHJhY2tpbmdEYXRhLm92ZXJUYXJnZXRzPy5sZW5ndGggPiAwICYmIG91dFRhcmdldCAhPT0gZS50YXJnZXQpIHtcbiAgICAgIGNvbnN0IG91dFR5cGUgPSBmcm9tLnR5cGUgPT09IFwibW91c2Vtb3ZlXCIgPyBcIm1vdXNlb3V0XCIgOiBcInBvaW50ZXJvdXRcIiwgb3V0RXZlbnQgPSB0aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tLCBvdXRUeXBlLCBvdXRUYXJnZXQpO1xuICAgICAgaWYgKHRoaXMuZGlzcGF0Y2hFdmVudChvdXRFdmVudCwgXCJwb2ludGVyb3V0XCIpLCBpc01vdXNlICYmIHRoaXMuZGlzcGF0Y2hFdmVudChvdXRFdmVudCwgXCJtb3VzZW91dFwiKSwgIWUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMob3V0VGFyZ2V0KSkge1xuICAgICAgICBjb25zdCBsZWF2ZUV2ZW50ID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgXCJwb2ludGVybGVhdmVcIiwgb3V0VGFyZ2V0KTtcbiAgICAgICAgZm9yIChsZWF2ZUV2ZW50LmV2ZW50UGhhc2UgPSBsZWF2ZUV2ZW50LkFUX1RBUkdFVDsgbGVhdmVFdmVudC50YXJnZXQgJiYgIWUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMobGVhdmVFdmVudC50YXJnZXQpOyApXG4gICAgICAgICAgbGVhdmVFdmVudC5jdXJyZW50VGFyZ2V0ID0gbGVhdmVFdmVudC50YXJnZXQsIHRoaXMubm90aWZ5VGFyZ2V0KGxlYXZlRXZlbnQpLCBpc01vdXNlICYmIHRoaXMubm90aWZ5VGFyZ2V0KGxlYXZlRXZlbnQsIFwibW91c2VsZWF2ZVwiKSwgbGVhdmVFdmVudC50YXJnZXQgPSBsZWF2ZUV2ZW50LnRhcmdldC5wYXJlbnQ7XG4gICAgICAgIHRoaXMuZnJlZUV2ZW50KGxlYXZlRXZlbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmVlRXZlbnQob3V0RXZlbnQpO1xuICAgIH1cbiAgICBpZiAob3V0VGFyZ2V0ICE9PSBlLnRhcmdldCkge1xuICAgICAgY29uc3Qgb3ZlclR5cGUgPSBmcm9tLnR5cGUgPT09IFwibW91c2Vtb3ZlXCIgPyBcIm1vdXNlb3ZlclwiIDogXCJwb2ludGVyb3ZlclwiLCBvdmVyRXZlbnQgPSB0aGlzLmNsb25lUG9pbnRlckV2ZW50KGUsIG92ZXJUeXBlKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChvdmVyRXZlbnQsIFwicG9pbnRlcm92ZXJcIiksIGlzTW91c2UgJiYgdGhpcy5kaXNwYXRjaEV2ZW50KG92ZXJFdmVudCwgXCJtb3VzZW92ZXJcIik7XG4gICAgICBsZXQgb3ZlclRhcmdldEFuY2VzdG9yID0gb3V0VGFyZ2V0Py5wYXJlbnQ7XG4gICAgICBmb3IgKDsgb3ZlclRhcmdldEFuY2VzdG9yICYmIG92ZXJUYXJnZXRBbmNlc3RvciAhPT0gdGhpcy5yb290VGFyZ2V0LnBhcmVudCAmJiBvdmVyVGFyZ2V0QW5jZXN0b3IgIT09IGUudGFyZ2V0OyApXG4gICAgICAgIG92ZXJUYXJnZXRBbmNlc3RvciA9IG92ZXJUYXJnZXRBbmNlc3Rvci5wYXJlbnQ7XG4gICAgICBpZiAoIW92ZXJUYXJnZXRBbmNlc3RvciB8fCBvdmVyVGFyZ2V0QW5jZXN0b3IgPT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQpIHtcbiAgICAgICAgY29uc3QgZW50ZXJFdmVudCA9IHRoaXMuY2xvbmVQb2ludGVyRXZlbnQoZSwgXCJwb2ludGVyZW50ZXJcIik7XG4gICAgICAgIGZvciAoZW50ZXJFdmVudC5ldmVudFBoYXNlID0gZW50ZXJFdmVudC5BVF9UQVJHRVQ7IGVudGVyRXZlbnQudGFyZ2V0ICYmIGVudGVyRXZlbnQudGFyZ2V0ICE9PSBvdXRUYXJnZXQgJiYgZW50ZXJFdmVudC50YXJnZXQgIT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQ7IClcbiAgICAgICAgICBlbnRlckV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbnRlckV2ZW50LnRhcmdldCwgdGhpcy5ub3RpZnlUYXJnZXQoZW50ZXJFdmVudCksIGlzTW91c2UgJiYgdGhpcy5ub3RpZnlUYXJnZXQoZW50ZXJFdmVudCwgXCJtb3VzZWVudGVyXCIpLCBlbnRlckV2ZW50LnRhcmdldCA9IGVudGVyRXZlbnQudGFyZ2V0LnBhcmVudDtcbiAgICAgICAgdGhpcy5mcmVlRXZlbnQoZW50ZXJFdmVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyZWVFdmVudChvdmVyRXZlbnQpO1xuICAgIH1cbiAgICBjb25zdCBhbGxNZXRob2RzID0gW10sIGFsbG93R2xvYmFsUG9pbnRlckV2ZW50cyA9IHRoaXMuZW5hYmxlR2xvYmFsTW92ZUV2ZW50cyA/PyAhMDtcbiAgICB0aGlzLm1vdmVPbkFsbCA/IGFsbE1ldGhvZHMucHVzaChcInBvaW50ZXJtb3ZlXCIpIDogdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwicG9pbnRlcm1vdmVcIiksIGFsbG93R2xvYmFsUG9pbnRlckV2ZW50cyAmJiBhbGxNZXRob2RzLnB1c2goXCJnbG9iYWxwb2ludGVybW92ZVwiKSwgZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiICYmICh0aGlzLm1vdmVPbkFsbCA/IGFsbE1ldGhvZHMuc3BsaWNlKDEsIDAsIFwidG91Y2htb3ZlXCIpIDogdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwidG91Y2htb3ZlXCIpLCBhbGxvd0dsb2JhbFBvaW50ZXJFdmVudHMgJiYgYWxsTWV0aG9kcy5wdXNoKFwiZ2xvYmFsdG91Y2htb3ZlXCIpKSwgaXNNb3VzZSAmJiAodGhpcy5tb3ZlT25BbGwgPyBhbGxNZXRob2RzLnNwbGljZSgxLCAwLCBcIm1vdXNlbW92ZVwiKSA6IHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcIm1vdXNlbW92ZVwiKSwgYWxsb3dHbG9iYWxQb2ludGVyRXZlbnRzICYmIGFsbE1ldGhvZHMucHVzaChcImdsb2JhbG1vdXNlbW92ZVwiKSwgdGhpcy5jdXJzb3IgPSBlLnRhcmdldD8uY3Vyc29yKSwgYWxsTWV0aG9kcy5sZW5ndGggPiAwICYmIHRoaXMuYWxsKGUsIGFsbE1ldGhvZHMpLCB0aGlzLl9hbGxJbnRlcmFjdGl2ZUVsZW1lbnRzLmxlbmd0aCA9IDAsIHRoaXMuX2hpdEVsZW1lbnRzLmxlbmd0aCA9IDAsIHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyA9IGUuY29tcG9zZWRQYXRoKCksIHRoaXMuZnJlZUV2ZW50KGUpO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSB1cHN0cmVhbSBgcG9pbnRlcm92ZXJgIHRvIGRvd25zdHJlYW0gYHBvaW50ZXJvdmVyYCBhbmQgYHBvaW50ZXJlbnRlcmAgZXZlbnRzLCBpbiB0aGF0IG9yZGVyLlxuICAgKlxuICAgKiBUaGUgdHJhY2tpbmcgZGF0YSBmb3IgdGhlIHNwZWNpZmljIHBvaW50ZXIgZ2V0cyBhIG5ldyBgb3ZlclRhcmdldGAuXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHVwc3RyZWFtIGBwb2ludGVyb3ZlcmAgZXZlbnQuXG4gICAqL1xuICBtYXBQb2ludGVyT3Zlcihmcm9tKSB7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZFBvaW50ZXJFdmVudC5GZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJFdmVudEJvdW5kYXJ5IGNhbm5vdCBtYXAgYSBub24tcG9pbnRlciBldmVudCBhcyBhIHBvaW50ZXIgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKSwgZSA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20pLCBpc01vdXNlID0gZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwicGVuXCI7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwicG9pbnRlcm92ZXJcIiksIGlzTW91c2UgJiYgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwibW91c2VvdmVyXCIpLCBlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgJiYgKHRoaXMuY3Vyc29yID0gZS50YXJnZXQ/LmN1cnNvcik7XG4gICAgY29uc3QgZW50ZXJFdmVudCA9IHRoaXMuY2xvbmVQb2ludGVyRXZlbnQoZSwgXCJwb2ludGVyZW50ZXJcIik7XG4gICAgZm9yIChlbnRlckV2ZW50LmV2ZW50UGhhc2UgPSBlbnRlckV2ZW50LkFUX1RBUkdFVDsgZW50ZXJFdmVudC50YXJnZXQgJiYgZW50ZXJFdmVudC50YXJnZXQgIT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQ7IClcbiAgICAgIGVudGVyRXZlbnQuY3VycmVudFRhcmdldCA9IGVudGVyRXZlbnQudGFyZ2V0LCB0aGlzLm5vdGlmeVRhcmdldChlbnRlckV2ZW50KSwgaXNNb3VzZSAmJiB0aGlzLm5vdGlmeVRhcmdldChlbnRlckV2ZW50LCBcIm1vdXNlZW50ZXJcIiksIGVudGVyRXZlbnQudGFyZ2V0ID0gZW50ZXJFdmVudC50YXJnZXQucGFyZW50O1xuICAgIHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyA9IGUuY29tcG9zZWRQYXRoKCksIHRoaXMuZnJlZUV2ZW50KGUpLCB0aGlzLmZyZWVFdmVudChlbnRlckV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgdXBzdHJlYW0gYHBvaW50ZXJvdXRgIHRvIGRvd25zdHJlYW0gYHBvaW50ZXJvdXRgLCBgcG9pbnRlcmxlYXZlYCBldmVudHMsIGluIHRoYXQgb3JkZXIuXG4gICAqXG4gICAqIFRoZSB0cmFja2luZyBkYXRhIGZvciB0aGUgc3BlY2lmaWMgcG9pbnRlciBpcyBjbGVhcmVkIG9mIGEgYG92ZXJUYXJnZXRgLlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSB1cHN0cmVhbSBgcG9pbnRlcm91dGAgZXZlbnQuXG4gICAqL1xuICBtYXBQb2ludGVyT3V0KGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50LkZlZGVyYXRlZFBvaW50ZXJFdmVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi1wb2ludGVyIGV2ZW50IGFzIGEgcG9pbnRlciBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tpbmdEYXRhID0gdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpO1xuICAgIGlmICh0cmFja2luZ0RhdGEub3ZlclRhcmdldHMpIHtcbiAgICAgIGNvbnN0IGlzTW91c2UgPSBmcm9tLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgfHwgZnJvbS5wb2ludGVyVHlwZSA9PT0gXCJwZW5cIiwgb3V0VGFyZ2V0ID0gdGhpcy5maW5kTW91bnRlZFRhcmdldCh0cmFja2luZ0RhdGEub3ZlclRhcmdldHMpLCBvdXRFdmVudCA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIFwicG9pbnRlcm91dFwiLCBvdXRUYXJnZXQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG91dEV2ZW50KSwgaXNNb3VzZSAmJiB0aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQsIFwibW91c2VvdXRcIik7XG4gICAgICBjb25zdCBsZWF2ZUV2ZW50ID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgXCJwb2ludGVybGVhdmVcIiwgb3V0VGFyZ2V0KTtcbiAgICAgIGZvciAobGVhdmVFdmVudC5ldmVudFBoYXNlID0gbGVhdmVFdmVudC5BVF9UQVJHRVQ7IGxlYXZlRXZlbnQudGFyZ2V0ICYmIGxlYXZlRXZlbnQudGFyZ2V0ICE9PSB0aGlzLnJvb3RUYXJnZXQucGFyZW50OyApXG4gICAgICAgIGxlYXZlRXZlbnQuY3VycmVudFRhcmdldCA9IGxlYXZlRXZlbnQudGFyZ2V0LCB0aGlzLm5vdGlmeVRhcmdldChsZWF2ZUV2ZW50KSwgaXNNb3VzZSAmJiB0aGlzLm5vdGlmeVRhcmdldChsZWF2ZUV2ZW50LCBcIm1vdXNlbGVhdmVcIiksIGxlYXZlRXZlbnQudGFyZ2V0ID0gbGVhdmVFdmVudC50YXJnZXQucGFyZW50O1xuICAgICAgdHJhY2tpbmdEYXRhLm92ZXJUYXJnZXRzID0gbnVsbCwgdGhpcy5mcmVlRXZlbnQob3V0RXZlbnQpLCB0aGlzLmZyZWVFdmVudChsZWF2ZUV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSB1cHN0cmVhbSBgcG9pbnRlcnVwYCBldmVudCB0byBkb3duc3RyZWFtIGBwb2ludGVydXBgLCBgcG9pbnRlcnVwb3V0c2lkZWAsXG4gICAqIGFuZCBgY2xpY2tgL2ByaWdodGNsaWNrYC9gcG9pbnRlcnRhcGAgZXZlbnRzLCBpbiB0aGF0IG9yZGVyLlxuICAgKlxuICAgKiBUaGUgYHBvaW50ZXJ1cG91dHNpZGVgIGV2ZW50IGJ1YmJsZXMgZnJvbSB0aGUgb3JpZ2luYWwgYHBvaW50ZXJkb3duYCB0YXJnZXQgdG8gdGhlIG1vc3Qgc3BlY2lmaWNcbiAgICogYW5jZXN0b3Igb2YgdGhlIGBwb2ludGVyZG93bmAgYW5kIGBwb2ludGVydXBgIHRhcmdldHMsIHdoaWNoIGlzIGFsc28gdGhlIGBjbGlja2AgZXZlbnQncyB0YXJnZXQuIGB0b3VjaGVuZGAsXG4gICAqIGByaWdodHVwYCwgYG1vdXNldXBgLCBgdG91Y2hlbmRvdXRzaWRlYCwgYHJpZ2h0dXBvdXRzaWRlYCwgYG1vdXNldXBvdXRzaWRlYCwgYW5kIGB0YXBgIGFyZSBmaXJlZCBhcyB3ZWxsIGZvclxuICAgKiBzcGVjaWZpYyBwb2ludGVyIHR5cGVzLlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSB1cHN0cmVhbSBgcG9pbnRlcnVwYCBldmVudC5cbiAgICovXG4gIG1hcFBvaW50ZXJVcChmcm9tKSB7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZFBvaW50ZXJFdmVudC5GZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJFdmVudEJvdW5kYXJ5IGNhbm5vdCBtYXAgYSBub24tcG9pbnRlciBldmVudCBhcyBhIHBvaW50ZXIgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpLCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgaWYgKHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcInBvaW50ZXJ1cFwiKSwgZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKVxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwidG91Y2hlbmRcIik7XG4gICAgZWxzZSBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwicGVuXCIpIHtcbiAgICAgIGNvbnN0IGlzUmlnaHRCdXR0b24gPSBlLmJ1dHRvbiA9PT0gMjtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLCBpc1JpZ2h0QnV0dG9uID8gXCJyaWdodHVwXCIgOiBcIm1vdXNldXBcIik7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKSwgcHJlc3NUYXJnZXQgPSB0aGlzLmZpbmRNb3VudGVkVGFyZ2V0KHRyYWNraW5nRGF0YS5wcmVzc1RhcmdldHNCeUJ1dHRvbltmcm9tLmJ1dHRvbl0pO1xuICAgIGxldCBjbGlja1RhcmdldCA9IHByZXNzVGFyZ2V0O1xuICAgIGlmIChwcmVzc1RhcmdldCAmJiAhZS5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhwcmVzc1RhcmdldCkpIHtcbiAgICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gcHJlc3NUYXJnZXQ7XG4gICAgICBmb3IgKDsgY3VycmVudFRhcmdldCAmJiAhZS5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhjdXJyZW50VGFyZ2V0KTsgKSB7XG4gICAgICAgIGlmIChlLmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0LCB0aGlzLm5vdGlmeVRhcmdldChlLCBcInBvaW50ZXJ1cG91dHNpZGVcIiksIGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIilcbiAgICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCBcInRvdWNoZW5kb3V0c2lkZVwiKTtcbiAgICAgICAgZWxzZSBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwicGVuXCIpIHtcbiAgICAgICAgICBjb25zdCBpc1JpZ2h0QnV0dG9uID0gZS5idXR0b24gPT09IDI7XG4gICAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgaXNSaWdodEJ1dHRvbiA/IFwicmlnaHR1cG91dHNpZGVcIiA6IFwibW91c2V1cG91dHNpZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQucGFyZW50O1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRyYWNraW5nRGF0YS5wcmVzc1RhcmdldHNCeUJ1dHRvbltmcm9tLmJ1dHRvbl0sIGNsaWNrVGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICB9XG4gICAgaWYgKGNsaWNrVGFyZ2V0KSB7XG4gICAgICBjb25zdCBjbGlja0V2ZW50ID0gdGhpcy5jbG9uZVBvaW50ZXJFdmVudChlLCBcImNsaWNrXCIpO1xuICAgICAgY2xpY2tFdmVudC50YXJnZXQgPSBjbGlja1RhcmdldCwgY2xpY2tFdmVudC5wYXRoID0gbnVsbCwgdHJhY2tpbmdEYXRhLmNsaWNrc0J5QnV0dG9uW2Zyb20uYnV0dG9uXSB8fCAodHJhY2tpbmdEYXRhLmNsaWNrc0J5QnV0dG9uW2Zyb20uYnV0dG9uXSA9IHtcbiAgICAgICAgY2xpY2tDb3VudDogMCxcbiAgICAgICAgdGFyZ2V0OiBjbGlja0V2ZW50LnRhcmdldCxcbiAgICAgICAgdGltZVN0YW1wOiBub3dcbiAgICAgIH0pO1xuICAgICAgY29uc3QgY2xpY2tIaXN0b3J5ID0gdHJhY2tpbmdEYXRhLmNsaWNrc0J5QnV0dG9uW2Zyb20uYnV0dG9uXTtcbiAgICAgIGlmIChjbGlja0hpc3RvcnkudGFyZ2V0ID09PSBjbGlja0V2ZW50LnRhcmdldCAmJiBub3cgLSBjbGlja0hpc3RvcnkudGltZVN0YW1wIDwgMjAwID8gKytjbGlja0hpc3RvcnkuY2xpY2tDb3VudCA6IGNsaWNrSGlzdG9yeS5jbGlja0NvdW50ID0gMSwgY2xpY2tIaXN0b3J5LnRhcmdldCA9IGNsaWNrRXZlbnQudGFyZ2V0LCBjbGlja0hpc3RvcnkudGltZVN0YW1wID0gbm93LCBjbGlja0V2ZW50LmRldGFpbCA9IGNsaWNrSGlzdG9yeS5jbGlja0NvdW50LCBjbGlja0V2ZW50LnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIpIHtcbiAgICAgICAgY29uc3QgaXNSaWdodEJ1dHRvbiA9IGNsaWNrRXZlbnQuYnV0dG9uID09PSAyO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCwgaXNSaWdodEJ1dHRvbiA/IFwicmlnaHRjbGlja1wiIDogXCJjbGlja1wiKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBjbGlja0V2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIgJiYgdGhpcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQsIFwidGFwXCIpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQsIFwicG9pbnRlcnRhcFwiKSwgdGhpcy5mcmVlRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfVxuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSB1cHN0cmVhbSBgcG9pbnRlcnVwb3V0c2lkZWAgZXZlbnQgdG8gYSBkb3duc3RyZWFtIGBwb2ludGVydXBvdXRzaWRlYCBldmVudCwgYnViYmxpbmcgZnJvbSB0aGUgb3JpZ2luYWxcbiAgICogYHBvaW50ZXJkb3duYCB0YXJnZXQgdG8gYHJvb3RUYXJnZXRgLlxuICAgKlxuICAgKiAoVGhlIG1vc3Qgc3BlY2lmaWMgYW5jZXN0b3Igb2YgdGhlIGBwb2ludGVyZG93bmAgZXZlbnQgYW5kIHRoZSBgcG9pbnRlcnVwYCBldmVudCBtdXN0IHRoZVxuICAgKiBge0BsaW5rIFBJWEkuRXZlbnRCb3VuZGFyeX0ncyByb290IGJlY2F1c2UgdGhlIGBwb2ludGVydXBgIGV2ZW50IG9jY3VycmVkIG91dHNpZGUgb2YgdGhlIGJvdW5kYXJ5LilcbiAgICpcbiAgICogYHRvdWNoZW5kb3V0c2lkZWAsIGBtb3VzZXVwb3V0c2lkZWAsIGFuZCBgcmlnaHR1cG91dHNpZGVgIGV2ZW50cyBhcmUgZmlyZWQgYXMgd2VsbCBmb3Igc3BlY2lmaWMgcG9pbnRlclxuICAgKiB0eXBlcy4gVGhlIHRyYWNraW5nIGRhdGEgZm9yIHRoZSBzcGVjaWZpYyBwb2ludGVyIGlzIGNsZWFyZWQgb2YgYSBgcHJlc3NUYXJnZXRgLlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSB1cHN0cmVhbSBgcG9pbnRlcnVwb3V0c2lkZWAgZXZlbnQuXG4gICAqL1xuICBtYXBQb2ludGVyVXBPdXRzaWRlKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50LkZlZGVyYXRlZFBvaW50ZXJFdmVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi1wb2ludGVyIGV2ZW50IGFzIGEgcG9pbnRlciBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tpbmdEYXRhID0gdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpLCBwcmVzc1RhcmdldCA9IHRoaXMuZmluZE1vdW50ZWRUYXJnZXQodHJhY2tpbmdEYXRhLnByZXNzVGFyZ2V0c0J5QnV0dG9uW2Zyb20uYnV0dG9uXSksIGUgPSB0aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tKTtcbiAgICBpZiAocHJlc3NUYXJnZXQpIHtcbiAgICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gcHJlc3NUYXJnZXQ7XG4gICAgICBmb3IgKDsgY3VycmVudFRhcmdldDsgKVxuICAgICAgICBlLmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0LCB0aGlzLm5vdGlmeVRhcmdldChlLCBcInBvaW50ZXJ1cG91dHNpZGVcIiksIGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiA/IHRoaXMubm90aWZ5VGFyZ2V0KGUsIFwidG91Y2hlbmRvdXRzaWRlXCIpIDogKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiKSAmJiB0aGlzLm5vdGlmeVRhcmdldChlLCBlLmJ1dHRvbiA9PT0gMiA/IFwicmlnaHR1cG91dHNpZGVcIiA6IFwibW91c2V1cG91dHNpZGVcIiksIGN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0LnBhcmVudDtcbiAgICAgIGRlbGV0ZSB0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dO1xuICAgIH1cbiAgICB0aGlzLmZyZWVFdmVudChlKTtcbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgdXBzdHJlYW0gYHdoZWVsYCBldmVudCB0byBhIGRvd25zdHJlYW0gYHdoZWVsYCBldmVudC5cbiAgICogQHBhcmFtIGZyb20gLSBUaGUgdXBzdHJlYW0gYHdoZWVsYCBldmVudC5cbiAgICovXG4gIG1hcFdoZWVsKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkV2hlZWxFdmVudC5GZWRlcmF0ZWRXaGVlbEV2ZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXdoZWVsIGV2ZW50IGFzIGEgd2hlZWwgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdoZWVsRXZlbnQgPSB0aGlzLmNyZWF0ZVdoZWVsRXZlbnQoZnJvbSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KHdoZWVsRXZlbnQpLCB0aGlzLmZyZWVFdmVudCh3aGVlbEV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogRmluZHMgdGhlIG1vc3Qgc3BlY2lmaWMgZXZlbnQtdGFyZ2V0IGluIHRoZSBnaXZlbiBwcm9wYWdhdGlvbiBwYXRoIHRoYXQgaXMgc3RpbGwgbW91bnRlZCBpbiB0aGUgc2NlbmUgZ3JhcGguXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZCB0byBmaW5kIHRoZSBjb3JyZWN0IGBwb2ludGVydXBgIGFuZCBgcG9pbnRlcm91dGAgdGFyZ2V0IGluIHRoZSBjYXNlIHRoYXQgdGhlIG9yaWdpbmFsIGBwb2ludGVyZG93bmBcbiAgICogb3IgYHBvaW50ZXJvdmVyYCB0YXJnZXQgd2FzIHVubW91bnRlZCBmcm9tIHRoZSBzY2VuZSBncmFwaC5cbiAgICogQHBhcmFtIHByb3BhZ2F0aW9uUGF0aCAtIFRoZSBwcm9wYWdhdGlvbiBwYXRoIHdhcyB2YWxpZCBpbiB0aGUgcGFzdC5cbiAgICogQHJldHVybnMgLSBUaGUgbW9zdCBzcGVjaWZpYyBldmVudC10YXJnZXQgc3RpbGwgbW91bnRlZCBhdCB0aGUgc2FtZSBsb2NhdGlvbiBpbiB0aGUgc2NlbmUgZ3JhcGguXG4gICAqL1xuICBmaW5kTW91bnRlZFRhcmdldChwcm9wYWdhdGlvblBhdGgpIHtcbiAgICBpZiAoIXByb3BhZ2F0aW9uUGF0aClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gcHJvcGFnYXRpb25QYXRoWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcHJvcGFnYXRpb25QYXRoLmxlbmd0aCAmJiBwcm9wYWdhdGlvblBhdGhbaV0ucGFyZW50ID09PSBjdXJyZW50VGFyZ2V0OyBpKyspXG4gICAgICBjdXJyZW50VGFyZ2V0ID0gcHJvcGFnYXRpb25QYXRoW2ldO1xuICAgIHJldHVybiBjdXJyZW50VGFyZ2V0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV2ZW50IHdob3NlIHtAY29kZSBvcmlnaW5hbEV2ZW50fSBpcyB7QGNvZGUgZnJvbX0sIHdpdGggYW4gb3B0aW9uYWwgYHR5cGVgIGFuZCBgdGFyZ2V0YCBvdmVycmlkZS5cbiAgICpcbiAgICogVGhlIGV2ZW50IGlzIGFsbG9jYXRlZCB1c2luZyB7QGxpbmsgUElYSS5FdmVudEJvdW5kYXJ5I2FsbG9jYXRlRXZlbnQgdGhpcy5hbGxvY2F0ZUV2ZW50fS5cbiAgICogQHBhcmFtIGZyb20gLSBUaGUge0Bjb2RlIG9yaWdpbmFsRXZlbnR9IGZvciB0aGUgcmV0dXJuZWQgZXZlbnQuXG4gICAqIEBwYXJhbSBbdHlwZT1mcm9tLnR5cGVdIC0gVGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGV2ZW50LlxuICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvZiB0aGUgcmV0dXJuZWQgZXZlbnQuXG4gICAqL1xuICBjcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgdHlwZSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLmFsbG9jYXRlRXZlbnQoRmVkZXJhdGVkUG9pbnRlckV2ZW50LkZlZGVyYXRlZFBvaW50ZXJFdmVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29weVBvaW50ZXJEYXRhKGZyb20sIGV2ZW50KSwgdGhpcy5jb3B5TW91c2VEYXRhKGZyb20sIGV2ZW50KSwgdGhpcy5jb3B5RGF0YShmcm9tLCBldmVudCksIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gZnJvbS5uYXRpdmVFdmVudCwgZXZlbnQub3JpZ2luYWxFdmVudCA9IGZyb20sIGV2ZW50LnRhcmdldCA9IHRhcmdldCA/PyB0aGlzLmhpdFRlc3QoZXZlbnQuZ2xvYmFsLngsIGV2ZW50Lmdsb2JhbC55KSA/PyB0aGlzLl9oaXRFbGVtZW50c1swXSwgdHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIiAmJiAoZXZlbnQudHlwZSA9IHR5cGUpLCBldmVudDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHdoZWVsIGV2ZW50IHdob3NlIHtAY29kZSBvcmlnaW5hbEV2ZW50fSBpcyB7QGNvZGUgZnJvbX0uXG4gICAqXG4gICAqIFRoZSBldmVudCBpcyBhbGxvY2F0ZWQgdXNpbmcge0BsaW5rIFBJWEkuRXZlbnRCb3VuZGFyeSNhbGxvY2F0ZUV2ZW50IHRoaXMuYWxsb2NhdGVFdmVudH0uXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHVwc3RyZWFtIHdoZWVsIGV2ZW50LlxuICAgKi9cbiAgY3JlYXRlV2hlZWxFdmVudChmcm9tKSB7XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLmFsbG9jYXRlRXZlbnQoRmVkZXJhdGVkV2hlZWxFdmVudC5GZWRlcmF0ZWRXaGVlbEV2ZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb3B5V2hlZWxEYXRhKGZyb20sIGV2ZW50KSwgdGhpcy5jb3B5TW91c2VEYXRhKGZyb20sIGV2ZW50KSwgdGhpcy5jb3B5RGF0YShmcm9tLCBldmVudCksIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gZnJvbS5uYXRpdmVFdmVudCwgZXZlbnQub3JpZ2luYWxFdmVudCA9IGZyb20sIGV2ZW50LnRhcmdldCA9IHRoaXMuaGl0VGVzdChldmVudC5nbG9iYWwueCwgZXZlbnQuZ2xvYmFsLnkpLCBldmVudDtcbiAgfVxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBldmVudCB7QGNvZGUgZnJvbX0sIHdpdGggYW4gb3B0aW9uYWwge0Bjb2RlIHR5cGV9IG92ZXJyaWRlLlxuICAgKlxuICAgKiBUaGUgZXZlbnQgaXMgYWxsb2NhdGVkIHVzaW5nIHtAbGluayBQSVhJLkV2ZW50Qm91bmRhcnkjYWxsb2NhdGVFdmVudCB0aGlzLmFsbG9jYXRlRXZlbnR9LlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSBldmVudCB0byBjbG9uZS5cbiAgICogQHBhcmFtIFt0eXBlPWZyb20udHlwZV0gLSBUaGUgdHlwZSBvZiB0aGUgcmV0dXJuZWQgZXZlbnQuXG4gICAqL1xuICBjbG9uZVBvaW50ZXJFdmVudChmcm9tLCB0eXBlKSB7XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLmFsbG9jYXRlRXZlbnQoRmVkZXJhdGVkUG9pbnRlckV2ZW50LkZlZGVyYXRlZFBvaW50ZXJFdmVudCk7XG4gICAgcmV0dXJuIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gZnJvbS5uYXRpdmVFdmVudCwgZXZlbnQub3JpZ2luYWxFdmVudCA9IGZyb20ub3JpZ2luYWxFdmVudCwgdGhpcy5jb3B5UG9pbnRlckRhdGEoZnJvbSwgZXZlbnQpLCB0aGlzLmNvcHlNb3VzZURhdGEoZnJvbSwgZXZlbnQpLCB0aGlzLmNvcHlEYXRhKGZyb20sIGV2ZW50KSwgZXZlbnQudGFyZ2V0ID0gZnJvbS50YXJnZXQsIGV2ZW50LnBhdGggPSBmcm9tLmNvbXBvc2VkUGF0aCgpLnNsaWNlKCksIGV2ZW50LnR5cGUgPSB0eXBlID8/IGV2ZW50LnR5cGUsIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgd2hlZWwge0BsaW5rIFBJWEkuRmVkZXJhdGVkV2hlZWxFdmVudH0gZGF0YSBmcm9tIHtAY29kZSBmcm9tfSBpbnRvIHtAY29kZSB0b30uXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgY29waWVkOlxuICAgKiArIGRlbHRhTW9kZVxuICAgKiArIGRlbHRhWFxuICAgKiArIGRlbHRhWVxuICAgKiArIGRlbHRhWlxuICAgKiBAcGFyYW0gZnJvbVxuICAgKiBAcGFyYW0gdG9cbiAgICovXG4gIGNvcHlXaGVlbERhdGEoZnJvbSwgdG8pIHtcbiAgICB0by5kZWx0YU1vZGUgPSBmcm9tLmRlbHRhTW9kZSwgdG8uZGVsdGFYID0gZnJvbS5kZWx0YVgsIHRvLmRlbHRhWSA9IGZyb20uZGVsdGFZLCB0by5kZWx0YVogPSBmcm9tLmRlbHRhWjtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHBvaW50ZXIge0BsaW5rIFBJWEkuRmVkZXJhdGVkUG9pbnRlckV2ZW50fSBkYXRhIGZyb20ge0Bjb2RlIGZyb219IGludG8ge0Bjb2RlIHRvfS5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQ6XG4gICAqICsgcG9pbnRlcklkXG4gICAqICsgd2lkdGhcbiAgICogKyBoZWlnaHRcbiAgICogKyBpc1ByaW1hcnlcbiAgICogKyBwb2ludGVyVHlwZVxuICAgKiArIHByZXNzdXJlXG4gICAqICsgdGFuZ2VudGlhbFByZXNzdXJlXG4gICAqICsgdGlsdFhcbiAgICogKyB0aWx0WVxuICAgKiBAcGFyYW0gZnJvbVxuICAgKiBAcGFyYW0gdG9cbiAgICovXG4gIGNvcHlQb2ludGVyRGF0YShmcm9tLCB0bykge1xuICAgIGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQuRmVkZXJhdGVkUG9pbnRlckV2ZW50ICYmIHRvIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50LkZlZGVyYXRlZFBvaW50ZXJFdmVudCAmJiAodG8ucG9pbnRlcklkID0gZnJvbS5wb2ludGVySWQsIHRvLndpZHRoID0gZnJvbS53aWR0aCwgdG8uaGVpZ2h0ID0gZnJvbS5oZWlnaHQsIHRvLmlzUHJpbWFyeSA9IGZyb20uaXNQcmltYXJ5LCB0by5wb2ludGVyVHlwZSA9IGZyb20ucG9pbnRlclR5cGUsIHRvLnByZXNzdXJlID0gZnJvbS5wcmVzc3VyZSwgdG8udGFuZ2VudGlhbFByZXNzdXJlID0gZnJvbS50YW5nZW50aWFsUHJlc3N1cmUsIHRvLnRpbHRYID0gZnJvbS50aWx0WCwgdG8udGlsdFkgPSBmcm9tLnRpbHRZLCB0by50d2lzdCA9IGZyb20udHdpc3QpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgbW91c2Uge0BsaW5rIFBJWEkuRmVkZXJhdGVkTW91c2VFdmVudH0gZGF0YSBmcm9tIHtAY29kZSBmcm9tfSB0byB7QGNvZGUgdG99LlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGNvcGllZDpcbiAgICogKyBhbHRLZXlcbiAgICogKyBidXR0b25cbiAgICogKyBidXR0b25zXG4gICAqICsgY2xpZW50WFxuICAgKiArIGNsaWVudFlcbiAgICogKyBtZXRhS2V5XG4gICAqICsgbW92ZW1lbnRYXG4gICAqICsgbW92ZW1lbnRZXG4gICAqICsgcGFnZVhcbiAgICogKyBwYWdlWVxuICAgKiArIHhcbiAgICogKyB5XG4gICAqICsgc2NyZWVuXG4gICAqICsgc2hpZnRLZXlcbiAgICogKyBnbG9iYWxcbiAgICogQHBhcmFtIGZyb21cbiAgICogQHBhcmFtIHRvXG4gICAqL1xuICBjb3B5TW91c2VEYXRhKGZyb20sIHRvKSB7XG4gICAgZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZE1vdXNlRXZlbnQuRmVkZXJhdGVkTW91c2VFdmVudCAmJiB0byBpbnN0YW5jZW9mIEZlZGVyYXRlZE1vdXNlRXZlbnQuRmVkZXJhdGVkTW91c2VFdmVudCAmJiAodG8uYWx0S2V5ID0gZnJvbS5hbHRLZXksIHRvLmJ1dHRvbiA9IGZyb20uYnV0dG9uLCB0by5idXR0b25zID0gZnJvbS5idXR0b25zLCB0by5jbGllbnQuY29weUZyb20oZnJvbS5jbGllbnQpLCB0by5jdHJsS2V5ID0gZnJvbS5jdHJsS2V5LCB0by5tZXRhS2V5ID0gZnJvbS5tZXRhS2V5LCB0by5tb3ZlbWVudC5jb3B5RnJvbShmcm9tLm1vdmVtZW50KSwgdG8uc2NyZWVuLmNvcHlGcm9tKGZyb20uc2NyZWVuKSwgdG8uc2hpZnRLZXkgPSBmcm9tLnNoaWZ0S2V5LCB0by5nbG9iYWwuY29weUZyb20oZnJvbS5nbG9iYWwpKTtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGJhc2Uge0BsaW5rIFBJWEkuRmVkZXJhdGVkRXZlbnR9IGRhdGEgZnJvbSB7QGNvZGUgZnJvbX0gaW50byB7QGNvZGUgdG99LlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGNvcGllZDpcbiAgICogKyBpc1RydXN0ZWRcbiAgICogKyBzcmNFbGVtZW50XG4gICAqICsgdGltZVN0YW1wXG4gICAqICsgdHlwZVxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSBldmVudCB0byBjb3B5IGRhdGEgZnJvbS5cbiAgICogQHBhcmFtIHRvIC0gVGhlIGV2ZW50IHRvIGNvcHkgZGF0YSBpbnRvLlxuICAgKi9cbiAgY29weURhdGEoZnJvbSwgdG8pIHtcbiAgICB0by5pc1RydXN0ZWQgPSBmcm9tLmlzVHJ1c3RlZCwgdG8uc3JjRWxlbWVudCA9IGZyb20uc3JjRWxlbWVudCwgdG8udGltZVN0YW1wID0gcGVyZm9ybWFuY2Uubm93KCksIHRvLnR5cGUgPSBmcm9tLnR5cGUsIHRvLmRldGFpbCA9IGZyb20uZGV0YWlsLCB0by52aWV3ID0gZnJvbS52aWV3LCB0by53aGljaCA9IGZyb20ud2hpY2gsIHRvLmxheWVyLmNvcHlGcm9tKGZyb20ubGF5ZXIpLCB0by5wYWdlLmNvcHlGcm9tKGZyb20ucGFnZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBwb2ludGVyIElELlxuICAgKiBAcmV0dXJucyBUaGUgdHJhY2tpbmcgZGF0YSBzdG9yZWQgZm9yIHRoZSBnaXZlbiBwb2ludGVyLiBJZiBubyBkYXRhIGV4aXN0cywgYSBibGFua1xuICAgKiAgc3RhdGUgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgdHJhY2tpbmdEYXRhKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwcGluZ1N0YXRlLnRyYWNraW5nRGF0YVtpZF0gfHwgKHRoaXMubWFwcGluZ1N0YXRlLnRyYWNraW5nRGF0YVtpZF0gPSB7XG4gICAgICBwcmVzc1RhcmdldHNCeUJ1dHRvbjoge30sXG4gICAgICBjbGlja3NCeUJ1dHRvbjoge30sXG4gICAgICBvdmVyVGFyZ2V0OiBudWxsXG4gICAgfSksIHRoaXMubWFwcGluZ1N0YXRlLnRyYWNraW5nRGF0YVtpZF07XG4gIH1cbiAgLyoqXG4gICAqIEFsbG9jYXRlIGEgc3BlY2lmaWMgdHlwZSBvZiBldmVudCBmcm9tIHtAbGluayBQSVhJLkV2ZW50Qm91bmRhcnkjZXZlbnRQb29sIHRoaXMuZXZlbnRQb29sfS5cbiAgICpcbiAgICogVGhpcyBhbGxvY2F0aW9uIGlzIGNvbnN0cnVjdG9yLWFnbm9zdGljLCBhcyBsb25nIGFzIGl0IG9ubHkgdGFrZXMgb25lIGFyZ3VtZW50IC0gdGhpcyBldmVudFxuICAgKiBib3VuZGFyeS5cbiAgICogQHBhcmFtIGNvbnN0cnVjdG9yIC0gVGhlIGV2ZW50J3MgY29uc3RydWN0b3IuXG4gICAqL1xuICBhbGxvY2F0ZUV2ZW50KGNvbnN0cnVjdG9yKSB7XG4gICAgdGhpcy5ldmVudFBvb2wuaGFzKGNvbnN0cnVjdG9yKSB8fCB0aGlzLmV2ZW50UG9vbC5zZXQoY29uc3RydWN0b3IsIFtdKTtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuZXZlbnRQb29sLmdldChjb25zdHJ1Y3RvcikucG9wKCkgfHwgbmV3IGNvbnN0cnVjdG9yKHRoaXMpO1xuICAgIHJldHVybiBldmVudC5ldmVudFBoYXNlID0gZXZlbnQuTk9ORSwgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGwsIGV2ZW50LnBhdGggPSBudWxsLCBldmVudC50YXJnZXQgPSBudWxsLCBldmVudDtcbiAgfVxuICAvKipcbiAgICogRnJlZXMgdGhlIGV2ZW50IGFuZCBwdXRzIGl0IGJhY2sgaW50byB0aGUgZXZlbnQgcG9vbC5cbiAgICpcbiAgICogSXQgaXMgaWxsZWdhbCB0byByZXVzZSB0aGUgZXZlbnQgdW50aWwgaXQgaXMgYWxsb2NhdGVkIGFnYWluLCB1c2luZyBgdGhpcy5hbGxvY2F0ZUV2ZW50YC5cbiAgICpcbiAgICogSXQgaXMgYWxzbyBhZHZpc2VkIHRoYXQgZXZlbnRzIG5vdCBhbGxvY2F0ZWQgZnJvbSB7QGxpbmsgUElYSS5FdmVudEJvdW5kYXJ5I2FsbG9jYXRlRXZlbnQgdGhpcy5hbGxvY2F0ZUV2ZW50fVxuICAgKiBub3QgYmUgZnJlZWQuIFRoaXMgaXMgYmVjYXVzZSBvZiB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgc2FtZSBldmVudCBpcyBmcmVlZCB0d2ljZSwgd2hpY2ggY2FuIGNhdXNlXG4gICAqIGl0IHRvIGJlIGFsbG9jYXRlZCB0d2ljZSAmIHJlc3VsdCBpbiBvdmVyd3JpdGluZy5cbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGV2ZW50IHRvIGJlIGZyZWVkLlxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBldmVudCBpcyBtYW5hZ2VkIGJ5IGFub3RoZXIgZXZlbnQgYm91bmRhcnkuXG4gICAqL1xuICBmcmVlRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQubWFuYWdlciAhPT0gdGhpcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkl0IGlzIGlsbGVnYWwgdG8gZnJlZSBhbiBldmVudCBub3QgbWFuYWdlZCBieSB0aGlzIEV2ZW50Qm91bmRhcnkhXCIpO1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gZXZlbnQuY29uc3RydWN0b3I7XG4gICAgdGhpcy5ldmVudFBvb2wuaGFzKGNvbnN0cnVjdG9yKSB8fCB0aGlzLmV2ZW50UG9vbC5zZXQoY29uc3RydWN0b3IsIFtdKSwgdGhpcy5ldmVudFBvb2wuZ2V0KGNvbnN0cnVjdG9yKS5wdXNoKGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogU2ltaWxhciB0byB7QGxpbmsgUElYSS5FdmVudEVtaXR0ZXIuZW1pdH0sIGV4Y2VwdCBpdCBzdG9wcyBpZiB0aGUgYHByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkYCBmbGFnXG4gICAqIGlzIHNldCBvbiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSBlIC0gVGhlIGV2ZW50IHRvIGNhbGwgZWFjaCBsaXN0ZW5lciB3aXRoLlxuICAgKiBAcGFyYW0gdHlwZSAtIFRoZSBldmVudCBrZXkuXG4gICAqL1xuICBub3RpZnlMaXN0ZW5lcnMoZSwgdHlwZSkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IGUuY3VycmVudFRhcmdldC5fZXZlbnRzW3R5cGVdO1xuICAgIGlmIChsaXN0ZW5lcnMgJiYgZS5jdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKSlcbiAgICAgIGlmIChcImZuXCIgaW4gbGlzdGVuZXJzKVxuICAgICAgICBsaXN0ZW5lcnMub25jZSAmJiBlLmN1cnJlbnRUYXJnZXQucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzLmZuLCB2b2lkIDAsICEwKSwgbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGUpO1xuICAgICAgZWxzZVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBqICYmICFlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkOyBpKyspXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLm9uY2UgJiYgZS5jdXJyZW50VGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXS5mbiwgdm9pZCAwLCAhMCksIGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBlKTtcbiAgfVxufVxuZXhwb3J0cy5FdmVudEJvdW5kYXJ5ID0gRXZlbnRCb3VuZGFyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50Qm91bmRhcnkuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIEV2ZW50Qm91bmRhcnkgPSByZXF1aXJlKFwiLi9FdmVudEJvdW5kYXJ5LmpzXCIpLCBFdmVudFRpY2tlciA9IHJlcXVpcmUoXCIuL0V2ZW50VGlja2VyLmpzXCIpLCBGZWRlcmF0ZWRQb2ludGVyRXZlbnQgPSByZXF1aXJlKFwiLi9GZWRlcmF0ZWRQb2ludGVyRXZlbnQuanNcIiksIEZlZGVyYXRlZFdoZWVsRXZlbnQgPSByZXF1aXJlKFwiLi9GZWRlcmF0ZWRXaGVlbEV2ZW50LmpzXCIpO1xuY29uc3QgTU9VU0VfUE9JTlRFUl9JRCA9IDEsIFRPVUNIX1RPX1BPSU5URVIgPSB7XG4gIHRvdWNoc3RhcnQ6IFwicG9pbnRlcmRvd25cIixcbiAgdG91Y2hlbmQ6IFwicG9pbnRlcnVwXCIsXG4gIHRvdWNoZW5kb3V0c2lkZTogXCJwb2ludGVydXBvdXRzaWRlXCIsXG4gIHRvdWNobW92ZTogXCJwb2ludGVybW92ZVwiLFxuICB0b3VjaGNhbmNlbDogXCJwb2ludGVyY2FuY2VsXCJcbn0sIF9FdmVudFN5c3RlbSA9IGNsYXNzIF9FdmVudFN5c3RlbTIge1xuICAvKipcbiAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgPSBcIm9udG91Y2hzdGFydFwiIGluIGdsb2JhbFRoaXMsIHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzID0gISFnbG9iYWxUaGlzLlBvaW50ZXJFdmVudCwgdGhpcy5kb21FbGVtZW50ID0gbnVsbCwgdGhpcy5yZXNvbHV0aW9uID0gMSwgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyLCB0aGlzLnJvb3RCb3VuZGFyeSA9IG5ldyBFdmVudEJvdW5kYXJ5LkV2ZW50Qm91bmRhcnkobnVsbCksIEV2ZW50VGlja2VyLkV2ZW50c1RpY2tlci5pbml0KHRoaXMpLCB0aGlzLmF1dG9QcmV2ZW50RGVmYXVsdCA9ICEwLCB0aGlzLmV2ZW50c0FkZGVkID0gITEsIHRoaXMucm9vdFBvaW50ZXJFdmVudCA9IG5ldyBGZWRlcmF0ZWRQb2ludGVyRXZlbnQuRmVkZXJhdGVkUG9pbnRlckV2ZW50KG51bGwpLCB0aGlzLnJvb3RXaGVlbEV2ZW50ID0gbmV3IEZlZGVyYXRlZFdoZWVsRXZlbnQuRmVkZXJhdGVkV2hlZWxFdmVudChudWxsKSwgdGhpcy5jdXJzb3JTdHlsZXMgPSB7XG4gICAgICBkZWZhdWx0OiBcImluaGVyaXRcIixcbiAgICAgIHBvaW50ZXI6IFwicG9pbnRlclwiXG4gICAgfSwgdGhpcy5mZWF0dXJlcyA9IG5ldyBQcm94eSh7IC4uLl9FdmVudFN5c3RlbTIuZGVmYXVsdEV2ZW50RmVhdHVyZXMgfSwge1xuICAgICAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlKSA9PiAoa2V5ID09PSBcImdsb2JhbE1vdmVcIiAmJiAodGhpcy5yb290Qm91bmRhcnkuZW5hYmxlR2xvYmFsTW92ZUV2ZW50cyA9IHZhbHVlKSwgdGFyZ2V0W2tleV0gPSB2YWx1ZSwgITApXG4gICAgfSksIHRoaXMub25Qb2ludGVyRG93biA9IHRoaXMub25Qb2ludGVyRG93bi5iaW5kKHRoaXMpLCB0aGlzLm9uUG9pbnRlck1vdmUgPSB0aGlzLm9uUG9pbnRlck1vdmUuYmluZCh0aGlzKSwgdGhpcy5vblBvaW50ZXJVcCA9IHRoaXMub25Qb2ludGVyVXAuYmluZCh0aGlzKSwgdGhpcy5vblBvaW50ZXJPdmVyT3V0ID0gdGhpcy5vblBvaW50ZXJPdmVyT3V0LmJpbmQodGhpcyksIHRoaXMub25XaGVlbCA9IHRoaXMub25XaGVlbC5iaW5kKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBpbnRlcmFjdGlvbiBtb2RlIGZvciBhbGwgZGlzcGxheSBvYmplY3RzLlxuICAgKiBAc2VlIFBJWEkuRGlzcGxheU9iamVjdC5ldmVudE1vZGVcbiAgICogQHR5cGUge1BJWEkuRXZlbnRNb2RlfVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHNpbmNlIDcuMi4wXG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRFdmVudE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRFdmVudE1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJ1bm5lciBpbml0IGNhbGxlZCwgdmlldyBpcyBhdmFpbGFibGUgYXQgdGhpcyBwb2ludC5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgY29uc3QgeyB2aWV3LCByZXNvbHV0aW9uIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIHRoaXMuc2V0VGFyZ2V0RWxlbWVudCh2aWV3KSwgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiwgX0V2ZW50U3lzdGVtMi5fZGVmYXVsdEV2ZW50TW9kZSA9IG9wdGlvbnMuZXZlbnRNb2RlID8/IFwiYXV0b1wiLCBPYmplY3QuYXNzaWduKHRoaXMuZmVhdHVyZXMsIG9wdGlvbnMuZXZlbnRGZWF0dXJlcyA/PyB7fSksIHRoaXMucm9vdEJvdW5kYXJ5LmVuYWJsZUdsb2JhbE1vdmVFdmVudHMgPSB0aGlzLmZlYXR1cmVzLmdsb2JhbE1vdmU7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBjaGFuZ2luZyByZXNvbHV0aW9uLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICByZXNvbHV0aW9uQ2hhbmdlKHJlc29sdXRpb24pIHtcbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICB9XG4gIC8qKiBEZXN0cm95cyBhbGwgZXZlbnQgbGlzdGVuZXJzIGFuZCBkZXRhY2hlcyB0aGUgcmVuZGVyZXIuICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zZXRUYXJnZXRFbGVtZW50KG51bGwpLCB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBjdXJzb3IgbW9kZSwgaGFuZGxpbmcgYW55IGNhbGxiYWNrcyBvciBDU1Mgc3R5bGUgY2hhbmdlcy5cbiAgICogQHBhcmFtIG1vZGUgLSBjdXJzb3IgbW9kZSwgYSBrZXkgZnJvbSB0aGUgY3Vyc29yU3R5bGVzIGRpY3Rpb25hcnlcbiAgICovXG4gIHNldEN1cnNvcihtb2RlKSB7XG4gICAgbW9kZSA9IG1vZGUgfHwgXCJkZWZhdWx0XCI7XG4gICAgbGV0IGFwcGx5U3R5bGVzID0gITA7XG4gICAgaWYgKGdsb2JhbFRoaXMuT2Zmc2NyZWVuQ2FudmFzICYmIHRoaXMuZG9tRWxlbWVudCBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcyAmJiAoYXBwbHlTdHlsZXMgPSAhMSksIHRoaXMuY3VycmVudEN1cnNvciA9PT0gbW9kZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmN1cnJlbnRDdXJzb3IgPSBtb2RlO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5jdXJzb3JTdHlsZXNbbW9kZV07XG4gICAgaWYgKHN0eWxlKVxuICAgICAgc3dpdGNoICh0eXBlb2Ygc3R5bGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIGFwcGx5U3R5bGVzICYmICh0aGlzLmRvbUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gc3R5bGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICBzdHlsZShtb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGFwcGx5U3R5bGVzICYmIE9iamVjdC5hc3NpZ24odGhpcy5kb21FbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgYXBwbHlTdHlsZXMgJiYgdHlwZW9mIG1vZGUgPT0gXCJzdHJpbmdcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY3Vyc29yU3R5bGVzLCBtb2RlKSAmJiAodGhpcy5kb21FbGVtZW50LnN0eWxlLmN1cnNvciA9IG1vZGUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZ2xvYmFsIHBvaW50ZXIgZXZlbnQuXG4gICAqIFVzZWZ1bCBmb3IgZ2V0dGluZyB0aGUgcG9pbnRlciBwb3NpdGlvbiB3aXRob3V0IGxpc3RlbmluZyB0byBldmVudHMuXG4gICAqIEBzaW5jZSA3LjIuMFxuICAgKi9cbiAgZ2V0IHBvaW50ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdFBvaW50ZXJFdmVudDtcbiAgfVxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgcG9pbnRlciBkb3duIGV2ZW50cyBvbiB7QGxpbmsgUElYSS5FdmVudFN5c3RlbSNkb21FbGVtZW50IHRoaXMuZG9tRWxlbWVudH0uXG4gICAqIEBwYXJhbSBuYXRpdmVFdmVudCAtIFRoZSBuYXRpdmUgbW91c2UvcG9pbnRlci90b3VjaCBldmVudC5cbiAgICovXG4gIG9uUG9pbnRlckRvd24obmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXMuY2xpY2spXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yb290Qm91bmRhcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShuYXRpdmVFdmVudCk7XG4gICAgdGhpcy5hdXRvUHJldmVudERlZmF1bHQgJiYgZXZlbnRzWzBdLmlzTm9ybWFsaXplZCAmJiAobmF0aXZlRXZlbnQuY2FuY2VsYWJsZSB8fCAhKFwiY2FuY2VsYWJsZVwiIGluIG5hdGl2ZUV2ZW50KSkgJiYgbmF0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGV2ZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUV2ZW50MiA9IGV2ZW50c1tpXSwgZmVkZXJhdGVkRXZlbnQgPSB0aGlzLmJvb3RzdHJhcEV2ZW50KHRoaXMucm9vdFBvaW50ZXJFdmVudCwgbmF0aXZlRXZlbnQyKTtcbiAgICAgIHRoaXMucm9vdEJvdW5kYXJ5Lm1hcEV2ZW50KGZlZGVyYXRlZEV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5zZXRDdXJzb3IodGhpcy5yb290Qm91bmRhcnkuY3Vyc29yKTtcbiAgfVxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgcG9pbnRlciBtb3ZlIGV2ZW50cyBvbiBvbiB7QGxpbmsgUElYSS5FdmVudFN5c3RlbSNkb21FbGVtZW50IHRoaXMuZG9tRWxlbWVudH0uXG4gICAqIEBwYXJhbSBuYXRpdmVFdmVudCAtIFRoZSBuYXRpdmUgbW91c2UvcG9pbnRlci90b3VjaCBldmVudHMuXG4gICAqL1xuICBvblBvaW50ZXJNb3ZlKG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLm1vdmUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yb290Qm91bmRhcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkLCBFdmVudFRpY2tlci5FdmVudHNUaWNrZXIucG9pbnRlck1vdmVkKCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZEV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShuYXRpdmVFdmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBub3JtYWxpemVkRXZlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmJvb3RzdHJhcEV2ZW50KHRoaXMucm9vdFBvaW50ZXJFdmVudCwgbm9ybWFsaXplZEV2ZW50c1tpXSk7XG4gICAgICB0aGlzLnJvb3RCb3VuZGFyeS5tYXBFdmVudChldmVudCk7XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMucm9vdEJvdW5kYXJ5LmN1cnNvcik7XG4gIH1cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHBvaW50ZXIgdXAgZXZlbnRzIG9uIHtAbGluayBQSVhJLkV2ZW50U3lzdGVtI2RvbUVsZW1lbnQgdGhpcy5kb21FbGVtZW50fS5cbiAgICogQHBhcmFtIG5hdGl2ZUV2ZW50IC0gVGhlIG5hdGl2ZSBtb3VzZS9wb2ludGVyL3RvdWNoIGV2ZW50LlxuICAgKi9cbiAgb25Qb2ludGVyVXAobmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXMuY2xpY2spXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yb290Qm91bmRhcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICAgIGxldCB0YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQ7XG4gICAgbmF0aXZlRXZlbnQuY29tcG9zZWRQYXRoICYmIG5hdGl2ZUV2ZW50LmNvbXBvc2VkUGF0aCgpLmxlbmd0aCA+IDAgJiYgKHRhcmdldCA9IG5hdGl2ZUV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdKTtcbiAgICBjb25zdCBvdXRzaWRlID0gdGFyZ2V0ICE9PSB0aGlzLmRvbUVsZW1lbnQgPyBcIm91dHNpZGVcIiA6IFwiXCIsIG5vcm1hbGl6ZWRFdmVudHMgPSB0aGlzLm5vcm1hbGl6ZVRvUG9pbnRlckRhdGEobmF0aXZlRXZlbnQpO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gbm9ybWFsaXplZEV2ZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5ib290c3RyYXBFdmVudCh0aGlzLnJvb3RQb2ludGVyRXZlbnQsIG5vcm1hbGl6ZWRFdmVudHNbaV0pO1xuICAgICAgZXZlbnQudHlwZSArPSBvdXRzaWRlLCB0aGlzLnJvb3RCb3VuZGFyeS5tYXBFdmVudChldmVudCk7XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMucm9vdEJvdW5kYXJ5LmN1cnNvcik7XG4gIH1cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHBvaW50ZXIgb3ZlciAmIG91dCBldmVudHMgb24ge0BsaW5rIFBJWEkuRXZlbnRTeXN0ZW0jZG9tRWxlbWVudCB0aGlzLmRvbUVsZW1lbnR9LlxuICAgKiBAcGFyYW0gbmF0aXZlRXZlbnQgLSBUaGUgbmF0aXZlIG1vdXNlL3BvaW50ZXIvdG91Y2ggZXZlbnQuXG4gICAqL1xuICBvblBvaW50ZXJPdmVyT3V0KG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLmNsaWNrKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5LnJvb3RUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZDtcbiAgICBjb25zdCBub3JtYWxpemVkRXZlbnRzID0gdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG5hdGl2ZUV2ZW50KTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IG5vcm1hbGl6ZWRFdmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBjb25zdCBldmVudCA9IHRoaXMuYm9vdHN0cmFwRXZlbnQodGhpcy5yb290UG9pbnRlckV2ZW50LCBub3JtYWxpemVkRXZlbnRzW2ldKTtcbiAgICAgIHRoaXMucm9vdEJvdW5kYXJ5Lm1hcEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5zZXRDdXJzb3IodGhpcy5yb290Qm91bmRhcnkuY3Vyc29yKTtcbiAgfVxuICAvKipcbiAgICogUGFzc2l2ZSBoYW5kbGVyIGZvciBgd2hlZWxgIGV2ZW50cyBvbiB7QGxpbmsgUElYSS5FdmVudFN5c3RlbS5kb21FbGVtZW50IHRoaXMuZG9tRWxlbWVudH0uXG4gICAqIEBwYXJhbSBuYXRpdmVFdmVudCAtIFRoZSBuYXRpdmUgd2hlZWwgZXZlbnQuXG4gICAqL1xuICBvbldoZWVsKG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLndoZWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHdoZWVsRXZlbnQgPSB0aGlzLm5vcm1hbGl6ZVdoZWVsRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5LnJvb3RUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZCwgdGhpcy5yb290Qm91bmRhcnkubWFwRXZlbnQod2hlZWxFdmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHtAbGluayBQSVhJLkV2ZW50U3lzdGVtI2RvbUVsZW1lbnQgZG9tRWxlbWVudH0gYW5kIGJpbmRzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogVG8gZGVyZWdpc3RlciB0aGUgY3VycmVudCBET00gZWxlbWVudCB3aXRob3V0IHNldHRpbmcgYSBuZXcgb25lLCBwYXNzIHtAY29kZSBudWxsfS5cbiAgICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgbmV3IERPTSBlbGVtZW50LlxuICAgKi9cbiAgc2V0VGFyZ2V0RWxlbWVudChlbGVtZW50KSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudHMoKSwgdGhpcy5kb21FbGVtZW50ID0gZWxlbWVudCwgRXZlbnRUaWNrZXIuRXZlbnRzVGlja2VyLmRvbUVsZW1lbnQgPSBlbGVtZW50LCB0aGlzLmFkZEV2ZW50cygpO1xuICB9XG4gIC8qKiBSZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgb24ge0BsaW5rIFBJWEkuUmVuZGVyZXIjZG9tRWxlbWVudCB0aGlzLmRvbUVsZW1lbnR9LiAqL1xuICBhZGRFdmVudHMoKSB7XG4gICAgaWYgKHRoaXMuZXZlbnRzQWRkZWQgfHwgIXRoaXMuZG9tRWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICBFdmVudFRpY2tlci5FdmVudHNUaWNrZXIuYWRkVGlja2VyTGlzdGVuZXIoKTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuZG9tRWxlbWVudC5zdHlsZTtcbiAgICBzdHlsZSAmJiAoZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCA/IChzdHlsZS5tc0NvbnRlbnRab29taW5nID0gXCJub25lXCIsIHN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcIm5vbmVcIikgOiB0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cyAmJiAoc3R5bGUudG91Y2hBY3Rpb24gPSBcIm5vbmVcIikpLCB0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cyA/IChnbG9iYWxUaGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsICEwKSwgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLm9uUG9pbnRlckRvd24sICEwKSwgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCAhMCksIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm92ZXJcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCAhMCksIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLm9uUG9pbnRlclVwLCAhMCkpIDogKGdsb2JhbFRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsICEwKSwgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vblBvaW50ZXJEb3duLCAhMCksIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCAhMCksIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIHRoaXMub25Qb2ludGVyT3Zlck91dCwgITApLCBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMub25Qb2ludGVyVXAsICEwKSwgdGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmICh0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5vblBvaW50ZXJEb3duLCAhMCksIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5vblBvaW50ZXJVcCwgITApLCB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsICEwKSkpLCB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMub25XaGVlbCwge1xuICAgICAgcGFzc2l2ZTogITAsXG4gICAgICBjYXB0dXJlOiAhMFxuICAgIH0pLCB0aGlzLmV2ZW50c0FkZGVkID0gITA7XG4gIH1cbiAgLyoqIFVucmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIG9uIHtAbGluayBQSVhJLkV2ZW50U3lzdGVtI2RvbUVsZW1lbnQgdGhpcy5kb21FbGVtZW50fS4gKi9cbiAgcmVtb3ZlRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5ldmVudHNBZGRlZCB8fCAhdGhpcy5kb21FbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIEV2ZW50VGlja2VyLkV2ZW50c1RpY2tlci5yZW1vdmVUaWNrZXJMaXN0ZW5lcigpO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5kb21FbGVtZW50LnN0eWxlO1xuICAgIGdsb2JhbFRoaXMubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgPyAoc3R5bGUubXNDb250ZW50Wm9vbWluZyA9IFwiXCIsIHN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcIlwiKSA6IHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzICYmIChzdHlsZS50b3VjaEFjdGlvbiA9IFwiXCIpLCB0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cyA/IChnbG9iYWxUaGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsICEwKSwgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLm9uUG9pbnRlckRvd24sICEwKSwgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCAhMCksIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm92ZXJcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCAhMCksIGdsb2JhbFRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLm9uUG9pbnRlclVwLCAhMCkpIDogKGdsb2JhbFRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsICEwKSwgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vblBvaW50ZXJEb3duLCAhMCksIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCAhMCksIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIHRoaXMub25Qb2ludGVyT3Zlck91dCwgITApLCBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMub25Qb2ludGVyVXAsICEwKSwgdGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmICh0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5vblBvaW50ZXJEb3duLCAhMCksIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5vblBvaW50ZXJVcCwgITApLCB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsICEwKSkpLCB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMub25XaGVlbCwgITApLCB0aGlzLmRvbUVsZW1lbnQgPSBudWxsLCB0aGlzLmV2ZW50c0FkZGVkID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIE1hcHMgeCBhbmQgeSBjb29yZHMgZnJvbSBhIERPTSBvYmplY3QgYW5kIG1hcHMgdGhlbSBjb3JyZWN0bHkgdG8gdGhlIFBpeGlKUyB2aWV3LiBUaGVcbiAgICogcmVzdWx0aW5nIHZhbHVlIGlzIHN0b3JlZCBpbiB0aGUgcG9pbnQuIFRoaXMgdGFrZXMgaW50byBhY2NvdW50IHRoZSBmYWN0IHRoYXQgdGhlIERPTVxuICAgKiBlbGVtZW50IGNvdWxkIGJlIHNjYWxlZCBhbmQgcG9zaXRpb25lZCBhbnl3aGVyZSBvbiB0aGUgc2NyZWVuLlxuICAgKiBAcGFyYW0gIHtQSVhJLklQb2ludERhdGF9IHBvaW50IC0gdGhlIHBvaW50IHRoYXQgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCBpblxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB0aGUgeCBjb29yZCBvZiB0aGUgcG9zaXRpb24gdG8gbWFwXG4gICAqIEBwYXJhbSAge251bWJlcn0geSAtIHRoZSB5IGNvb3JkIG9mIHRoZSBwb3NpdGlvbiB0byBtYXBcbiAgICovXG4gIG1hcFBvc2l0aW9uVG9Qb2ludChwb2ludCwgeCwgeSkge1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmRvbUVsZW1lbnQuaXNDb25uZWN0ZWQgPyB0aGlzLmRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiB0aGlzLmRvbUVsZW1lbnQud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuZG9tRWxlbWVudC5oZWlnaHQsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfSwgcmVzb2x1dGlvbk11bHRpcGxpZXIgPSAxIC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHBvaW50LnggPSAoeCAtIHJlY3QubGVmdCkgKiAodGhpcy5kb21FbGVtZW50LndpZHRoIC8gcmVjdC53aWR0aCkgKiByZXNvbHV0aW9uTXVsdGlwbGllciwgcG9pbnQueSA9ICh5IC0gcmVjdC50b3ApICogKHRoaXMuZG9tRWxlbWVudC5oZWlnaHQgLyByZWN0LmhlaWdodCkgKiByZXNvbHV0aW9uTXVsdGlwbGllcjtcbiAgfVxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IHRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QgY29udGFpbnMgYWxsIGRhdGEgdGhhdCBhIHJlZ3VsYXIgcG9pbnRlciBldmVudCB3b3VsZCBoYXZlXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBvcmlnaW5hbCBldmVudCBkYXRhIGZyb20gYSB0b3VjaCBvciBtb3VzZSBldmVudFxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIGEgc2luZ2xlIG5vcm1hbGl6ZWQgcG9pbnRlciBldmVudCwgaW4gdGhlIGNhc2Ugb2YgYSBwb2ludGVyXG4gICAqICBvciBtb3VzZSBldmVudCwgb3IgYSBtdWx0aXBsZSBub3JtYWxpemVkIHBvaW50ZXIgZXZlbnRzIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBjaGFuZ2VkIHRvdWNoZXNcbiAgICovXG4gIG5vcm1hbGl6ZVRvUG9pbnRlckRhdGEoZXZlbnQpIHtcbiAgICBjb25zdCBub3JtYWxpemVkRXZlbnRzID0gW107XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBldmVudCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpXG4gICAgICBmb3IgKGxldCBpID0gMCwgbGkgPSBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkgPCBsaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgICAgIHR5cGVvZiB0b3VjaC5idXR0b24gPiBcInVcIiAmJiAodG91Y2guYnV0dG9uID0gMCksIHR5cGVvZiB0b3VjaC5idXR0b25zID4gXCJ1XCIgJiYgKHRvdWNoLmJ1dHRvbnMgPSAxKSwgdHlwZW9mIHRvdWNoLmlzUHJpbWFyeSA+IFwidVwiICYmICh0b3VjaC5pc1ByaW1hcnkgPSBldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSAmJiBldmVudC50eXBlID09PSBcInRvdWNoc3RhcnRcIiksIHR5cGVvZiB0b3VjaC53aWR0aCA+IFwidVwiICYmICh0b3VjaC53aWR0aCA9IHRvdWNoLnJhZGl1c1ggfHwgMSksIHR5cGVvZiB0b3VjaC5oZWlnaHQgPiBcInVcIiAmJiAodG91Y2guaGVpZ2h0ID0gdG91Y2gucmFkaXVzWSB8fCAxKSwgdHlwZW9mIHRvdWNoLnRpbHRYID4gXCJ1XCIgJiYgKHRvdWNoLnRpbHRYID0gMCksIHR5cGVvZiB0b3VjaC50aWx0WSA+IFwidVwiICYmICh0b3VjaC50aWx0WSA9IDApLCB0eXBlb2YgdG91Y2gucG9pbnRlclR5cGUgPiBcInVcIiAmJiAodG91Y2gucG9pbnRlclR5cGUgPSBcInRvdWNoXCIpLCB0eXBlb2YgdG91Y2gucG9pbnRlcklkID4gXCJ1XCIgJiYgKHRvdWNoLnBvaW50ZXJJZCA9IHRvdWNoLmlkZW50aWZpZXIgfHwgMCksIHR5cGVvZiB0b3VjaC5wcmVzc3VyZSA+IFwidVwiICYmICh0b3VjaC5wcmVzc3VyZSA9IHRvdWNoLmZvcmNlIHx8IDAuNSksIHR5cGVvZiB0b3VjaC50d2lzdCA+IFwidVwiICYmICh0b3VjaC50d2lzdCA9IDApLCB0eXBlb2YgdG91Y2gudGFuZ2VudGlhbFByZXNzdXJlID4gXCJ1XCIgJiYgKHRvdWNoLnRhbmdlbnRpYWxQcmVzc3VyZSA9IDApLCB0eXBlb2YgdG91Y2gubGF5ZXJYID4gXCJ1XCIgJiYgKHRvdWNoLmxheWVyWCA9IHRvdWNoLm9mZnNldFggPSB0b3VjaC5jbGllbnRYKSwgdHlwZW9mIHRvdWNoLmxheWVyWSA+IFwidVwiICYmICh0b3VjaC5sYXllclkgPSB0b3VjaC5vZmZzZXRZID0gdG91Y2guY2xpZW50WSksIHRvdWNoLmlzTm9ybWFsaXplZCA9ICEwLCB0b3VjaC50eXBlID0gZXZlbnQudHlwZSwgbm9ybWFsaXplZEV2ZW50cy5wdXNoKHRvdWNoKTtcbiAgICAgIH1cbiAgICBlbHNlIGlmICghZ2xvYmFsVGhpcy5Nb3VzZUV2ZW50IHx8IGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCAmJiAoIXRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzIHx8ICEoZXZlbnQgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLlBvaW50ZXJFdmVudCkpKSB7XG4gICAgICBjb25zdCB0ZW1wRXZlbnQgPSBldmVudDtcbiAgICAgIHR5cGVvZiB0ZW1wRXZlbnQuaXNQcmltYXJ5ID4gXCJ1XCIgJiYgKHRlbXBFdmVudC5pc1ByaW1hcnkgPSAhMCksIHR5cGVvZiB0ZW1wRXZlbnQud2lkdGggPiBcInVcIiAmJiAodGVtcEV2ZW50LndpZHRoID0gMSksIHR5cGVvZiB0ZW1wRXZlbnQuaGVpZ2h0ID4gXCJ1XCIgJiYgKHRlbXBFdmVudC5oZWlnaHQgPSAxKSwgdHlwZW9mIHRlbXBFdmVudC50aWx0WCA+IFwidVwiICYmICh0ZW1wRXZlbnQudGlsdFggPSAwKSwgdHlwZW9mIHRlbXBFdmVudC50aWx0WSA+IFwidVwiICYmICh0ZW1wRXZlbnQudGlsdFkgPSAwKSwgdHlwZW9mIHRlbXBFdmVudC5wb2ludGVyVHlwZSA+IFwidVwiICYmICh0ZW1wRXZlbnQucG9pbnRlclR5cGUgPSBcIm1vdXNlXCIpLCB0eXBlb2YgdGVtcEV2ZW50LnBvaW50ZXJJZCA+IFwidVwiICYmICh0ZW1wRXZlbnQucG9pbnRlcklkID0gTU9VU0VfUE9JTlRFUl9JRCksIHR5cGVvZiB0ZW1wRXZlbnQucHJlc3N1cmUgPiBcInVcIiAmJiAodGVtcEV2ZW50LnByZXNzdXJlID0gMC41KSwgdHlwZW9mIHRlbXBFdmVudC50d2lzdCA+IFwidVwiICYmICh0ZW1wRXZlbnQudHdpc3QgPSAwKSwgdHlwZW9mIHRlbXBFdmVudC50YW5nZW50aWFsUHJlc3N1cmUgPiBcInVcIiAmJiAodGVtcEV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSA9IDApLCB0ZW1wRXZlbnQuaXNOb3JtYWxpemVkID0gITAsIG5vcm1hbGl6ZWRFdmVudHMucHVzaCh0ZW1wRXZlbnQpO1xuICAgIH0gZWxzZVxuICAgICAgbm9ybWFsaXplZEV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICByZXR1cm4gbm9ybWFsaXplZEV2ZW50cztcbiAgfVxuICAvKipcbiAgICogTm9ybWFsaXplcyB0aGUgbmF0aXZlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vdWlldmVudHMvI2ludGVyZmFjZS13aGVlbGV2ZW50IFdoZWVsRXZlbnR9LlxuICAgKlxuICAgKiBUaGUgcmV0dXJuZWQge0BsaW5rIFBJWEkuRmVkZXJhdGVkV2hlZWxFdmVudH0gaXMgYSBzaGFyZWQgaW5zdGFuY2UuIEl0IHdpbGwgbm90IHBlcnNpc3QgYWNyb3NzXG4gICAqIG11bHRpcGxlIG5hdGl2ZSB3aGVlbCBldmVudHMuXG4gICAqIEBwYXJhbSBuYXRpdmVFdmVudCAtIFRoZSBuYXRpdmUgd2hlZWwgZXZlbnQgdGhhdCBvY2N1cnJlZCBvbiB0aGUgY2FudmFzLlxuICAgKiBAcmV0dXJucyBBIGZlZGVyYXRlZCB3aGVlbCBldmVudC5cbiAgICovXG4gIG5vcm1hbGl6ZVdoZWVsRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgICBjb25zdCBldmVudCA9IHRoaXMucm9vdFdoZWVsRXZlbnQ7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmZXJNb3VzZURhdGEoZXZlbnQsIG5hdGl2ZUV2ZW50KSwgZXZlbnQuZGVsdGFYID0gbmF0aXZlRXZlbnQuZGVsdGFYLCBldmVudC5kZWx0YVkgPSBuYXRpdmVFdmVudC5kZWx0YVksIGV2ZW50LmRlbHRhWiA9IG5hdGl2ZUV2ZW50LmRlbHRhWiwgZXZlbnQuZGVsdGFNb2RlID0gbmF0aXZlRXZlbnQuZGVsdGFNb2RlLCB0aGlzLm1hcFBvc2l0aW9uVG9Qb2ludChldmVudC5zY3JlZW4sIG5hdGl2ZUV2ZW50LmNsaWVudFgsIG5hdGl2ZUV2ZW50LmNsaWVudFkpLCBldmVudC5nbG9iYWwuY29weUZyb20oZXZlbnQuc2NyZWVuKSwgZXZlbnQub2Zmc2V0LmNvcHlGcm9tKGV2ZW50LnNjcmVlbiksIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQsIGV2ZW50LnR5cGUgPSBuYXRpdmVFdmVudC50eXBlLCBldmVudDtcbiAgfVxuICAvKipcbiAgICogTm9ybWFsaXplcyB0aGUgYG5hdGl2ZUV2ZW50YCBpbnRvIGEgZmVkZXJhdGVlZCB7QGxpbmsgUElYSS5GZWRlcmF0ZWRQb2ludGVyRXZlbnR9LlxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHBhcmFtIG5hdGl2ZUV2ZW50XG4gICAqL1xuICBib290c3RyYXBFdmVudChldmVudCwgbmF0aXZlRXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQub3JpZ2luYWxFdmVudCA9IG51bGwsIGV2ZW50Lm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQsIGV2ZW50LnBvaW50ZXJJZCA9IG5hdGl2ZUV2ZW50LnBvaW50ZXJJZCwgZXZlbnQud2lkdGggPSBuYXRpdmVFdmVudC53aWR0aCwgZXZlbnQuaGVpZ2h0ID0gbmF0aXZlRXZlbnQuaGVpZ2h0LCBldmVudC5pc1ByaW1hcnkgPSBuYXRpdmVFdmVudC5pc1ByaW1hcnksIGV2ZW50LnBvaW50ZXJUeXBlID0gbmF0aXZlRXZlbnQucG9pbnRlclR5cGUsIGV2ZW50LnByZXNzdXJlID0gbmF0aXZlRXZlbnQucHJlc3N1cmUsIGV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSA9IG5hdGl2ZUV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSwgZXZlbnQudGlsdFggPSBuYXRpdmVFdmVudC50aWx0WCwgZXZlbnQudGlsdFkgPSBuYXRpdmVFdmVudC50aWx0WSwgZXZlbnQudHdpc3QgPSBuYXRpdmVFdmVudC50d2lzdCwgdGhpcy50cmFuc2Zlck1vdXNlRGF0YShldmVudCwgbmF0aXZlRXZlbnQpLCB0aGlzLm1hcFBvc2l0aW9uVG9Qb2ludChldmVudC5zY3JlZW4sIG5hdGl2ZUV2ZW50LmNsaWVudFgsIG5hdGl2ZUV2ZW50LmNsaWVudFkpLCBldmVudC5nbG9iYWwuY29weUZyb20oZXZlbnQuc2NyZWVuKSwgZXZlbnQub2Zmc2V0LmNvcHlGcm9tKGV2ZW50LnNjcmVlbiksIGV2ZW50LmlzVHJ1c3RlZCA9IG5hdGl2ZUV2ZW50LmlzVHJ1c3RlZCwgZXZlbnQudHlwZSA9PT0gXCJwb2ludGVybGVhdmVcIiAmJiAoZXZlbnQudHlwZSA9IFwicG9pbnRlcm91dFwiKSwgZXZlbnQudHlwZS5zdGFydHNXaXRoKFwibW91c2VcIikgJiYgKGV2ZW50LnR5cGUgPSBldmVudC50eXBlLnJlcGxhY2UoXCJtb3VzZVwiLCBcInBvaW50ZXJcIikpLCBldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJ0b3VjaFwiKSAmJiAoZXZlbnQudHlwZSA9IFRPVUNIX1RPX1BPSU5URVJbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZSksIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2ZlcnMgYmFzZSAmIG1vdXNlIGV2ZW50IGRhdGEgZnJvbSB0aGUge0Bjb2RlIG5hdGl2ZUV2ZW50fSB0byB0aGUgZmVkZXJhdGVkIGV2ZW50LlxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHBhcmFtIG5hdGl2ZUV2ZW50XG4gICAqL1xuICB0cmFuc2Zlck1vdXNlRGF0YShldmVudCwgbmF0aXZlRXZlbnQpIHtcbiAgICBldmVudC5pc1RydXN0ZWQgPSBuYXRpdmVFdmVudC5pc1RydXN0ZWQsIGV2ZW50LnNyY0VsZW1lbnQgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50LCBldmVudC50aW1lU3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKSwgZXZlbnQudHlwZSA9IG5hdGl2ZUV2ZW50LnR5cGUsIGV2ZW50LmFsdEtleSA9IG5hdGl2ZUV2ZW50LmFsdEtleSwgZXZlbnQuYnV0dG9uID0gbmF0aXZlRXZlbnQuYnV0dG9uLCBldmVudC5idXR0b25zID0gbmF0aXZlRXZlbnQuYnV0dG9ucywgZXZlbnQuY2xpZW50LnggPSBuYXRpdmVFdmVudC5jbGllbnRYLCBldmVudC5jbGllbnQueSA9IG5hdGl2ZUV2ZW50LmNsaWVudFksIGV2ZW50LmN0cmxLZXkgPSBuYXRpdmVFdmVudC5jdHJsS2V5LCBldmVudC5tZXRhS2V5ID0gbmF0aXZlRXZlbnQubWV0YUtleSwgZXZlbnQubW92ZW1lbnQueCA9IG5hdGl2ZUV2ZW50Lm1vdmVtZW50WCwgZXZlbnQubW92ZW1lbnQueSA9IG5hdGl2ZUV2ZW50Lm1vdmVtZW50WSwgZXZlbnQucGFnZS54ID0gbmF0aXZlRXZlbnQucGFnZVgsIGV2ZW50LnBhZ2UueSA9IG5hdGl2ZUV2ZW50LnBhZ2VZLCBldmVudC5yZWxhdGVkVGFyZ2V0ID0gbnVsbCwgZXZlbnQuc2hpZnRLZXkgPSBuYXRpdmVFdmVudC5zaGlmdEtleTtcbiAgfVxufTtcbl9FdmVudFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIG5hbWU6IFwiZXZlbnRzXCIsXG4gIHR5cGU6IFtcbiAgICBjb3JlLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gICAgY29yZS5FeHRlbnNpb25UeXBlLkNhbnZhc1JlbmRlcmVyU3lzdGVtXG4gIF1cbn0sIC8qKlxuKiBUaGUgZXZlbnQgZmVhdHVyZXMgdGhhdCBhcmUgZW5hYmxlZCBieSB0aGUgRXZlbnRTeXN0ZW1cbiogVGhpcyBvcHRpb24gb25seSBpcyBhdmFpbGFibGUgd2hlbiB1c2luZyAqKkBwaXhpL2V2ZW50cyoqIHBhY2thZ2VcbiogKGluY2x1ZGVkIGluIHRoZSAqKnBpeGkuanMqKiBhbmQgKipwaXhpLmpzLWxlZ2FjeSoqIGJ1bmRsZSksIG90aGVyd2lzZSBpdCB3aWxsIGJlIGlnbm9yZWQuXG4qIEBzaW5jZSA3LjIuMFxuKi9cbl9FdmVudFN5c3RlbS5kZWZhdWx0RXZlbnRGZWF0dXJlcyA9IHtcbiAgbW92ZTogITAsXG4gIGdsb2JhbE1vdmU6ICEwLFxuICBjbGljazogITAsXG4gIHdoZWVsOiAhMFxufTtcbmxldCBFdmVudFN5c3RlbSA9IF9FdmVudFN5c3RlbTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQoRXZlbnRTeXN0ZW0pO1xuZXhwb3J0cy5FdmVudFN5c3RlbSA9IEV2ZW50U3lzdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRTeXN0ZW0uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIik7XG5jbGFzcyBFdmVudHNUaWNrZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW50ZXJhY3Rpb25GcmVxdWVuY3kgPSAxMCwgdGhpcy5fZGVsdGFUaW1lID0gMCwgdGhpcy5fZGlkTW92ZSA9ICExLCB0aGlzLnRpY2tlckFkZGVkID0gITEsIHRoaXMuX3BhdXNlVXBkYXRlID0gITA7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBldmVudCB0aWNrZXIuXG4gICAqIEBwYXJhbSBldmVudHMgLSBUaGUgZXZlbnQgc3lzdGVtLlxuICAgKi9cbiAgaW5pdChldmVudHMpIHtcbiAgICB0aGlzLnJlbW92ZVRpY2tlckxpc3RlbmVyKCksIHRoaXMuZXZlbnRzID0gZXZlbnRzLCB0aGlzLmludGVyYWN0aW9uRnJlcXVlbmN5ID0gMTAsIHRoaXMuX2RlbHRhVGltZSA9IDAsIHRoaXMuX2RpZE1vdmUgPSAhMSwgdGhpcy50aWNrZXJBZGRlZCA9ICExLCB0aGlzLl9wYXVzZVVwZGF0ZSA9ICEwO1xuICB9XG4gIC8qKiBXaGV0aGVyIHRvIHBhdXNlIHRoZSB1cGRhdGUgY2hlY2tzIG9yIG5vdC4gKi9cbiAgZ2V0IHBhdXNlVXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXVzZVVwZGF0ZTtcbiAgfVxuICBzZXQgcGF1c2VVcGRhdGUocGF1c2VkKSB7XG4gICAgdGhpcy5fcGF1c2VVcGRhdGUgPSBwYXVzZWQ7XG4gIH1cbiAgLyoqIEFkZHMgdGhlIHRpY2tlciBsaXN0ZW5lci4gKi9cbiAgYWRkVGlja2VyTGlzdGVuZXIoKSB7XG4gICAgdGhpcy50aWNrZXJBZGRlZCB8fCAhdGhpcy5kb21FbGVtZW50IHx8IChjb3JlLlRpY2tlci5zeXN0ZW0uYWRkKHRoaXMudGlja2VyVXBkYXRlLCB0aGlzLCBjb3JlLlVQREFURV9QUklPUklUWS5JTlRFUkFDVElPTiksIHRoaXMudGlja2VyQWRkZWQgPSAhMCk7XG4gIH1cbiAgLyoqIFJlbW92ZXMgdGhlIHRpY2tlciBsaXN0ZW5lci4gKi9cbiAgcmVtb3ZlVGlja2VyTGlzdGVuZXIoKSB7XG4gICAgdGhpcy50aWNrZXJBZGRlZCAmJiAoY29yZS5UaWNrZXIuc3lzdGVtLnJlbW92ZSh0aGlzLnRpY2tlclVwZGF0ZSwgdGhpcyksIHRoaXMudGlja2VyQWRkZWQgPSAhMSk7XG4gIH1cbiAgLyoqIFNldHMgZmxhZyB0byBub3QgZmlyZSBleHRyYSBldmVudHMgd2hlbiB0aGUgdXNlciBoYXMgYWxyZWFkeSBtb3ZlZCB0aGVyZSBtb3VzZSAqL1xuICBwb2ludGVyTW92ZWQoKSB7XG4gICAgdGhpcy5fZGlkTW92ZSA9ICEwO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSBzdGF0ZSBvZiBpbnRlcmFjdGl2ZSBvYmplY3RzLiAqL1xuICB1cGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmRvbUVsZW1lbnQgfHwgdGhpcy5fcGF1c2VVcGRhdGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMuX2RpZE1vdmUpIHtcbiAgICAgIHRoaXMuX2RpZE1vdmUgPSAhMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm9vdFBvaW50ZXJFdmVudCA9IHRoaXMuZXZlbnRzLnJvb3RQb2ludGVyRXZlbnQ7XG4gICAgdGhpcy5ldmVudHMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiByb290UG9pbnRlckV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIgfHwgZ2xvYmFsVGhpcy5kb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBQb2ludGVyRXZlbnQoXCJwb2ludGVybW92ZVwiLCB7XG4gICAgICBjbGllbnRYOiByb290UG9pbnRlckV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiByb290UG9pbnRlckV2ZW50LmNsaWVudFlcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIGludGVyYWN0aXZlIG9iamVjdHMgaWYgYXQgbGVhc3Qge0BsaW5rIGludGVyYWN0aW9uRnJlcXVlbmN5fVxuICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBwYXNzZWQgc2luY2UgdGhlIGxhc3QgaW52b2NhdGlvbi5cbiAgICpcbiAgICogSW52b2tlZCBieSBhIHRocm90dGxlZCB0aWNrZXIgdXBkYXRlIGZyb20ge0BsaW5rIFBJWEkuVGlja2VyLnN5c3RlbX0uXG4gICAqIEBwYXJhbSBkZWx0YVRpbWUgLSB0aW1lIGRlbHRhIHNpbmNlIHRoZSBsYXN0IGNhbGxcbiAgICovXG4gIHRpY2tlclVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICB0aGlzLl9kZWx0YVRpbWUgKz0gZGVsdGFUaW1lLCAhKHRoaXMuX2RlbHRhVGltZSA8IHRoaXMuaW50ZXJhY3Rpb25GcmVxdWVuY3kpICYmICh0aGlzLl9kZWx0YVRpbWUgPSAwLCB0aGlzLnVwZGF0ZSgpKTtcbiAgfVxufVxuY29uc3QgRXZlbnRzVGlja2VyID0gbmV3IEV2ZW50c1RpY2tlckNsYXNzKCk7XG5leHBvcnRzLkV2ZW50c1RpY2tlciA9IEV2ZW50c1RpY2tlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50VGlja2VyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpO1xuY2xhc3MgRmVkZXJhdGVkRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIG1hbmFnZXIgLSBUaGUgZXZlbnQgYm91bmRhcnkgd2hpY2ggbWFuYWdlcyB0aGlzIGV2ZW50LiBQcm9wYWdhdGlvbiBjYW4gb25seSBvY2N1clxuICAgKiAgd2l0aGluIHRoZSBib3VuZGFyeSdzIGp1cmlzZGljdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICB0aGlzLmJ1YmJsZXMgPSAhMCwgdGhpcy5jYW5jZWxCdWJibGUgPSAhMCwgdGhpcy5jYW5jZWxhYmxlID0gITEsIHRoaXMuY29tcG9zZWQgPSAhMSwgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gITEsIHRoaXMuZXZlbnRQaGFzZSA9IEZlZGVyYXRlZEV2ZW50LnByb3RvdHlwZS5OT05FLCB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9ICExLCB0aGlzLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkID0gITEsIHRoaXMubGF5ZXIgPSBuZXcgY29yZS5Qb2ludCgpLCB0aGlzLnBhZ2UgPSBuZXcgY29yZS5Qb2ludCgpLCB0aGlzLk5PTkUgPSAwLCB0aGlzLkNBUFRVUklOR19QSEFTRSA9IDEsIHRoaXMuQVRfVEFSR0VUID0gMiwgdGhpcy5CVUJCTElOR19QSEFTRSA9IDMsIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gIH1cbiAgLyoqIEByZWFkb25seSAqL1xuICBnZXQgbGF5ZXJYKCkge1xuICAgIHJldHVybiB0aGlzLmxheWVyLng7XG4gIH1cbiAgLyoqIEByZWFkb25seSAqL1xuICBnZXQgbGF5ZXJZKCkge1xuICAgIHJldHVybiB0aGlzLmxheWVyLnk7XG4gIH1cbiAgLyoqIEByZWFkb25seSAqL1xuICBnZXQgcGFnZVgoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFnZS54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IHBhZ2VZKCkge1xuICAgIHJldHVybiB0aGlzLnBhZ2UueTtcbiAgfVxuICAvKipcbiAgICogRmFsbGJhY2sgZm9yIHRoZSBkZXByZWNhdGVkIEBjb2Rle1BJWEkuSW50ZXJhY3Rpb25FdmVudC5kYXRhfS5cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4wLjBcbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKiBUaGUgcHJvcGFnYXRpb24gcGF0aCBmb3IgdGhpcyBldmVudC4gQWxpYXMgZm9yIHtAbGluayBQSVhJLkV2ZW50Qm91bmRhcnkucHJvcGFnYXRpb25QYXRofS4gKi9cbiAgY29tcG9zZWRQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLm1hbmFnZXIgJiYgKCF0aGlzLnBhdGggfHwgdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSAhPT0gdGhpcy50YXJnZXQpICYmICh0aGlzLnBhdGggPSB0aGlzLnRhcmdldCA/IHRoaXMubWFuYWdlci5wcm9wYWdhdGlvblBhdGgodGhpcy50YXJnZXQpIDogW10pLCB0aGlzLnBhdGg7XG4gIH1cbiAgLyoqXG4gICAqIFVuaW1wbGVtZW50ZWQgbWV0aG9kIGluY2x1ZGVkIGZvciBpbXBsZW1lbnRpbmcgdGhlIERPTSBpbnRlcmZhY2Uge0Bjb2RlIEV2ZW50fS4gSXQgd2lsbCB0aHJvdyBhbiB7QGNvZGUgRXJyb3J9LlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0gX3R5cGVcbiAgICogQHBhcmFtIF9idWJibGVzXG4gICAqIEBwYXJhbSBfY2FuY2VsYWJsZVxuICAgKi9cbiAgaW5pdEV2ZW50KF90eXBlLCBfYnViYmxlcywgX2NhbmNlbGFibGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbml0RXZlbnQoKSBpcyBhIGxlZ2FjeSBET00gQVBJLiBJdCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIEZlZGVyYXRlZCBFdmVudHMgQVBJLlwiKTtcbiAgfVxuICAvKipcbiAgICogVW5pbXBsZW1lbnRlZCBtZXRob2QgaW5jbHVkZWQgZm9yIGltcGxlbWVudGluZyB0aGUgRE9NIGludGVyZmFjZSB7QGNvZGUgVUlFdmVudH0uIEl0IHdpbGwgdGhyb3cgYW4ge0Bjb2RlIEVycm9yfS5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIF90eXBlQXJnXG4gICAqIEBwYXJhbSBfYnViYmxlc0FyZ1xuICAgKiBAcGFyYW0gX2NhbmNlbGFibGVBcmdcbiAgICogQHBhcmFtIF92aWV3QXJnXG4gICAqIEBwYXJhbSBfZGV0YWlsQXJnXG4gICAqL1xuICBpbml0VUlFdmVudChfdHlwZUFyZywgX2J1YmJsZXNBcmcsIF9jYW5jZWxhYmxlQXJnLCBfdmlld0FyZywgX2RldGFpbEFyZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcImluaXRVSUV2ZW50KCkgaXMgYSBsZWdhY3kgRE9NIEFQSS4gSXQgaXMgbm90IGltcGxlbWVudGVkIGluIHRoZSBGZWRlcmF0ZWQgRXZlbnRzIEFQSS5cIik7XG4gIH1cbiAgLyoqIFByZXZlbnQgZGVmYXVsdCBiZWhhdmlvciBvZiBQaXhpSlMgYW5kIHRoZSB1c2VyIGFnZW50LiAqL1xuICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50IGluc3RhbmNlb2YgRXZlbnQgJiYgdGhpcy5uYXRpdmVFdmVudC5jYW5jZWxhYmxlICYmIHRoaXMubmF0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKSwgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gITA7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3AgdGhpcyBldmVudCBmcm9tIHByb3BhZ2F0aW5nIHRvIGFueSBhZGRpdGlvbiBsaXN0ZW5lcnMsIGluY2x1ZGluZyBvbiB0aGVcbiAgICoge0BsaW5rIFBJWEkuRmVkZXJhdGVkRXZlbnRUYXJnZXQuY3VycmVudFRhcmdldCBjdXJyZW50VGFyZ2V0fSBhbmQgYWxzbyB0aGUgZm9sbG93aW5nXG4gICAqIGV2ZW50IHRhcmdldHMgb24gdGhlIHByb3BhZ2F0aW9uIHBhdGguXG4gICAqL1xuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5wcm9wYWdhdGlvbkltbWVkaWF0ZWx5U3RvcHBlZCA9ICEwO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wIHRoaXMgZXZlbnQgZnJvbSBwcm9wYWdhdGluZyB0byB0aGUgbmV4dCB7QGxpbmsgUElYSS5GZWRlcmF0ZWRFdmVudFRhcmdldH0uIFRoZSByZXN0IG9mIHRoZSBsaXN0ZW5lcnNcbiAgICogb24gdGhlIHtAbGluayBQSVhJLkZlZGVyYXRlZEV2ZW50VGFyZ2V0LmN1cnJlbnRUYXJnZXQgY3VycmVudFRhcmdldH0gd2lsbCBzdGlsbCBiZSBub3RpZmllZC5cbiAgICovXG4gIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9ICEwO1xuICB9XG59XG5leHBvcnRzLkZlZGVyYXRlZEV2ZW50ID0gRmVkZXJhdGVkRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRFdmVudC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmVkZXJhdGVkRXZlbnRNYXAuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIGRpc3BsYXkgPSByZXF1aXJlKFwiQHBpeGkvZGlzcGxheVwiKSwgRXZlbnRTeXN0ZW0gPSByZXF1aXJlKFwiLi9FdmVudFN5c3RlbS5qc1wiKSwgRmVkZXJhdGVkRXZlbnQgPSByZXF1aXJlKFwiLi9GZWRlcmF0ZWRFdmVudC5qc1wiKTtcbmZ1bmN0aW9uIGNvbnZlcnRFdmVudE1vZGVUb0ludGVyYWN0aXZlTW9kZShtb2RlKSB7XG4gIHJldHVybiBtb2RlID09PSBcImR5bmFtaWNcIiB8fCBtb2RlID09PSBcInN0YXRpY1wiO1xufVxuY29uc3QgRmVkZXJhdGVkRGlzcGxheU9iamVjdCA9IHtcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgY2xpY2tgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25jbGljayA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIGNsaWNrXG4gICAqIH1cbiAgICovXG4gIG9uY2xpY2s6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYG1vdXNlZG93bmAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbm1vdXNlZG93biA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIG1vdXNlZG93blxuICAgKiB9XG4gICAqL1xuICBvbm1vdXNlZG93bjogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgbW91c2VlbnRlcmAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbm1vdXNlZW50ZXIgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBtb3VzZWVudGVyXG4gICAqIH1cbiAgICovXG4gIG9ubW91c2VlbnRlcjogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgbW91c2VsZWF2ZWAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbm1vdXNlbGVhdmUgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBtb3VzZWxlYXZlXG4gICAqIH1cbiAgICovXG4gIG9ubW91c2VsZWF2ZTogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgbW91c2Vtb3ZlYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ubW91c2Vtb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gbW91c2Vtb3ZlXG4gICAqIH1cbiAgICovXG4gIG9ubW91c2Vtb3ZlOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBnbG9iYWxtb3VzZW1vdmVgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25nbG9iYWxtb3VzZW1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBnbG9iYWxtb3VzZW1vdmVcbiAgICogfVxuICAgKi9cbiAgb25nbG9iYWxtb3VzZW1vdmU6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYG1vdXNlb3V0YCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ubW91c2VvdXQgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBtb3VzZW91dFxuICAgKiB9XG4gICAqL1xuICBvbm1vdXNlb3V0OiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBtb3VzZW92ZXJgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25tb3VzZW92ZXIgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBtb3VzZW92ZXJcbiAgICogfVxuICAgKi9cbiAgb25tb3VzZW92ZXI6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYG1vdXNldXBgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25tb3VzZXVwID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gbW91c2V1cFxuICAgKiB9XG4gICAqL1xuICBvbm1vdXNldXA6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYG1vdXNldXBvdXRzaWRlYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ubW91c2V1cG91dHNpZGUgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBtb3VzZXVwb3V0c2lkZVxuICAgKiB9XG4gICAqL1xuICBvbm1vdXNldXBvdXRzaWRlOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBwb2ludGVyY2FuY2VsYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucG9pbnRlcmNhbmNlbCA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHBvaW50ZXJjYW5jZWxcbiAgICogfVxuICAgKi9cbiAgb25wb2ludGVyY2FuY2VsOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBwb2ludGVyZG93bmAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnBvaW50ZXJkb3duID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gcG9pbnRlcmRvd25cbiAgICogfVxuICAgKi9cbiAgb25wb2ludGVyZG93bjogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgcG9pbnRlcmVudGVyYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucG9pbnRlcmVudGVyID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gcG9pbnRlcmVudGVyXG4gICAqIH1cbiAgICovXG4gIG9ucG9pbnRlcmVudGVyOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBwb2ludGVybGVhdmVgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25wb2ludGVybGVhdmUgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBwb2ludGVybGVhdmVcbiAgICogfVxuICAgKi9cbiAgb25wb2ludGVybGVhdmU6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHBvaW50ZXJtb3ZlYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucG9pbnRlcm1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBwb2ludGVybW92ZVxuICAgKiB9XG4gICAqL1xuICBvbnBvaW50ZXJtb3ZlOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBnbG9iYWxwb2ludGVybW92ZWAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbmdsb2JhbHBvaW50ZXJtb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gZ2xvYmFscG9pbnRlcm1vdmVcbiAgICogfVxuICAgKi9cbiAgb25nbG9iYWxwb2ludGVybW92ZTogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgcG9pbnRlcm91dGAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnBvaW50ZXJvdXQgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBwb2ludGVyb3V0XG4gICAqIH1cbiAgICovXG4gIG9ucG9pbnRlcm91dDogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgcG9pbnRlcm92ZXJgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25wb2ludGVyb3ZlciA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHBvaW50ZXJvdmVyXG4gICAqIH1cbiAgICovXG4gIG9ucG9pbnRlcm92ZXI6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHBvaW50ZXJ0YXBgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25wb2ludGVydGFwID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gcG9pbnRlcnRhcFxuICAgKiB9XG4gICAqL1xuICBvbnBvaW50ZXJ0YXA6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHBvaW50ZXJ1cGAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnBvaW50ZXJ1cCA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHBvaW50ZXJ1cFxuICAgKiB9XG4gICAqL1xuICBvbnBvaW50ZXJ1cDogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgcG9pbnRlcnVwb3V0c2lkZWAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnBvaW50ZXJ1cG91dHNpZGUgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBwb2ludGVydXBvdXRzaWRlXG4gICAqIH1cbiAgICovXG4gIG9ucG9pbnRlcnVwb3V0c2lkZTogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgcmlnaHRjbGlja2AgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnJpZ2h0Y2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiByaWdodGNsaWNrXG4gICAqIH1cbiAgICovXG4gIG9ucmlnaHRjbGljazogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgcmlnaHRkb3duYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucmlnaHRkb3duID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gcmlnaHRkb3duXG4gICAqIH1cbiAgICovXG4gIG9ucmlnaHRkb3duOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGByaWdodHVwYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucmlnaHR1cCA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHJpZ2h0dXBcbiAgICogfVxuICAgKi9cbiAgb25yaWdodHVwOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGByaWdodHVwb3V0c2lkZWAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnJpZ2h0dXBvdXRzaWRlID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gcmlnaHR1cG91dHNpZGVcbiAgICogfVxuICAgKi9cbiAgb25yaWdodHVwb3V0c2lkZTogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgdGFwYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9udGFwID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gdGFwXG4gICAqIH1cbiAgICovXG4gIG9udGFwOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGB0b3VjaGNhbmNlbGAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnRvdWNoY2FuY2VsID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gdG91Y2hjYW5jZWxcbiAgICogfVxuICAgKi9cbiAgb250b3VjaGNhbmNlbDogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgdG91Y2hlbmRgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub250b3VjaGVuZCA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHRvdWNoZW5kXG4gICAqIH1cbiAgICovXG4gIG9udG91Y2hlbmQ6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHRvdWNoZW5kb3V0c2lkZWAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnRvdWNoZW5kb3V0c2lkZSA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHRvdWNoZW5kb3V0c2lkZVxuICAgKiB9XG4gICAqL1xuICBvbnRvdWNoZW5kb3V0c2lkZTogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgdG91Y2htb3ZlYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9udG91Y2htb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gdG91Y2htb3ZlXG4gICAqIH1cbiAgICovXG4gIG9udG91Y2htb3ZlOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBnbG9iYWx0b3VjaG1vdmVgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25nbG9iYWx0b3VjaG1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBnbG9iYWx0b3VjaG1vdmVcbiAgICogfVxuICAgKi9cbiAgb25nbG9iYWx0b3VjaG1vdmU6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHRvdWNoc3RhcnRgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub250b3VjaHN0YXJ0ID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gdG91Y2hzdGFydFxuICAgKiB9XG4gICAqL1xuICBvbnRvdWNoc3RhcnQ6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHdoZWVsYCBldmVudC5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ud2hlZWwgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiB3aGVlbFxuICAgKiB9XG4gICAqL1xuICBvbndoZWVsOiBudWxsLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX2ludGVybmFsSW50ZXJhY3RpdmU6IHZvaWQgMCxcbiAgLyoqXG4gICAqIEVuYWJsZSBpbnRlcmFjdGlvbiBldmVudHMgZm9yIHRoZSBEaXNwbGF5T2JqZWN0LiBUb3VjaCwgcG9pbnRlciBhbmQgbW91c2VcbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICovXG4gIGdldCBpbnRlcmFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxJbnRlcmFjdGl2ZSA/PyBjb252ZXJ0RXZlbnRNb2RlVG9JbnRlcmFjdGl2ZU1vZGUoRXZlbnRTeXN0ZW0uRXZlbnRTeXN0ZW0uZGVmYXVsdEV2ZW50TW9kZSk7XG4gIH0sXG4gIHNldCBpbnRlcmFjdGl2ZSh2YWx1ZSkge1xuICAgIGNvcmUudXRpbHMuZGVwcmVjYXRpb24oXG4gICAgICBcIjcuMi4wXCIsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgXCJTZXR0aW5nIGludGVyYWN0aXZlIGlzIGRlcHJlY2F0ZWQsIHVzZSBldmVudE1vZGUgPSAnbm9uZScvJ3Bhc3NpdmUnLydhdXRvJy8nc3RhdGljJy8nZHluYW1pYycgaW5zdGVhZC5cIlxuICAgICksIHRoaXMuX2ludGVybmFsSW50ZXJhY3RpdmUgPSB2YWx1ZSwgdGhpcy5ldmVudE1vZGUgPSB2YWx1ZSA/IFwic3RhdGljXCIgOiBcImF1dG9cIjtcbiAgfSxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF9pbnRlcm5hbEV2ZW50TW9kZTogdm9pZCAwLFxuICAvKipcbiAgICogRW5hYmxlIGludGVyYWN0aW9uIGV2ZW50cyBmb3IgdGhlIERpc3BsYXlPYmplY3QuIFRvdWNoLCBwb2ludGVyIGFuZCBtb3VzZS5cbiAgICogVGhpcyBub3cgcmVwbGFjZXMgdGhlIGBpbnRlcmFjdGl2ZWAgcHJvcGVydHkuXG4gICAqIFRoZXJlIGFyZSA1IHR5cGVzIG9mIGludGVyYWN0aW9uIHNldHRpbmdzOlxuICAgKiAtIGAnbm9uZSdgOiBJZ25vcmVzIGFsbCBpbnRlcmFjdGlvbiBldmVudHMsIGV2ZW4gb24gaXRzIGNoaWxkcmVuLlxuICAgKiAtIGAncGFzc2l2ZSdgOiBEb2VzIG5vdCBlbWl0IGV2ZW50cyBhbmQgaWdub3JlcyBhbGwgaGl0IHRlc3Rpbmcgb24gaXRzZWxmIGFuZCBub24taW50ZXJhY3RpdmUgY2hpbGRyZW4uXG4gICAqIEludGVyYWN0aXZlIGNoaWxkcmVuIHdpbGwgc3RpbGwgZW1pdCBldmVudHMuXG4gICAqIC0gYCdhdXRvJ2A6IERvZXMgbm90IGVtaXQgZXZlbnRzIGJ1dCBpcyBoaXQgdGVzdGVkIGlmIHBhcmVudCBpcyBpbnRlcmFjdGl2ZS4gU2FtZSBhcyBgaW50ZXJhY3RpdmUgPSBmYWxzZWAgaW4gdjdcbiAgICogLSBgJ3N0YXRpYydgOiBFbWl0IGV2ZW50cyBhbmQgaXMgaGl0IHRlc3RlZC4gU2FtZSBhcyBgaW50ZXJhY3Rpb24gPSB0cnVlYCBpbiB2N1xuICAgKiAtIGAnZHluYW1pYydgOiBFbWl0cyBldmVudHMgYW5kIGlzIGhpdCB0ZXN0ZWQgYnV0IHdpbGwgYWxzbyByZWNlaXZlIG1vY2sgaW50ZXJhY3Rpb24gZXZlbnRzIGZpcmVkIGZyb20gYSB0aWNrZXIgdG9cbiAgICogYWxsb3cgZm9yIGludGVyYWN0aW9uIHdoZW4gdGhlIG1vdXNlIGlzbid0IG1vdmluZ1xuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBTcHJpdGUgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogY29uc3Qgc3ByaXRlID0gbmV3IFNwcml0ZSh0ZXh0dXJlKTtcbiAgICogc3ByaXRlLmV2ZW50TW9kZSA9ICdzdGF0aWMnO1xuICAgKiBzcHJpdGUub24oJ3RhcCcsIChldmVudCkgPT4ge1xuICAgKiAgICAgLy8gSGFuZGxlIGV2ZW50XG4gICAqIH0pO1xuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAc2luY2UgNy4yLjBcbiAgICovXG4gIGdldCBldmVudE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsRXZlbnRNb2RlID8/IEV2ZW50U3lzdGVtLkV2ZW50U3lzdGVtLmRlZmF1bHRFdmVudE1vZGU7XG4gIH0sXG4gIHNldCBldmVudE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLl9pbnRlcm5hbEludGVyYWN0aXZlID0gY29udmVydEV2ZW50TW9kZVRvSW50ZXJhY3RpdmVNb2RlKHZhbHVlKSwgdGhpcy5faW50ZXJuYWxFdmVudE1vZGUgPSB2YWx1ZTtcbiAgfSxcbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIGRpc3BsYXlPYmplY3QgaXMgaW50ZXJhY3RpdmUgb3Igbm90XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBkaXNwbGF5T2JqZWN0IGlzIGludGVyYWN0aXZlIG9yIG5vdFxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAc2luY2UgNy4yLjBcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgU3ByaXRlIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gICAqIHNwcml0ZS5ldmVudE1vZGUgPSAnc3RhdGljJztcbiAgICogc3ByaXRlLmlzSW50ZXJhY3RpdmUoKTsgLy8gdHJ1ZVxuICAgKlxuICAgKiBzcHJpdGUuZXZlbnRNb2RlID0gJ2R5bmFtaWMnO1xuICAgKiBzcHJpdGUuaXNJbnRlcmFjdGl2ZSgpOyAvLyB0cnVlXG4gICAqXG4gICAqIHNwcml0ZS5ldmVudE1vZGUgPSAnbm9uZSc7XG4gICAqIHNwcml0ZS5pc0ludGVyYWN0aXZlKCk7IC8vIGZhbHNlXG4gICAqXG4gICAqIHNwcml0ZS5ldmVudE1vZGUgPSAncGFzc2l2ZSc7XG4gICAqIHNwcml0ZS5pc0ludGVyYWN0aXZlKCk7IC8vIGZhbHNlXG4gICAqXG4gICAqIHNwcml0ZS5ldmVudE1vZGUgPSAnYXV0byc7XG4gICAqIHNwcml0ZS5pc0ludGVyYWN0aXZlKCk7IC8vIGZhbHNlXG4gICAqL1xuICBpc0ludGVyYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50TW9kZSA9PT0gXCJzdGF0aWNcIiB8fCB0aGlzLmV2ZW50TW9kZSA9PT0gXCJkeW5hbWljXCI7XG4gIH0sXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBjaGlsZHJlbiB0byB0aGUgZGlzcGxheU9iamVjdCBjYW4gYmUgY2xpY2tlZC90b3VjaGVkXG4gICAqIFNldHRpbmcgdGhpcyB0byBmYWxzZSBhbGxvd3MgUGl4aUpTIHRvIGJ5cGFzcyBhIHJlY3Vyc2l2ZSBgaGl0VGVzdGAgZnVuY3Rpb25cbiAgICogQG1lbWJlcm9mIFBJWEkuQ29udGFpbmVyI1xuICAgKi9cbiAgaW50ZXJhY3RpdmVDaGlsZHJlbjogITAsXG4gIC8qKlxuICAgKiBJbnRlcmFjdGlvbiBzaGFwZS4gQ2hpbGRyZW4gd2lsbCBiZSBoaXQgZmlyc3QsIHRoZW4gdGhpcyBzaGFwZSB3aWxsIGJlIGNoZWNrZWQuXG4gICAqIFNldHRpbmcgdGhpcyB3aWxsIGNhdXNlIHRoaXMgc2hhcGUgdG8gYmUgY2hlY2tlZCBpbiBoaXQgdGVzdHMgcmF0aGVyIHRoYW4gdGhlIGRpc3BsYXlPYmplY3QncyBib3VuZHMuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IFJlY3RhbmdsZSwgU3ByaXRlIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gICAqIHNwcml0ZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAqIHNwcml0ZS5oaXRBcmVhID0gbmV3IFJlY3RhbmdsZSgwLCAwLCAxMDAsIDEwMCk7XG4gICAqIEBtZW1iZXIge1BJWEkuSUhpdEFyZWF9XG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqL1xuICBoaXRBcmVhOiBudWxsLFxuICAvKipcbiAgICogVW5saWtlIGBvbmAgb3IgYGFkZExpc3RlbmVyYCB3aGljaCBhcmUgbWV0aG9kcyBmcm9tIEV2ZW50RW1pdHRlciwgYGFkZEV2ZW50TGlzdGVuZXJgXG4gICAqIHNlZWtzIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgRE9NJ3MgYGFkZEV2ZW50TGlzdGVuZXJgIHdpdGggc3VwcG9ydCBmb3Igb3B0aW9ucy5cbiAgICogKipJTVBPUlRBTlQ6KiogX09ubHlfIGF2YWlsYWJsZSBpZiB1c2luZyB0aGUgYEBwaXhpL2V2ZW50c2AgcGFja2FnZS5cbiAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdFxuICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIGV2ZW50IHRvIGxpc3RlbiB0by5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGNhbGxiYWNrIG9yIG9iamVjdC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBMaXN0ZW5lciBvcHRpb25zLCB1c2VkIGZvciBjYXB0dXJlIHBoYXNlLlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBUZWxsIHRoZSB1c2VyIHdoZXRoZXIgdGhleSBkaWQgYSBzaW5nbGUsIGRvdWJsZSwgdHJpcGxlLCBvciBudGggY2xpY2suXG4gICAqIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHtcbiAgICogICAgIGhhbmRsZUV2ZW50KGUpOiB7XG4gICAqICAgICAgICAgbGV0IHByZWZpeDtcbiAgICpcbiAgICogICAgICAgICBzd2l0Y2ggKGUuZGV0YWlsKSB7XG4gICAqICAgICAgICAgICAgIGNhc2UgMTogcHJlZml4ID0gJ3NpbmdsZSc7IGJyZWFrO1xuICAgKiAgICAgICAgICAgICBjYXNlIDI6IHByZWZpeCA9ICdkb3VibGUnOyBicmVhaztcbiAgICogICAgICAgICAgICAgY2FzZSAzOiBwcmVmaXggPSAndHJpcGxlJzsgYnJlYWs7XG4gICAqICAgICAgICAgICAgIGRlZmF1bHQ6IHByZWZpeCA9IGUuZGV0YWlsICsgJ3RoJzsgYnJlYWs7XG4gICAqICAgICAgICAgfVxuICAgKlxuICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCdUaGF0IHdhcyBhICcgKyBwcmVmaXggKyAnY2xpY2snKTtcbiAgICogICAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIC8vIEJ1dCBza2lwIHRoZSBmaXJzdCBjbGljayFcbiAgICogYnV0dG9uLnBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIGJsb2NrQ2xpY2tPbmNlKGUpIHtcbiAgICogICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAqICAgICBidXR0b24ucGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYmxvY2tDbGlja09uY2UsIHRydWUpO1xuICAgKiB9LCB7XG4gICAqICAgICBjYXB0dXJlOiB0cnVlLFxuICAgKiB9KTtcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXB0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT0gXCJib29sZWFuXCIgJiYgb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyA9PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuY2FwdHVyZSwgY29udGV4dCA9IHR5cGVvZiBsaXN0ZW5lciA9PSBcImZ1bmN0aW9uXCIgPyB2b2lkIDAgOiBsaXN0ZW5lcjtcbiAgICB0eXBlID0gY2FwdHVyZSA/IGAke3R5cGV9Y2FwdHVyZWAgOiB0eXBlLCBsaXN0ZW5lciA9IHR5cGVvZiBsaXN0ZW5lciA9PSBcImZ1bmN0aW9uXCIgPyBsaXN0ZW5lciA6IGxpc3RlbmVyLmhhbmRsZUV2ZW50LCB0aGlzLm9uKHR5cGUsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfSxcbiAgLyoqXG4gICAqIFVubGlrZSBgb2ZmYCBvciBgcmVtb3ZlTGlzdGVuZXJgIHdoaWNoIGFyZSBtZXRob2RzIGZyb20gRXZlbnRFbWl0dGVyLCBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmBcbiAgICogc2Vla3MgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBET00ncyBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgd2l0aCBzdXBwb3J0IGZvciBvcHRpb25zLlxuICAgKiAqKklNUE9SVEFOVDoqKiBfT25seV8gYXZhaWxhYmxlIGlmIHVzaW5nIHRoZSBgQHBpeGkvZXZlbnRzYCBwYWNrYWdlLlxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0XG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgZXZlbnQgdGhlIGxpc3RlbmVyIGlzIGJvdW5kIHRvLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgY2FsbGJhY2sgb3Igb2JqZWN0LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcmlnaW5hbCBsaXN0ZW5lciBvcHRpb25zLiBUaGlzIGlzIHJlcXVpcmVkIHRvIGRlcmVnaXN0ZXIgYSBjYXB0dXJlIHBoYXNlIGxpc3RlbmVyLlxuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhcHR1cmUgPSB0eXBlb2Ygb3B0aW9ucyA9PSBcImJvb2xlYW5cIiAmJiBvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zID09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5jYXB0dXJlLCBjb250ZXh0ID0gdHlwZW9mIGxpc3RlbmVyID09IFwiZnVuY3Rpb25cIiA/IHZvaWQgMCA6IGxpc3RlbmVyO1xuICAgIHR5cGUgPSBjYXB0dXJlID8gYCR7dHlwZX1jYXB0dXJlYCA6IHR5cGUsIGxpc3RlbmVyID0gdHlwZW9mIGxpc3RlbmVyID09IFwiZnVuY3Rpb25cIiA/IGxpc3RlbmVyIDogbGlzdGVuZXIuaGFuZGxlRXZlbnQsIHRoaXMub2ZmKHR5cGUsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfSxcbiAgLyoqXG4gICAqIERpc3BhdGNoIHRoZSBldmVudCBvbiB0aGlzIHtAbGluayBQSVhJLkRpc3BsYXlPYmplY3R9IHVzaW5nIHRoZSBldmVudCdzIHtAbGluayBQSVhJLkV2ZW50Qm91bmRhcnl9LlxuICAgKlxuICAgKiBUaGUgdGFyZ2V0IG9mIHRoZSBldmVudCBpcyBzZXQgdG8gYHRoaXNgIGFuZCB0aGUgYGRlZmF1bHRQcmV2ZW50ZWRgIGZsYWcgaXMgY2xlYXJlZCBiZWZvcmUgZGlzcGF0Y2guXG4gICAqXG4gICAqICoqSU1QT1JUQU5UOioqIF9Pbmx5XyBhdmFpbGFibGUgaWYgdXNpbmcgdGhlIGBAcGl4aS9ldmVudHNgIHBhY2thZ2UuXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3RcbiAgICogQHBhcmFtIGUgLSBUaGUgZXZlbnQgdG8gZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHtAbGluayBQSVhJLkZlZGVyYXRlZEV2ZW50LnByZXZlbnREZWZhdWx0IHByZXZlbnREZWZhdWx0fSgpIG1ldGhvZCB3YXMgbm90IGludm9rZWQuXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFJldXNlIGEgY2xpY2sgZXZlbnQhXG4gICAqIGJ1dHRvbi5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgKi9cbiAgZGlzcGF0Y2hFdmVudChlKSB7XG4gICAgaWYgKCEoZSBpbnN0YW5jZW9mIEZlZGVyYXRlZEV2ZW50LkZlZGVyYXRlZEV2ZW50KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc3BsYXlPYmplY3QgY2Fubm90IHByb3BhZ2F0ZSBldmVudHMgb3V0c2lkZSBvZiB0aGUgRmVkZXJhdGVkIEV2ZW50cyBBUElcIik7XG4gICAgcmV0dXJuIGUuZGVmYXVsdFByZXZlbnRlZCA9ICExLCBlLnBhdGggPSBudWxsLCBlLnRhcmdldCA9IHRoaXMsIGUubWFuYWdlci5kaXNwYXRjaEV2ZW50KGUpLCAhZS5kZWZhdWx0UHJldmVudGVkO1xuICB9XG59O1xuZGlzcGxheS5EaXNwbGF5T2JqZWN0Lm1peGluKEZlZGVyYXRlZERpc3BsYXlPYmplY3QpO1xuZXhwb3J0cy5GZWRlcmF0ZWREaXNwbGF5T2JqZWN0ID0gRmVkZXJhdGVkRGlzcGxheU9iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZlZGVyYXRlZEV2ZW50VGFyZ2V0LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCBGZWRlcmF0ZWRFdmVudCA9IHJlcXVpcmUoXCIuL0ZlZGVyYXRlZEV2ZW50LmpzXCIpO1xuY2xhc3MgRmVkZXJhdGVkTW91c2VFdmVudCBleHRlbmRzIEZlZGVyYXRlZEV2ZW50LkZlZGVyYXRlZEV2ZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5jbGllbnQgPSBuZXcgY29yZS5Qb2ludCgpLCB0aGlzLm1vdmVtZW50ID0gbmV3IGNvcmUuUG9pbnQoKSwgdGhpcy5vZmZzZXQgPSBuZXcgY29yZS5Qb2ludCgpLCB0aGlzLmdsb2JhbCA9IG5ldyBjb3JlLlBvaW50KCksIHRoaXMuc2NyZWVuID0gbmV3IGNvcmUuUG9pbnQoKTtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBjbGllbnRYKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IGNsaWVudFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50Lnk7XG4gIH1cbiAgLyoqXG4gICAqIEFsaWFzIGZvciB7QGxpbmsgUElYSS5GZWRlcmF0ZWRNb3VzZUV2ZW50LmNsaWVudFggdGhpcy5jbGllbnRYfS5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnRYO1xuICB9XG4gIC8qKlxuICAgKiBBbGlhcyBmb3Ige0BsaW5rIFBJWEkuRmVkZXJhdGVkTW91c2VFdmVudC5jbGllbnRZIHRoaXMuY2xpZW50WX0uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50WTtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBtb3ZlbWVudFgoKSB7XG4gICAgcmV0dXJuIHRoaXMubW92ZW1lbnQueDtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBtb3ZlbWVudFkoKSB7XG4gICAgcmV0dXJuIHRoaXMubW92ZW1lbnQueTtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBvZmZzZXRYKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldC54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IG9mZnNldFkoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0Lnk7XG4gIH1cbiAgLyoqIEByZWFkb25seSAqL1xuICBnZXQgZ2xvYmFsWCgpIHtcbiAgICByZXR1cm4gdGhpcy5nbG9iYWwueDtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBnbG9iYWxZKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbC55O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcG9pbnRlciBjb29yZGluYXRlcyBpbiB0aGUgcmVuZGVyZXIncyBzY3JlZW4uIEFsaWFzIGZvciB7QGNvZGUgc2NyZWVuLnh9LlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBzY3JlZW5YKCkge1xuICAgIHJldHVybiB0aGlzLnNjcmVlbi54O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcG9pbnRlciBjb29yZGluYXRlcyBpbiB0aGUgcmVuZGVyZXIncyBzY3JlZW4uIEFsaWFzIGZvciB7QGNvZGUgc2NyZWVuLnl9LlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBzY3JlZW5ZKCkge1xuICAgIHJldHVybiB0aGlzLnNjcmVlbi55O1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIHdpbGwgcmV0dXJuIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgc3BlY2lmaWVkIGRpc3BsYXlPYmplY3QgZm9yIHRoaXMgSW50ZXJhY3Rpb25EYXRhXG4gICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0IC0gVGhlIERpc3BsYXlPYmplY3QgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgbG9jYWxcbiAgICogIGNvb3JkcyBvZmZcbiAgICogQHBhcmFtIHtQSVhJLklQb2ludERhdGF9IHBvaW50IC0gQSBQb2ludCBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHZhbHVlLCBvcHRpb25hbCAob3RoZXJ3aXNlXG4gICAqICB3aWxsIGNyZWF0ZSBhIG5ldyBwb2ludClcbiAgICogQHBhcmFtIHtQSVhJLklQb2ludERhdGF9IGdsb2JhbFBvcyAtIEEgUG9pbnQgb2JqZWN0IGNvbnRhaW5pbmcgeW91ciBjdXN0b20gZ2xvYmFsIGNvb3Jkcywgb3B0aW9uYWxcbiAgICogIChvdGhlcndpc2Ugd2lsbCB1c2UgdGhlIGN1cnJlbnQgZ2xvYmFsIGNvb3JkcylcbiAgICogQHJldHVybnMgLSBBIHBvaW50IGNvbnRhaW5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBJbnRlcmFjdGlvbkRhdGEgcG9zaXRpb24gcmVsYXRpdmVcbiAgICogIHRvIHRoZSBEaXNwbGF5T2JqZWN0XG4gICAqL1xuICBnZXRMb2NhbFBvc2l0aW9uKGRpc3BsYXlPYmplY3QsIHBvaW50LCBnbG9iYWxQb3MpIHtcbiAgICByZXR1cm4gZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UoZ2xvYmFsUG9zIHx8IHRoaXMuZ2xvYmFsLCBwb2ludCk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGtleSB3YXMgcHJlc3NlZCB3aGVuIHRoaXMgZXZlbnQgbmF0aXZlbHkgb2NjdXJyZWQuXG4gICAqIEBwYXJhbSBrZXkgLSBUaGUgbW9kaWZpZXIga2V5LlxuICAgKi9cbiAgZ2V0TW9kaWZpZXJTdGF0ZShrZXkpIHtcbiAgICByZXR1cm4gXCJnZXRNb2RpZmllclN0YXRlXCIgaW4gdGhpcy5uYXRpdmVFdmVudCAmJiB0aGlzLm5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5KTtcbiAgfVxuICAvKipcbiAgICogTm90IHN1cHBvcnRlZC5cbiAgICogQHBhcmFtIF90eXBlQXJnXG4gICAqIEBwYXJhbSBfY2FuQnViYmxlQXJnXG4gICAqIEBwYXJhbSBfY2FuY2VsYWJsZUFyZ1xuICAgKiBAcGFyYW0gX3ZpZXdBcmdcbiAgICogQHBhcmFtIF9kZXRhaWxBcmdcbiAgICogQHBhcmFtIF9zY3JlZW5YQXJnXG4gICAqIEBwYXJhbSBfc2NyZWVuWUFyZ1xuICAgKiBAcGFyYW0gX2NsaWVudFhBcmdcbiAgICogQHBhcmFtIF9jbGllbnRZQXJnXG4gICAqIEBwYXJhbSBfY3RybEtleUFyZ1xuICAgKiBAcGFyYW0gX2FsdEtleUFyZ1xuICAgKiBAcGFyYW0gX3NoaWZ0S2V5QXJnXG4gICAqIEBwYXJhbSBfbWV0YUtleUFyZ1xuICAgKiBAcGFyYW0gX2J1dHRvbkFyZ1xuICAgKiBAcGFyYW0gX3JlbGF0ZWRUYXJnZXRBcmdcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4wLjBcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG4gIGluaXRNb3VzZUV2ZW50KF90eXBlQXJnLCBfY2FuQnViYmxlQXJnLCBfY2FuY2VsYWJsZUFyZywgX3ZpZXdBcmcsIF9kZXRhaWxBcmcsIF9zY3JlZW5YQXJnLCBfc2NyZWVuWUFyZywgX2NsaWVudFhBcmcsIF9jbGllbnRZQXJnLCBfY3RybEtleUFyZywgX2FsdEtleUFyZywgX3NoaWZ0S2V5QXJnLCBfbWV0YUtleUFyZywgX2J1dHRvbkFyZywgX3JlbGF0ZWRUYXJnZXRBcmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgfVxufVxuZXhwb3J0cy5GZWRlcmF0ZWRNb3VzZUV2ZW50ID0gRmVkZXJhdGVkTW91c2VFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZlZGVyYXRlZE1vdXNlRXZlbnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBGZWRlcmF0ZWRNb3VzZUV2ZW50ID0gcmVxdWlyZShcIi4vRmVkZXJhdGVkTW91c2VFdmVudC5qc1wiKTtcbmNsYXNzIEZlZGVyYXRlZFBvaW50ZXJFdmVudCBleHRlbmRzIEZlZGVyYXRlZE1vdXNlRXZlbnQuRmVkZXJhdGVkTW91c2VFdmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMud2lkdGggPSAwLCB0aGlzLmhlaWdodCA9IDAsIHRoaXMuaXNQcmltYXJ5ID0gITE7XG4gIH1cbiAgLy8gT25seSBpbmNsdWRlZCBmb3IgY29tcGxldGVuZXNzIGZvciBub3dcbiAgZ2V0Q29hbGVzY2VkRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFwicG9pbnRlcm1vdmVcIiB8fCB0aGlzLnR5cGUgPT09IFwibW91c2Vtb3ZlXCIgfHwgdGhpcy50eXBlID09PSBcInRvdWNobW92ZVwiID8gW3RoaXNdIDogW107XG4gIH1cbiAgLy8gT25seSBpbmNsdWRlZCBmb3IgY29tcGxldGVuZXNzIGZvciBub3dcbiAgZ2V0UHJlZGljdGVkRXZlbnRzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImdldFByZWRpY3RlZEV2ZW50cyBpcyBub3Qgc3VwcG9ydGVkIVwiKTtcbiAgfVxufVxuZXhwb3J0cy5GZWRlcmF0ZWRQb2ludGVyRXZlbnQgPSBGZWRlcmF0ZWRQb2ludGVyRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRQb2ludGVyRXZlbnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBGZWRlcmF0ZWRNb3VzZUV2ZW50ID0gcmVxdWlyZShcIi4vRmVkZXJhdGVkTW91c2VFdmVudC5qc1wiKTtcbmNsYXNzIEZlZGVyYXRlZFdoZWVsRXZlbnQgZXh0ZW5kcyBGZWRlcmF0ZWRNb3VzZUV2ZW50LkZlZGVyYXRlZE1vdXNlRXZlbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLkRPTV9ERUxUQV9QSVhFTCA9IDAsIHRoaXMuRE9NX0RFTFRBX0xJTkUgPSAxLCB0aGlzLkRPTV9ERUxUQV9QQUdFID0gMjtcbiAgfVxufVxuRmVkZXJhdGVkV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUwgPSAwLCAvKiogVW5pdHMgc3BlY2lmaWVkIGluIGxpbmVzLiAqL1xuRmVkZXJhdGVkV2hlZWxFdmVudC5ET01fREVMVEFfTElORSA9IDEsIC8qKiBVbml0cyBzcGVjaWZpZWQgaW4gcGFnZXMuICovXG5GZWRlcmF0ZWRXaGVlbEV2ZW50LkRPTV9ERUxUQV9QQUdFID0gMjtcbmV4cG9ydHMuRmVkZXJhdGVkV2hlZWxFdmVudCA9IEZlZGVyYXRlZFdoZWVsRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRXaGVlbEV2ZW50LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRXZlbnRCb3VuZGFyeSA9IHJlcXVpcmUoXCIuL0V2ZW50Qm91bmRhcnkuanNcIiksIEV2ZW50U3lzdGVtID0gcmVxdWlyZShcIi4vRXZlbnRTeXN0ZW0uanNcIiksIEZlZGVyYXRlZEV2ZW50ID0gcmVxdWlyZShcIi4vRmVkZXJhdGVkRXZlbnQuanNcIik7XG5yZXF1aXJlKFwiLi9GZWRlcmF0ZWRFdmVudE1hcC5qc1wiKTtcbnZhciBGZWRlcmF0ZWRFdmVudFRhcmdldCA9IHJlcXVpcmUoXCIuL0ZlZGVyYXRlZEV2ZW50VGFyZ2V0LmpzXCIpLCBGZWRlcmF0ZWRNb3VzZUV2ZW50ID0gcmVxdWlyZShcIi4vRmVkZXJhdGVkTW91c2VFdmVudC5qc1wiKSwgRmVkZXJhdGVkUG9pbnRlckV2ZW50ID0gcmVxdWlyZShcIi4vRmVkZXJhdGVkUG9pbnRlckV2ZW50LmpzXCIpLCBGZWRlcmF0ZWRXaGVlbEV2ZW50ID0gcmVxdWlyZShcIi4vRmVkZXJhdGVkV2hlZWxFdmVudC5qc1wiKTtcbmV4cG9ydHMuRXZlbnRCb3VuZGFyeSA9IEV2ZW50Qm91bmRhcnkuRXZlbnRCb3VuZGFyeTtcbmV4cG9ydHMuRXZlbnRTeXN0ZW0gPSBFdmVudFN5c3RlbS5FdmVudFN5c3RlbTtcbmV4cG9ydHMuRmVkZXJhdGVkRXZlbnQgPSBGZWRlcmF0ZWRFdmVudC5GZWRlcmF0ZWRFdmVudDtcbmV4cG9ydHMuRmVkZXJhdGVkRGlzcGxheU9iamVjdCA9IEZlZGVyYXRlZEV2ZW50VGFyZ2V0LkZlZGVyYXRlZERpc3BsYXlPYmplY3Q7XG5leHBvcnRzLkZlZGVyYXRlZE1vdXNlRXZlbnQgPSBGZWRlcmF0ZWRNb3VzZUV2ZW50LkZlZGVyYXRlZE1vdXNlRXZlbnQ7XG5leHBvcnRzLkZlZGVyYXRlZFBvaW50ZXJFdmVudCA9IEZlZGVyYXRlZFBvaW50ZXJFdmVudC5GZWRlcmF0ZWRQb2ludGVyRXZlbnQ7XG5leHBvcnRzLkZlZGVyYXRlZFdoZWVsRXZlbnQgPSBGZWRlcmF0ZWRXaGVlbEV2ZW50LkZlZGVyYXRlZFdoZWVsRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIEV4dGVuc2lvblR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFeHRlbnNpb25UeXBlMikgPT4gKEV4dGVuc2lvblR5cGUyLlJlbmRlcmVyID0gXCJyZW5kZXJlclwiLCBFeHRlbnNpb25UeXBlMi5BcHBsaWNhdGlvbiA9IFwiYXBwbGljYXRpb25cIiwgRXh0ZW5zaW9uVHlwZTIuUmVuZGVyZXJTeXN0ZW0gPSBcInJlbmRlcmVyLXdlYmdsLXN5c3RlbVwiLCBFeHRlbnNpb25UeXBlMi5SZW5kZXJlclBsdWdpbiA9IFwicmVuZGVyZXItd2ViZ2wtcGx1Z2luXCIsIEV4dGVuc2lvblR5cGUyLkNhbnZhc1JlbmRlcmVyU3lzdGVtID0gXCJyZW5kZXJlci1jYW52YXMtc3lzdGVtXCIsIEV4dGVuc2lvblR5cGUyLkNhbnZhc1JlbmRlcmVyUGx1Z2luID0gXCJyZW5kZXJlci1jYW52YXMtcGx1Z2luXCIsIEV4dGVuc2lvblR5cGUyLkFzc2V0ID0gXCJhc3NldFwiLCBFeHRlbnNpb25UeXBlMi5Mb2FkUGFyc2VyID0gXCJsb2FkLXBhcnNlclwiLCBFeHRlbnNpb25UeXBlMi5SZXNvbHZlUGFyc2VyID0gXCJyZXNvbHZlLXBhcnNlclwiLCBFeHRlbnNpb25UeXBlMi5DYWNoZVBhcnNlciA9IFwiY2FjaGUtcGFyc2VyXCIsIEV4dGVuc2lvblR5cGUyLkRldGVjdGlvblBhcnNlciA9IFwiZGV0ZWN0aW9uLXBhcnNlclwiLCBFeHRlbnNpb25UeXBlMikpKEV4dGVuc2lvblR5cGUgfHwge30pO1xuY29uc3Qgbm9ybWFsaXplRXh0ZW5zaW9uID0gKGV4dCkgPT4ge1xuICBpZiAodHlwZW9mIGV4dCA9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGV4dCA9PSBcIm9iamVjdFwiICYmIGV4dC5leHRlbnNpb24pIHtcbiAgICBpZiAoIWV4dC5leHRlbnNpb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHRlbnNpb24gY2xhc3MgbXVzdCBoYXZlIGFuIGV4dGVuc2lvbiBvYmplY3RcIik7XG4gICAgZXh0ID0geyAuLi50eXBlb2YgZXh0LmV4dGVuc2lvbiAhPSBcIm9iamVjdFwiID8geyB0eXBlOiBleHQuZXh0ZW5zaW9uIH0gOiBleHQuZXh0ZW5zaW9uLCByZWY6IGV4dCB9O1xuICB9XG4gIGlmICh0eXBlb2YgZXh0ID09IFwib2JqZWN0XCIpXG4gICAgZXh0ID0geyAuLi5leHQgfTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZXh0ZW5zaW9uIHR5cGVcIik7XG4gIHJldHVybiB0eXBlb2YgZXh0LnR5cGUgPT0gXCJzdHJpbmdcIiAmJiAoZXh0LnR5cGUgPSBbZXh0LnR5cGVdKSwgZXh0O1xufSwgbm9ybWFsaXplUHJpb3JpdHkgPSAoZXh0LCBkZWZhdWx0UHJpb3JpdHkpID0+IG5vcm1hbGl6ZUV4dGVuc2lvbihleHQpLnByaW9yaXR5ID8/IGRlZmF1bHRQcmlvcml0eSwgZXh0ZW5zaW9ucyA9IHtcbiAgLyoqIEBpZ25vcmUgKi9cbiAgX2FkZEhhbmRsZXJzOiB7fSxcbiAgLyoqIEBpZ25vcmUgKi9cbiAgX3JlbW92ZUhhbmRsZXJzOiB7fSxcbiAgLyoqIEBpZ25vcmUgKi9cbiAgX3F1ZXVlOiB7fSxcbiAgLyoqXG4gICAqIFJlbW92ZSBleHRlbnNpb25zIGZyb20gUGl4aUpTLlxuICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyAtIEV4dGVuc2lvbnMgdG8gYmUgcmVtb3ZlZC5cbiAgICogQHJldHVybnMge1BJWEkuZXh0ZW5zaW9uc30gRm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcmVtb3ZlKC4uLmV4dGVuc2lvbnMyKSB7XG4gICAgcmV0dXJuIGV4dGVuc2lvbnMyLm1hcChub3JtYWxpemVFeHRlbnNpb24pLmZvckVhY2goKGV4dCkgPT4ge1xuICAgICAgZXh0LnR5cGUuZm9yRWFjaCgodHlwZSkgPT4gdGhpcy5fcmVtb3ZlSGFuZGxlcnNbdHlwZV0/LihleHQpKTtcbiAgICB9KSwgdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIG5ldyBleHRlbnNpb25zIHdpdGggUGl4aUpTLlxuICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyAtIFRoZSBzcHJlYWQgb2YgZXh0ZW5zaW9ucyB0byBhZGQgdG8gUGl4aUpTLlxuICAgKiBAcmV0dXJucyB7UElYSS5leHRlbnNpb25zfSBGb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhZGQoLi4uZXh0ZW5zaW9uczIpIHtcbiAgICByZXR1cm4gZXh0ZW5zaW9uczIubWFwKG5vcm1hbGl6ZUV4dGVuc2lvbikuZm9yRWFjaCgoZXh0KSA9PiB7XG4gICAgICBleHQudHlwZS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5fYWRkSGFuZGxlcnMsIHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgICAgIGhhbmRsZXJzW3R5cGVdID8gaGFuZGxlcnNbdHlwZV0oZXh0KSA6IChxdWV1ZVt0eXBlXSA9IHF1ZXVlW3R5cGVdIHx8IFtdLCBxdWV1ZVt0eXBlXS5wdXNoKGV4dCkpO1xuICAgICAgfSk7XG4gICAgfSksIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gaGFuZGxlIGV4dGVuc2lvbnMgYnkgbmFtZS5cbiAgICogQHBhcmFtIHR5cGUgLSBUaGUgZXh0ZW5zaW9uIHR5cGUuXG4gICAqIEBwYXJhbSBvbkFkZCAgLSBGdW5jdGlvbiBmb3IgaGFuZGxpbmcgd2hlbiBleHRlbnNpb25zIGFyZSBhZGRlZC9yZWdpc3RlcmVkIHBhc3NlcyB7QGxpbmsgUElYSS5FeHRlbnNpb25Gb3JtYXR9LlxuICAgKiBAcGFyYW0gb25SZW1vdmUgIC0gRnVuY3Rpb24gZm9yIGhhbmRsaW5nIHdoZW4gZXh0ZW5zaW9ucyBhcmUgcmVtb3ZlZC91bnJlZ2lzdGVyZWQgcGFzc2VzIHtAbGluayBQSVhJLkV4dGVuc2lvbkZvcm1hdH0uXG4gICAqIEByZXR1cm5zIHtQSVhJLmV4dGVuc2lvbnN9IEZvciBjaGFpbmluZy5cbiAgICovXG4gIGhhbmRsZSh0eXBlLCBvbkFkZCwgb25SZW1vdmUpIHtcbiAgICBjb25zdCBhZGRIYW5kbGVycyA9IHRoaXMuX2FkZEhhbmRsZXJzLCByZW1vdmVIYW5kbGVycyA9IHRoaXMuX3JlbW92ZUhhbmRsZXJzO1xuICAgIGlmIChhZGRIYW5kbGVyc1t0eXBlXSB8fCByZW1vdmVIYW5kbGVyc1t0eXBlXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXh0ZW5zaW9uIHR5cGUgJHt0eXBlfSBhbHJlYWR5IGhhcyBhIGhhbmRsZXJgKTtcbiAgICBhZGRIYW5kbGVyc1t0eXBlXSA9IG9uQWRkLCByZW1vdmVIYW5kbGVyc1t0eXBlXSA9IG9uUmVtb3ZlO1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgcmV0dXJuIHF1ZXVlW3R5cGVdICYmIChxdWV1ZVt0eXBlXS5mb3JFYWNoKChleHQpID0+IG9uQWRkKGV4dCkpLCBkZWxldGUgcXVldWVbdHlwZV0pLCB0aGlzO1xuICB9LFxuICAvKipcbiAgICogSGFuZGxlIGEgdHlwZSwgYnV0IHVzaW5nIGEgbWFwIGJ5IGBuYW1lYCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHR5cGUgLSBUeXBlIG9mIGV4dGVuc2lvbiB0byBoYW5kbGUuXG4gICAqIEBwYXJhbSBtYXAgLSBUaGUgb2JqZWN0IG1hcCBvZiBuYW1lZCBleHRlbnNpb25zLlxuICAgKiBAcmV0dXJucyB7UElYSS5leHRlbnNpb25zfSBGb3IgY2hhaW5pbmcuXG4gICAqL1xuICBoYW5kbGVCeU1hcCh0eXBlLCBtYXApIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGUoXG4gICAgICB0eXBlLFxuICAgICAgKGV4dGVuc2lvbikgPT4ge1xuICAgICAgICBtYXBbZXh0ZW5zaW9uLm5hbWVdID0gZXh0ZW5zaW9uLnJlZjtcbiAgICAgIH0sXG4gICAgICAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgIGRlbGV0ZSBtYXBbZXh0ZW5zaW9uLm5hbWVdO1xuICAgICAgfVxuICAgICk7XG4gIH0sXG4gIC8qKlxuICAgKiBIYW5kbGUgYSB0eXBlLCBidXQgdXNpbmcgYSBsaXN0IG9mIGV4dGVuc2lvbnMuXG4gICAqIEBwYXJhbSB0eXBlIC0gVHlwZSBvZiBleHRlbnNpb24gdG8gaGFuZGxlLlxuICAgKiBAcGFyYW0gbGlzdCAtIFRoZSBsaXN0IG9mIGV4dGVuc2lvbnMuXG4gICAqIEBwYXJhbSBkZWZhdWx0UHJpb3JpdHkgLSBUaGUgZGVmYXVsdCBwcmlvcml0eSB0byB1c2UgaWYgbm9uZSBpcyBzcGVjaWZpZWQuXG4gICAqIEByZXR1cm5zIHtQSVhJLmV4dGVuc2lvbnN9IEZvciBjaGFpbmluZy5cbiAgICovXG4gIGhhbmRsZUJ5TGlzdCh0eXBlLCBsaXN0LCBkZWZhdWx0UHJpb3JpdHkgPSAtMSkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZShcbiAgICAgIHR5cGUsXG4gICAgICAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgIGxpc3QuaW5jbHVkZXMoZXh0ZW5zaW9uLnJlZikgfHwgKGxpc3QucHVzaChleHRlbnNpb24ucmVmKSwgbGlzdC5zb3J0KChhLCBiKSA9PiBub3JtYWxpemVQcmlvcml0eShiLCBkZWZhdWx0UHJpb3JpdHkpIC0gbm9ybWFsaXplUHJpb3JpdHkoYSwgZGVmYXVsdFByaW9yaXR5KSkpO1xuICAgICAgfSxcbiAgICAgIChleHRlbnNpb24pID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBsaXN0LmluZGV4T2YoZXh0ZW5zaW9uLnJlZik7XG4gICAgICAgIGluZGV4ICE9PSAtMSAmJiBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxufTtcbmV4cG9ydHMuRXh0ZW5zaW9uVHlwZSA9IEV4dGVuc2lvblR5cGU7XG5leHBvcnRzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIik7XG5jb25zdCBURU1QX1JFQ1QgPSBuZXcgY29yZS5SZWN0YW5nbGUoKSwgQllURVNfUEVSX1BJWEVMID0gNCwgX0V4dHJhY3QgPSBjbGFzcyBfRXh0cmFjdDIge1xuICAvKipcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcmVuZGVyZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyLCB0aGlzLl9yZW5kZXJlclByZW11bHRpcGxpZWRBbHBoYSA9ICExO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHRoaXMucmVuZGVyZXI/LmdsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XG4gICAgdGhpcy5fcmVuZGVyZXJQcmVtdWx0aXBsaWVkQWxwaGEgPSAhIShhdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXMuYWxwaGEgJiYgYXR0cmlidXRlcy5wcmVtdWx0aXBsaWVkQWxwaGEpO1xuICB9XG4gIC8qKlxuICAgKiBXaWxsIHJldHVybiBhIEhUTUwgSW1hZ2Ugb2YgdGhlIHRhcmdldFxuICAgKiBAcGFyYW0gdGFyZ2V0IC0gQSBkaXNwbGF5T2JqZWN0IG9yIHJlbmRlclRleHR1cmVcbiAgICogIHRvIGNvbnZlcnQuIElmIGxlZnQgZW1wdHkgd2lsbCB1c2UgdGhlIG1haW4gcmVuZGVyZXJcbiAgICogQHBhcmFtIGZvcm1hdCAtIEltYWdlIGZvcm1hdCwgZS5nLiBcImltYWdlL2pwZWdcIiBvciBcImltYWdlL3dlYnBcIi5cbiAgICogQHBhcmFtIHF1YWxpdHkgLSBKUEVHIG9yIFdlYnAgY29tcHJlc3Npb24gZnJvbSAwIHRvIDEuIERlZmF1bHQgaXMgMC45Mi5cbiAgICogQHBhcmFtIGZyYW1lIC0gVGhlIGZyYW1lIHRoZSBleHRyYWN0aW9uIGlzIHJlc3RyaWN0ZWQgdG8uXG4gICAqIEByZXR1cm5zIC0gSFRNTCBJbWFnZSBvZiB0aGUgdGFyZ2V0XG4gICAqL1xuICBhc3luYyBpbWFnZSh0YXJnZXQsIGZvcm1hdCwgcXVhbGl0eSwgZnJhbWUpIHtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIHJldHVybiBpbWFnZS5zcmMgPSBhd2FpdCB0aGlzLmJhc2U2NCh0YXJnZXQsIGZvcm1hdCwgcXVhbGl0eSwgZnJhbWUpLCBpbWFnZTtcbiAgfVxuICAvKipcbiAgICogV2lsbCByZXR1cm4gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb2YgdGhpcyB0YXJnZXQuIEl0IHdvcmtzIGJ5IGNhbGxpbmdcbiAgICogIGBFeHRyYWN0LmNhbnZhc2AgYW5kIHRoZW4gcnVubmluZyB0b0RhdGFVUkwgb24gdGhhdC5cbiAgICogQHBhcmFtIHRhcmdldCAtIEEgZGlzcGxheU9iamVjdCBvciByZW5kZXJUZXh0dXJlXG4gICAqICB0byBjb252ZXJ0LiBJZiBsZWZ0IGVtcHR5IHdpbGwgdXNlIHRoZSBtYWluIHJlbmRlcmVyXG4gICAqIEBwYXJhbSBmb3JtYXQgLSBJbWFnZSBmb3JtYXQsIGUuZy4gXCJpbWFnZS9qcGVnXCIgb3IgXCJpbWFnZS93ZWJwXCIuXG4gICAqIEBwYXJhbSBxdWFsaXR5IC0gSlBFRyBvciBXZWJwIGNvbXByZXNzaW9uIGZyb20gMCB0byAxLiBEZWZhdWx0IGlzIDAuOTIuXG4gICAqIEBwYXJhbSBmcmFtZSAtIFRoZSBmcmFtZSB0aGUgZXh0cmFjdGlvbiBpcyByZXN0cmljdGVkIHRvLlxuICAgKiBAcmV0dXJucyAtIEEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIG9mIHRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgYXN5bmMgYmFzZTY0KHRhcmdldCwgZm9ybWF0LCBxdWFsaXR5LCBmcmFtZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzKHRhcmdldCwgZnJhbWUpO1xuICAgIGlmIChjYW52YXMudG9CbG9iICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjYW52YXMudG9CbG9iKChibG9iKSA9PiB7XG4gICAgICAgICAgaWYgKCFibG9iKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiSUNhbnZhcy50b0Jsb2IgZmFpbGVkIVwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHJlc29sdmUocmVhZGVyLnJlc3VsdCksIHJlYWRlci5vbmVycm9yID0gcmVqZWN0LCByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgICAgICAgfSwgZm9ybWF0LCBxdWFsaXR5KTtcbiAgICAgIH0pO1xuICAgIGlmIChjYW52YXMudG9EYXRhVVJMICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTChmb3JtYXQsIHF1YWxpdHkpO1xuICAgIGlmIChjYW52YXMuY29udmVydFRvQmxvYiAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBibG9iID0gYXdhaXQgY2FudmFzLmNvbnZlcnRUb0Jsb2IoeyB0eXBlOiBmb3JtYXQsIHF1YWxpdHkgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KSwgcmVhZGVyLm9uZXJyb3IgPSByZWplY3QsIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4dHJhY3QuYmFzZTY0KCkgcmVxdWlyZXMgSUNhbnZhcy50b0RhdGFVUkwsIElDYW52YXMudG9CbG9iLCBvciBJQ2FudmFzLmNvbnZlcnRUb0Jsb2IgdG8gYmUgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBDYW52YXMgZWxlbWVudCwgcmVuZGVycyB0aGlzIHRhcmdldCB0byBpdCBhbmQgdGhlbiByZXR1cm5zIGl0LlxuICAgKiBAcGFyYW0gdGFyZ2V0IC0gQSBkaXNwbGF5T2JqZWN0IG9yIHJlbmRlclRleHR1cmVcbiAgICogIHRvIGNvbnZlcnQuIElmIGxlZnQgZW1wdHkgd2lsbCB1c2UgdGhlIG1haW4gcmVuZGVyZXJcbiAgICogQHBhcmFtIGZyYW1lIC0gVGhlIGZyYW1lIHRoZSBleHRyYWN0aW9uIGlzIHJlc3RyaWN0ZWQgdG8uXG4gICAqIEByZXR1cm5zIC0gQSBDYW52YXMgZWxlbWVudCB3aXRoIHRoZSB0ZXh0dXJlIHJlbmRlcmVkIG9uLlxuICAgKi9cbiAgY2FudmFzKHRhcmdldCwgZnJhbWUpIHtcbiAgICBjb25zdCB7IHBpeGVscywgd2lkdGgsIGhlaWdodCwgZmxpcFksIHByZW11bHRpcGxpZWRBbHBoYSB9ID0gdGhpcy5fcmF3UGl4ZWxzKHRhcmdldCwgZnJhbWUpO1xuICAgIGZsaXBZICYmIF9FeHRyYWN0Mi5fZmxpcFkocGl4ZWxzLCB3aWR0aCwgaGVpZ2h0KSwgcHJlbXVsdGlwbGllZEFscGhhICYmIF9FeHRyYWN0Mi5fdW5wcmVtdWx0aXBseUFscGhhKHBpeGVscyk7XG4gICAgY29uc3QgY2FudmFzQnVmZmVyID0gbmV3IGNvcmUudXRpbHMuQ2FudmFzUmVuZGVyVGFyZ2V0KHdpZHRoLCBoZWlnaHQsIDEpLCBpbWFnZURhdGEgPSBuZXcgSW1hZ2VEYXRhKG5ldyBVaW50OENsYW1wZWRBcnJheShwaXhlbHMuYnVmZmVyKSwgd2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIGNhbnZhc0J1ZmZlci5jb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApLCBjYW52YXNCdWZmZXIuY2FudmFzO1xuICB9XG4gIC8qKlxuICAgKiBXaWxsIHJldHVybiBhIG9uZS1kaW1lbnNpb25hbCBhcnJheSBjb250YWluaW5nIHRoZSBwaXhlbCBkYXRhIG9mIHRoZSBlbnRpcmUgdGV4dHVyZSBpbiBSR0JBXG4gICAqIG9yZGVyLCB3aXRoIGludGVnZXIgdmFsdWVzIGJldHdlZW4gMCBhbmQgMjU1IChpbmNsdWRlZCkuXG4gICAqIEBwYXJhbSB0YXJnZXQgLSBBIGRpc3BsYXlPYmplY3Qgb3IgcmVuZGVyVGV4dHVyZVxuICAgKiAgdG8gY29udmVydC4gSWYgbGVmdCBlbXB0eSB3aWxsIHVzZSB0aGUgbWFpbiByZW5kZXJlclxuICAgKiBAcGFyYW0gZnJhbWUgLSBUaGUgZnJhbWUgdGhlIGV4dHJhY3Rpb24gaXMgcmVzdHJpY3RlZCB0by5cbiAgICogQHJldHVybnMgLSBPbmUtZGltZW5zaW9uYWwgYXJyYXkgY29udGFpbmluZyB0aGUgcGl4ZWwgZGF0YSBvZiB0aGUgZW50aXJlIHRleHR1cmVcbiAgICovXG4gIHBpeGVscyh0YXJnZXQsIGZyYW1lKSB7XG4gICAgY29uc3QgeyBwaXhlbHMsIHdpZHRoLCBoZWlnaHQsIGZsaXBZLCBwcmVtdWx0aXBsaWVkQWxwaGEgfSA9IHRoaXMuX3Jhd1BpeGVscyh0YXJnZXQsIGZyYW1lKTtcbiAgICByZXR1cm4gZmxpcFkgJiYgX0V4dHJhY3QyLl9mbGlwWShwaXhlbHMsIHdpZHRoLCBoZWlnaHQpLCBwcmVtdWx0aXBsaWVkQWxwaGEgJiYgX0V4dHJhY3QyLl91bnByZW11bHRpcGx5QWxwaGEocGl4ZWxzKSwgcGl4ZWxzO1xuICB9XG4gIF9yYXdQaXhlbHModGFyZ2V0LCBmcmFtZSkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBpZiAoIXJlbmRlcmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIEV4dHJhY3QgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWRcIik7XG4gICAgbGV0IHJlc29sdXRpb24sIGZsaXBZID0gITEsIHByZW11bHRpcGxpZWRBbHBoYSA9ICExLCByZW5kZXJUZXh0dXJlLCBnZW5lcmF0ZWQgPSAhMTtcbiAgICB0YXJnZXQgJiYgKHRhcmdldCBpbnN0YW5jZW9mIGNvcmUuUmVuZGVyVGV4dHVyZSA/IHJlbmRlclRleHR1cmUgPSB0YXJnZXQgOiAocmVuZGVyVGV4dHVyZSA9IHJlbmRlcmVyLmdlbmVyYXRlVGV4dHVyZSh0YXJnZXQsIHtcbiAgICAgIHJlZ2lvbjogZnJhbWUsXG4gICAgICByZXNvbHV0aW9uOiByZW5kZXJlci5yZXNvbHV0aW9uLFxuICAgICAgbXVsdGlzYW1wbGU6IHJlbmRlcmVyLm11bHRpc2FtcGxlXG4gICAgfSksIGdlbmVyYXRlZCA9ICEwLCBmcmFtZSAmJiAoVEVNUF9SRUNULndpZHRoID0gZnJhbWUud2lkdGgsIFRFTVBfUkVDVC5oZWlnaHQgPSBmcmFtZS5oZWlnaHQsIGZyYW1lID0gVEVNUF9SRUNUKSkpO1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgaWYgKHJlbmRlclRleHR1cmUpIHtcbiAgICAgIGlmIChyZXNvbHV0aW9uID0gcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uLCBmcmFtZSA9IGZyYW1lID8/IHJlbmRlclRleHR1cmUuZnJhbWUsIGZsaXBZID0gITEsIHByZW11bHRpcGxpZWRBbHBoYSA9IHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUuYWxwaGFNb2RlID4gMCAmJiByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLmZvcm1hdCA9PT0gY29yZS5GT1JNQVRTLlJHQkEsICFnZW5lcmF0ZWQpIHtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKHJlbmRlclRleHR1cmUpO1xuICAgICAgICBjb25zdCBmYm8gPSByZW5kZXJUZXh0dXJlLmZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3JlbmRlcmVyLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgZmJvLmJsaXRGcmFtZWJ1ZmZlciAmJiByZW5kZXJlci5mcmFtZWJ1ZmZlci5iaW5kKGZiby5ibGl0RnJhbWVidWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgcmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb24sIGZyYW1lIHx8IChmcmFtZSA9IFRFTVBfUkVDVCwgZnJhbWUud2lkdGggPSByZW5kZXJlci53aWR0aCAvIHJlc29sdXRpb24sIGZyYW1lLmhlaWdodCA9IHJlbmRlcmVyLmhlaWdodCAvIHJlc29sdXRpb24pLCBmbGlwWSA9ICEwLCBwcmVtdWx0aXBsaWVkQWxwaGEgPSB0aGlzLl9yZW5kZXJlclByZW11bHRpcGxpZWRBbHBoYSwgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKCk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heChNYXRoLnJvdW5kKGZyYW1lLndpZHRoICogcmVzb2x1dGlvbiksIDEpLCBoZWlnaHQgPSBNYXRoLm1heChNYXRoLnJvdW5kKGZyYW1lLmhlaWdodCAqIHJlc29sdXRpb24pLCAxKSwgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoQllURVNfUEVSX1BJWEVMICogd2lkdGggKiBoZWlnaHQpO1xuICAgIHJldHVybiBnbC5yZWFkUGl4ZWxzKFxuICAgICAgTWF0aC5yb3VuZChmcmFtZS54ICogcmVzb2x1dGlvbiksXG4gICAgICBNYXRoLnJvdW5kKGZyYW1lLnkgKiByZXNvbHV0aW9uKSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgZ2wuUkdCQSxcbiAgICAgIGdsLlVOU0lHTkVEX0JZVEUsXG4gICAgICBwaXhlbHNcbiAgICApLCBnZW5lcmF0ZWQgJiYgcmVuZGVyVGV4dHVyZT8uZGVzdHJveSghMCksIHsgcGl4ZWxzLCB3aWR0aCwgaGVpZ2h0LCBmbGlwWSwgcHJlbXVsdGlwbGllZEFscGhhIH07XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoZSBleHRyYWN0LiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBfZmxpcFkocGl4ZWxzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgdyA9IHdpZHRoIDw8IDIsIGggPSBoZWlnaHQgPj4gMSwgdGVtcCA9IG5ldyBVaW50OEFycmF5KHcpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaDsgeSsrKSB7XG4gICAgICBjb25zdCB0ID0geSAqIHcsIGIgPSAoaGVpZ2h0IC0geSAtIDEpICogdztcbiAgICAgIHRlbXAuc2V0KHBpeGVscy5zdWJhcnJheSh0LCB0ICsgdykpLCBwaXhlbHMuY29weVdpdGhpbih0LCBiLCBiICsgdyksIHBpeGVscy5zZXQodGVtcCwgYik7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfdW5wcmVtdWx0aXBseUFscGhhKHBpeGVscykge1xuICAgIHBpeGVscyBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICYmIChwaXhlbHMgPSBuZXcgVWludDhBcnJheShwaXhlbHMuYnVmZmVyKSk7XG4gICAgY29uc3QgbiA9IHBpeGVscy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpICs9IDQpIHtcbiAgICAgIGNvbnN0IGFscGhhID0gcGl4ZWxzW2kgKyAzXTtcbiAgICAgIGlmIChhbHBoYSAhPT0gMCkge1xuICAgICAgICBjb25zdCBhID0gMjU1LjAwMSAvIGFscGhhO1xuICAgICAgICBwaXhlbHNbaV0gPSBwaXhlbHNbaV0gKiBhICsgMC41LCBwaXhlbHNbaSArIDFdID0gcGl4ZWxzW2kgKyAxXSAqIGEgKyAwLjUsIHBpeGVsc1tpICsgMl0gPSBwaXhlbHNbaSArIDJdICogYSArIDAuNTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5fRXh0cmFjdC5leHRlbnNpb24gPSB7XG4gIG5hbWU6IFwiZXh0cmFjdFwiLFxuICB0eXBlOiBjb3JlLkV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW1cbn07XG5sZXQgRXh0cmFjdCA9IF9FeHRyYWN0O1xuY29yZS5leHRlbnNpb25zLmFkZChFeHRyYWN0KTtcbmV4cG9ydHMuRXh0cmFjdCA9IEV4dHJhY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeHRyYWN0LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRXh0cmFjdCA9IHJlcXVpcmUoXCIuL0V4dHJhY3QuanNcIik7XG5leHBvcnRzLkV4dHJhY3QgPSBFeHRyYWN0LkV4dHJhY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgYWxwaGEgPSByZXF1aXJlKFwiLi9hbHBoYS5mcmFnLmpzXCIpO1xuY2xhc3MgQWxwaGFGaWx0ZXIgZXh0ZW5kcyBjb3JlLkZpbHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gYWxwaGEgLSBBbW91bnQgb2YgYWxwaGEgZnJvbSAwIHRvIDEsIHdoZXJlIDAgaXMgdHJhbnNwYXJlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFscGhhJDEgPSAxKSB7XG4gICAgc3VwZXIoY29yZS5kZWZhdWx0VmVydGV4LCBhbHBoYS5kZWZhdWx0LCB7IHVBbHBoYTogMSB9KSwgdGhpcy5hbHBoYSA9IGFscGhhJDE7XG4gIH1cbiAgLyoqXG4gICAqIENvZWZmaWNpZW50IGZvciBhbHBoYSBtdWx0aXBsaWNhdGlvblxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgYWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUFscGhhO1xuICB9XG4gIHNldCBhbHBoYSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudUFscGhhID0gdmFsdWU7XG4gIH1cbn1cbmV4cG9ydHMuQWxwaGFGaWx0ZXIgPSBBbHBoYUZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFscGhhRmlsdGVyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIGZyYWdtZW50ID0gYHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbnVuaWZvcm0gZmxvYXQgdUFscGhhO1xuXG52b2lkIG1haW4odm9pZClcbntcbiAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB1QWxwaGE7XG59XG5gO1xuZXhwb3J0cy5kZWZhdWx0ID0gZnJhZ21lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbHBoYS5mcmFnLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQWxwaGFGaWx0ZXIgPSByZXF1aXJlKFwiLi9BbHBoYUZpbHRlci5qc1wiKTtcbmV4cG9ydHMuQWxwaGFGaWx0ZXIgPSBBbHBoYUZpbHRlci5BbHBoYUZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCBCbHVyRmlsdGVyUGFzcyA9IHJlcXVpcmUoXCIuL0JsdXJGaWx0ZXJQYXNzLmpzXCIpO1xuY2xhc3MgQmx1ckZpbHRlciBleHRlbmRzIGNvcmUuRmlsdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBzdHJlbmd0aCAtIFRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1ciBmaWx0ZXIuXG4gICAqIEBwYXJhbSBxdWFsaXR5IC0gVGhlIHF1YWxpdHkgb2YgdGhlIGJsdXIgZmlsdGVyLlxuICAgKiBAcGFyYW0ge251bWJlcnxudWxsfSBbcmVzb2x1dGlvbj1QSVhJLkZpbHRlci5kZWZhdWx0UmVzb2x1dGlvbl0gLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgYmx1ciBmaWx0ZXIuXG4gICAqIEBwYXJhbSBrZXJuZWxTaXplIC0gVGhlIGtlcm5lbFNpemUgb2YgdGhlIGJsdXIgZmlsdGVyLk9wdGlvbnM6IDUsIDcsIDksIDExLCAxMywgMTUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzdHJlbmd0aCA9IDgsIHF1YWxpdHkgPSA0LCByZXNvbHV0aW9uID0gY29yZS5GaWx0ZXIuZGVmYXVsdFJlc29sdXRpb24sIGtlcm5lbFNpemUgPSA1KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5fcmVwZWF0RWRnZVBpeGVscyA9ICExLCB0aGlzLmJsdXJYRmlsdGVyID0gbmV3IEJsdXJGaWx0ZXJQYXNzLkJsdXJGaWx0ZXJQYXNzKCEwLCBzdHJlbmd0aCwgcXVhbGl0eSwgcmVzb2x1dGlvbiwga2VybmVsU2l6ZSksIHRoaXMuYmx1cllGaWx0ZXIgPSBuZXcgQmx1ckZpbHRlclBhc3MuQmx1ckZpbHRlclBhc3MoITEsIHN0cmVuZ3RoLCBxdWFsaXR5LCByZXNvbHV0aW9uLCBrZXJuZWxTaXplKSwgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiwgdGhpcy5xdWFsaXR5ID0gcXVhbGl0eSwgdGhpcy5ibHVyID0gc3RyZW5ndGgsIHRoaXMucmVwZWF0RWRnZVBpeGVscyA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBmaWx0ZXIuXG4gICAqIEBwYXJhbSBmaWx0ZXJNYW5hZ2VyIC0gVGhlIG1hbmFnZXIuXG4gICAqIEBwYXJhbSBpbnB1dCAtIFRoZSBpbnB1dCB0YXJnZXQuXG4gICAqIEBwYXJhbSBvdXRwdXQgLSBUaGUgb3V0cHV0IHRhcmdldC5cbiAgICogQHBhcmFtIGNsZWFyTW9kZSAtIEhvdyB0byBjbGVhclxuICAgKi9cbiAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKSB7XG4gICAgY29uc3QgeFN0cmVuZ3RoID0gTWF0aC5hYnModGhpcy5ibHVyWEZpbHRlci5zdHJlbmd0aCksIHlTdHJlbmd0aCA9IE1hdGguYWJzKHRoaXMuYmx1cllGaWx0ZXIuc3RyZW5ndGgpO1xuICAgIGlmICh4U3RyZW5ndGggJiYgeVN0cmVuZ3RoKSB7XG4gICAgICBjb25zdCByZW5kZXJUYXJnZXQgPSBmaWx0ZXJNYW5hZ2VyLmdldEZpbHRlclRleHR1cmUoKTtcbiAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIHJlbmRlclRhcmdldCwgY29yZS5DTEVBUl9NT0RFUy5DTEVBUiksIHRoaXMuYmx1cllGaWx0ZXIuYXBwbHkoZmlsdGVyTWFuYWdlciwgcmVuZGVyVGFyZ2V0LCBvdXRwdXQsIGNsZWFyTW9kZSksIGZpbHRlck1hbmFnZXIucmV0dXJuRmlsdGVyVGV4dHVyZShyZW5kZXJUYXJnZXQpO1xuICAgIH0gZWxzZVxuICAgICAgeVN0cmVuZ3RoID8gdGhpcy5ibHVyWUZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIDogdGhpcy5ibHVyWEZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICB9XG4gIHVwZGF0ZVBhZGRpbmcoKSB7XG4gICAgdGhpcy5fcmVwZWF0RWRnZVBpeGVscyA/IHRoaXMucGFkZGluZyA9IDAgOiB0aGlzLnBhZGRpbmcgPSBNYXRoLm1heChNYXRoLmFicyh0aGlzLmJsdXJYRmlsdGVyLnN0cmVuZ3RoKSwgTWF0aC5hYnModGhpcy5ibHVyWUZpbHRlci5zdHJlbmd0aCkpICogMjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgYm90aCB0aGUgYmx1clggYW5kIGJsdXJZIHByb3BlcnRpZXMgc2ltdWx0YW5lb3VzbHlcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgZ2V0IGJsdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcbiAgfVxuICBzZXQgYmx1cih2YWx1ZSkge1xuICAgIHRoaXMuYmx1clhGaWx0ZXIuYmx1ciA9IHRoaXMuYmx1cllGaWx0ZXIuYmx1ciA9IHZhbHVlLCB0aGlzLnVwZGF0ZVBhZGRpbmcoKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHBhc3NlcyBmb3IgYmx1ci4gTW9yZSBwYXNzZXMgbWVhbnMgaGlnaGVyIHF1YWxpdHkgYmx1cmluZy5cbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgZ2V0IHF1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIucXVhbGl0eTtcbiAgfVxuICBzZXQgcXVhbGl0eSh2YWx1ZSkge1xuICAgIHRoaXMuYmx1clhGaWx0ZXIucXVhbGl0eSA9IHRoaXMuYmx1cllGaWx0ZXIucXVhbGl0eSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clggcHJvcGVydHlcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgZ2V0IGJsdXJYKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XG4gIH1cbiAgc2V0IGJsdXJYKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyWEZpbHRlci5ibHVyID0gdmFsdWUsIHRoaXMudXBkYXRlUGFkZGluZygpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clkgcHJvcGVydHlcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgZ2V0IGJsdXJZKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJZRmlsdGVyLmJsdXI7XG4gIH1cbiAgc2V0IGJsdXJZKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyWUZpbHRlci5ibHVyID0gdmFsdWUsIHRoaXMudXBkYXRlUGFkZGluZygpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBibGVuZG1vZGUgb2YgdGhlIGZpbHRlclxuICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTFxuICAgKi9cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyWUZpbHRlci5ibGVuZE1vZGU7XG4gIH1cbiAgc2V0IGJsZW5kTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuYmx1cllGaWx0ZXIuYmxlbmRNb2RlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIElmIHNldCB0byB0cnVlIHRoZSBlZGdlIG9mIHRoZSB0YXJnZXQgd2lsbCBiZSBjbGFtcGVkXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBnZXQgcmVwZWF0RWRnZVBpeGVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVwZWF0RWRnZVBpeGVscztcbiAgfVxuICBzZXQgcmVwZWF0RWRnZVBpeGVscyh2YWx1ZSkge1xuICAgIHRoaXMuX3JlcGVhdEVkZ2VQaXhlbHMgPSB2YWx1ZSwgdGhpcy51cGRhdGVQYWRkaW5nKCk7XG4gIH1cbn1cbmV4cG9ydHMuQmx1ckZpbHRlciA9IEJsdXJGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbHVyRmlsdGVyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCBnZW5lcmF0ZUJsdXJGcmFnU291cmNlID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZS5qc1wiKSwgZ2VuZXJhdGVCbHVyVmVydFNvdXJjZSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlQmx1clZlcnRTb3VyY2UuanNcIik7XG5jbGFzcyBCbHVyRmlsdGVyUGFzcyBleHRlbmRzIGNvcmUuRmlsdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBob3Jpem9udGFsIC0gRG8gcGFzcyBhbG9uZyB0aGUgeC1heGlzIChgdHJ1ZWApIG9yIHktYXhpcyAoYGZhbHNlYCkuXG4gICAqIEBwYXJhbSBzdHJlbmd0aCAtIFRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1ciBmaWx0ZXIuXG4gICAqIEBwYXJhbSBxdWFsaXR5IC0gVGhlIHF1YWxpdHkgb2YgdGhlIGJsdXIgZmlsdGVyLlxuICAgKiBAcGFyYW0ge251bWJlcnxudWxsfSBbcmVzb2x1dGlvbj1QSVhJLkZpbHRlci5kZWZhdWx0UmVzb2x1dGlvbl0gLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgYmx1ciBmaWx0ZXIuXG4gICAqIEBwYXJhbSBrZXJuZWxTaXplIC0gVGhlIGtlcm5lbFNpemUgb2YgdGhlIGJsdXIgZmlsdGVyLk9wdGlvbnM6IDUsIDcsIDksIDExLCAxMywgMTUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihob3Jpem9udGFsLCBzdHJlbmd0aCA9IDgsIHF1YWxpdHkgPSA0LCByZXNvbHV0aW9uID0gY29yZS5GaWx0ZXIuZGVmYXVsdFJlc29sdXRpb24sIGtlcm5lbFNpemUgPSA1KSB7XG4gICAgY29uc3QgdmVydFNyYyA9IGdlbmVyYXRlQmx1clZlcnRTb3VyY2UuZ2VuZXJhdGVCbHVyVmVydFNvdXJjZShrZXJuZWxTaXplLCBob3Jpem9udGFsKSwgZnJhZ1NyYyA9IGdlbmVyYXRlQmx1ckZyYWdTb3VyY2UuZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZShrZXJuZWxTaXplKTtcbiAgICBzdXBlcihcbiAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgIHZlcnRTcmMsXG4gICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgIGZyYWdTcmNcbiAgICApLCB0aGlzLmhvcml6b250YWwgPSBob3Jpem9udGFsLCB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uLCB0aGlzLl9xdWFsaXR5ID0gMCwgdGhpcy5xdWFsaXR5ID0gcXVhbGl0eSwgdGhpcy5ibHVyID0gc3RyZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGZpbHRlci5cbiAgICogQHBhcmFtIGZpbHRlck1hbmFnZXIgLSBUaGUgbWFuYWdlci5cbiAgICogQHBhcmFtIGlucHV0IC0gVGhlIGlucHV0IHRhcmdldC5cbiAgICogQHBhcmFtIG91dHB1dCAtIFRoZSBvdXRwdXQgdGFyZ2V0LlxuICAgKiBAcGFyYW0gY2xlYXJNb2RlIC0gSG93IHRvIGNsZWFyXG4gICAqL1xuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICBpZiAob3V0cHV0ID8gdGhpcy5ob3Jpem9udGFsID8gdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCA9IDEgLyBvdXRwdXQud2lkdGggKiAob3V0cHV0LndpZHRoIC8gaW5wdXQud2lkdGgpIDogdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCA9IDEgLyBvdXRwdXQuaGVpZ2h0ICogKG91dHB1dC5oZWlnaHQgLyBpbnB1dC5oZWlnaHQpIDogdGhpcy5ob3Jpem9udGFsID8gdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCA9IDEgLyBmaWx0ZXJNYW5hZ2VyLnJlbmRlcmVyLndpZHRoICogKGZpbHRlck1hbmFnZXIucmVuZGVyZXIud2lkdGggLyBpbnB1dC53aWR0aCkgOiB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoID0gMSAvIGZpbHRlck1hbmFnZXIucmVuZGVyZXIuaGVpZ2h0ICogKGZpbHRlck1hbmFnZXIucmVuZGVyZXIuaGVpZ2h0IC8gaW5wdXQuaGVpZ2h0KSwgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCAqPSB0aGlzLnN0cmVuZ3RoLCB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoIC89IHRoaXMucGFzc2VzLCB0aGlzLnBhc3NlcyA9PT0gMSlcbiAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IGZpbHRlck1hbmFnZXIuZ2V0RmlsdGVyVGV4dHVyZSgpLCByZW5kZXJlciA9IGZpbHRlck1hbmFnZXIucmVuZGVyZXI7XG4gICAgICBsZXQgZmxpcCA9IGlucHV0LCBmbG9wID0gcmVuZGVyVGFyZ2V0O1xuICAgICAgdGhpcy5zdGF0ZS5ibGVuZCA9ICExLCBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGZsaXAsIGZsb3AsIGNvcmUuQ0xFQVJfTU9ERVMuQ0xFQVIpO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnBhc3NlcyAtIDE7IGkrKykge1xuICAgICAgICBmaWx0ZXJNYW5hZ2VyLmJpbmRBbmRDbGVhcihmbGlwLCBjb3JlLkNMRUFSX01PREVTLkJMSVQpLCB0aGlzLnVuaWZvcm1zLnVTYW1wbGVyID0gZmxvcDtcbiAgICAgICAgY29uc3QgdGVtcCA9IGZsb3A7XG4gICAgICAgIGZsb3AgPSBmbGlwLCBmbGlwID0gdGVtcCwgcmVuZGVyZXIuc2hhZGVyLmJpbmQodGhpcyksIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcoNSk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlLmJsZW5kID0gITAsIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgZmxvcCwgb3V0cHV0LCBjbGVhck1vZGUpLCBmaWx0ZXJNYW5hZ2VyLnJldHVybkZpbHRlclRleHR1cmUocmVuZGVyVGFyZ2V0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXIuXG4gICAqIEBkZWZhdWx0IDE2XG4gICAqL1xuICBnZXQgYmx1cigpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlbmd0aDtcbiAgfVxuICBzZXQgYmx1cih2YWx1ZSkge1xuICAgIHRoaXMucGFkZGluZyA9IDEgKyBNYXRoLmFicyh2YWx1ZSkgKiAyLCB0aGlzLnN0cmVuZ3RoID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHF1YWxpdHkgb2YgdGhlIGJsdXIgYnkgbW9kaWZ5aW5nIHRoZSBudW1iZXIgb2YgcGFzc2VzLiBNb3JlIHBhc3NlcyBtZWFucyBoaWdoZXJcbiAgICogcXVhbGl0eSBibHVyaW5nIGJ1dCB0aGUgbG93ZXIgdGhlIHBlcmZvcm1hbmNlLlxuICAgKiBAZGVmYXVsdCA0XG4gICAqL1xuICBnZXQgcXVhbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVhbGl0eTtcbiAgfVxuICBzZXQgcXVhbGl0eSh2YWx1ZSkge1xuICAgIHRoaXMuX3F1YWxpdHkgPSB2YWx1ZSwgdGhpcy5wYXNzZXMgPSB2YWx1ZTtcbiAgfVxufVxuZXhwb3J0cy5CbHVyRmlsdGVyUGFzcyA9IEJsdXJGaWx0ZXJQYXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qmx1ckZpbHRlclBhc3MuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEdBVVNTSUFOX1ZBTFVFUyA9IHtcbiAgNTogWzAuMTUzMzg4LCAwLjIyMTQ2MSwgMC4yNTAzMDFdLFxuICA3OiBbMC4wNzEzMDMsIDAuMTMxNTE0LCAwLjE4OTg3OSwgMC4yMTQ2MDddLFxuICA5OiBbMC4wMjg1MzIsIDAuMDY3MjM0LCAwLjEyNDAwOSwgMC4xNzkwNDQsIDAuMjAyMzZdLFxuICAxMTogWzkzZS00LCAwLjAyODAwMiwgMC4wNjU5ODQsIDAuMTIxNzAzLCAwLjE3NTcxMywgMC4xOTg1OTZdLFxuICAxMzogWzI0MDZlLTYsIDkyNTVlLTYsIDAuMDI3ODY3LCAwLjA2NTY2NiwgMC4xMjExMTcsIDAuMTc0ODY4LCAwLjE5NzY0MV0sXG4gIDE1OiBbNDg5ZS02LCAyNDAzZS02LCA5MjQ2ZS02LCAwLjAyNzg0LCAwLjA2NTYwMiwgMC4xMjA5OTksIDAuMTc0Njk3LCAwLjE5NzQ0OF1cbn0sIGZyYWdUZW1wbGF0ZSA9IFtcbiAgXCJ2YXJ5aW5nIHZlYzIgdkJsdXJUZXhDb29yZHNbJXNpemUlXTtcIixcbiAgXCJ1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcIixcbiAgXCJ2b2lkIG1haW4odm9pZClcIixcbiAgXCJ7XCIsXG4gIFwiICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wKTtcIixcbiAgXCIgICAgJWJsdXIlXCIsXG4gIFwifVwiXG5dLmpvaW4oYFxuYCk7XG5mdW5jdGlvbiBnZW5lcmF0ZUJsdXJGcmFnU291cmNlKGtlcm5lbFNpemUpIHtcbiAgY29uc3Qga2VybmVsID0gR0FVU1NJQU5fVkFMVUVTW2tlcm5lbFNpemVdLCBoYWxmTGVuZ3RoID0ga2VybmVsLmxlbmd0aDtcbiAgbGV0IGZyYWdTb3VyY2UgPSBmcmFnVGVtcGxhdGUsIGJsdXJMb29wID0gXCJcIjtcbiAgY29uc3QgdGVtcGxhdGUgPSBcImdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyVpbmRleCVdKSAqICV2YWx1ZSU7XCI7XG4gIGxldCB2YWx1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxTaXplOyBpKyspIHtcbiAgICBsZXQgYmx1ciA9IHRlbXBsYXRlLnJlcGxhY2UoXCIlaW5kZXglXCIsIGkudG9TdHJpbmcoKSk7XG4gICAgdmFsdWUgPSBpLCBpID49IGhhbGZMZW5ndGggJiYgKHZhbHVlID0ga2VybmVsU2l6ZSAtIGkgLSAxKSwgYmx1ciA9IGJsdXIucmVwbGFjZShcIiV2YWx1ZSVcIiwga2VybmVsW3ZhbHVlXS50b1N0cmluZygpKSwgYmx1ckxvb3AgKz0gYmx1ciwgYmx1ckxvb3AgKz0gYFxuYDtcbiAgfVxuICByZXR1cm4gZnJhZ1NvdXJjZSA9IGZyYWdTb3VyY2UucmVwbGFjZShcIiVibHVyJVwiLCBibHVyTG9vcCksIGZyYWdTb3VyY2UgPSBmcmFnU291cmNlLnJlcGxhY2UoXCIlc2l6ZSVcIiwga2VybmVsU2l6ZS50b1N0cmluZygpKSwgZnJhZ1NvdXJjZTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZSA9IGdlbmVyYXRlQmx1ckZyYWdTb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZUJsdXJGcmFnU291cmNlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB2ZXJ0VGVtcGxhdGUgPSBgXG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuXG4gICAgdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XG5cbiAgICB1bmlmb3JtIGZsb2F0IHN0cmVuZ3RoO1xuXG4gICAgdmFyeWluZyB2ZWMyIHZCbHVyVGV4Q29vcmRzWyVzaXplJV07XG5cbiAgICB1bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xuICAgIHVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcblxuICAgIHZlYzQgZmlsdGVyVmVydGV4UG9zaXRpb24oIHZvaWQgKVxuICAgIHtcbiAgICAgICAgdmVjMiBwb3NpdGlvbiA9IGFWZXJ0ZXhQb3NpdGlvbiAqIG1heChvdXRwdXRGcmFtZS56dywgdmVjMigwLikpICsgb3V0cHV0RnJhbWUueHk7XG5cbiAgICAgICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xuICAgIH1cblxuICAgIHZlYzIgZmlsdGVyVGV4dHVyZUNvb3JkKCB2b2lkIClcbiAgICB7XG4gICAgICAgIHJldHVybiBhVmVydGV4UG9zaXRpb24gKiAob3V0cHV0RnJhbWUuencgKiBpbnB1dFNpemUuencpO1xuICAgIH1cblxuICAgIHZvaWQgbWFpbih2b2lkKVxuICAgIHtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbigpO1xuXG4gICAgICAgIHZlYzIgdGV4dHVyZUNvb3JkID0gZmlsdGVyVGV4dHVyZUNvb3JkKCk7XG4gICAgICAgICVibHVyJVxuICAgIH1gO1xuZnVuY3Rpb24gZ2VuZXJhdGVCbHVyVmVydFNvdXJjZShrZXJuZWxTaXplLCB4KSB7XG4gIGNvbnN0IGhhbGZMZW5ndGggPSBNYXRoLmNlaWwoa2VybmVsU2l6ZSAvIDIpO1xuICBsZXQgdmVydFNvdXJjZSA9IHZlcnRUZW1wbGF0ZSwgYmx1ckxvb3AgPSBcIlwiLCB0ZW1wbGF0ZTtcbiAgeCA/IHRlbXBsYXRlID0gXCJ2Qmx1clRleENvb3Jkc1slaW5kZXglXSA9ICB0ZXh0dXJlQ29vcmQgKyB2ZWMyKCVzYW1wbGVJbmRleCUgKiBzdHJlbmd0aCwgMC4wKTtcIiA6IHRlbXBsYXRlID0gXCJ2Qmx1clRleENvb3Jkc1slaW5kZXglXSA9ICB0ZXh0dXJlQ29vcmQgKyB2ZWMyKDAuMCwgJXNhbXBsZUluZGV4JSAqIHN0cmVuZ3RoKTtcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxTaXplOyBpKyspIHtcbiAgICBsZXQgYmx1ciA9IHRlbXBsYXRlLnJlcGxhY2UoXCIlaW5kZXglXCIsIGkudG9TdHJpbmcoKSk7XG4gICAgYmx1ciA9IGJsdXIucmVwbGFjZShcIiVzYW1wbGVJbmRleCVcIiwgYCR7aSAtIChoYWxmTGVuZ3RoIC0gMSl9LjBgKSwgYmx1ckxvb3AgKz0gYmx1ciwgYmx1ckxvb3AgKz0gYFxuYDtcbiAgfVxuICByZXR1cm4gdmVydFNvdXJjZSA9IHZlcnRTb3VyY2UucmVwbGFjZShcIiVibHVyJVwiLCBibHVyTG9vcCksIHZlcnRTb3VyY2UgPSB2ZXJ0U291cmNlLnJlcGxhY2UoXCIlc2l6ZSVcIiwga2VybmVsU2l6ZS50b1N0cmluZygpKSwgdmVydFNvdXJjZTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVCbHVyVmVydFNvdXJjZSA9IGdlbmVyYXRlQmx1clZlcnRTb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZUJsdXJWZXJ0U291cmNlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQmx1ckZpbHRlciA9IHJlcXVpcmUoXCIuL0JsdXJGaWx0ZXIuanNcIiksIEJsdXJGaWx0ZXJQYXNzID0gcmVxdWlyZShcIi4vQmx1ckZpbHRlclBhc3MuanNcIik7XG5leHBvcnRzLkJsdXJGaWx0ZXIgPSBCbHVyRmlsdGVyLkJsdXJGaWx0ZXI7XG5leHBvcnRzLkJsdXJGaWx0ZXJQYXNzID0gQmx1ckZpbHRlclBhc3MuQmx1ckZpbHRlclBhc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgY29sb3JNYXRyaXggPSByZXF1aXJlKFwiLi9jb2xvck1hdHJpeC5mcmFnLmpzXCIpO1xuY2xhc3MgQ29sb3JNYXRyaXhGaWx0ZXIgZXh0ZW5kcyBjb3JlLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IHVuaWZvcm1zID0ge1xuICAgICAgbTogbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDBcbiAgICAgIF0pLFxuICAgICAgdUFscGhhOiAxXG4gICAgfTtcbiAgICBzdXBlcihjb3JlLmRlZmF1bHRGaWx0ZXJWZXJ0ZXgsIGNvbG9yTWF0cml4LmRlZmF1bHQsIHVuaWZvcm1zKSwgdGhpcy5hbHBoYSA9IDE7XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgY3VycmVudCBtYXRyaXggYW5kIHNldCB0aGUgbmV3IG9uZVxuICAgKiBAcGFyYW0ge251bWJlcltdfSBtYXRyaXggLSA1eDQgbWF0cml4XG4gICAqIEBwYXJhbSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSA9ICExKSB7XG4gICAgbGV0IG5ld01hdHJpeCA9IG1hdHJpeDtcbiAgICBtdWx0aXBseSAmJiAodGhpcy5fbXVsdGlwbHkobmV3TWF0cml4LCB0aGlzLnVuaWZvcm1zLm0sIG1hdHJpeCksIG5ld01hdHJpeCA9IHRoaXMuX2NvbG9yTWF0cml4KG5ld01hdHJpeCkpLCB0aGlzLnVuaWZvcm1zLm0gPSBuZXdNYXRyaXg7XG4gIH1cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdHdvIG1hdDUnc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gb3V0IC0gNXg0IG1hdHJpeCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICAgKiBAcGFyYW0gYSAtIDV4NCBtYXRyaXggdGhlIGZpcnN0IG9wZXJhbmRcbiAgICogQHBhcmFtIGIgLSA1eDQgbWF0cml4IHRoZSBzZWNvbmQgb3BlcmFuZFxuICAgKiBAcmV0dXJucyB7bnVtYmVyW119IDV4NCBtYXRyaXhcbiAgICovXG4gIF9tdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICByZXR1cm4gb3V0WzBdID0gYVswXSAqIGJbMF0gKyBhWzFdICogYls1XSArIGFbMl0gKiBiWzEwXSArIGFbM10gKiBiWzE1XSwgb3V0WzFdID0gYVswXSAqIGJbMV0gKyBhWzFdICogYls2XSArIGFbMl0gKiBiWzExXSArIGFbM10gKiBiWzE2XSwgb3V0WzJdID0gYVswXSAqIGJbMl0gKyBhWzFdICogYls3XSArIGFbMl0gKiBiWzEyXSArIGFbM10gKiBiWzE3XSwgb3V0WzNdID0gYVswXSAqIGJbM10gKyBhWzFdICogYls4XSArIGFbMl0gKiBiWzEzXSArIGFbM10gKiBiWzE4XSwgb3V0WzRdID0gYVswXSAqIGJbNF0gKyBhWzFdICogYls5XSArIGFbMl0gKiBiWzE0XSArIGFbM10gKiBiWzE5XSArIGFbNF0sIG91dFs1XSA9IGFbNV0gKiBiWzBdICsgYVs2XSAqIGJbNV0gKyBhWzddICogYlsxMF0gKyBhWzhdICogYlsxNV0sIG91dFs2XSA9IGFbNV0gKiBiWzFdICsgYVs2XSAqIGJbNl0gKyBhWzddICogYlsxMV0gKyBhWzhdICogYlsxNl0sIG91dFs3XSA9IGFbNV0gKiBiWzJdICsgYVs2XSAqIGJbN10gKyBhWzddICogYlsxMl0gKyBhWzhdICogYlsxN10sIG91dFs4XSA9IGFbNV0gKiBiWzNdICsgYVs2XSAqIGJbOF0gKyBhWzddICogYlsxM10gKyBhWzhdICogYlsxOF0sIG91dFs5XSA9IGFbNV0gKiBiWzRdICsgYVs2XSAqIGJbOV0gKyBhWzddICogYlsxNF0gKyBhWzhdICogYlsxOV0gKyBhWzldLCBvdXRbMTBdID0gYVsxMF0gKiBiWzBdICsgYVsxMV0gKiBiWzVdICsgYVsxMl0gKiBiWzEwXSArIGFbMTNdICogYlsxNV0sIG91dFsxMV0gPSBhWzEwXSAqIGJbMV0gKyBhWzExXSAqIGJbNl0gKyBhWzEyXSAqIGJbMTFdICsgYVsxM10gKiBiWzE2XSwgb3V0WzEyXSA9IGFbMTBdICogYlsyXSArIGFbMTFdICogYls3XSArIGFbMTJdICogYlsxMl0gKyBhWzEzXSAqIGJbMTddLCBvdXRbMTNdID0gYVsxMF0gKiBiWzNdICsgYVsxMV0gKiBiWzhdICsgYVsxMl0gKiBiWzEzXSArIGFbMTNdICogYlsxOF0sIG91dFsxNF0gPSBhWzEwXSAqIGJbNF0gKyBhWzExXSAqIGJbOV0gKyBhWzEyXSAqIGJbMTRdICsgYVsxM10gKiBiWzE5XSArIGFbMTRdLCBvdXRbMTVdID0gYVsxNV0gKiBiWzBdICsgYVsxNl0gKiBiWzVdICsgYVsxN10gKiBiWzEwXSArIGFbMThdICogYlsxNV0sIG91dFsxNl0gPSBhWzE1XSAqIGJbMV0gKyBhWzE2XSAqIGJbNl0gKyBhWzE3XSAqIGJbMTFdICsgYVsxOF0gKiBiWzE2XSwgb3V0WzE3XSA9IGFbMTVdICogYlsyXSArIGFbMTZdICogYls3XSArIGFbMTddICogYlsxMl0gKyBhWzE4XSAqIGJbMTddLCBvdXRbMThdID0gYVsxNV0gKiBiWzNdICsgYVsxNl0gKiBiWzhdICsgYVsxN10gKiBiWzEzXSArIGFbMThdICogYlsxOF0sIG91dFsxOV0gPSBhWzE1XSAqIGJbNF0gKyBhWzE2XSAqIGJbOV0gKyBhWzE3XSAqIGJbMTRdICsgYVsxOF0gKiBiWzE5XSArIGFbMTldLCBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIEZsb2F0MzIgQXJyYXkgYW5kIG5vcm1hbGl6ZSB0aGUgb2Zmc2V0IGNvbXBvbmVudCB0byAwLTFcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gbWF0cml4IC0gNXg0IG1hdHJpeFxuICAgKiBAcmV0dXJucyB7bnVtYmVyW119IDV4NCBtYXRyaXggd2l0aCBhbGwgdmFsdWVzIGJldHdlZW4gMC0xXG4gICAqL1xuICBfY29sb3JNYXRyaXgobWF0cml4KSB7XG4gICAgY29uc3QgbSA9IG5ldyBGbG9hdDMyQXJyYXkobWF0cml4KTtcbiAgICByZXR1cm4gbVs0XSAvPSAyNTUsIG1bOV0gLz0gMjU1LCBtWzE0XSAvPSAyNTUsIG1bMTldIC89IDI1NSwgbTtcbiAgfVxuICAvKipcbiAgICogQWRqdXN0cyBicmlnaHRuZXNzXG4gICAqIEBwYXJhbSBiIC0gdmFsdWUgb2YgdGhlIGJyaWd0aG5lc3MgKDAtMSwgd2hlcmUgMCBpcyBibGFjaylcbiAgICogQHBhcmFtIG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAqL1xuICBicmlnaHRuZXNzKGIsIG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgYixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgYixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgYixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgZWFjaCBjaGFubmVsIG9uIHRoZSBkaWFnb25hbCBvZiB0aGUgY29sb3IgbWF0cml4LlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGFjaGlldmUgYSB0aW50aW5nIGVmZmVjdCBvbiBDb250YWluZXJzIHNpbWlsYXIgdG8gdGhlIHRpbnQgZmllbGQgb2Ygc29tZVxuICAgKiBkaXNwbGF5IG9iamVjdHMgbGlrZSBTcHJpdGUsIFRleHQsIEdyYXBoaWNzLCBhbmQgTWVzaC5cbiAgICogQHBhcmFtIGNvbG9yIC0gQ29sb3Igb2YgdGhlIHRpbnQuIFRoaXMgaXMgYSBoZXggdmFsdWUuXG4gICAqIEBwYXJhbSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgdGludChjb2xvciwgbXVsdGlwbHkpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSBjb3JlLkNvbG9yLnNoYXJlZC5zZXRWYWx1ZShjb2xvcikudG9BcnJheSgpLCBtYXRyaXggPSBbXG4gICAgICByLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBnLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBiLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBtYXRyaWNlcyBpbiBncmV5IHNjYWxlc1xuICAgKiBAcGFyYW0gc2NhbGUgLSB2YWx1ZSBvZiB0aGUgZ3JleSAoMC0xLCB3aGVyZSAwIGlzIGJsYWNrKVxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIGdyZXlzY2FsZShzY2FsZSwgbXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICBzY2FsZSxcbiAgICAgIHNjYWxlLFxuICAgICAgc2NhbGUsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIHNjYWxlLFxuICAgICAgc2NhbGUsXG4gICAgICBzY2FsZSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgc2NhbGUsXG4gICAgICBzY2FsZSxcbiAgICAgIHNjYWxlLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBibGFjayBhbmQgd2hpdGUgbWF0cmljZS5cbiAgICogQHBhcmFtIG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAqL1xuICBibGFja0FuZFdoaXRlKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMC4zLFxuICAgICAgMC42LFxuICAgICAgMC4xLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLjMsXG4gICAgICAwLjYsXG4gICAgICAwLjEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAuMyxcbiAgICAgIDAuNixcbiAgICAgIDAuMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgaHVlIHByb3BlcnR5IG9mIHRoZSBjb2xvclxuICAgKiBAcGFyYW0gcm90YXRpb24gLSBpbiBkZWdyZWVzXG4gICAqIEBwYXJhbSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgaHVlKHJvdGF0aW9uLCBtdWx0aXBseSkge1xuICAgIHJvdGF0aW9uID0gKHJvdGF0aW9uIHx8IDApIC8gMTgwICogTWF0aC5QSTtcbiAgICBjb25zdCBjb3NSID0gTWF0aC5jb3Mocm90YXRpb24pLCBzaW5SID0gTWF0aC5zaW4ocm90YXRpb24pLCBzcXJ0ID0gTWF0aC5zcXJ0LCB3ID0gMSAvIDMsIHNxclcgPSBzcXJ0KHcpLCBhMDAgPSBjb3NSICsgKDEgLSBjb3NSKSAqIHcsIGEwMSA9IHcgKiAoMSAtIGNvc1IpIC0gc3FyVyAqIHNpblIsIGEwMiA9IHcgKiAoMSAtIGNvc1IpICsgc3FyVyAqIHNpblIsIGExMCA9IHcgKiAoMSAtIGNvc1IpICsgc3FyVyAqIHNpblIsIGExMSA9IGNvc1IgKyB3ICogKDEgLSBjb3NSKSwgYTEyID0gdyAqICgxIC0gY29zUikgLSBzcXJXICogc2luUiwgYTIwID0gdyAqICgxIC0gY29zUikgLSBzcXJXICogc2luUiwgYTIxID0gdyAqICgxIC0gY29zUikgKyBzcXJXICogc2luUiwgYTIyID0gY29zUiArIHcgKiAoMSAtIGNvc1IpLCBtYXRyaXggPSBbXG4gICAgICBhMDAsXG4gICAgICBhMDEsXG4gICAgICBhMDIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIGExMCxcbiAgICAgIGExMSxcbiAgICAgIGExMixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgYTIwLFxuICAgICAgYTIxLFxuICAgICAgYTIyLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBjb250cmFzdCBtYXRyaXgsIGluY3JlYXNlIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gZGFyayBhbmQgYnJpZ2h0XG4gICAqIEluY3JlYXNlIGNvbnRyYXN0IDogc2hhZG93cyBkYXJrZXIgYW5kIGhpZ2hsaWdodHMgYnJpZ2h0ZXJcbiAgICogRGVjcmVhc2UgY29udHJhc3QgOiBicmluZyB0aGUgc2hhZG93cyB1cCBhbmQgdGhlIGhpZ2hsaWdodHMgZG93blxuICAgKiBAcGFyYW0gYW1vdW50IC0gdmFsdWUgb2YgdGhlIGNvbnRyYXN0ICgwLTEpXG4gICAqIEBwYXJhbSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgY29udHJhc3QoYW1vdW50LCBtdWx0aXBseSkge1xuICAgIGNvbnN0IHYgPSAoYW1vdW50IHx8IDApICsgMSwgbyA9IC0wLjUgKiAodiAtIDEpLCBtYXRyaXggPSBbXG4gICAgICB2LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgbyxcbiAgICAgIDAsXG4gICAgICB2LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBvLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB2LFxuICAgICAgMCxcbiAgICAgIG8sXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBzYXR1cmF0aW9uIG1hdHJpeCwgaW5jcmVhc2UgdGhlIHNlcGFyYXRpb24gYmV0d2VlbiBjb2xvcnNcbiAgICogSW5jcmVhc2Ugc2F0dXJhdGlvbiA6IGluY3JlYXNlIGNvbnRyYXN0LCBicmlnaHRuZXNzLCBhbmQgc2hhcnBuZXNzXG4gICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgc2F0dXJhdGlvbiBhbW91bnQgKDAtMSlcbiAgICogQHBhcmFtIG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAqL1xuICBzYXR1cmF0ZShhbW91bnQgPSAwLCBtdWx0aXBseSkge1xuICAgIGNvbnN0IHggPSBhbW91bnQgKiAyIC8gMyArIDEsIHkgPSAoeCAtIDEpICogLTAuNSwgbWF0cml4ID0gW1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB5LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB5LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIHksXG4gICAgICB5LFxuICAgICAgeCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqIERlc2F0dXJhdGUgaW1hZ2UgKHJlbW92ZSBjb2xvcikgQ2FsbCB0aGUgc2F0dXJhdGUgZnVuY3Rpb24gKi9cbiAgZGVzYXR1cmF0ZSgpIHtcbiAgICB0aGlzLnNhdHVyYXRlKC0xKTtcbiAgfVxuICAvKipcbiAgICogTmVnYXRpdmUgaW1hZ2UgKGludmVyc2Ugb2YgY2xhc3NpYyByZ2IgbWF0cml4KVxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIG5lZ2F0aXZlKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgLTEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC0xLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAtMSxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcGlhIGltYWdlXG4gICAqIEBwYXJhbSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgc2VwaWEobXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAwLjM5MyxcbiAgICAgIDAuNzY4OTk5OSxcbiAgICAgIDAuMTg4OTk5OTksXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAuMzQ5LFxuICAgICAgMC42ODU5OTk5LFxuICAgICAgMC4xNjc5OTk5OSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMC4yNzIsXG4gICAgICAwLjUzMzk5OTksXG4gICAgICAwLjEzMDk5OTk5LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogQ29sb3IgbW90aW9uIHBpY3R1cmUgcHJvY2VzcyBpbnZlbnRlZCBpbiAxOTE2ICh0aGFua3MgRG9taW5pYyBTemFibGV3c2tpKVxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIHRlY2huaWNvbG9yKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMS45MTI1Mjc3ODkxNDU2MDgzLFxuICAgICAgLTAuODU0NTM0NDk3Njk1MTY0NSxcbiAgICAgIC0wLjA5MTU1NTA4NDgyNzU1NTg1LFxuICAgICAgMCxcbiAgICAgIDExLjc5MzYwMzQzNDM3NzMzNyxcbiAgICAgIC0wLjMwODc4MzMzODU5MjgwOTcsXG4gICAgICAxLjc2NTg5MDg1NTU0NTg0MjgsXG4gICAgICAtMC4xMDYwMTc0MzA3NDcyMjI0NSxcbiAgICAgIDAsXG4gICAgICAtNzAuMzUyMDUxNjE0NjEzOTgsXG4gICAgICAtMC4yMzExMDMzNzc1NDg2MTYsXG4gICAgICAtMC43NTAxODk5MTk3NDQwMjEyLFxuICAgICAgMS44NDc1OTc4MTYxMDgxODksXG4gICAgICAwLFxuICAgICAgMzAuOTUwOTQwODY5NDkxMTM4LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIFBvbGFyb2lkIGZpbHRlclxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIHBvbGFyb2lkKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMS40MzgsXG4gICAgICAtMC4wNjIsXG4gICAgICAtMC4wNjIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC0wLjEyMixcbiAgICAgIDEuMzc4LFxuICAgICAgLTAuMTIyLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAtMC4wMTYsXG4gICAgICAtMC4wMTYsXG4gICAgICAxLjQ4MyxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbHRlciB3aG8gdHJhbnNmb3JtcyA6IFJlZCAtPiBCbHVlIGFuZCBCbHVlIC0+IFJlZFxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIHRvQkdSKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbG9yIHJldmVyc2FsIGZpbG0gaW50cm9kdWNlZCBieSBFYXN0bWFuIEtvZGFrIGluIDE5MzUuICh0aGFua3MgRG9taW5pYyBTemFibGV3c2tpKVxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIGtvZGFjaHJvbWUobXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAxLjEyODU1ODIzOTY1OTM1MjUsXG4gICAgICAtMC4zOTY3MzgyMjgzNjAxMzQ4LFxuICAgICAgLTAuMDM5OTI1NTkxNzI5MjE3OTMsXG4gICAgICAwLFxuICAgICAgNjMuNzI5NTg3NjIxOTY1MDIsXG4gICAgICAtMC4xNjQwNDMzOTk2MjI0NDYxNixcbiAgICAgIDEuMDgzNTI1MTU2NjI5MTMwNCxcbiAgICAgIC0wLjA1NDk4ODA1MTE1NjMzMTMyLFxuICAgICAgMCxcbiAgICAgIDI0LjczMjQwNzg5NjcwNjIwMyxcbiAgICAgIC0wLjE2Nzg2MDEwNzA2MTU1NzYzLFxuICAgICAgLTAuNTYwMzQxNjI3NzY5NTI0OCxcbiAgICAgIDEuNjAxNDg1MDc2MTk2NDk0MyxcbiAgICAgIDAsXG4gICAgICAzNS42Mjk4MjgwNzQ2MDk0NixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIC8qKlxuICAgKiBCcm93biBkZWxpY2lvdXMgYnJvd25pIGZpbHRlciAodGhhbmtzIERvbWluaWMgU3phYmxld3NraSlcbiAgICogQHBhcmFtIG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAqL1xuICBicm93bmkobXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAwLjU5OTcwMjM0OTgxNTk3MTUsXG4gICAgICAwLjM0NTUzMjQzMDQ4MzkxMjYzLFxuICAgICAgLTAuMjcwODI5ODY3NDUzODA0MixcbiAgICAgIDAsXG4gICAgICA0Ny40MzE5Mjg1NTYwMDg3MyxcbiAgICAgIC0wLjAzNzcwMzI0OTgzNzc4MzE1NyxcbiAgICAgIDAuODYwOTU3NzU4Nzk5MjY0MSxcbiAgICAgIDAuMTUwNTk1NTIzODg0NTk5MTMsXG4gICAgICAwLFxuICAgICAgLTM2Ljk2ODQxNDk4MzE5MTI3LFxuICAgICAgMC4yNDExMzYzNTEyODE1MzMzNSxcbiAgICAgIC0wLjA3NDQxMDM3OTA4NDIyNDkyLFxuICAgICAgMC40NDk3MjE4MjA2NDg3NzE1MyxcbiAgICAgIDAsXG4gICAgICAtNy41NjIwNzUyNzc1OTEyODMsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogVmludGFnZSBmaWx0ZXIgKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXG4gICAqIEBwYXJhbSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgdmludGFnZShtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDAuNjI3OTM0NTYzNTYwNTk5NCxcbiAgICAgIDAuMzIwMjE4MzQyMDgxOTM2NyxcbiAgICAgIC0wLjAzOTY1NDA4MjExMzEyNDUzLFxuICAgICAgMCxcbiAgICAgIDkuNjUxMjg1ODM1Mjk0MTIzLFxuICAgICAgMC4wMjU3ODM5NzcwNDgwODg2OCxcbiAgICAgIDAuNjQ0MTE4ODY0NDM3NDc3MSxcbiAgICAgIDAuMDMyNTkxMjc2MTYxNDkyOTQsXG4gICAgICAwLFxuICAgICAgNy40NjI4MjkxNzY0NzA1OTEsXG4gICAgICAwLjA0NjYwNTU1NTY3ODI3MTksXG4gICAgICAtMC4wODUxMjMyOTg3MjQ3ODkxLFxuICAgICAgMC41MjQxNjQ4MDE4NzAwNDY1LFxuICAgICAgMCxcbiAgICAgIDUuMTU5MTkwNTg4MjM1Mjk2LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgLyoqXG4gICAqIFdlIGRvbid0IGtub3cgZXhhY3RseSB3aGF0IGl0IGRvZXMsIGtpbmQgb2YgZ3JhZGllbnQgbWFwLCBidXQgZnVubnkgdG8gcGxheSB3aXRoIVxuICAgKiBAcGFyYW0gZGVzYXR1cmF0aW9uIC0gVG9uZSB2YWx1ZXMuXG4gICAqIEBwYXJhbSB0b25lZCAtIFRvbmUgdmFsdWVzLlxuICAgKiBAcGFyYW0gbGlnaHRDb2xvciAtIFRvbmUgdmFsdWVzLCBleGFtcGxlOiBgMHhGRkU1ODBgXG4gICAqIEBwYXJhbSBkYXJrQ29sb3IgLSBUb25lIHZhbHVlcywgZXhhbXBsZTogYDB4RkZFNTgwYFxuICAgKiBAcGFyYW0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICovXG4gIGNvbG9yVG9uZShkZXNhdHVyYXRpb24sIHRvbmVkLCBsaWdodENvbG9yLCBkYXJrQ29sb3IsIG11bHRpcGx5KSB7XG4gICAgZGVzYXR1cmF0aW9uID0gZGVzYXR1cmF0aW9uIHx8IDAuMiwgdG9uZWQgPSB0b25lZCB8fCAwLjE1LCBsaWdodENvbG9yID0gbGlnaHRDb2xvciB8fCAxNjc3MDQzMiwgZGFya0NvbG9yID0gZGFya0NvbG9yIHx8IDMzNzUxMDQ7XG4gICAgY29uc3QgdGVtcCA9IGNvcmUuQ29sb3Iuc2hhcmVkLCBbbFIsIGxHLCBsQl0gPSB0ZW1wLnNldFZhbHVlKGxpZ2h0Q29sb3IpLnRvQXJyYXkoKSwgW2RSLCBkRywgZEJdID0gdGVtcC5zZXRWYWx1ZShkYXJrQ29sb3IpLnRvQXJyYXkoKSwgbWF0cml4ID0gW1xuICAgICAgMC4zLFxuICAgICAgMC41OSxcbiAgICAgIDAuMTEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIGxSLFxuICAgICAgbEcsXG4gICAgICBsQixcbiAgICAgIGRlc2F0dXJhdGlvbixcbiAgICAgIDAsXG4gICAgICBkUixcbiAgICAgIGRHLFxuICAgICAgZEIsXG4gICAgICB0b25lZCxcbiAgICAgIDAsXG4gICAgICBsUiAtIGRSLFxuICAgICAgbEcgLSBkRyxcbiAgICAgIGxCIC0gZEIsXG4gICAgICAwLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogTmlnaHQgZWZmZWN0XG4gICAqIEBwYXJhbSBpbnRlbnNpdHkgLSBUaGUgaW50ZW5zaXR5IG9mIHRoZSBuaWdodCBlZmZlY3QuXG4gICAqIEBwYXJhbSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgbmlnaHQoaW50ZW5zaXR5LCBtdWx0aXBseSkge1xuICAgIGludGVuc2l0eSA9IGludGVuc2l0eSB8fCAwLjE7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgaW50ZW5zaXR5ICogLTIsXG4gICAgICAtaW50ZW5zaXR5LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLWludGVuc2l0eSxcbiAgICAgIDAsXG4gICAgICBpbnRlbnNpdHksXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBpbnRlbnNpdHksXG4gICAgICBpbnRlbnNpdHkgKiAyLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogUHJlZGF0b3IgZWZmZWN0XG4gICAqXG4gICAqIEVyYXNlIHRoZSBjdXJyZW50IG1hdHJpeCBieSBzZXR0aW5nIGEgbmV3IGluZGVwZW50IG9uZVxuICAgKiBAcGFyYW0gYW1vdW50IC0gaG93IG11Y2ggdGhlIHByZWRhdG9yIGZlZWxzIGhpcyBmdXR1cmUgdmljdGltXG4gICAqIEBwYXJhbSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgcHJlZGF0b3IoYW1vdW50LCBtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIC8vIHJvdyAxXG4gICAgICAxMS4yMjQxMzA2MzA0OTMxNjQgKiBhbW91bnQsXG4gICAgICAtNC43OTQ0ODY5OTk1MTE3MTkgKiBhbW91bnQsXG4gICAgICAtMi44NzQ2MTE4NTQ1NTMyMjI3ICogYW1vdW50LFxuICAgICAgMCAqIGFtb3VudCxcbiAgICAgIDAuNDAzNDI0MzgyMjA5Nzc3ODMgKiBhbW91bnQsXG4gICAgICAvLyByb3cgMlxuICAgICAgLTMuNjMzMDY5NzUzNjQ2ODUwNiAqIGFtb3VudCxcbiAgICAgIDkuMTkzMTU3MTk2MDQ0OTIyICogYW1vdW50LFxuICAgICAgLTIuOTUxODEwODM2NzkxOTkyICogYW1vdW50LFxuICAgICAgMCAqIGFtb3VudCxcbiAgICAgIC0xLjMxNjEzNTA0ODg2NjI3MiAqIGFtb3VudCxcbiAgICAgIC8vIHJvdyAzXG4gICAgICAtMy4yMTg0MTk3OTAyNjc5NDQzICogYW1vdW50LFxuICAgICAgLTQuMjM3NTAzMDUxNzU3ODEyNSAqIGFtb3VudCxcbiAgICAgIDcuNDc2NDQ4MDU5MDgyMDMxICogYW1vdW50LFxuICAgICAgMCAqIGFtb3VudCxcbiAgICAgIDAuODA0NDQ1OTIyMzc0NzI1MyAqIGFtb3VudCxcbiAgICAgIC8vIHJvdyA0XG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICAvKipcbiAgICogTFNEIGVmZmVjdFxuICAgKlxuICAgKiBNdWx0aXBseSB0aGUgY3VycmVudCBtYXRyaXhcbiAgICogQHBhcmFtIG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAqL1xuICBsc2QobXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAyLFxuICAgICAgLTAuNCxcbiAgICAgIDAuNSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLTAuNSxcbiAgICAgIDIsXG4gICAgICAtMC40LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAtMC40LFxuICAgICAgLTAuNSxcbiAgICAgIDMsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIC8qKiBFcmFzZSB0aGUgY3VycmVudCBtYXRyaXggYnkgc2V0dGluZyB0aGUgZGVmYXVsdCBvbmUuICovXG4gIHJlc2V0KCkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgITEpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWF0cml4IG9mIHRoZSBjb2xvciBtYXRyaXggZmlsdGVyXG4gICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgKiBAZGVmYXVsdCBbMSwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMSwgMF1cbiAgICovXG4gIGdldCBtYXRyaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubTtcbiAgfVxuICBzZXQgbWF0cml4KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5tID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvcGFjaXR5IHZhbHVlIHRvIHVzZSB3aGVuIG1peGluZyB0aGUgb3JpZ2luYWwgYW5kIHJlc3VsdGFudCBjb2xvcnMuXG4gICAqXG4gICAqIFdoZW4gdGhlIHZhbHVlIGlzIDAsIHRoZSBvcmlnaW5hbCBjb2xvciBpcyB1c2VkIHdpdGhvdXQgbW9kaWZpY2F0aW9uLlxuICAgKiBXaGVuIHRoZSB2YWx1ZSBpcyAxLCB0aGUgcmVzdWx0IGNvbG9yIGlzIHVzZWQuXG4gICAqIFdoZW4gaW4gdGhlIHJhbmdlICgwLCAxKSB0aGUgY29sb3IgaXMgaW50ZXJwb2xhdGVkIGJldHdlZW4gdGhlIG9yaWdpbmFsIGFuZCByZXN1bHQgYnkgdGhpcyBhbW91bnQuXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGdldCBhbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51QWxwaGE7XG4gIH1cbiAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51QWxwaGEgPSB2YWx1ZTtcbiAgfVxufVxuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmdyYXlzY2FsZSA9IENvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5ncmV5c2NhbGU7XG5leHBvcnRzLkNvbG9yTWF0cml4RmlsdGVyID0gQ29sb3JNYXRyaXhGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvck1hdHJpeEZpbHRlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnZhciBmcmFnbWVudCA9IGB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xudW5pZm9ybSBmbG9hdCBtWzIwXTtcbnVuaWZvcm0gZmxvYXQgdUFscGhhO1xuXG52b2lkIG1haW4odm9pZClcbntcbiAgICB2ZWM0IGMgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuXG4gICAgaWYgKHVBbHBoYSA9PSAwLjApIHtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gYztcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFVuLXByZW11bHRpcGx5IGFscGhhIGJlZm9yZSBhcHBseWluZyB0aGUgY29sb3IgbWF0cml4LiBTZWUgaXNzdWUgIzM1MzkuXG4gICAgaWYgKGMuYSA+IDAuMCkge1xuICAgICAgYy5yZ2IgLz0gYy5hO1xuICAgIH1cblxuICAgIHZlYzQgcmVzdWx0O1xuXG4gICAgcmVzdWx0LnIgPSAobVswXSAqIGMucik7XG4gICAgICAgIHJlc3VsdC5yICs9IChtWzFdICogYy5nKTtcbiAgICAgICAgcmVzdWx0LnIgKz0gKG1bMl0gKiBjLmIpO1xuICAgICAgICByZXN1bHQuciArPSAobVszXSAqIGMuYSk7XG4gICAgICAgIHJlc3VsdC5yICs9IG1bNF07XG5cbiAgICByZXN1bHQuZyA9IChtWzVdICogYy5yKTtcbiAgICAgICAgcmVzdWx0LmcgKz0gKG1bNl0gKiBjLmcpO1xuICAgICAgICByZXN1bHQuZyArPSAobVs3XSAqIGMuYik7XG4gICAgICAgIHJlc3VsdC5nICs9IChtWzhdICogYy5hKTtcbiAgICAgICAgcmVzdWx0LmcgKz0gbVs5XTtcblxuICAgIHJlc3VsdC5iID0gKG1bMTBdICogYy5yKTtcbiAgICAgICByZXN1bHQuYiArPSAobVsxMV0gKiBjLmcpO1xuICAgICAgIHJlc3VsdC5iICs9IChtWzEyXSAqIGMuYik7XG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTNdICogYy5hKTtcbiAgICAgICByZXN1bHQuYiArPSBtWzE0XTtcblxuICAgIHJlc3VsdC5hID0gKG1bMTVdICogYy5yKTtcbiAgICAgICByZXN1bHQuYSArPSAobVsxNl0gKiBjLmcpO1xuICAgICAgIHJlc3VsdC5hICs9IChtWzE3XSAqIGMuYik7XG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMThdICogYy5hKTtcbiAgICAgICByZXN1bHQuYSArPSBtWzE5XTtcblxuICAgIHZlYzMgcmdiID0gbWl4KGMucmdiLCByZXN1bHQucmdiLCB1QWxwaGEpO1xuXG4gICAgLy8gUHJlbXVsdGlwbHkgYWxwaGEgYWdhaW4uXG4gICAgcmdiICo9IHJlc3VsdC5hO1xuXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChyZ2IsIHJlc3VsdC5hKTtcbn1cbmA7XG5leHBvcnRzLmRlZmF1bHQgPSBmcmFnbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9yTWF0cml4LmZyYWcuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBDb2xvck1hdHJpeEZpbHRlciA9IHJlcXVpcmUoXCIuL0NvbG9yTWF0cml4RmlsdGVyLmpzXCIpO1xuZXhwb3J0cy5Db2xvck1hdHJpeEZpbHRlciA9IENvbG9yTWF0cml4RmlsdGVyLkNvbG9yTWF0cml4RmlsdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIGRpc3BsYWNlbWVudCQxID0gcmVxdWlyZShcIi4vZGlzcGxhY2VtZW50LmZyYWcuanNcIiksIGRpc3BsYWNlbWVudCA9IHJlcXVpcmUoXCIuL2Rpc3BsYWNlbWVudC52ZXJ0LmpzXCIpO1xuY2xhc3MgRGlzcGxhY2VtZW50RmlsdGVyIGV4dGVuZHMgY29yZS5GaWx0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtQSVhJLlNwcml0ZX0gc3ByaXRlIC0gVGhlIHNwcml0ZSB1c2VkIGZvciB0aGUgZGlzcGxhY2VtZW50IG1hcC4gKG1ha2Ugc3VyZSBpdHMgYWRkZWQgdG8gdGhlIHNjZW5lISlcbiAgICogQHBhcmFtIHNjYWxlIC0gVGhlIHNjYWxlIG9mIHRoZSBkaXNwbGFjZW1lbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNwcml0ZSwgc2NhbGUpIHtcbiAgICBjb25zdCBtYXNrTWF0cml4ID0gbmV3IGNvcmUuTWF0cml4KCk7XG4gICAgc3ByaXRlLnJlbmRlcmFibGUgPSAhMSwgc3VwZXIoZGlzcGxhY2VtZW50LmRlZmF1bHQsIGRpc3BsYWNlbWVudCQxLmRlZmF1bHQsIHtcbiAgICAgIG1hcFNhbXBsZXI6IHNwcml0ZS5fdGV4dHVyZSxcbiAgICAgIGZpbHRlck1hdHJpeDogbWFza01hdHJpeCxcbiAgICAgIHNjYWxlOiB7IHg6IDEsIHk6IDEgfSxcbiAgICAgIHJvdGF0aW9uOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAxXSlcbiAgICB9KSwgdGhpcy5tYXNrU3ByaXRlID0gc3ByaXRlLCB0aGlzLm1hc2tNYXRyaXggPSBtYXNrTWF0cml4LCBzY2FsZSA9PSBudWxsICYmIChzY2FsZSA9IDIwKSwgdGhpcy5zY2FsZSA9IG5ldyBjb3JlLlBvaW50KHNjYWxlLCBzY2FsZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGZpbHRlci5cbiAgICogQHBhcmFtIGZpbHRlck1hbmFnZXIgLSBUaGUgbWFuYWdlci5cbiAgICogQHBhcmFtIGlucHV0IC0gVGhlIGlucHV0IHRhcmdldC5cbiAgICogQHBhcmFtIG91dHB1dCAtIFRoZSBvdXRwdXQgdGFyZ2V0LlxuICAgKiBAcGFyYW0gY2xlYXJNb2RlIC0gY2xlYXJNb2RlLlxuICAgKi9cbiAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5maWx0ZXJNYXRyaXggPSBmaWx0ZXJNYW5hZ2VyLmNhbGN1bGF0ZVNwcml0ZU1hdHJpeCh0aGlzLm1hc2tNYXRyaXgsIHRoaXMubWFza1Nwcml0ZSksIHRoaXMudW5pZm9ybXMuc2NhbGUueCA9IHRoaXMuc2NhbGUueCwgdGhpcy51bmlmb3Jtcy5zY2FsZS55ID0gdGhpcy5zY2FsZS55O1xuICAgIGNvbnN0IHd0ID0gdGhpcy5tYXNrU3ByaXRlLndvcmxkVHJhbnNmb3JtLCBsZW5YID0gTWF0aC5zcXJ0KHd0LmEgKiB3dC5hICsgd3QuYiAqIHd0LmIpLCBsZW5ZID0gTWF0aC5zcXJ0KHd0LmMgKiB3dC5jICsgd3QuZCAqIHd0LmQpO1xuICAgIGxlblggIT09IDAgJiYgbGVuWSAhPT0gMCAmJiAodGhpcy51bmlmb3Jtcy5yb3RhdGlvblswXSA9IHd0LmEgLyBsZW5YLCB0aGlzLnVuaWZvcm1zLnJvdGF0aW9uWzFdID0gd3QuYiAvIGxlblgsIHRoaXMudW5pZm9ybXMucm90YXRpb25bMl0gPSB3dC5jIC8gbGVuWSwgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblszXSA9IHd0LmQgLyBsZW5ZKSwgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICB9XG4gIC8qKiBUaGUgdGV4dHVyZSB1c2VkIGZvciB0aGUgZGlzcGxhY2VtZW50IG1hcC4gTXVzdCBiZSBwb3dlciBvZiAyIHNpemVkIHRleHR1cmUuICovXG4gIGdldCBtYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubWFwU2FtcGxlcjtcbiAgfVxuICBzZXQgbWFwKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5tYXBTYW1wbGVyID0gdmFsdWU7XG4gIH1cbn1cbmV4cG9ydHMuRGlzcGxhY2VtZW50RmlsdGVyID0gRGlzcGxhY2VtZW50RmlsdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGlzcGxhY2VtZW50RmlsdGVyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIGZyYWdtZW50ID0gYHZhcnlpbmcgdmVjMiB2RmlsdGVyQ29vcmQ7XG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcblxudW5pZm9ybSB2ZWMyIHNjYWxlO1xudW5pZm9ybSBtYXQyIHJvdGF0aW9uO1xudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG51bmlmb3JtIHNhbXBsZXIyRCBtYXBTYW1wbGVyO1xuXG51bmlmb3JtIGhpZ2hwIHZlYzQgaW5wdXRTaXplO1xudW5pZm9ybSB2ZWM0IGlucHV0Q2xhbXA7XG5cbnZvaWQgbWFpbih2b2lkKVxue1xuICB2ZWM0IG1hcCA9ICB0ZXh0dXJlMkQobWFwU2FtcGxlciwgdkZpbHRlckNvb3JkKTtcblxuICBtYXAgLT0gMC41O1xuICBtYXAueHkgPSBzY2FsZSAqIGlucHV0U2l6ZS56dyAqIChyb3RhdGlvbiAqIG1hcC54eSk7XG5cbiAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjbGFtcCh2ZWMyKHZUZXh0dXJlQ29vcmQueCArIG1hcC54LCB2VGV4dHVyZUNvb3JkLnkgKyBtYXAueSksIGlucHV0Q2xhbXAueHksIGlucHV0Q2xhbXAuencpKTtcbn1cbmA7XG5leHBvcnRzLmRlZmF1bHQgPSBmcmFnbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3BsYWNlbWVudC5mcmFnLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIHZlcnRleCA9IGBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG5cbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xudW5pZm9ybSBtYXQzIGZpbHRlck1hdHJpeDtcblxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG52YXJ5aW5nIHZlYzIgdkZpbHRlckNvb3JkO1xuXG51bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xudW5pZm9ybSB2ZWM0IG91dHB1dEZyYW1lO1xuXG52ZWM0IGZpbHRlclZlcnRleFBvc2l0aW9uKCB2b2lkIClcbntcbiAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcblxuICAgIHJldHVybiB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcbn1cblxudmVjMiBmaWx0ZXJUZXh0dXJlQ29vcmQoIHZvaWQgKVxue1xuICAgIHJldHVybiBhVmVydGV4UG9zaXRpb24gKiAob3V0cHV0RnJhbWUuencgKiBpbnB1dFNpemUuencpO1xufVxuXG52b2lkIG1haW4odm9pZClcbntcblx0Z2xfUG9zaXRpb24gPSBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbigpO1xuXHR2VGV4dHVyZUNvb3JkID0gZmlsdGVyVGV4dHVyZUNvb3JkKCk7XG5cdHZGaWx0ZXJDb29yZCA9ICggZmlsdGVyTWF0cml4ICogdmVjMyggdlRleHR1cmVDb29yZCwgMS4wKSAgKS54eTtcbn1cbmA7XG5leHBvcnRzLmRlZmF1bHQgPSB2ZXJ0ZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXNwbGFjZW1lbnQudmVydC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIERpc3BsYWNlbWVudEZpbHRlciA9IHJlcXVpcmUoXCIuL0Rpc3BsYWNlbWVudEZpbHRlci5qc1wiKTtcbmV4cG9ydHMuRGlzcGxhY2VtZW50RmlsdGVyID0gRGlzcGxhY2VtZW50RmlsdGVyLkRpc3BsYWNlbWVudEZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCBmeGFhJDEgPSByZXF1aXJlKFwiLi9meGFhLmZyYWcuanNcIiksIGZ4YWEgPSByZXF1aXJlKFwiLi9meGFhLnZlcnQuanNcIik7XG5jbGFzcyBGWEFBRmlsdGVyIGV4dGVuZHMgY29yZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihmeGFhLmRlZmF1bHQsIGZ4YWEkMS5kZWZhdWx0KTtcbiAgfVxufVxuZXhwb3J0cy5GWEFBRmlsdGVyID0gRlhBQUZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZYQUFGaWx0ZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgZnJhZ21lbnQgPSBgdmFyeWluZyB2ZWMyIHZfcmdiTlc7XG52YXJ5aW5nIHZlYzIgdl9yZ2JORTtcbnZhcnlpbmcgdmVjMiB2X3JnYlNXO1xudmFyeWluZyB2ZWMyIHZfcmdiU0U7XG52YXJ5aW5nIHZlYzIgdl9yZ2JNO1xuXG52YXJ5aW5nIHZlYzIgdkZyYWdDb29yZDtcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xudW5pZm9ybSBoaWdocCB2ZWM0IGlucHV0U2l6ZTtcblxuXG4vKipcbiBCYXNpYyBGWEFBIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uIHRoZSBjb2RlIG9uIGdlZWtzM2QuY29tIHdpdGggdGhlXG4gbW9kaWZpY2F0aW9uIHRoYXQgdGhlIHRleHR1cmUyRExvZCBzdHVmZiB3YXMgcmVtb3ZlZCBzaW5jZSBpdCdzXG4gdW5zdXBwb3J0ZWQgYnkgV2ViR0wuXG5cbiAtLVxuXG4gRnJvbTpcbiBodHRwczovL2dpdGh1Yi5jb20vbWl0c3VoaWtvL3dlYmdsLW1laW5jcmFmdFxuXG4gQ29weXJpZ2h0IChjKSAyMDExIGJ5IEFybWluIFJvbmFjaGVyLlxuXG4gU29tZSByaWdodHMgcmVzZXJ2ZWQuXG5cbiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gbWV0OlxuXG4gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gKiBUaGUgbmFtZXMgb2YgdGhlIGNvbnRyaWJ1dG9ycyBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvclxuIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xuIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuI2lmbmRlZiBGWEFBX1JFRFVDRV9NSU5cbiNkZWZpbmUgRlhBQV9SRURVQ0VfTUlOICAgKDEuMC8gMTI4LjApXG4jZW5kaWZcbiNpZm5kZWYgRlhBQV9SRURVQ0VfTVVMXG4jZGVmaW5lIEZYQUFfUkVEVUNFX01VTCAgICgxLjAgLyA4LjApXG4jZW5kaWZcbiNpZm5kZWYgRlhBQV9TUEFOX01BWFxuI2RlZmluZSBGWEFBX1NQQU5fTUFYICAgICA4LjBcbiNlbmRpZlxuXG4vL29wdGltaXplZCB2ZXJzaW9uIGZvciBtb2JpbGUsIHdoZXJlIGRlcGVuZGVudFxuLy90ZXh0dXJlIHJlYWRzIGNhbiBiZSBhIGJvdHRsZW5lY2tcbnZlYzQgZnhhYShzYW1wbGVyMkQgdGV4LCB2ZWMyIGZyYWdDb29yZCwgdmVjMiBpbnZlcnNlVlAsXG4gICAgICAgICAgdmVjMiB2X3JnYk5XLCB2ZWMyIHZfcmdiTkUsXG4gICAgICAgICAgdmVjMiB2X3JnYlNXLCB2ZWMyIHZfcmdiU0UsXG4gICAgICAgICAgdmVjMiB2X3JnYk0pIHtcbiAgICB2ZWM0IGNvbG9yO1xuICAgIHZlYzMgcmdiTlcgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYk5XKS54eXo7XG4gICAgdmVjMyByZ2JORSA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiTkUpLnh5ejtcbiAgICB2ZWMzIHJnYlNXID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JTVykueHl6O1xuICAgIHZlYzMgcmdiU0UgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYlNFKS54eXo7XG4gICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiTSk7XG4gICAgdmVjMyByZ2JNICA9IHRleENvbG9yLnh5ejtcbiAgICB2ZWMzIGx1bWEgPSB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpO1xuICAgIGZsb2F0IGx1bWFOVyA9IGRvdChyZ2JOVywgbHVtYSk7XG4gICAgZmxvYXQgbHVtYU5FID0gZG90KHJnYk5FLCBsdW1hKTtcbiAgICBmbG9hdCBsdW1hU1cgPSBkb3QocmdiU1csIGx1bWEpO1xuICAgIGZsb2F0IGx1bWFTRSA9IGRvdChyZ2JTRSwgbHVtYSk7XG4gICAgZmxvYXQgbHVtYU0gID0gZG90KHJnYk0sICBsdW1hKTtcbiAgICBmbG9hdCBsdW1hTWluID0gbWluKGx1bWFNLCBtaW4obWluKGx1bWFOVywgbHVtYU5FKSwgbWluKGx1bWFTVywgbHVtYVNFKSkpO1xuICAgIGZsb2F0IGx1bWFNYXggPSBtYXgobHVtYU0sIG1heChtYXgobHVtYU5XLCBsdW1hTkUpLCBtYXgobHVtYVNXLCBsdW1hU0UpKSk7XG5cbiAgICBtZWRpdW1wIHZlYzIgZGlyO1xuICAgIGRpci54ID0gLSgobHVtYU5XICsgbHVtYU5FKSAtIChsdW1hU1cgKyBsdW1hU0UpKTtcbiAgICBkaXIueSA9ICAoKGx1bWFOVyArIGx1bWFTVykgLSAobHVtYU5FICsgbHVtYVNFKSk7XG5cbiAgICBmbG9hdCBkaXJSZWR1Y2UgPSBtYXgoKGx1bWFOVyArIGx1bWFORSArIGx1bWFTVyArIGx1bWFTRSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoMC4yNSAqIEZYQUFfUkVEVUNFX01VTCksIEZYQUFfUkVEVUNFX01JTik7XG5cbiAgICBmbG9hdCByY3BEaXJNaW4gPSAxLjAgLyAobWluKGFicyhkaXIueCksIGFicyhkaXIueSkpICsgZGlyUmVkdWNlKTtcbiAgICBkaXIgPSBtaW4odmVjMihGWEFBX1NQQU5fTUFYLCBGWEFBX1NQQU5fTUFYKSxcbiAgICAgICAgICAgICAgbWF4KHZlYzIoLUZYQUFfU1BBTl9NQVgsIC1GWEFBX1NQQU5fTUFYKSxcbiAgICAgICAgICAgICAgICAgIGRpciAqIHJjcERpck1pbikpICogaW52ZXJzZVZQO1xuXG4gICAgdmVjMyByZ2JBID0gMC41ICogKFxuICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAoMS4wIC8gMy4wIC0gMC41KSkueHl6ICtcbiAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogKDIuMCAvIDMuMCAtIDAuNSkpLnh5eik7XG4gICAgdmVjMyByZ2JCID0gcmdiQSAqIDAuNSArIDAuMjUgKiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogLTAuNSkueHl6ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAwLjUpLnh5eik7XG5cbiAgICBmbG9hdCBsdW1hQiA9IGRvdChyZ2JCLCBsdW1hKTtcbiAgICBpZiAoKGx1bWFCIDwgbHVtYU1pbikgfHwgKGx1bWFCID4gbHVtYU1heCkpXG4gICAgICAgIGNvbG9yID0gdmVjNChyZ2JBLCB0ZXhDb2xvci5hKTtcbiAgICBlbHNlXG4gICAgICAgIGNvbG9yID0gdmVjNChyZ2JCLCB0ZXhDb2xvci5hKTtcbiAgICByZXR1cm4gY29sb3I7XG59XG5cbnZvaWQgbWFpbigpIHtcblxuICAgICAgdmVjNCBjb2xvcjtcblxuICAgICAgY29sb3IgPSBmeGFhKHVTYW1wbGVyLCB2RnJhZ0Nvb3JkLCBpbnB1dFNpemUuencsIHZfcmdiTlcsIHZfcmdiTkUsIHZfcmdiU1csIHZfcmdiU0UsIHZfcmdiTSk7XG5cbiAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xufVxuYDtcbmV4cG9ydHMuZGVmYXVsdCA9IGZyYWdtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnhhYS5mcmFnLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIHZlcnRleCA9IGBcbmF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcblxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XG5cbnZhcnlpbmcgdmVjMiB2X3JnYk5XO1xudmFyeWluZyB2ZWMyIHZfcmdiTkU7XG52YXJ5aW5nIHZlYzIgdl9yZ2JTVztcbnZhcnlpbmcgdmVjMiB2X3JnYlNFO1xudmFyeWluZyB2ZWMyIHZfcmdiTTtcblxudmFyeWluZyB2ZWMyIHZGcmFnQ29vcmQ7XG5cbnVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XG51bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XG5cbnZlYzQgZmlsdGVyVmVydGV4UG9zaXRpb24oIHZvaWQgKVxue1xuICAgIHZlYzIgcG9zaXRpb24gPSBhVmVydGV4UG9zaXRpb24gKiBtYXgob3V0cHV0RnJhbWUuencsIHZlYzIoMC4pKSArIG91dHB1dEZyYW1lLnh5O1xuXG4gICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xufVxuXG52b2lkIHRleGNvb3Jkcyh2ZWMyIGZyYWdDb29yZCwgdmVjMiBpbnZlcnNlVlAsXG4gICAgICAgICAgICAgICBvdXQgdmVjMiB2X3JnYk5XLCBvdXQgdmVjMiB2X3JnYk5FLFxuICAgICAgICAgICAgICAgb3V0IHZlYzIgdl9yZ2JTVywgb3V0IHZlYzIgdl9yZ2JTRSxcbiAgICAgICAgICAgICAgIG91dCB2ZWMyIHZfcmdiTSkge1xuICAgIHZfcmdiTlcgPSAoZnJhZ0Nvb3JkICsgdmVjMigtMS4wLCAtMS4wKSkgKiBpbnZlcnNlVlA7XG4gICAgdl9yZ2JORSA9IChmcmFnQ29vcmQgKyB2ZWMyKDEuMCwgLTEuMCkpICogaW52ZXJzZVZQO1xuICAgIHZfcmdiU1cgPSAoZnJhZ0Nvb3JkICsgdmVjMigtMS4wLCAxLjApKSAqIGludmVyc2VWUDtcbiAgICB2X3JnYlNFID0gKGZyYWdDb29yZCArIHZlYzIoMS4wLCAxLjApKSAqIGludmVyc2VWUDtcbiAgICB2X3JnYk0gPSB2ZWMyKGZyYWdDb29yZCAqIGludmVyc2VWUCk7XG59XG5cbnZvaWQgbWFpbih2b2lkKSB7XG5cbiAgIGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oKTtcblxuICAgdkZyYWdDb29yZCA9IGFWZXJ0ZXhQb3NpdGlvbiAqIG91dHB1dEZyYW1lLnp3O1xuXG4gICB0ZXhjb29yZHModkZyYWdDb29yZCwgaW5wdXRTaXplLnp3LCB2X3JnYk5XLCB2X3JnYk5FLCB2X3JnYlNXLCB2X3JnYlNFLCB2X3JnYk0pO1xufVxuYDtcbmV4cG9ydHMuZGVmYXVsdCA9IHZlcnRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ4YWEudmVydC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIEZYQUFGaWx0ZXIgPSByZXF1aXJlKFwiLi9GWEFBRmlsdGVyLmpzXCIpO1xuZXhwb3J0cy5GWEFBRmlsdGVyID0gRlhBQUZpbHRlci5GWEFBRmlsdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIG5vaXNlID0gcmVxdWlyZShcIi4vbm9pc2UuZnJhZy5qc1wiKTtcbmNsYXNzIE5vaXNlRmlsdGVyIGV4dGVuZHMgY29yZS5GaWx0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtub2lzZT0wLjVdIC0gVGhlIG5vaXNlIGludGVuc2l0eSwgc2hvdWxkIGJlIGEgbm9ybWFsaXplZCB2YWx1ZSBpbiB0aGUgcmFuZ2UgWzAsIDFdLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlZWRdIC0gQSByYW5kb20gc2VlZCBmb3IgdGhlIG5vaXNlIGdlbmVyYXRpb24uIERlZmF1bHQgaXMgYE1hdGgucmFuZG9tKClgLlxuICAgKi9cbiAgY29uc3RydWN0b3Iobm9pc2UkMSA9IDAuNSwgc2VlZCA9IE1hdGgucmFuZG9tKCkpIHtcbiAgICBzdXBlcihjb3JlLmRlZmF1bHRGaWx0ZXJWZXJ0ZXgsIG5vaXNlLmRlZmF1bHQsIHtcbiAgICAgIHVOb2lzZTogMCxcbiAgICAgIHVTZWVkOiAwXG4gICAgfSksIHRoaXMubm9pc2UgPSBub2lzZSQxLCB0aGlzLnNlZWQgPSBzZWVkO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIG5vaXNlIHRvIGFwcGx5LCB0aGlzIHZhbHVlIHNob3VsZCBiZSBpbiB0aGUgcmFuZ2UgKDAsIDFdLlxuICAgKiBAZGVmYXVsdCAwLjVcbiAgICovXG4gIGdldCBub2lzZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51Tm9pc2U7XG4gIH1cbiAgc2V0IG5vaXNlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51Tm9pc2UgPSB2YWx1ZTtcbiAgfVxuICAvKiogQSBzZWVkIHZhbHVlIHRvIGFwcGx5IHRvIHRoZSByYW5kb20gbm9pc2UgZ2VuZXJhdGlvbi4gYE1hdGgucmFuZG9tKClgIGlzIGEgZ29vZCB2YWx1ZSB0byB1c2UuICovXG4gIGdldCBzZWVkKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVTZWVkO1xuICB9XG4gIHNldCBzZWVkKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51U2VlZCA9IHZhbHVlO1xuICB9XG59XG5leHBvcnRzLk5vaXNlRmlsdGVyID0gTm9pc2VGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob2lzZUZpbHRlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIE5vaXNlRmlsdGVyID0gcmVxdWlyZShcIi4vTm9pc2VGaWx0ZXIuanNcIik7XG5leHBvcnRzLk5vaXNlRmlsdGVyID0gTm9pc2VGaWx0ZXIuTm9pc2VGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnZhciBmcmFnbWVudCA9IGBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xudmFyeWluZyB2ZWM0IHZDb2xvcjtcblxudW5pZm9ybSBmbG9hdCB1Tm9pc2U7XG51bmlmb3JtIGZsb2F0IHVTZWVkO1xudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG5cbmZsb2F0IHJhbmQodmVjMiBjbylcbntcbiAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChjby54eSwgdmVjMigxMi45ODk4LCA3OC4yMzMpKSkgKiA0Mzc1OC41NDUzKTtcbn1cblxudm9pZCBtYWluKClcbntcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcbiAgICBmbG9hdCByYW5kb21WYWx1ZSA9IHJhbmQoZ2xfRnJhZ0Nvb3JkLnh5ICogdVNlZWQpO1xuICAgIGZsb2F0IGRpZmYgPSAocmFuZG9tVmFsdWUgLSAwLjUpICogdU5vaXNlO1xuXG4gICAgLy8gVW4tcHJlbXVsdGlwbHkgYWxwaGEgYmVmb3JlIGFwcGx5aW5nIHRoZSBjb2xvciBtYXRyaXguIFNlZSBpc3N1ZSAjMzUzOS5cbiAgICBpZiAoY29sb3IuYSA+IDAuMCkge1xuICAgICAgICBjb2xvci5yZ2IgLz0gY29sb3IuYTtcbiAgICB9XG5cbiAgICBjb2xvci5yICs9IGRpZmY7XG4gICAgY29sb3IuZyArPSBkaWZmO1xuICAgIGNvbG9yLmIgKz0gZGlmZjtcblxuICAgIC8vIFByZW11bHRpcGx5IGFscGhhIGFnYWluLlxuICAgIGNvbG9yLnJnYiAqPSBjb2xvci5hO1xuXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG59XG5gO1xuZXhwb3J0cy5kZWZhdWx0ID0gZnJhZ21lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2lzZS5mcmFnLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCBkaXNwbGF5ID0gcmVxdWlyZShcIkBwaXhpL2Rpc3BsYXlcIiksIF9jb25zdCA9IHJlcXVpcmUoXCIuL2NvbnN0LmpzXCIpLCBHcmFwaGljc0dlb21ldHJ5ID0gcmVxdWlyZShcIi4vR3JhcGhpY3NHZW9tZXRyeS5qc1wiKSwgRmlsbFN0eWxlID0gcmVxdWlyZShcIi4vc3R5bGVzL0ZpbGxTdHlsZS5qc1wiKSwgTGluZVN0eWxlID0gcmVxdWlyZShcIi4vc3R5bGVzL0xpbmVTdHlsZS5qc1wiKTtcbnJlcXVpcmUoXCIuL3V0aWxzL2luZGV4LmpzXCIpO1xudmFyIFF1YWRyYXRpY1V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMvUXVhZHJhdGljVXRpbHMuanNcIiksIEJlemllclV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMvQmV6aWVyVXRpbHMuanNcIiksIEFyY1V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMvQXJjVXRpbHMuanNcIik7XG5jb25zdCBERUZBVUxUX1NIQURFUlMgPSB7fSwgX0dyYXBoaWNzID0gY2xhc3MgX0dyYXBoaWNzMiBleHRlbmRzIGRpc3BsYXkuQ29udGFpbmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBnZW9tZXRyeSAtIEdlb21ldHJ5IHRvIHVzZSwgaWYgb21pdHRlZCB3aWxsIGNyZWF0ZSBhIG5ldyBHcmFwaGljc0dlb21ldHJ5IGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZ2VvbWV0cnkgPSBudWxsKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5zaGFkZXIgPSBudWxsLCB0aGlzLnBsdWdpbk5hbWUgPSBcImJhdGNoXCIsIHRoaXMuY3VycmVudFBhdGggPSBudWxsLCB0aGlzLmJhdGNoZXMgPSBbXSwgdGhpcy5iYXRjaFRpbnQgPSAtMSwgdGhpcy5iYXRjaERpcnR5ID0gLTEsIHRoaXMudmVydGV4RGF0YSA9IG51bGwsIHRoaXMuX2ZpbGxTdHlsZSA9IG5ldyBGaWxsU3R5bGUuRmlsbFN0eWxlKCksIHRoaXMuX2xpbmVTdHlsZSA9IG5ldyBMaW5lU3R5bGUuTGluZVN0eWxlKCksIHRoaXMuX21hdHJpeCA9IG51bGwsIHRoaXMuX2hvbGVNb2RlID0gITEsIHRoaXMuc3RhdGUgPSBjb3JlLlN0YXRlLmZvcjJkKCksIHRoaXMuX2dlb21ldHJ5ID0gZ2VvbWV0cnkgfHwgbmV3IEdyYXBoaWNzR2VvbWV0cnkuR3JhcGhpY3NHZW9tZXRyeSgpLCB0aGlzLl9nZW9tZXRyeS5yZWZDb3VudCsrLCB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xLCB0aGlzLl90aW50Q29sb3IgPSBuZXcgY29yZS5Db2xvcigxNjc3NzIxNSksIHRoaXMuYmxlbmRNb2RlID0gY29yZS5CTEVORF9NT0RFUy5OT1JNQUw7XG4gIH1cbiAgLyoqXG4gICAqIEluY2x1ZGVzIHZlcnRleCBwb3NpdGlvbnMsIGZhY2UgaW5kaWNlcywgbm9ybWFscywgY29sb3JzLCBVVnMsIGFuZFxuICAgKiBjdXN0b20gYXR0cmlidXRlcyB3aXRoaW4gYnVmZmVycywgcmVkdWNpbmcgdGhlIGNvc3Qgb2YgcGFzc2luZyBhbGxcbiAgICogdGhpcyBkYXRhIHRvIHRoZSBHUFUuIENhbiBiZSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBNZXNoIG9yIEdyYXBoaWNzIG9iamVjdHMuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLl9nZW9tZXRyeTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBHcmFwaGljcyBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAqIE5vdGUgdGhhdCBvbmx5IHRoZSBnZW9tZXRyeSBvZiB0aGUgb2JqZWN0IGlzIGNsb25lZCwgbm90IGl0cyB0cmFuc2Zvcm0gKHBvc2l0aW9uLHNjYWxlLGV0YylcbiAgICogQHJldHVybnMgLSBBIGNsb25lIG9mIHRoZSBncmFwaGljcyBvYmplY3RcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFBvbHkoKSwgbmV3IF9HcmFwaGljczIodGhpcy5fZ2VvbWV0cnkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBncmFwaGljIHNoYXBlLiBBcHBseSBhIHZhbHVlIG9mXG4gICAqIGBQSVhJLkJMRU5EX01PREVTLk5PUk1BTGAgdG8gcmVzZXQgdGhlIGJsZW5kIG1vZGUuICBOb3RlIHRoYXQsIHNpbmNlIGVhY2hcbiAgICogcHJpbWl0aXZlIGluIHRoZSBHcmFwaGljc0dlb21ldHJ5IGxpc3QgaXMgcmVuZGVyZWQgc2VxdWVudGlhbGx5LCBtb2Rlc1xuICAgKiBzdWNoIGFzIGBQSVhJLkJMRU5EX01PREVTLkFERGAgYW5kIGBQSVhJLkJMRU5EX01PREVTLk1VTFRJUExZYCB3aWxsXG4gICAqIGJlIGFwcGxpZWQgcGVyLXByaW1pdGl2ZS5cbiAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcbiAgICovXG4gIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IHZhbHVlO1xuICB9XG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuYmxlbmRNb2RlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIGVhY2ggZ3JhcGhpYyBzaGFwZS4gVGhpcyBpcyBhIGhleCB2YWx1ZS4gQSB2YWx1ZSBvZlxuICAgKiAweEZGRkZGRiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAqL1xuICBnZXQgdGludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGludENvbG9yLnZhbHVlO1xuICB9XG4gIHNldCB0aW50KHZhbHVlKSB7XG4gICAgdGhpcy5fdGludENvbG9yLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgZmlsbCBzdHlsZS5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsbFN0eWxlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBsaW5lIHN0eWxlLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl9saW5lU3R5bGU7XG4gIH1cbiAgbGluZVN0eWxlKG9wdGlvbnMgPSBudWxsLCBjb2xvciA9IDAsIGFscGhhLCBhbGlnbm1lbnQgPSAwLjUsIG5hdGl2ZSA9ICExKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvcHRpb25zID09IFwibnVtYmVyXCIgJiYgKG9wdGlvbnMgPSB7IHdpZHRoOiBvcHRpb25zLCBjb2xvciwgYWxwaGEsIGFsaWdubWVudCwgbmF0aXZlIH0pLCB0aGlzLmxpbmVUZXh0dXJlU3R5bGUob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIExpa2UgbGluZSBzdHlsZSBidXQgc3VwcG9ydCB0ZXh0dXJlIGZvciBsaW5lIGZpbGwuXG4gICAqIEBwYXJhbSBbb3B0aW9uc10gLSBDb2xsZWN0aW9uIG9mIG9wdGlvbnMgZm9yIHNldHRpbmcgbGluZSBzdHlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoPTBdIC0gd2lkdGggb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSBbb3B0aW9ucy50ZXh0dXJlPVBJWEkuVGV4dHVyZS5XSElURV0gLSBUZXh0dXJlIHRvIHVzZVxuICAgKiBAcGFyYW0ge1BJWEkuQ29sb3JTb3VyY2V9IFtvcHRpb25zLmNvbG9yPTB4MF0gLSBjb2xvciBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0cyBzdG9yZWQgc3R5bGUuXG4gICAqICBEZWZhdWx0IDB4RkZGRkZGIGlmIHRleHR1cmUgcHJlc2VudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmFscGhhPTFdIC0gYWxwaGEgb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IFtvcHRpb25zLm1hdHJpeD1udWxsXSAtIFRleHR1cmUgbWF0cml4IHRvIHRyYW5zZm9ybSB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5hbGlnbm1lbnQ9MC41XSAtIGFsaWdubWVudCBvZiB0aGUgbGluZSB0byBkcmF3LCAoMCA9IGlubmVyLCAwLjUgPSBtaWRkbGUsIDEgPSBvdXRlcikuXG4gICAqICAgICAgICBXZWJHTCBvbmx5LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm5hdGl2ZT1mYWxzZV0gLSBJZiB0cnVlIHRoZSBsaW5lcyB3aWxsIGJlIGRyYXcgdXNpbmcgTElORVMgaW5zdGVhZCBvZiBUUklBTkdMRV9TVFJJUFxuICAgKiBAcGFyYW0ge1BJWEkuTElORV9DQVB9W29wdGlvbnMuY2FwPVBJWEkuTElORV9DQVAuQlVUVF0gLSBsaW5lIGNhcCBzdHlsZVxuICAgKiBAcGFyYW0ge1BJWEkuTElORV9KT0lOfVtvcHRpb25zLmpvaW49UElYSS5MSU5FX0pPSU4uTUlURVJdIC0gbGluZSBqb2luIHN0eWxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfVtvcHRpb25zLm1pdGVyTGltaXQ9MTBdIC0gbWl0ZXIgbGltaXQgcmF0aW9cbiAgICogQHJldHVybnMge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICovXG4gIGxpbmVUZXh0dXJlU3R5bGUob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRMaW5lU3R5bGVPcHRpb25zID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICB0ZXh0dXJlOiBjb3JlLlRleHR1cmUuV0hJVEUsXG4gICAgICBjb2xvcjogb3B0aW9ucz8udGV4dHVyZSA/IDE2Nzc3MjE1IDogMCxcbiAgICAgIG1hdHJpeDogbnVsbCxcbiAgICAgIGFsaWdubWVudDogMC41LFxuICAgICAgbmF0aXZlOiAhMSxcbiAgICAgIGNhcDogX2NvbnN0LkxJTkVfQ0FQLkJVVFQsXG4gICAgICBqb2luOiBfY29uc3QuTElORV9KT0lOLk1JVEVSLFxuICAgICAgbWl0ZXJMaW1pdDogMTBcbiAgICB9O1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRMaW5lU3R5bGVPcHRpb25zLCBvcHRpb25zKSwgdGhpcy5ub3JtYWxpemVDb2xvcihvcHRpb25zKSwgdGhpcy5jdXJyZW50UGF0aCAmJiB0aGlzLnN0YXJ0UG9seSgpO1xuICAgIGNvbnN0IHZpc2libGUgPSBvcHRpb25zLndpZHRoID4gMCAmJiBvcHRpb25zLmFscGhhID4gMDtcbiAgICByZXR1cm4gdmlzaWJsZSA/IChvcHRpb25zLm1hdHJpeCAmJiAob3B0aW9ucy5tYXRyaXggPSBvcHRpb25zLm1hdHJpeC5jbG9uZSgpLCBvcHRpb25zLm1hdHJpeC5pbnZlcnQoKSksIE9iamVjdC5hc3NpZ24odGhpcy5fbGluZVN0eWxlLCB7IHZpc2libGUgfSwgb3B0aW9ucykpIDogdGhpcy5fbGluZVN0eWxlLnJlc2V0KCksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IGEgcG9seWdvbiBvYmplY3QgaW50ZXJuYWxseS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc3RhcnRQb2x5KCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XG4gICAgICBjb25zdCBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cywgbGVuID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoO1xuICAgICAgbGVuID4gMiAmJiAodGhpcy5kcmF3U2hhcGUodGhpcy5jdXJyZW50UGF0aCksIHRoaXMuY3VycmVudFBhdGggPSBuZXcgY29yZS5Qb2x5Z29uKCksIHRoaXMuY3VycmVudFBhdGguY2xvc2VTdHJva2UgPSAhMSwgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMucHVzaChwb2ludHNbbGVuIC0gMl0sIHBvaW50c1tsZW4gLSAxXSkpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG5ldyBjb3JlLlBvbHlnb24oKSwgdGhpcy5jdXJyZW50UGF0aC5jbG9zZVN0cm9rZSA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBGaW5pc2ggdGhlIHBvbHlnb24gb2JqZWN0LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBmaW5pc2hQb2x5KCkge1xuICAgIHRoaXMuY3VycmVudFBhdGggJiYgKHRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCA+IDIgPyAodGhpcy5kcmF3U2hhcGUodGhpcy5jdXJyZW50UGF0aCksIHRoaXMuY3VycmVudFBhdGggPSBudWxsKSA6IHRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCA9IDApO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIHRvIHgsIHkuXG4gICAqIEBwYXJhbSB4IC0gdGhlIFggY29vcmRpbmF0ZSB0byBtb3ZlIHRvXG4gICAqIEBwYXJhbSB5IC0gdGhlIFkgY29vcmRpbmF0ZSB0byBtb3ZlIHRvXG4gICAqIEByZXR1cm5zIC0gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgKi9cbiAgbW92ZVRvKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydFBvbHkoKSwgdGhpcy5jdXJyZW50UGF0aC5wb2ludHNbMF0gPSB4LCB0aGlzLmN1cnJlbnRQYXRoLnBvaW50c1sxXSA9IHksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgbGluZSB1c2luZyB0aGUgY3VycmVudCBsaW5lIHN0eWxlIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb3NpdGlvbiB0byAoeCwgeSk7XG4gICAqIFRoZSBjdXJyZW50IGRyYXdpbmcgcG9zaXRpb24gaXMgdGhlbiBzZXQgdG8gKHgsIHkpLlxuICAgKiBAcGFyYW0geCAtIHRoZSBYIGNvb3JkaW5hdGUgdG8gZHJhdyB0b1xuICAgKiBAcGFyYW0geSAtIHRoZSBZIGNvb3JkaW5hdGUgdG8gZHJhdyB0b1xuICAgKiBAcmV0dXJucyAtIFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICovXG4gIGxpbmVUbyh4LCB5KSB7XG4gICAgdGhpcy5jdXJyZW50UGF0aCB8fCB0aGlzLm1vdmVUbygwLCAwKTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cywgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIChmcm9tWCAhPT0geCB8fCBmcm9tWSAhPT0geSkgJiYgcG9pbnRzLnB1c2goeCwgeSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGN1cnZlXG4gICAqIEBwYXJhbSB4XG4gICAqIEBwYXJhbSB5XG4gICAqL1xuICBfaW5pdEN1cnZlKHggPSAwLCB5ID0gMCkge1xuICAgIHRoaXMuY3VycmVudFBhdGggPyB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGggPT09IDAgJiYgKHRoaXMuY3VycmVudFBhdGgucG9pbnRzID0gW3gsIHldKSA6IHRoaXMubW92ZVRvKHgsIHkpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlIGFuZCB0aGVuIGRyYXdzIGl0LlxuICAgKiBCYXNlZCBvbjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzg1MDk3L2hvdy1kby1pLWltcGxlbWVudC1hLWJlemllci1jdXJ2ZS1pbi1jXG4gICAqIEBwYXJhbSBjcFggLSBDb250cm9sIHBvaW50IHhcbiAgICogQHBhcmFtIGNwWSAtIENvbnRyb2wgcG9pbnQgeVxuICAgKiBAcGFyYW0gdG9YIC0gRGVzdGluYXRpb24gcG9pbnQgeFxuICAgKiBAcGFyYW0gdG9ZIC0gRGVzdGluYXRpb24gcG9pbnQgeVxuICAgKiBAcmV0dXJucyAtIFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICovXG4gIHF1YWRyYXRpY0N1cnZlVG8oY3BYLCBjcFksIHRvWCwgdG9ZKSB7XG4gICAgdGhpcy5faW5pdEN1cnZlKCk7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHM7XG4gICAgcmV0dXJuIHBvaW50cy5sZW5ndGggPT09IDAgJiYgdGhpcy5tb3ZlVG8oMCwgMCksIFF1YWRyYXRpY1V0aWxzLlF1YWRyYXRpY1V0aWxzLmN1cnZlVG8oY3BYLCBjcFksIHRvWCwgdG9ZLCBwb2ludHMpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXG4gICAqIEBwYXJhbSBjcFggLSBDb250cm9sIHBvaW50IHhcbiAgICogQHBhcmFtIGNwWSAtIENvbnRyb2wgcG9pbnQgeVxuICAgKiBAcGFyYW0gY3BYMiAtIFNlY29uZCBDb250cm9sIHBvaW50IHhcbiAgICogQHBhcmFtIGNwWTIgLSBTZWNvbmQgQ29udHJvbCBwb2ludCB5XG4gICAqIEBwYXJhbSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XG4gICAqIEBwYXJhbSB0b1kgLSBEZXN0aW5hdGlvbiBwb2ludCB5XG4gICAqIEByZXR1cm5zIFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICovXG4gIGJlemllckN1cnZlVG8oY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXRDdXJ2ZSgpLCBCZXppZXJVdGlscy5CZXppZXJVdGlscy5jdXJ2ZVRvKGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSwgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYGFyY1RvYCBtZXRob2QgY3JlYXRlcyBhbiBhcmMvY3VydmUgYmV0d2VlbiB0d28gdGFuZ2VudHMgb24gdGhlIGNhbnZhcy5cbiAgICogVGhlIGZpcnN0IHRhbmdlbnQgaXMgZnJvbSB0aGUgc3RhcnQgcG9pbnQgdG8gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQsXG4gICAqIGFuZCB0aGUgc2Vjb25kIHRhbmdlbnQgaXMgZnJvbSB0aGUgZmlyc3QgY29udHJvbCBwb2ludCB0byB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAqIE5vdGUgdGhhdCB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgaXMgbm90IG5lY2Vzc2FyaWx5IHRoZSBlbmQgcG9pbnQgb2YgdGhlIGFyYy5cbiAgICpcbiAgICogXCJib3Jyb3dlZFwiIGZyb20gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9meGNhbnZhcy8gLSB0aGFua3MgZ29vZ2xlIVxuICAgKiBAcGFyYW0geDEgLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IG9mIHRoZSBhcmNcbiAgICogQHBhcmFtIHkxIC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBvZiB0aGUgYXJjXG4gICAqIEBwYXJhbSB4MiAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9mIHRoZSBhcmNcbiAgICogQHBhcmFtIHkyIC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb2YgdGhlIGFyY1xuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgYXJjXG4gICAqIEByZXR1cm5zIC0gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgKi9cbiAgYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICAgIHRoaXMuX2luaXRDdXJ2ZSh4MSwgeTEpO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzLCByZXN1bHQgPSBBcmNVdGlscy5BcmNVdGlscy5jdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMsIHBvaW50cyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgY29uc3QgeyBjeCwgY3ksIHJhZGl1czogcmFkaXVzMiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UgfSA9IHJlc3VsdDtcbiAgICAgIHRoaXMuYXJjKGN4LCBjeSwgcmFkaXVzMiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhlIGFyYyBtZXRob2QgY3JlYXRlcyBhbiBhcmMvY3VydmUgKHVzZWQgdG8gY3JlYXRlIGNpcmNsZXMsIG9yIHBhcnRzIG9mIGNpcmNsZXMpLlxuICAgKiBAcGFyYW0gY3ggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuICAgKiBAcGFyYW0gY3kgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gICAqIEBwYXJhbSBzdGFydEFuZ2xlIC0gVGhlIHN0YXJ0aW5nIGFuZ2xlLCBpbiByYWRpYW5zICgwIGlzIGF0IHRoZSAzIG8nY2xvY2sgcG9zaXRpb25cbiAgICogIG9mIHRoZSBhcmMncyBjaXJjbGUpXG4gICAqIEBwYXJhbSBlbmRBbmdsZSAtIFRoZSBlbmRpbmcgYW5nbGUsIGluIHJhZGlhbnNcbiAgICogQHBhcmFtIGFudGljbG9ja3dpc2UgLSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZHJhd2luZyBzaG91bGQgYmVcbiAgICogIGNvdW50ZXItY2xvY2t3aXNlIG9yIGNsb2Nrd2lzZS4gRmFsc2UgaXMgZGVmYXVsdCwgYW5kIGluZGljYXRlcyBjbG9ja3dpc2UsIHdoaWxlIHRydWVcbiAgICogIGluZGljYXRlcyBjb3VudGVyLWNsb2Nrd2lzZS5cbiAgICogQHJldHVybnMgLSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAqL1xuICBhcmMoY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlID0gITEpIHtcbiAgICBpZiAoc3RhcnRBbmdsZSA9PT0gZW5kQW5nbGUpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAoIWFudGljbG9ja3dpc2UgJiYgZW5kQW5nbGUgPD0gc3RhcnRBbmdsZSA/IGVuZEFuZ2xlICs9IGNvcmUuUElfMiA6IGFudGljbG9ja3dpc2UgJiYgc3RhcnRBbmdsZSA8PSBlbmRBbmdsZSAmJiAoc3RhcnRBbmdsZSArPSBjb3JlLlBJXzIpLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPT09IDApXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBjb25zdCBzdGFydFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzLCBzdGFydFkgPSBjeSArIE1hdGguc2luKHN0YXJ0QW5nbGUpICogcmFkaXVzLCBlcHMgPSB0aGlzLl9nZW9tZXRyeS5jbG9zZVBvaW50RXBzO1xuICAgIGxldCBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoID8gdGhpcy5jdXJyZW50UGF0aC5wb2ludHMgOiBudWxsO1xuICAgIGlmIChwb2ludHMpIHtcbiAgICAgIGNvbnN0IHhEaWZmID0gTWF0aC5hYnMocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSAtIHN0YXJ0WCksIHlEaWZmID0gTWF0aC5hYnMocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSAtIHN0YXJ0WSk7XG4gICAgICB4RGlmZiA8IGVwcyAmJiB5RGlmZiA8IGVwcyB8fCBwb2ludHMucHVzaChzdGFydFgsIHN0YXJ0WSk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLm1vdmVUbyhzdGFydFgsIHN0YXJ0WSksIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuICAgIHJldHVybiBBcmNVdGlscy5BcmNVdGlscy5hcmMoc3RhcnRYLCBzdGFydFksIGN4LCBjeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgcG9pbnRzKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWVzIGEgc2ltcGxlIG9uZS1jb2xvciBmaWxsIHRoYXQgc3Vic2VxdWVudCBjYWxscyB0byBvdGhlciBHcmFwaGljcyBtZXRob2RzXG4gICAqIChzdWNoIGFzIGxpbmVUbygpIG9yIGRyYXdDaXJjbGUoKSkgdXNlIHdoZW4gZHJhd2luZy5cbiAgICogQHBhcmFtIHtQSVhJLkNvbG9yU291cmNlfSBjb2xvciAtIHRoZSBjb2xvciBvZiB0aGUgZmlsbFxuICAgKiBAcGFyYW0gYWxwaGEgLSB0aGUgYWxwaGEgb2YgdGhlIGZpbGwsIHdpbGwgb3ZlcnJpZGUgdGhlIGNvbG9yJ3MgYWxwaGFcbiAgICogQHJldHVybnMgLSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gU3VpdGFibGUgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgKi9cbiAgYmVnaW5GaWxsKGNvbG9yID0gMCwgYWxwaGEpIHtcbiAgICByZXR1cm4gdGhpcy5iZWdpblRleHR1cmVGaWxsKHsgdGV4dHVyZTogY29yZS5UZXh0dXJlLldISVRFLCBjb2xvciwgYWxwaGEgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSB0aGUgY29sb3IgaW5wdXQgZnJvbSBvcHRpb25zIGZvciBsaW5lIHN0eWxlIG9yIGZpbGxcbiAgICogQHBhcmFtIHtQSVhJLklGaWxsU3R5bGVPcHRpb25zfSBvcHRpb25zIC0gRmlsbCBzdHlsZSBvYmplY3QuXG4gICAqL1xuICBub3JtYWxpemVDb2xvcihvcHRpb25zKSB7XG4gICAgY29uc3QgdGVtcCA9IGNvcmUuQ29sb3Iuc2hhcmVkLnNldFZhbHVlKG9wdGlvbnMuY29sb3IgPz8gMCk7XG4gICAgb3B0aW9ucy5jb2xvciA9IHRlbXAudG9OdW1iZXIoKSwgb3B0aW9ucy5hbHBoYSA/PyAob3B0aW9ucy5hbHBoYSA9IHRlbXAuYWxwaGEpO1xuICB9XG4gIC8qKlxuICAgKiBCZWdpbiB0aGUgdGV4dHVyZSBmaWxsLlxuICAgKiBOb3RlOiBUaGUgd3JhcCBtb2RlIG9mIHRoZSB0ZXh0dXJlIGlzIGZvcmNlZCB0byBSRVBFQVQgb24gcmVuZGVyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEZpbGwgc3R5bGUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gW29wdGlvbnMudGV4dHVyZT1QSVhJLlRleHR1cmUuV0hJVEVdIC0gVGV4dHVyZSB0byBmaWxsXG4gICAqIEBwYXJhbSB7UElYSS5Db2xvclNvdXJjZX0gW29wdGlvbnMuY29sb3I9MHhmZmZmZmZdIC0gQmFja2dyb3VuZCB0byBmaWxsIGJlaGluZCB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5hbHBoYV0gLSBBbHBoYSBvZiBmaWxsLCBvdmVycmlkZXMgdGhlIGNvbG9yJ3MgYWxwaGFcbiAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gW29wdGlvbnMubWF0cml4PW51bGxdIC0gVHJhbnNmb3JtIG1hdHJpeFxuICAgKiBAcmV0dXJucyB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgKi9cbiAgYmVnaW5UZXh0dXJlRmlsbChvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB0ZXh0dXJlOiBjb3JlLlRleHR1cmUuV0hJVEUsXG4gICAgICBjb2xvcjogMTY3NzcyMTUsXG4gICAgICBtYXRyaXg6IG51bGxcbiAgICB9O1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKSwgdGhpcy5ub3JtYWxpemVDb2xvcihvcHRpb25zKSwgdGhpcy5jdXJyZW50UGF0aCAmJiB0aGlzLnN0YXJ0UG9seSgpO1xuICAgIGNvbnN0IHZpc2libGUgPSBvcHRpb25zLmFscGhhID4gMDtcbiAgICByZXR1cm4gdmlzaWJsZSA/IChvcHRpb25zLm1hdHJpeCAmJiAob3B0aW9ucy5tYXRyaXggPSBvcHRpb25zLm1hdHJpeC5jbG9uZSgpLCBvcHRpb25zLm1hdHJpeC5pbnZlcnQoKSksIE9iamVjdC5hc3NpZ24odGhpcy5fZmlsbFN0eWxlLCB7IHZpc2libGUgfSwgb3B0aW9ucykpIDogdGhpcy5fZmlsbFN0eWxlLnJlc2V0KCksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBmaWxsIHRvIHRoZSBsaW5lcyBhbmQgc2hhcGVzIHRoYXQgd2VyZSBhZGRlZCBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHRoZSBiZWdpbkZpbGwoKSBtZXRob2QuXG4gICAqIEByZXR1cm5zIC0gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgKi9cbiAgZW5kRmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hQb2x5KCksIHRoaXMuX2ZpbGxTdHlsZS5yZXNldCgpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHJlY3RhbmdsZSBzaGFwZS5cbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICogQHJldHVybnMgLSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAqL1xuICBkcmF3UmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBjb3JlLlJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG4gIH1cbiAgLyoqXG4gICAqIERyYXcgYSByZWN0YW5nbGUgc2hhcGUgd2l0aCByb3VuZGVkL2JldmVsZWQgY29ybmVycy5cbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICogQHBhcmFtIHJhZGl1cyAtIFJhZGl1cyBvZiB0aGUgcmVjdGFuZ2xlIGNvcm5lcnNcbiAgICogQHJldHVybnMgLSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAqL1xuICBkcmF3Um91bmRlZFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBjb3JlLlJvdW5kZWRSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSk7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgY2lyY2xlLlxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICAgKiBAcmV0dXJucyAtIFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICovXG4gIGRyYXdDaXJjbGUoeCwgeSwgcmFkaXVzKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBjb3JlLkNpcmNsZSh4LCB5LCByYWRpdXMpKTtcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYW4gZWxsaXBzZS5cbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2VcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2VcbiAgICogQHBhcmFtIHdpZHRoIC0gVGhlIGhhbGYgd2lkdGggb2YgdGhlIGVsbGlwc2VcbiAgICogQHBhcmFtIGhlaWdodCAtIFRoZSBoYWxmIGhlaWdodCBvZiB0aGUgZWxsaXBzZVxuICAgKiBAcmV0dXJucyAtIFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICovXG4gIGRyYXdFbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICByZXR1cm4gdGhpcy5kcmF3U2hhcGUobmV3IGNvcmUuRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcG9seWdvbiB1c2luZyB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtIHtudW1iZXJbXXxQSVhJLklQb2ludERhdGFbXXxQSVhJLlBvbHlnb259IHBhdGggLSBUaGUgcGF0aCBkYXRhIHVzZWQgdG8gY29uc3RydWN0IHRoZSBwb2x5Z29uLlxuICAgKiBAcmV0dXJucyAtIFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICovXG4gIGRyYXdQb2x5Z29uKC4uLnBhdGgpIHtcbiAgICBsZXQgcG9pbnRzLCBjbG9zZVN0cm9rZSA9ICEwO1xuICAgIGNvbnN0IHBvbHkgPSBwYXRoWzBdO1xuICAgIHBvbHkucG9pbnRzID8gKGNsb3NlU3Ryb2tlID0gcG9seS5jbG9zZVN0cm9rZSwgcG9pbnRzID0gcG9seS5wb2ludHMpIDogQXJyYXkuaXNBcnJheShwYXRoWzBdKSA/IHBvaW50cyA9IHBhdGhbMF0gOiBwb2ludHMgPSBwYXRoO1xuICAgIGNvbnN0IHNoYXBlID0gbmV3IGNvcmUuUG9seWdvbihwb2ludHMpO1xuICAgIHJldHVybiBzaGFwZS5jbG9zZVN0cm9rZSA9IGNsb3NlU3Ryb2tlLCB0aGlzLmRyYXdTaGFwZShzaGFwZSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXcgYW55IHNoYXBlLlxuICAgKiBAcGFyYW0ge1BJWEkuQ2lyY2xlfFBJWEkuRWxsaXBzZXxQSVhJLlBvbHlnb258UElYSS5SZWN0YW5nbGV8UElYSS5Sb3VuZGVkUmVjdGFuZ2xlfSBzaGFwZSAtIFNoYXBlIHRvIGRyYXdcbiAgICogQHJldHVybnMgLSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAqL1xuICBkcmF3U2hhcGUoc2hhcGUpIHtcbiAgICByZXR1cm4gdGhpcy5faG9sZU1vZGUgPyB0aGlzLl9nZW9tZXRyeS5kcmF3SG9sZShzaGFwZSwgdGhpcy5fbWF0cml4KSA6IHRoaXMuX2dlb21ldHJ5LmRyYXdTaGFwZShcbiAgICAgIHNoYXBlLFxuICAgICAgdGhpcy5fZmlsbFN0eWxlLmNsb25lKCksXG4gICAgICB0aGlzLl9saW5lU3R5bGUuY2xvbmUoKSxcbiAgICAgIHRoaXMuX21hdHJpeFxuICAgICksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgZ3JhcGhpY3MgdGhhdCB3ZXJlIGRyYXduIHRvIHRoaXMgR3JhcGhpY3Mgb2JqZWN0LCBhbmQgcmVzZXRzIGZpbGwgYW5kIGxpbmUgc3R5bGUgc2V0dGluZ3MuXG4gICAqIEByZXR1cm5zIC0gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dlb21ldHJ5LmNsZWFyKCksIHRoaXMuX2xpbmVTdHlsZS5yZXNldCgpLCB0aGlzLl9maWxsU3R5bGUucmVzZXQoKSwgdGhpcy5fYm91bmRzSUQrKywgdGhpcy5fbWF0cml4ID0gbnVsbCwgdGhpcy5faG9sZU1vZGUgPSAhMSwgdGhpcy5jdXJyZW50UGF0aCA9IG51bGwsIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgZ3JhcGhpY3MgY29uc2lzdHMgb2Ygb25lIHJlY3RhbmdsZSwgYW5kIHRodXMsIGNhbiBiZSBkcmF3biBsaWtlIGEgU3ByaXRlIGFuZFxuICAgKiBtYXNrZWQgd2l0aCBnbC5zY2lzc29yLlxuICAgKiBAcmV0dXJucyAtIFRydWUgaWYgb25seSAxIHJlY3QuXG4gICAqL1xuICBpc0Zhc3RSZWN0KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9nZW9tZXRyeS5ncmFwaGljc0RhdGE7XG4gICAgcmV0dXJuIGRhdGEubGVuZ3RoID09PSAxICYmIGRhdGFbMF0uc2hhcGUudHlwZSA9PT0gY29yZS5TSEFQRVMuUkVDVCAmJiAhZGF0YVswXS5tYXRyaXggJiYgIWRhdGFbMF0uaG9sZXMubGVuZ3RoICYmICEoZGF0YVswXS5saW5lU3R5bGUudmlzaWJsZSAmJiBkYXRhWzBdLmxpbmVTdHlsZS53aWR0aCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAqL1xuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5maW5pc2hQb2x5KCk7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcbiAgICBnZW9tZXRyeS51cGRhdGVCYXRjaGVzKCksIGdlb21ldHJ5LmJhdGNoYWJsZSA/ICh0aGlzLmJhdGNoRGlydHkgIT09IGdlb21ldHJ5LmJhdGNoRGlydHkgJiYgdGhpcy5fcG9wdWxhdGVCYXRjaGVzKCksIHRoaXMuX3JlbmRlckJhdGNoZWQocmVuZGVyZXIpKSA6IChyZW5kZXJlci5iYXRjaC5mbHVzaCgpLCB0aGlzLl9yZW5kZXJEaXJlY3QocmVuZGVyZXIpKTtcbiAgfVxuICAvKiogUG9wdWxhdGluZyBiYXRjaGVzIGZvciByZW5kZXJpbmcuICovXG4gIF9wb3B1bGF0ZUJhdGNoZXMoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeSwgYmxlbmRNb2RlID0gdGhpcy5ibGVuZE1vZGUsIGxlbiA9IGdlb21ldHJ5LmJhdGNoZXMubGVuZ3RoO1xuICAgIHRoaXMuYmF0Y2hUaW50ID0gLTEsIHRoaXMuX3RyYW5zZm9ybUlEID0gLTEsIHRoaXMuYmF0Y2hEaXJ0eSA9IGdlb21ldHJ5LmJhdGNoRGlydHksIHRoaXMuYmF0Y2hlcy5sZW5ndGggPSBsZW4sIHRoaXMudmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZ2VvbWV0cnkucG9pbnRzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBnSSA9IGdlb21ldHJ5LmJhdGNoZXNbaV0sIGNvbG9yID0gZ0kuc3R5bGUuY29sb3IsIHZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgICB0aGlzLnZlcnRleERhdGEuYnVmZmVyLFxuICAgICAgICBnSS5hdHRyaWJTdGFydCAqIDQgKiAyLFxuICAgICAgICBnSS5hdHRyaWJTaXplICogMlxuICAgICAgKSwgdXZzID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgZ2VvbWV0cnkudXZzRmxvYXQzMi5idWZmZXIsXG4gICAgICAgIGdJLmF0dHJpYlN0YXJ0ICogNCAqIDIsXG4gICAgICAgIGdJLmF0dHJpYlNpemUgKiAyXG4gICAgICApLCBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFxuICAgICAgICBnZW9tZXRyeS5pbmRpY2VzVWludDE2LmJ1ZmZlcixcbiAgICAgICAgZ0kuc3RhcnQgKiAyLFxuICAgICAgICBnSS5zaXplXG4gICAgICApLCBiYXRjaCA9IHtcbiAgICAgICAgdmVydGV4RGF0YSxcbiAgICAgICAgYmxlbmRNb2RlLFxuICAgICAgICBpbmRpY2VzLFxuICAgICAgICB1dnMsXG4gICAgICAgIF9iYXRjaFJHQjogY29yZS5Db2xvci5zaGFyZWQuc2V0VmFsdWUoY29sb3IpLnRvUmdiQXJyYXkoKSxcbiAgICAgICAgX3RpbnRSR0I6IGNvbG9yLFxuICAgICAgICBfdGV4dHVyZTogZ0kuc3R5bGUudGV4dHVyZSxcbiAgICAgICAgYWxwaGE6IGdJLnN0eWxlLmFscGhhLFxuICAgICAgICB3b3JsZEFscGhhOiAxXG4gICAgICB9O1xuICAgICAgdGhpcy5iYXRjaGVzW2ldID0gYmF0Y2g7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBiYXRjaGVzIHVzaW5nIHRoZSBCYXRoZWRSZW5kZXJlciBwbHVnaW5cbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAqL1xuICBfcmVuZGVyQmF0Y2hlZChyZW5kZXJlcikge1xuICAgIGlmICh0aGlzLmJhdGNoZXMubGVuZ3RoKSB7XG4gICAgICByZW5kZXJlci5iYXRjaC5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0pLCB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCksIHRoaXMuY2FsY3VsYXRlVGludHMoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5iYXRjaGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMuYmF0Y2hlc1tpXTtcbiAgICAgICAgYmF0Y2gud29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYSAqIGJhdGNoLmFscGhhLCByZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0ucmVuZGVyKGJhdGNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGdyYXBoaWNzIGRpcmVjdFxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICovXG4gIF9yZW5kZXJEaXJlY3QocmVuZGVyZXIpIHtcbiAgICBjb25zdCBzaGFkZXIgPSB0aGlzLl9yZXNvbHZlRGlyZWN0U2hhZGVyKHJlbmRlcmVyKSwgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeSwgd29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYSwgdW5pZm9ybXMgPSBzaGFkZXIudW5pZm9ybXMsIGRyYXdDYWxscyA9IGdlb21ldHJ5LmRyYXdDYWxscztcbiAgICB1bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLCBjb3JlLkNvbG9yLnNoYXJlZC5zZXRWYWx1ZSh0aGlzLl90aW50Q29sb3IpLnByZW11bHRpcGx5KHdvcmxkQWxwaGEpLnRvQXJyYXkodW5pZm9ybXMudGludCksIHJlbmRlcmVyLnNoYWRlci5iaW5kKHNoYWRlciksIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQoZ2VvbWV0cnksIHNoYWRlciksIHJlbmRlcmVyLnN0YXRlLnNldCh0aGlzLnN0YXRlKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGRyYXdDYWxscy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLl9yZW5kZXJEcmF3Q2FsbERpcmVjdChyZW5kZXJlciwgZ2VvbWV0cnkuZHJhd0NhbGxzW2ldKTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyBzcGVjaWZpYyBEcmF3Q2FsbFxuICAgKiBAcGFyYW0gcmVuZGVyZXJcbiAgICogQHBhcmFtIGRyYXdDYWxsXG4gICAqL1xuICBfcmVuZGVyRHJhd0NhbGxEaXJlY3QocmVuZGVyZXIsIGRyYXdDYWxsKSB7XG4gICAgY29uc3QgeyB0ZXhBcnJheSwgdHlwZSwgc2l6ZSwgc3RhcnQgfSA9IGRyYXdDYWxsLCBncm91cFRleHR1cmVDb3VudCA9IHRleEFycmF5LmNvdW50O1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ3JvdXBUZXh0dXJlQ291bnQ7IGorKylcbiAgICAgIHJlbmRlcmVyLnRleHR1cmUuYmluZCh0ZXhBcnJheS5lbGVtZW50c1tqXSwgaik7XG4gICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyh0eXBlLCBzaXplLCBzdGFydCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc29sdmVzIHNoYWRlciBmb3IgZGlyZWN0IHJlbmRlcmluZ1xuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICovXG4gIF9yZXNvbHZlRGlyZWN0U2hhZGVyKHJlbmRlcmVyKSB7XG4gICAgbGV0IHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuICAgIGNvbnN0IHBsdWdpbk5hbWUgPSB0aGlzLnBsdWdpbk5hbWU7XG4gICAgaWYgKCFzaGFkZXIpIHtcbiAgICAgIGlmICghREVGQVVMVF9TSEFERVJTW3BsdWdpbk5hbWVdKSB7XG4gICAgICAgIGNvbnN0IHsgbWF4VGV4dHVyZXMgfSA9IHJlbmRlcmVyLnBsdWdpbnNbcGx1Z2luTmFtZV0sIHNhbXBsZVZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KG1heFRleHR1cmVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKVxuICAgICAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGk7XG4gICAgICAgIGNvbnN0IHVuaWZvcm1zID0ge1xuICAgICAgICAgIHRpbnQ6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSxcbiAgICAgICAgICB0cmFuc2xhdGlvbk1hdHJpeDogbmV3IGNvcmUuTWF0cml4KCksXG4gICAgICAgICAgZGVmYXVsdDogY29yZS5Vbmlmb3JtR3JvdXAuZnJvbSh7IHVTYW1wbGVyczogc2FtcGxlVmFsdWVzIH0sICEwKVxuICAgICAgICB9LCBwcm9ncmFtID0gcmVuZGVyZXIucGx1Z2luc1twbHVnaW5OYW1lXS5fc2hhZGVyLnByb2dyYW07XG4gICAgICAgIERFRkFVTFRfU0hBREVSU1twbHVnaW5OYW1lXSA9IG5ldyBjb3JlLlNoYWRlcihwcm9ncmFtLCB1bmlmb3Jtcyk7XG4gICAgICB9XG4gICAgICBzaGFkZXIgPSBERUZBVUxUX1NIQURFUlNbcGx1Z2luTmFtZV07XG4gICAgfVxuICAgIHJldHVybiBzaGFkZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgYm91bmRzIG9mIHRoZSBncmFwaGljIHNoYXBlIGFzIGEgcmVjdGFuZ2xlIG9iamVjdC5cbiAgICogQHNlZSBQSVhJLkdyYXBoaWNzR2VvbWV0cnkjYm91bmRzXG4gICAqL1xuICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgIHRoaXMuZmluaXNoUG9seSgpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cnk7XG4gICAgaWYgKCFnZW9tZXRyeS5ncmFwaGljc0RhdGEubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbWluWCwgbWluWSwgbWF4WCwgbWF4WSB9ID0gZ2VvbWV0cnkuYm91bmRzO1xuICAgIHRoaXMuX2JvdW5kcy5hZGRGcmFtZSh0aGlzLnRyYW5zZm9ybSwgbWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG4gIH1cbiAgLyoqXG4gICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgZ3JhcGhpY3Mgb2JqZWN0XG4gICAqIEBwYXJhbSBwb2ludCAtIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIC0gdGhlIHJlc3VsdCBvZiB0aGUgdGVzdFxuICAgKi9cbiAgY29udGFpbnNQb2ludChwb2ludCkge1xuICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgX0dyYXBoaWNzMi5fVEVNUF9QT0lOVCksIHRoaXMuX2dlb21ldHJ5LmNvbnRhaW5zUG9pbnQoX0dyYXBoaWNzMi5fVEVNUF9QT0lOVCk7XG4gIH1cbiAgLyoqIFJlY2FsY3VsYXRlIHRoZSB0aW50IGJ5IGFwcGx5aW5nIHRpbnQgdG8gYmF0Y2hlcyB1c2luZyBHcmFwaGljcyB0aW50LiAqL1xuICBjYWxjdWxhdGVUaW50cygpIHtcbiAgICBpZiAodGhpcy5iYXRjaFRpbnQgIT09IHRoaXMudGludCkge1xuICAgICAgdGhpcy5iYXRjaFRpbnQgPSB0aGlzLl90aW50Q29sb3IudG9OdW1iZXIoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5iYXRjaGVzW2ldO1xuICAgICAgICBiYXRjaC5fdGludFJHQiA9IGNvcmUuQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHRoaXMuX3RpbnRDb2xvcikubXVsdGlwbHkoYmF0Y2guX2JhdGNoUkdCKS50b0xpdHRsZUVuZGlhbk51bWJlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogSWYgdGhlcmUncyBhIHRyYW5zZm9ybSB1cGRhdGUgb3IgYSBjaGFuZ2UgdG8gdGhlIHNoYXBlIG9mIHRoZSBnZW9tZXRyeSwgcmVjYWxjdWxhdGUgdGhlIHZlcnRpY2VzLiAqL1xuICBjYWxjdWxhdGVWZXJ0aWNlcygpIHtcbiAgICBjb25zdCB3dElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgaWYgKHRoaXMuX3RyYW5zZm9ybUlEID09PSB3dElEKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gd3RJRDtcbiAgICBjb25zdCB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLCBhID0gd3QuYSwgYiA9IHd0LmIsIGMgPSB3dC5jLCBkID0gd3QuZCwgdHggPSB3dC50eCwgdHkgPSB3dC50eSwgZGF0YSA9IHRoaXMuX2dlb21ldHJ5LnBvaW50cywgdmVydGV4RGF0YSA9IHRoaXMudmVydGV4RGF0YTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IGRhdGFbaV0sIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgIHZlcnRleERhdGFbY291bnQrK10gPSBhICogeCArIGMgKiB5ICsgdHgsIHZlcnRleERhdGFbY291bnQrK10gPSBkICogeSArIGIgKiB4ICsgdHk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICogQHJldHVybnMgLSBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNsb3NlUGF0aCgpIHtcbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XG4gICAgcmV0dXJuIGN1cnJlbnRQYXRoICYmIChjdXJyZW50UGF0aC5jbG9zZVN0cm9rZSA9ICEwLCB0aGlzLmZpbmlzaFBvbHkoKSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGx5IGEgbWF0cml4IHRvIHRoZSBwb3NpdGlvbmFsIGRhdGEuXG4gICAqIEBwYXJhbSBtYXRyaXggLSBNYXRyaXggdG8gdXNlIGZvciB0cmFuc2Zvcm0gY3VycmVudCBzaGFwZS5cbiAgICogQHJldHVybnMgLSBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIHNldE1hdHJpeChtYXRyaXgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF0cml4ID0gbWF0cml4LCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBCZWdpbiBhZGRpbmcgaG9sZXMgdG8gdGhlIGxhc3QgZHJhdyBzaGFwZVxuICAgKiBJTVBPUlRBTlQ6IGhvbGVzIG11c3QgYmUgZnVsbHkgaW5zaWRlIGEgc2hhcGUgdG8gd29ya1xuICAgKiBBbHNvIHdlaXJkbmVzcyBlbnN1ZXMgaWYgaG9sZXMgb3ZlcmxhcCFcbiAgICogRWxsaXBzZXMsIENpcmNsZXMsIFJlY3RhbmdsZXMgYW5kIFJvdW5kZWQgUmVjdGFuZ2xlcyBjYW5ub3QgYmUgaG9sZXMgb3IgaG9zdCBmb3IgaG9sZXMgaW4gQ2FudmFzUmVuZGVyZXIsXG4gICAqIHBsZWFzZSB1c2UgYG1vdmVUb2AgYGxpbmVUb2AsIGBxdWFkcmF0aWNDdXJ2ZVRvYCBpZiB5b3UgcmVseSBvbiBwaXhpLWxlZ2FjeSBidW5kbGUuXG4gICAqIEByZXR1cm5zIC0gUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBiZWdpbkhvbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoUG9seSgpLCB0aGlzLl9ob2xlTW9kZSA9ICEwLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBFbmQgYWRkaW5nIGhvbGVzIHRvIHRoZSBsYXN0IGRyYXcgc2hhcGUuXG4gICAqIEByZXR1cm5zIC0gUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBlbmRIb2xlKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFBvbHkoKSwgdGhpcy5faG9sZU1vZGUgPSAhMSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIEdyYXBoaWNzIG9iamVjdC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbFxuICAgKiAgb3B0aW9ucyBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmVcbiAgICogIHRoZWlyIGRlc3Ryb3kgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBPbmx5IHVzZWQgZm9yIGNoaWxkIFNwcml0ZXMgaWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZVxuICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAqICBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIHRoaXMuX2dlb21ldHJ5LnJlZkNvdW50LS0sIHRoaXMuX2dlb21ldHJ5LnJlZkNvdW50ID09PSAwICYmIHRoaXMuX2dlb21ldHJ5LmRpc3Bvc2UoKSwgdGhpcy5fbWF0cml4ID0gbnVsbCwgdGhpcy5jdXJyZW50UGF0aCA9IG51bGwsIHRoaXMuX2xpbmVTdHlsZS5kZXN0cm95KCksIHRoaXMuX2xpbmVTdHlsZSA9IG51bGwsIHRoaXMuX2ZpbGxTdHlsZS5kZXN0cm95KCksIHRoaXMuX2ZpbGxTdHlsZSA9IG51bGwsIHRoaXMuX2dlb21ldHJ5ID0gbnVsbCwgdGhpcy5zaGFkZXIgPSBudWxsLCB0aGlzLnZlcnRleERhdGEgPSBudWxsLCB0aGlzLmJhdGNoZXMubGVuZ3RoID0gMCwgdGhpcy5iYXRjaGVzID0gbnVsbCwgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgfVxufTtcbl9HcmFwaGljcy5jdXJ2ZXMgPSBfY29uc3QuY3VydmVzLCAvKipcbiogVGVtcG9yYXJ5IHBvaW50IHRvIHVzZSBmb3IgY29udGFpbnNQb2ludC5cbiogQHByaXZhdGVcbiovXG5fR3JhcGhpY3MuX1RFTVBfUE9JTlQgPSBuZXcgY29yZS5Qb2ludCgpO1xubGV0IEdyYXBoaWNzID0gX0dyYXBoaWNzO1xuZXhwb3J0cy5HcmFwaGljcyA9IEdyYXBoaWNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY3MuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdyYXBoaWNzRGF0YSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1BJWEkuQ2lyY2xlfFBJWEkuRWxsaXBzZXxQSVhJLlBvbHlnb258UElYSS5SZWN0YW5nbGV8UElYSS5Sb3VuZGVkUmVjdGFuZ2xlfSBzaGFwZSAtIFRoZSBzaGFwZSBvYmplY3QgdG8gZHJhdy5cbiAgICogQHBhcmFtIGZpbGxTdHlsZSAtIHRoZSB3aWR0aCBvZiB0aGUgbGluZSB0byBkcmF3XG4gICAqIEBwYXJhbSBsaW5lU3R5bGUgLSB0aGUgY29sb3Igb2YgdGhlIGxpbmUgdG8gZHJhd1xuICAgKiBAcGFyYW0gbWF0cml4IC0gVHJhbnNmb3JtIG1hdHJpeFxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2hhcGUsIGZpbGxTdHlsZSA9IG51bGwsIGxpbmVTdHlsZSA9IG51bGwsIG1hdHJpeCA9IG51bGwpIHtcbiAgICB0aGlzLnBvaW50cyA9IFtdLCB0aGlzLmhvbGVzID0gW10sIHRoaXMuc2hhcGUgPSBzaGFwZSwgdGhpcy5saW5lU3R5bGUgPSBsaW5lU3R5bGUsIHRoaXMuZmlsbFN0eWxlID0gZmlsbFN0eWxlLCB0aGlzLm1hdHJpeCA9IG1hdHJpeCwgdGhpcy50eXBlID0gc2hhcGUudHlwZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBHcmFwaGljc0RhdGEgb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgb25lLlxuICAgKiBAcmV0dXJucyAtIENsb25lZCBHcmFwaGljc0RhdGEgb2JqZWN0XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IEdyYXBoaWNzRGF0YShcbiAgICAgIHRoaXMuc2hhcGUsXG4gICAgICB0aGlzLmZpbGxTdHlsZSxcbiAgICAgIHRoaXMubGluZVN0eWxlLFxuICAgICAgdGhpcy5tYXRyaXhcbiAgICApO1xuICB9XG4gIC8qKiBEZXN0cm95cyB0aGUgR3JhcGhpY3MgZGF0YS4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnNoYXBlID0gbnVsbCwgdGhpcy5ob2xlcy5sZW5ndGggPSAwLCB0aGlzLmhvbGVzID0gbnVsbCwgdGhpcy5wb2ludHMubGVuZ3RoID0gMCwgdGhpcy5wb2ludHMgPSBudWxsLCB0aGlzLmxpbmVTdHlsZSA9IG51bGwsIHRoaXMuZmlsbFN0eWxlID0gbnVsbDtcbiAgfVxufVxuZXhwb3J0cy5HcmFwaGljc0RhdGEgPSBHcmFwaGljc0RhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljc0RhdGEuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIGRpc3BsYXkgPSByZXF1aXJlKFwiQHBpeGkvZGlzcGxheVwiKSwgR3JhcGhpY3NEYXRhID0gcmVxdWlyZShcIi4vR3JhcGhpY3NEYXRhLmpzXCIpLCBpbmRleCA9IHJlcXVpcmUoXCIuL3V0aWxzL2luZGV4LmpzXCIpLCBCYXRjaFBhcnQgPSByZXF1aXJlKFwiLi91dGlscy9CYXRjaFBhcnQuanNcIiksIGJ1aWxkUG9seSA9IHJlcXVpcmUoXCIuL3V0aWxzL2J1aWxkUG9seS5qc1wiKSwgYnVpbGRMaW5lID0gcmVxdWlyZShcIi4vdXRpbHMvYnVpbGRMaW5lLmpzXCIpO1xuY29uc3QgdG1wUG9pbnQgPSBuZXcgY29yZS5Qb2ludCgpLCBfR3JhcGhpY3NHZW9tZXRyeSA9IGNsYXNzIF9HcmFwaGljc0dlb21ldHJ5MiBleHRlbmRzIGNvcmUuQmF0Y2hHZW9tZXRyeSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlbGVzcy1jb25zdHJ1Y3RvclxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpLCB0aGlzLmNsb3NlUG9pbnRFcHMgPSAxZS00LCB0aGlzLmJvdW5kc1BhZGRpbmcgPSAwLCB0aGlzLnV2c0Zsb2F0MzIgPSBudWxsLCB0aGlzLmluZGljZXNVaW50MTYgPSBudWxsLCB0aGlzLmJhdGNoYWJsZSA9ICExLCB0aGlzLnBvaW50cyA9IFtdLCB0aGlzLmNvbG9ycyA9IFtdLCB0aGlzLnV2cyA9IFtdLCB0aGlzLmluZGljZXMgPSBbXSwgdGhpcy50ZXh0dXJlSWRzID0gW10sIHRoaXMuZ3JhcGhpY3NEYXRhID0gW10sIHRoaXMuZHJhd0NhbGxzID0gW10sIHRoaXMuYmF0Y2hEaXJ0eSA9IC0xLCB0aGlzLmJhdGNoZXMgPSBbXSwgdGhpcy5kaXJ0eSA9IDAsIHRoaXMuY2FjaGVEaXJ0eSA9IC0xLCB0aGlzLmNsZWFyRGlydHkgPSAwLCB0aGlzLnNoYXBlSW5kZXggPSAwLCB0aGlzLl9ib3VuZHMgPSBuZXcgZGlzcGxheS5Cb3VuZHMoKSwgdGhpcy5ib3VuZHNEaXJ0eSA9IC0xO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgYm91bmRzIG9mIHRoZSBncmFwaGljIGdlb21ldHJ5LlxuICAgKlxuICAgKiBTaW5jZSA2LjUuMCwgYm91bmRzIG9mIHRoZSBncmFwaGljcyBnZW9tZXRyeSBhcmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgdmVydGljZXMgb2YgZ2VuZXJhdGVkIGdlb21ldHJ5LlxuICAgKiBTaW5jZSBzaGFwZXMgb3Igc3Ryb2tlcyB3aXRoIGZ1bGwgdHJhbnNwYXJlbmN5IChgYWxwaGE6IDBgKSB3aWxsIG5vdCBnZW5lcmF0ZSBnZW9tZXRyeSwgdGhleSBhcmUgbm90IGNvbnNpZGVyZWRcbiAgICogd2hlbiBjYWxjdWxhdGluZyBib3VuZHMgZm9yIHRoZSBncmFwaGljcyBnZW9tZXRyeS4gU2VlIFBSIFsjODM0M117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpanMvcHVsbC84MzQzfVxuICAgKiBhbmQgaXNzdWUgWyM4NjIzXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL3BpeGlqcy9wdWxsLzg2MjN9LlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBib3VuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlQmF0Y2hlcygpLCB0aGlzLmJvdW5kc0RpcnR5ICE9PSB0aGlzLmRpcnR5ICYmICh0aGlzLmJvdW5kc0RpcnR5ID0gdGhpcy5kaXJ0eSwgdGhpcy5jYWxjdWxhdGVCb3VuZHMoKSksIHRoaXMuX2JvdW5kcztcbiAgfVxuICAvKiogQ2FsbCBpZiB5b3UgY2hhbmdlZCBncmFwaGljc0RhdGEgbWFudWFsbHkuIEVtcHRpZXMgYWxsIGJhdGNoIGJ1ZmZlcnMuICovXG4gIGludmFsaWRhdGUoKSB7XG4gICAgdGhpcy5ib3VuZHNEaXJ0eSA9IC0xLCB0aGlzLmRpcnR5KyssIHRoaXMuYmF0Y2hEaXJ0eSsrLCB0aGlzLnNoYXBlSW5kZXggPSAwLCB0aGlzLnBvaW50cy5sZW5ndGggPSAwLCB0aGlzLmNvbG9ycy5sZW5ndGggPSAwLCB0aGlzLnV2cy5sZW5ndGggPSAwLCB0aGlzLmluZGljZXMubGVuZ3RoID0gMCwgdGhpcy50ZXh0dXJlSWRzLmxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRyYXdDYWxscy5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMuZHJhd0NhbGxzW2ldLnRleEFycmF5LmNsZWFyKCksIGluZGV4LkRSQVdfQ0FMTF9QT09MLnB1c2godGhpcy5kcmF3Q2FsbHNbaV0pO1xuICAgIHRoaXMuZHJhd0NhbGxzLmxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhdGNoUGFydCA9IHRoaXMuYmF0Y2hlc1tpXTtcbiAgICAgIGJhdGNoUGFydC5yZXNldCgpLCBpbmRleC5CQVRDSF9QT09MLnB1c2goYmF0Y2hQYXJ0KTtcbiAgICB9XG4gICAgdGhpcy5iYXRjaGVzLmxlbmd0aCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgZ3JhcGhpY3MgdGhhdCB3ZXJlIGRyYXduIHRvIHRoaXMgR3JhcGhpY3Mgb2JqZWN0LCBhbmQgcmVzZXRzIGZpbGwgYW5kIGxpbmUgc3R5bGUgc2V0dGluZ3MuXG4gICAqIEByZXR1cm5zIC0gVGhpcyBHcmFwaGljc0dlb21ldHJ5IG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoID4gMCAmJiAodGhpcy5pbnZhbGlkYXRlKCksIHRoaXMuY2xlYXJEaXJ0eSsrLCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggPSAwKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgdGhlIGdpdmVuIHNoYXBlIHRvIHRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBDYW4gYmUgYW55IG9mIENpcmNsZSwgUmVjdGFuZ2xlLCBFbGxpcHNlLCBMaW5lIG9yIFBvbHlnb24uXG4gICAqIEBwYXJhbSB7UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJlY3RhbmdsZXxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9IHNoYXBlIC0gVGhlIHNoYXBlIG9iamVjdCB0byBkcmF3LlxuICAgKiBAcGFyYW0gZmlsbFN0eWxlIC0gRGVmaW5lcyBzdHlsZSBvZiB0aGUgZmlsbC5cbiAgICogQHBhcmFtIGxpbmVTdHlsZSAtIERlZmluZXMgc3R5bGUgb2YgdGhlIGxpbmVzLlxuICAgKiBAcGFyYW0gbWF0cml4IC0gVHJhbnNmb3JtIGFwcGxpZWQgdG8gdGhlIHBvaW50cyBvZiB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm5zIC0gUmV0dXJucyBnZW9tZXRyeSBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBkcmF3U2hhcGUoc2hhcGUsIGZpbGxTdHlsZSA9IG51bGwsIGxpbmVTdHlsZSA9IG51bGwsIG1hdHJpeCA9IG51bGwpIHtcbiAgICBjb25zdCBkYXRhID0gbmV3IEdyYXBoaWNzRGF0YS5HcmFwaGljc0RhdGEoc2hhcGUsIGZpbGxTdHlsZSwgbGluZVN0eWxlLCBtYXRyaXgpO1xuICAgIHJldHVybiB0aGlzLmdyYXBoaWNzRGF0YS5wdXNoKGRhdGEpLCB0aGlzLmRpcnR5KyssIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIHRoZSBnaXZlbiBzaGFwZSB0byB0aGlzIEdyYXBoaWNzIG9iamVjdC4gQ2FuIGJlIGFueSBvZiBDaXJjbGUsIFJlY3RhbmdsZSwgRWxsaXBzZSwgTGluZSBvciBQb2x5Z29uLlxuICAgKiBAcGFyYW0ge1BJWEkuQ2lyY2xlfFBJWEkuRWxsaXBzZXxQSVhJLlBvbHlnb258UElYSS5SZWN0YW5nbGV8UElYSS5Sb3VuZGVkUmVjdGFuZ2xlfSBzaGFwZSAtIFRoZSBzaGFwZSBvYmplY3QgdG8gZHJhdy5cbiAgICogQHBhcmFtIG1hdHJpeCAtIFRyYW5zZm9ybSBhcHBsaWVkIHRvIHRoZSBwb2ludHMgb2YgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJucyAtIFJldHVybnMgZ2VvbWV0cnkgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgZHJhd0hvbGUoc2hhcGUsIG1hdHJpeCA9IG51bGwpIHtcbiAgICBpZiAoIXRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgR3JhcGhpY3NEYXRhLkdyYXBoaWNzRGF0YShzaGFwZSwgbnVsbCwgbnVsbCwgbWF0cml4KSwgbGFzdFNoYXBlID0gdGhpcy5ncmFwaGljc0RhdGFbdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGRhdGEubGluZVN0eWxlID0gbGFzdFNoYXBlLmxpbmVTdHlsZSwgbGFzdFNoYXBlLmhvbGVzLnB1c2goZGF0YSksIHRoaXMuZGlydHkrKywgdGhpcztcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIEdyYXBoaWNzR2VvbWV0cnkgb2JqZWN0LiAqL1xuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgdGhpcy5ncmFwaGljc0RhdGFbaV0uZGVzdHJveSgpO1xuICAgIHRoaXMucG9pbnRzLmxlbmd0aCA9IDAsIHRoaXMucG9pbnRzID0gbnVsbCwgdGhpcy5jb2xvcnMubGVuZ3RoID0gMCwgdGhpcy5jb2xvcnMgPSBudWxsLCB0aGlzLnV2cy5sZW5ndGggPSAwLCB0aGlzLnV2cyA9IG51bGwsIHRoaXMuaW5kaWNlcy5sZW5ndGggPSAwLCB0aGlzLmluZGljZXMgPSBudWxsLCB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGwsIHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA9IDAsIHRoaXMuZ3JhcGhpY3NEYXRhID0gbnVsbCwgdGhpcy5kcmF3Q2FsbHMubGVuZ3RoID0gMCwgdGhpcy5kcmF3Q2FsbHMgPSBudWxsLCB0aGlzLmJhdGNoZXMubGVuZ3RoID0gMCwgdGhpcy5iYXRjaGVzID0gbnVsbCwgdGhpcy5fYm91bmRzID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIGEgcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpbiB0aGlzIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0gcG9pbnQgLSBQb2ludCB0byBjaGVjayBpZiBpdCdzIGNvbnRhaW5lZC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpbiBnZW9tZXRyeS5cbiAgICovXG4gIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICBjb25zdCBncmFwaGljc0RhdGEgPSB0aGlzLmdyYXBoaWNzRGF0YTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoaWNzRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZGF0YSA9IGdyYXBoaWNzRGF0YVtpXTtcbiAgICAgIGlmIChkYXRhLmZpbGxTdHlsZS52aXNpYmxlICYmIGRhdGEuc2hhcGUgJiYgKGRhdGEubWF0cml4ID8gZGF0YS5tYXRyaXguYXBwbHlJbnZlcnNlKHBvaW50LCB0bXBQb2ludCkgOiB0bXBQb2ludC5jb3B5RnJvbShwb2ludCksIGRhdGEuc2hhcGUuY29udGFpbnModG1wUG9pbnQueCwgdG1wUG9pbnQueSkpKSB7XG4gICAgICAgIGxldCBoaXRIb2xlID0gITE7XG4gICAgICAgIGlmIChkYXRhLmhvbGVzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGRhdGEuaG9sZXMubGVuZ3RoOyBpMisrKVxuICAgICAgICAgICAgaWYgKGRhdGEuaG9sZXNbaTJdLnNoYXBlLmNvbnRhaW5zKHRtcFBvaW50LngsIHRtcFBvaW50LnkpKSB7XG4gICAgICAgICAgICAgIGhpdEhvbGUgPSAhMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoaXRIb2xlKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgaW50ZXJtZWRpYXRlIGJhdGNoIGRhdGEuIEVpdGhlciBnZXRzIGNvbnZlcnRlZCB0byBkcmF3Q2FsbHNcbiAgICogb3IgdXNlZCB0byBjb252ZXJ0IHRvIGJhdGNoIG9iamVjdHMgZGlyZWN0bHkgYnkgdGhlIEdyYXBoaWNzIG9iamVjdC5cbiAgICovXG4gIHVwZGF0ZUJhdGNoZXMoKSB7XG4gICAgaWYgKCF0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYmF0Y2hhYmxlID0gITA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy52YWxpZGF0ZUJhdGNoaW5nKCkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jYWNoZURpcnR5ID0gdGhpcy5kaXJ0eTtcbiAgICBjb25zdCB1dnMgPSB0aGlzLnV2cywgZ3JhcGhpY3NEYXRhID0gdGhpcy5ncmFwaGljc0RhdGE7XG4gICAgbGV0IGJhdGNoUGFydCA9IG51bGwsIGN1cnJlbnRTdHlsZSA9IG51bGw7XG4gICAgdGhpcy5iYXRjaGVzLmxlbmd0aCA+IDAgJiYgKGJhdGNoUGFydCA9IHRoaXMuYmF0Y2hlc1t0aGlzLmJhdGNoZXMubGVuZ3RoIC0gMV0sIGN1cnJlbnRTdHlsZSA9IGJhdGNoUGFydC5zdHlsZSk7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuc2hhcGVJbmRleDsgaSA8IGdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zaGFwZUluZGV4Kys7XG4gICAgICBjb25zdCBkYXRhID0gZ3JhcGhpY3NEYXRhW2ldLCBmaWxsU3R5bGUgPSBkYXRhLmZpbGxTdHlsZSwgbGluZVN0eWxlID0gZGF0YS5saW5lU3R5bGU7XG4gICAgICBpbmRleC5GSUxMX0NPTU1BTkRTW2RhdGEudHlwZV0uYnVpbGQoZGF0YSksIGRhdGEubWF0cml4ICYmIHRoaXMudHJhbnNmb3JtUG9pbnRzKGRhdGEucG9pbnRzLCBkYXRhLm1hdHJpeCksIChmaWxsU3R5bGUudmlzaWJsZSB8fCBsaW5lU3R5bGUudmlzaWJsZSkgJiYgdGhpcy5wcm9jZXNzSG9sZXMoZGF0YS5ob2xlcyk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI7IGorKykge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGogPT09IDAgPyBmaWxsU3R5bGUgOiBsaW5lU3R5bGU7XG4gICAgICAgIGlmICghc3R5bGUudmlzaWJsZSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbmV4dFRleHR1cmUgPSBzdHlsZS50ZXh0dXJlLmJhc2VUZXh0dXJlLCBpbmRleDIgPSB0aGlzLmluZGljZXMubGVuZ3RoLCBhdHRyaWJJbmRleCA9IHRoaXMucG9pbnRzLmxlbmd0aCAvIDI7XG4gICAgICAgIG5leHRUZXh0dXJlLndyYXBNb2RlID0gY29yZS5XUkFQX01PREVTLlJFUEVBVCwgaiA9PT0gMCA/IHRoaXMucHJvY2Vzc0ZpbGwoZGF0YSkgOiB0aGlzLnByb2Nlc3NMaW5lKGRhdGEpO1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMiAtIGF0dHJpYkluZGV4O1xuICAgICAgICBzaXplICE9PSAwICYmIChiYXRjaFBhcnQgJiYgIXRoaXMuX2NvbXBhcmVTdHlsZXMoY3VycmVudFN0eWxlLCBzdHlsZSkgJiYgKGJhdGNoUGFydC5lbmQoaW5kZXgyLCBhdHRyaWJJbmRleCksIGJhdGNoUGFydCA9IG51bGwpLCBiYXRjaFBhcnQgfHwgKGJhdGNoUGFydCA9IGluZGV4LkJBVENIX1BPT0wucG9wKCkgfHwgbmV3IEJhdGNoUGFydC5CYXRjaFBhcnQoKSwgYmF0Y2hQYXJ0LmJlZ2luKHN0eWxlLCBpbmRleDIsIGF0dHJpYkluZGV4KSwgdGhpcy5iYXRjaGVzLnB1c2goYmF0Y2hQYXJ0KSwgY3VycmVudFN0eWxlID0gc3R5bGUpLCB0aGlzLmFkZFV2cyh0aGlzLnBvaW50cywgdXZzLCBzdHlsZS50ZXh0dXJlLCBhdHRyaWJJbmRleCwgc2l6ZSwgc3R5bGUubWF0cml4KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluZGV4JDEgPSB0aGlzLmluZGljZXMubGVuZ3RoLCBhdHRyaWIgPSB0aGlzLnBvaW50cy5sZW5ndGggLyAyO1xuICAgIGlmIChiYXRjaFBhcnQgJiYgYmF0Y2hQYXJ0LmVuZChpbmRleCQxLCBhdHRyaWIpLCB0aGlzLmJhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmJhdGNoYWJsZSA9ICEwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZWVkMzIgPSBhdHRyaWIgPiA2NTUzNTtcbiAgICB0aGlzLmluZGljZXNVaW50MTYgJiYgdGhpcy5pbmRpY2VzLmxlbmd0aCA9PT0gdGhpcy5pbmRpY2VzVWludDE2Lmxlbmd0aCAmJiBuZWVkMzIgPT09IHRoaXMuaW5kaWNlc1VpbnQxNi5CWVRFU19QRVJfRUxFTUVOVCA+IDIgPyB0aGlzLmluZGljZXNVaW50MTYuc2V0KHRoaXMuaW5kaWNlcykgOiB0aGlzLmluZGljZXNVaW50MTYgPSBuZWVkMzIgPyBuZXcgVWludDMyQXJyYXkodGhpcy5pbmRpY2VzKSA6IG5ldyBVaW50MTZBcnJheSh0aGlzLmluZGljZXMpLCB0aGlzLmJhdGNoYWJsZSA9IHRoaXMuaXNCYXRjaGFibGUoKSwgdGhpcy5iYXRjaGFibGUgPyB0aGlzLnBhY2tCYXRjaGVzKCkgOiB0aGlzLmJ1aWxkRHJhd0NhbGxzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFmZmluaXR5IGNoZWNrXG4gICAqIEBwYXJhbSBzdHlsZUFcbiAgICogQHBhcmFtIHN0eWxlQlxuICAgKi9cbiAgX2NvbXBhcmVTdHlsZXMoc3R5bGVBLCBzdHlsZUIpIHtcbiAgICByZXR1cm4gISghc3R5bGVBIHx8ICFzdHlsZUIgfHwgc3R5bGVBLnRleHR1cmUuYmFzZVRleHR1cmUgIT09IHN0eWxlQi50ZXh0dXJlLmJhc2VUZXh0dXJlIHx8IHN0eWxlQS5jb2xvciArIHN0eWxlQS5hbHBoYSAhPT0gc3R5bGVCLmNvbG9yICsgc3R5bGVCLmFscGhhIHx8ICEhc3R5bGVBLm5hdGl2ZSAhPSAhIXN0eWxlQi5uYXRpdmUpO1xuICB9XG4gIC8qKiBUZXN0IGdlb21ldHJ5IGZvciBiYXRjaGluZyBwcm9jZXNzLiAqL1xuICB2YWxpZGF0ZUJhdGNoaW5nKCkge1xuICAgIGlmICh0aGlzLmRpcnR5ID09PSB0aGlzLmNhY2hlRGlydHkgfHwgIXRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aClcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhW2ldLCBmaWxsID0gZGF0YS5maWxsU3R5bGUsIGxpbmUgPSBkYXRhLmxpbmVTdHlsZTtcbiAgICAgIGlmIChmaWxsICYmICFmaWxsLnRleHR1cmUuYmFzZVRleHR1cmUudmFsaWQgfHwgbGluZSAmJiAhbGluZS50ZXh0dXJlLmJhc2VUZXh0dXJlLnZhbGlkKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKiogT2Zmc2V0IHRoZSBpbmRpY2VzIHNvIHRoYXQgaXQgd29ya3Mgd2l0aCB0aGUgYmF0Y2hlci4gKi9cbiAgcGFja0JhdGNoZXMoKSB7XG4gICAgdGhpcy5iYXRjaERpcnR5KyssIHRoaXMudXZzRmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51dnMpO1xuICAgIGNvbnN0IGJhdGNoZXMgPSB0aGlzLmJhdGNoZXM7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBiYXRjaGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgYmF0Y2ggPSBiYXRjaGVzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiYXRjaC5zaXplOyBqKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXgyID0gYmF0Y2guc3RhcnQgKyBqO1xuICAgICAgICB0aGlzLmluZGljZXNVaW50MTZbaW5kZXgyXSA9IHRoaXMuaW5kaWNlc1VpbnQxNltpbmRleDJdIC0gYmF0Y2guYXR0cmliU3RhcnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoaXMgZ3JhcGhpY3MgZ2VvbWV0cnkgY2FuIGJlIGJhdGNoZWQuXG4gICAqIEN1cnJlbnRseSBpdCBuZWVkcyB0byBiZSBzbWFsbCBlbm91Z2ggYW5kIG5vdCBjb250YWluIGFueSBuYXRpdmUgbGluZXMuXG4gICAqL1xuICBpc0JhdGNoYWJsZSgpIHtcbiAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoID4gNjU1MzUgKiAyKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGJhdGNoZXMgPSB0aGlzLmJhdGNoZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKVxuICAgICAgaWYgKGJhdGNoZXNbaV0uc3R5bGUubmF0aXZlKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzLmxlbmd0aCA8IF9HcmFwaGljc0dlb21ldHJ5Mi5CQVRDSEFCTEVfU0laRSAqIDI7XG4gIH1cbiAgLyoqIENvbnZlcnRzIGludGVybWVkaWF0ZSBiYXRjaGVzIGRhdGEgdG8gZHJhd0NhbGxzLiAqL1xuICBidWlsZERyYXdDYWxscygpIHtcbiAgICBsZXQgVElDSyA9ICsrY29yZS5CYXNlVGV4dHVyZS5fZ2xvYmFsQmF0Y2g7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRyYXdDYWxscy5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMuZHJhd0NhbGxzW2ldLnRleEFycmF5LmNsZWFyKCksIGluZGV4LkRSQVdfQ0FMTF9QT09MLnB1c2godGhpcy5kcmF3Q2FsbHNbaV0pO1xuICAgIHRoaXMuZHJhd0NhbGxzLmxlbmd0aCA9IDA7XG4gICAgY29uc3QgY29sb3JzID0gdGhpcy5jb2xvcnMsIHRleHR1cmVJZHMgPSB0aGlzLnRleHR1cmVJZHM7XG4gICAgbGV0IGN1cnJlbnRHcm91cCA9IGluZGV4LkRSQVdfQ0FMTF9QT09MLnBvcCgpO1xuICAgIGN1cnJlbnRHcm91cCB8fCAoY3VycmVudEdyb3VwID0gbmV3IGNvcmUuQmF0Y2hEcmF3Q2FsbCgpLCBjdXJyZW50R3JvdXAudGV4QXJyYXkgPSBuZXcgY29yZS5CYXRjaFRleHR1cmVBcnJheSgpKSwgY3VycmVudEdyb3VwLnRleEFycmF5LmNvdW50ID0gMCwgY3VycmVudEdyb3VwLnN0YXJ0ID0gMCwgY3VycmVudEdyb3VwLnNpemUgPSAwLCBjdXJyZW50R3JvdXAudHlwZSA9IGNvcmUuRFJBV19NT0RFUy5UUklBTkdMRVM7XG4gICAgbGV0IHRleHR1cmVDb3VudCA9IDAsIGN1cnJlbnRUZXh0dXJlID0gbnVsbCwgdGV4dHVyZUlkID0gMCwgbmF0aXZlID0gITEsIGRyYXdNb2RlID0gY29yZS5EUkFXX01PREVTLlRSSUFOR0xFUywgaW5kZXgkMSA9IDA7XG4gICAgdGhpcy5kcmF3Q2FsbHMucHVzaChjdXJyZW50R3JvdXApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5iYXRjaGVzW2ldLCBtYXhUZXh0dXJlcyA9IDgsIHN0eWxlID0gZGF0YS5zdHlsZSwgbmV4dFRleHR1cmUgPSBzdHlsZS50ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgbmF0aXZlICE9PSAhIXN0eWxlLm5hdGl2ZSAmJiAobmF0aXZlID0gISFzdHlsZS5uYXRpdmUsIGRyYXdNb2RlID0gbmF0aXZlID8gY29yZS5EUkFXX01PREVTLkxJTkVTIDogY29yZS5EUkFXX01PREVTLlRSSUFOR0xFUywgY3VycmVudFRleHR1cmUgPSBudWxsLCB0ZXh0dXJlQ291bnQgPSBtYXhUZXh0dXJlcywgVElDSysrKSwgY3VycmVudFRleHR1cmUgIT09IG5leHRUZXh0dXJlICYmIChjdXJyZW50VGV4dHVyZSA9IG5leHRUZXh0dXJlLCBuZXh0VGV4dHVyZS5fYmF0Y2hFbmFibGVkICE9PSBUSUNLICYmICh0ZXh0dXJlQ291bnQgPT09IG1heFRleHR1cmVzICYmIChUSUNLKyssIHRleHR1cmVDb3VudCA9IDAsIGN1cnJlbnRHcm91cC5zaXplID4gMCAmJiAoY3VycmVudEdyb3VwID0gaW5kZXguRFJBV19DQUxMX1BPT0wucG9wKCksIGN1cnJlbnRHcm91cCB8fCAoY3VycmVudEdyb3VwID0gbmV3IGNvcmUuQmF0Y2hEcmF3Q2FsbCgpLCBjdXJyZW50R3JvdXAudGV4QXJyYXkgPSBuZXcgY29yZS5CYXRjaFRleHR1cmVBcnJheSgpKSwgdGhpcy5kcmF3Q2FsbHMucHVzaChjdXJyZW50R3JvdXApKSwgY3VycmVudEdyb3VwLnN0YXJ0ID0gaW5kZXgkMSwgY3VycmVudEdyb3VwLnNpemUgPSAwLCBjdXJyZW50R3JvdXAudGV4QXJyYXkuY291bnQgPSAwLCBjdXJyZW50R3JvdXAudHlwZSA9IGRyYXdNb2RlKSwgbmV4dFRleHR1cmUudG91Y2hlZCA9IDEsIG5leHRUZXh0dXJlLl9iYXRjaEVuYWJsZWQgPSBUSUNLLCBuZXh0VGV4dHVyZS5fYmF0Y2hMb2NhdGlvbiA9IHRleHR1cmVDb3VudCwgbmV4dFRleHR1cmUud3JhcE1vZGUgPSBjb3JlLldSQVBfTU9ERVMuUkVQRUFULCBjdXJyZW50R3JvdXAudGV4QXJyYXkuZWxlbWVudHNbY3VycmVudEdyb3VwLnRleEFycmF5LmNvdW50KytdID0gbmV4dFRleHR1cmUsIHRleHR1cmVDb3VudCsrKSksIGN1cnJlbnRHcm91cC5zaXplICs9IGRhdGEuc2l6ZSwgaW5kZXgkMSArPSBkYXRhLnNpemUsIHRleHR1cmVJZCA9IG5leHRUZXh0dXJlLl9iYXRjaExvY2F0aW9uLCB0aGlzLmFkZENvbG9ycyhjb2xvcnMsIHN0eWxlLmNvbG9yLCBzdHlsZS5hbHBoYSwgZGF0YS5hdHRyaWJTaXplLCBkYXRhLmF0dHJpYlN0YXJ0KSwgdGhpcy5hZGRUZXh0dXJlSWRzKHRleHR1cmVJZHMsIHRleHR1cmVJZCwgZGF0YS5hdHRyaWJTaXplLCBkYXRhLmF0dHJpYlN0YXJ0KTtcbiAgICB9XG4gICAgY29yZS5CYXNlVGV4dHVyZS5fZ2xvYmFsQmF0Y2ggPSBUSUNLLCB0aGlzLnBhY2tBdHRyaWJ1dGVzKCk7XG4gIH1cbiAgLyoqIFBhY2tzIGF0dHJpYnV0ZXMgdG8gc2luZ2xlIGJ1ZmZlci4gKi9cbiAgcGFja0F0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgdmVydHMgPSB0aGlzLnBvaW50cywgdXZzID0gdGhpcy51dnMsIGNvbG9ycyA9IHRoaXMuY29sb3JzLCB0ZXh0dXJlSWRzID0gdGhpcy50ZXh0dXJlSWRzLCBnbFBvaW50cyA9IG5ldyBBcnJheUJ1ZmZlcih2ZXJ0cy5sZW5ndGggKiAzICogNCksIGYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoZ2xQb2ludHMpLCB1MzIgPSBuZXcgVWludDMyQXJyYXkoZ2xQb2ludHMpO1xuICAgIGxldCBwID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRzLmxlbmd0aCAvIDI7IGkrKylcbiAgICAgIGYzMltwKytdID0gdmVydHNbaSAqIDJdLCBmMzJbcCsrXSA9IHZlcnRzW2kgKiAyICsgMV0sIGYzMltwKytdID0gdXZzW2kgKiAyXSwgZjMyW3ArK10gPSB1dnNbaSAqIDIgKyAxXSwgdTMyW3ArK10gPSBjb2xvcnNbaV0sIGYzMltwKytdID0gdGV4dHVyZUlkc1tpXTtcbiAgICB0aGlzLl9idWZmZXIudXBkYXRlKGdsUG9pbnRzKSwgdGhpcy5faW5kZXhCdWZmZXIudXBkYXRlKHRoaXMuaW5kaWNlc1VpbnQxNik7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgZmlsbCBwYXJ0IG9mIEdyYXBoaWNzLlxuICAgKiBAcGFyYW0gZGF0YVxuICAgKi9cbiAgcHJvY2Vzc0ZpbGwoZGF0YSkge1xuICAgIGRhdGEuaG9sZXMubGVuZ3RoID8gYnVpbGRQb2x5LmJ1aWxkUG9seS50cmlhbmd1bGF0ZShkYXRhLCB0aGlzKSA6IGluZGV4LkZJTExfQ09NTUFORFNbZGF0YS50eXBlXS50cmlhbmd1bGF0ZShkYXRhLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBsaW5lIHBhcnQgb2YgR3JhcGhpY3MuXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqL1xuICBwcm9jZXNzTGluZShkYXRhKSB7XG4gICAgYnVpbGRMaW5lLmJ1aWxkTGluZShkYXRhLCB0aGlzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEuaG9sZXMubGVuZ3RoOyBpKyspXG4gICAgICBidWlsZExpbmUuYnVpbGRMaW5lKGRhdGEuaG9sZXNbaV0sIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBob2xlcyBkYXRhLlxuICAgKiBAcGFyYW0gaG9sZXNcbiAgICovXG4gIHByb2Nlc3NIb2xlcyhob2xlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGhvbGUgPSBob2xlc1tpXTtcbiAgICAgIGluZGV4LkZJTExfQ09NTUFORFNbaG9sZS50eXBlXS5idWlsZChob2xlKSwgaG9sZS5tYXRyaXggJiYgdGhpcy50cmFuc2Zvcm1Qb2ludHMoaG9sZS5wb2ludHMsIGhvbGUubWF0cml4KTtcbiAgICB9XG4gIH1cbiAgLyoqIFVwZGF0ZSB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBvYmplY3QuIEV4cGVuc2l2ZSB0byB1c2UgcGVyZm9ybWFuY2Utd2lzZS4gKi9cbiAgY2FsY3VsYXRlQm91bmRzKCkge1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcbiAgICBib3VuZHMuY2xlYXIoKSwgYm91bmRzLmFkZFZlcnRleERhdGEodGhpcy5wb2ludHMsIDAsIHRoaXMucG9pbnRzLmxlbmd0aCksIGJvdW5kcy5wYWQodGhpcy5ib3VuZHNQYWRkaW5nLCB0aGlzLmJvdW5kc1BhZGRpbmcpO1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gcG9pbnRzIHVzaW5nIG1hdHJpeC5cbiAgICogQHBhcmFtIHBvaW50cyAtIFBvaW50cyB0byB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIG1hdHJpeCAtIFRyYW5zZm9ybSBtYXRyaXhcbiAgICovXG4gIHRyYW5zZm9ybVBvaW50cyhwb2ludHMsIG1hdHJpeCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgY29uc3QgeCA9IHBvaW50c1tpICogMl0sIHkgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIHBvaW50c1tpICogMl0gPSBtYXRyaXguYSAqIHggKyBtYXRyaXguYyAqIHkgKyBtYXRyaXgudHgsIHBvaW50c1tpICogMiArIDFdID0gbWF0cml4LmIgKiB4ICsgbWF0cml4LmQgKiB5ICsgbWF0cml4LnR5O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkIGNvbG9ycy5cbiAgICogQHBhcmFtIGNvbG9ycyAtIExpc3Qgb2YgY29sb3JzIHRvIGFkZCB0b1xuICAgKiBAcGFyYW0gY29sb3IgLSBDb2xvciB0byBhZGRcbiAgICogQHBhcmFtIGFscGhhIC0gQWxwaGEgdG8gdXNlXG4gICAqIEBwYXJhbSBzaXplIC0gTnVtYmVyIG9mIGNvbG9ycyB0byBhZGRcbiAgICogQHBhcmFtIG9mZnNldFxuICAgKi9cbiAgYWRkQ29sb3JzKGNvbG9ycywgY29sb3IsIGFscGhhLCBzaXplLCBvZmZzZXQgPSAwKSB7XG4gICAgY29uc3QgYmdyID0gY29yZS5Db2xvci5zaGFyZWQuc2V0VmFsdWUoY29sb3IpLnRvTGl0dGxlRW5kaWFuTnVtYmVyKCksIHJlc3VsdCA9IGNvcmUuQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGJncikudG9QcmVtdWx0aXBsaWVkKGFscGhhKTtcbiAgICBjb2xvcnMubGVuZ3RoID0gTWF0aC5tYXgoY29sb3JzLmxlbmd0aCwgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspXG4gICAgICBjb2xvcnNbb2Zmc2V0ICsgaV0gPSByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCB0ZXh0dXJlIGlkIHRoYXQgdGhlIHNoYWRlci9mcmFnbWVudCB3YW50cyB0byB1c2UuXG4gICAqIEBwYXJhbSB0ZXh0dXJlSWRzXG4gICAqIEBwYXJhbSBpZFxuICAgKiBAcGFyYW0gc2l6ZVxuICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAqL1xuICBhZGRUZXh0dXJlSWRzKHRleHR1cmVJZHMsIGlkLCBzaXplLCBvZmZzZXQgPSAwKSB7XG4gICAgdGV4dHVyZUlkcy5sZW5ndGggPSBNYXRoLm1heCh0ZXh0dXJlSWRzLmxlbmd0aCwgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspXG4gICAgICB0ZXh0dXJlSWRzW29mZnNldCArIGldID0gaWQ7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgVVZzIGZvciBhIHNoYXBlLlxuICAgKiBAcGFyYW0gdmVydHMgLSBWZXJ0aWNlc1xuICAgKiBAcGFyYW0gdXZzIC0gVVZzXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gUmVmZXJlbmNlIHRvIFRleHR1cmVcbiAgICogQHBhcmFtIHN0YXJ0IC0gSW5kZXggYnVmZmVyIHN0YXJ0IGluZGV4LlxuICAgKiBAcGFyYW0gc2l6ZSAtIFRoZSBzaXplL2xlbmd0aCBmb3IgaW5kZXggYnVmZmVyLlxuICAgKiBAcGFyYW0gbWF0cml4IC0gT3B0aW9uYWwgdHJhbnNmb3JtIGZvciBhbGwgcG9pbnRzLlxuICAgKi9cbiAgYWRkVXZzKHZlcnRzLCB1dnMsIHRleHR1cmUsIHN0YXJ0LCBzaXplLCBtYXRyaXggPSBudWxsKSB7XG4gICAgbGV0IGluZGV4MiA9IDA7XG4gICAgY29uc3QgdXZzU3RhcnQgPSB1dnMubGVuZ3RoLCBmcmFtZSA9IHRleHR1cmUuZnJhbWU7XG4gICAgZm9yICg7IGluZGV4MiA8IHNpemU7ICkge1xuICAgICAgbGV0IHggPSB2ZXJ0c1soc3RhcnQgKyBpbmRleDIpICogMl0sIHkgPSB2ZXJ0c1soc3RhcnQgKyBpbmRleDIpICogMiArIDFdO1xuICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICBjb25zdCBueCA9IG1hdHJpeC5hICogeCArIG1hdHJpeC5jICogeSArIG1hdHJpeC50eDtcbiAgICAgICAgeSA9IG1hdHJpeC5iICogeCArIG1hdHJpeC5kICogeSArIG1hdHJpeC50eSwgeCA9IG54O1xuICAgICAgfVxuICAgICAgaW5kZXgyKyssIHV2cy5wdXNoKHggLyBmcmFtZS53aWR0aCwgeSAvIGZyYW1lLmhlaWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAoZnJhbWUud2lkdGggPCBiYXNlVGV4dHVyZS53aWR0aCB8fCBmcmFtZS5oZWlnaHQgPCBiYXNlVGV4dHVyZS5oZWlnaHQpICYmIHRoaXMuYWRqdXN0VXZzKHV2cywgdGV4dHVyZSwgdXZzU3RhcnQsIHNpemUpO1xuICB9XG4gIC8qKlxuICAgKiBNb2RpZnkgdXZzIGFycmF5IGFjY29yZGluZyB0byBwb3NpdGlvbiBvZiB0ZXh0dXJlIHJlZ2lvblxuICAgKiBEb2VzIG5vdCB3b3JrIHdpdGggcm90YXRlZCBvciB0cmltbWVkIHRleHR1cmVzXG4gICAqIEBwYXJhbSB1dnMgLSBhcnJheVxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIHJlZ2lvblxuICAgKiBAcGFyYW0gc3RhcnQgLSBzdGFydGluZyBpbmRleCBmb3IgdXZzXG4gICAqIEBwYXJhbSBzaXplIC0gaG93IG1hbnkgcG9pbnRzIHRvIGFkanVzdFxuICAgKi9cbiAgYWRqdXN0VXZzKHV2cywgdGV4dHVyZSwgc3RhcnQsIHNpemUpIHtcbiAgICBjb25zdCBiYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmUsIGVwcyA9IDFlLTYsIGZpbmlzaCA9IHN0YXJ0ICsgc2l6ZSAqIDIsIGZyYW1lID0gdGV4dHVyZS5mcmFtZSwgc2NhbGVYID0gZnJhbWUud2lkdGggLyBiYXNlVGV4dHVyZS53aWR0aCwgc2NhbGVZID0gZnJhbWUuaGVpZ2h0IC8gYmFzZVRleHR1cmUuaGVpZ2h0O1xuICAgIGxldCBvZmZzZXRYID0gZnJhbWUueCAvIGZyYW1lLndpZHRoLCBvZmZzZXRZID0gZnJhbWUueSAvIGZyYW1lLmhlaWdodCwgbWluWCA9IE1hdGguZmxvb3IodXZzW3N0YXJ0XSArIGVwcyksIG1pblkgPSBNYXRoLmZsb29yKHV2c1tzdGFydCArIDFdICsgZXBzKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQgKyAyOyBpIDwgZmluaXNoOyBpICs9IDIpXG4gICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgTWF0aC5mbG9vcih1dnNbaV0gKyBlcHMpKSwgbWluWSA9IE1hdGgubWluKG1pblksIE1hdGguZmxvb3IodXZzW2kgKyAxXSArIGVwcykpO1xuICAgIG9mZnNldFggLT0gbWluWCwgb2Zmc2V0WSAtPSBtaW5ZO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGZpbmlzaDsgaSArPSAyKVxuICAgICAgdXZzW2ldID0gKHV2c1tpXSArIG9mZnNldFgpICogc2NhbGVYLCB1dnNbaSArIDFdID0gKHV2c1tpICsgMV0gKyBvZmZzZXRZKSAqIHNjYWxlWTtcbiAgfVxufTtcbl9HcmFwaGljc0dlb21ldHJ5LkJBVENIQUJMRV9TSVpFID0gMTAwO1xubGV0IEdyYXBoaWNzR2VvbWV0cnkgPSBfR3JhcGhpY3NHZW9tZXRyeTtcbmV4cG9ydHMuR3JhcGhpY3NHZW9tZXRyeSA9IEdyYXBoaWNzR2VvbWV0cnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljc0dlb21ldHJ5LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgTElORV9KT0lOID0gLyogQF9fUFVSRV9fICovICgoTElORV9KT0lOMikgPT4gKExJTkVfSk9JTjIuTUlURVIgPSBcIm1pdGVyXCIsIExJTkVfSk9JTjIuQkVWRUwgPSBcImJldmVsXCIsIExJTkVfSk9JTjIuUk9VTkQgPSBcInJvdW5kXCIsIExJTkVfSk9JTjIpKShMSU5FX0pPSU4gfHwge30pLCBMSU5FX0NBUCA9IC8qIEBfX1BVUkVfXyAqLyAoKExJTkVfQ0FQMikgPT4gKExJTkVfQ0FQMi5CVVRUID0gXCJidXR0XCIsIExJTkVfQ0FQMi5ST1VORCA9IFwicm91bmRcIiwgTElORV9DQVAyLlNRVUFSRSA9IFwic3F1YXJlXCIsIExJTkVfQ0FQMikpKExJTkVfQ0FQIHx8IHt9KTtcbmNvbnN0IGN1cnZlcyA9IHtcbiAgYWRhcHRpdmU6ICEwLFxuICBtYXhMZW5ndGg6IDEwLFxuICBtaW5TZWdtZW50czogOCxcbiAgbWF4U2VnbWVudHM6IDIwNDgsXG4gIGVwc2lsb246IDFlLTQsXG4gIF9zZWdtZW50c0NvdW50KGxlbmd0aCwgZGVmYXVsdFNlZ21lbnRzID0gMjApIHtcbiAgICBpZiAoIXRoaXMuYWRhcHRpdmUgfHwgIWxlbmd0aCB8fCBpc05hTihsZW5ndGgpKVxuICAgICAgcmV0dXJuIGRlZmF1bHRTZWdtZW50cztcbiAgICBsZXQgcmVzdWx0ID0gTWF0aC5jZWlsKGxlbmd0aCAvIHRoaXMubWF4TGVuZ3RoKTtcbiAgICByZXR1cm4gcmVzdWx0IDwgdGhpcy5taW5TZWdtZW50cyA/IHJlc3VsdCA9IHRoaXMubWluU2VnbWVudHMgOiByZXN1bHQgPiB0aGlzLm1heFNlZ21lbnRzICYmIChyZXN1bHQgPSB0aGlzLm1heFNlZ21lbnRzKSwgcmVzdWx0O1xuICB9XG59LCBHUkFQSElDU19DVVJWRVMgPSBjdXJ2ZXM7XG5leHBvcnRzLkdSQVBISUNTX0NVUlZFUyA9IEdSQVBISUNTX0NVUlZFUztcbmV4cG9ydHMuTElORV9DQVAgPSBMSU5FX0NBUDtcbmV4cG9ydHMuTElORV9KT0lOID0gTElORV9KT0lOO1xuZXhwb3J0cy5jdXJ2ZXMgPSBjdXJ2ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGluZGV4ID0gcmVxdWlyZShcIi4vdXRpbHMvaW5kZXguanNcIiksIF9jb25zdCA9IHJlcXVpcmUoXCIuL2NvbnN0LmpzXCIpLCBHcmFwaGljcyA9IHJlcXVpcmUoXCIuL0dyYXBoaWNzLmpzXCIpLCBHcmFwaGljc0RhdGEgPSByZXF1aXJlKFwiLi9HcmFwaGljc0RhdGEuanNcIiksIEdyYXBoaWNzR2VvbWV0cnkgPSByZXF1aXJlKFwiLi9HcmFwaGljc0dlb21ldHJ5LmpzXCIpLCBGaWxsU3R5bGUgPSByZXF1aXJlKFwiLi9zdHlsZXMvRmlsbFN0eWxlLmpzXCIpLCBMaW5lU3R5bGUgPSByZXF1aXJlKFwiLi9zdHlsZXMvTGluZVN0eWxlLmpzXCIpLCBidWlsZFBvbHkgPSByZXF1aXJlKFwiLi91dGlscy9idWlsZFBvbHkuanNcIiksIGJ1aWxkQ2lyY2xlID0gcmVxdWlyZShcIi4vdXRpbHMvYnVpbGRDaXJjbGUuanNcIiksIGJ1aWxkUmVjdGFuZ2xlID0gcmVxdWlyZShcIi4vdXRpbHMvYnVpbGRSZWN0YW5nbGUuanNcIiksIGJ1aWxkUm91bmRlZFJlY3RhbmdsZSA9IHJlcXVpcmUoXCIuL3V0aWxzL2J1aWxkUm91bmRlZFJlY3RhbmdsZS5qc1wiKSwgYnVpbGRMaW5lID0gcmVxdWlyZShcIi4vdXRpbHMvYnVpbGRMaW5lLmpzXCIpLCBBcmNVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzL0FyY1V0aWxzLmpzXCIpLCBCZXppZXJVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzL0JlemllclV0aWxzLmpzXCIpLCBRdWFkcmF0aWNVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzL1F1YWRyYXRpY1V0aWxzLmpzXCIpLCBCYXRjaFBhcnQgPSByZXF1aXJlKFwiLi91dGlscy9CYXRjaFBhcnQuanNcIik7XG5jb25zdCBncmFwaGljc1V0aWxzID0ge1xuICBidWlsZFBvbHk6IGJ1aWxkUG9seS5idWlsZFBvbHksXG4gIGJ1aWxkQ2lyY2xlOiBidWlsZENpcmNsZS5idWlsZENpcmNsZSxcbiAgYnVpbGRSZWN0YW5nbGU6IGJ1aWxkUmVjdGFuZ2xlLmJ1aWxkUmVjdGFuZ2xlLFxuICBidWlsZFJvdW5kZWRSZWN0YW5nbGU6IGJ1aWxkUm91bmRlZFJlY3RhbmdsZS5idWlsZFJvdW5kZWRSZWN0YW5nbGUsXG4gIGJ1aWxkTGluZTogYnVpbGRMaW5lLmJ1aWxkTGluZSxcbiAgQXJjVXRpbHM6IEFyY1V0aWxzLkFyY1V0aWxzLFxuICBCZXppZXJVdGlsczogQmV6aWVyVXRpbHMuQmV6aWVyVXRpbHMsXG4gIFF1YWRyYXRpY1V0aWxzOiBRdWFkcmF0aWNVdGlscy5RdWFkcmF0aWNVdGlscyxcbiAgQmF0Y2hQYXJ0OiBCYXRjaFBhcnQuQmF0Y2hQYXJ0LFxuICBGSUxMX0NPTU1BTkRTOiBpbmRleC5GSUxMX0NPTU1BTkRTLFxuICBCQVRDSF9QT09MOiBpbmRleC5CQVRDSF9QT09MLFxuICBEUkFXX0NBTExfUE9PTDogaW5kZXguRFJBV19DQUxMX1BPT0xcbn07XG5leHBvcnRzLkdSQVBISUNTX0NVUlZFUyA9IF9jb25zdC5HUkFQSElDU19DVVJWRVM7XG5leHBvcnRzLkxJTkVfQ0FQID0gX2NvbnN0LkxJTkVfQ0FQO1xuZXhwb3J0cy5MSU5FX0pPSU4gPSBfY29uc3QuTElORV9KT0lOO1xuZXhwb3J0cy5jdXJ2ZXMgPSBfY29uc3QuY3VydmVzO1xuZXhwb3J0cy5HcmFwaGljcyA9IEdyYXBoaWNzLkdyYXBoaWNzO1xuZXhwb3J0cy5HcmFwaGljc0RhdGEgPSBHcmFwaGljc0RhdGEuR3JhcGhpY3NEYXRhO1xuZXhwb3J0cy5HcmFwaGljc0dlb21ldHJ5ID0gR3JhcGhpY3NHZW9tZXRyeS5HcmFwaGljc0dlb21ldHJ5O1xuZXhwb3J0cy5GaWxsU3R5bGUgPSBGaWxsU3R5bGUuRmlsbFN0eWxlO1xuZXhwb3J0cy5MaW5lU3R5bGUgPSBMaW5lU3R5bGUuTGluZVN0eWxlO1xuZXhwb3J0cy5ncmFwaGljc1V0aWxzID0gZ3JhcGhpY3NVdGlscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpO1xuY2xhc3MgRmlsbFN0eWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb2xvciA9IDE2Nzc3MjE1LCB0aGlzLmFscGhhID0gMSwgdGhpcy50ZXh0dXJlID0gY29yZS5UZXh0dXJlLldISVRFLCB0aGlzLm1hdHJpeCA9IG51bGwsIHRoaXMudmlzaWJsZSA9ICExLCB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgLyoqIENsb25lcyB0aGUgb2JqZWN0ICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IG9iaiA9IG5ldyBGaWxsU3R5bGUoKTtcbiAgICByZXR1cm4gb2JqLmNvbG9yID0gdGhpcy5jb2xvciwgb2JqLmFscGhhID0gdGhpcy5hbHBoYSwgb2JqLnRleHR1cmUgPSB0aGlzLnRleHR1cmUsIG9iai5tYXRyaXggPSB0aGlzLm1hdHJpeCwgb2JqLnZpc2libGUgPSB0aGlzLnZpc2libGUsIG9iajtcbiAgfVxuICAvKiogUmVzZXQgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jb2xvciA9IDE2Nzc3MjE1LCB0aGlzLmFscGhhID0gMSwgdGhpcy50ZXh0dXJlID0gY29yZS5UZXh0dXJlLldISVRFLCB0aGlzLm1hdHJpeCA9IG51bGwsIHRoaXMudmlzaWJsZSA9ICExO1xuICB9XG4gIC8qKiBEZXN0cm95IGFuZCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnRleHR1cmUgPSBudWxsLCB0aGlzLm1hdHJpeCA9IG51bGw7XG4gIH1cbn1cbmV4cG9ydHMuRmlsbFN0eWxlID0gRmlsbFN0eWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsbFN0eWxlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2NvbnN0ID0gcmVxdWlyZShcIi4uL2NvbnN0LmpzXCIpLCBGaWxsU3R5bGUgPSByZXF1aXJlKFwiLi9GaWxsU3R5bGUuanNcIik7XG5jbGFzcyBMaW5lU3R5bGUgZXh0ZW5kcyBGaWxsU3R5bGUuRmlsbFN0eWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy53aWR0aCA9IDAsIHRoaXMuYWxpZ25tZW50ID0gMC41LCB0aGlzLm5hdGl2ZSA9ICExLCB0aGlzLmNhcCA9IF9jb25zdC5MSU5FX0NBUC5CVVRULCB0aGlzLmpvaW4gPSBfY29uc3QuTElORV9KT0lOLk1JVEVSLCB0aGlzLm1pdGVyTGltaXQgPSAxMDtcbiAgfVxuICAvKiogQ2xvbmVzIHRoZSBvYmplY3QuICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IG9iaiA9IG5ldyBMaW5lU3R5bGUoKTtcbiAgICByZXR1cm4gb2JqLmNvbG9yID0gdGhpcy5jb2xvciwgb2JqLmFscGhhID0gdGhpcy5hbHBoYSwgb2JqLnRleHR1cmUgPSB0aGlzLnRleHR1cmUsIG9iai5tYXRyaXggPSB0aGlzLm1hdHJpeCwgb2JqLnZpc2libGUgPSB0aGlzLnZpc2libGUsIG9iai53aWR0aCA9IHRoaXMud2lkdGgsIG9iai5hbGlnbm1lbnQgPSB0aGlzLmFsaWdubWVudCwgb2JqLm5hdGl2ZSA9IHRoaXMubmF0aXZlLCBvYmouY2FwID0gdGhpcy5jYXAsIG9iai5qb2luID0gdGhpcy5qb2luLCBvYmoubWl0ZXJMaW1pdCA9IHRoaXMubWl0ZXJMaW1pdCwgb2JqO1xuICB9XG4gIC8qKiBSZXNldCB0aGUgbGluZSBzdHlsZSB0byBkZWZhdWx0LiAqL1xuICByZXNldCgpIHtcbiAgICBzdXBlci5yZXNldCgpLCB0aGlzLmNvbG9yID0gMCwgdGhpcy5hbGlnbm1lbnQgPSAwLjUsIHRoaXMud2lkdGggPSAwLCB0aGlzLm5hdGl2ZSA9ICExLCB0aGlzLmNhcCA9IF9jb25zdC5MSU5FX0NBUC5CVVRULCB0aGlzLmpvaW4gPSBfY29uc3QuTElORV9KT0lOLk1JVEVSLCB0aGlzLm1pdGVyTGltaXQgPSAxMDtcbiAgfVxufVxuZXhwb3J0cy5MaW5lU3R5bGUgPSBMaW5lU3R5bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lU3R5bGUuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIF9jb25zdCA9IHJlcXVpcmUoXCIuLi9jb25zdC5qc1wiKTtcbmNsYXNzIEFyY1V0aWxzIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBpbmZvcm1hdGlvbiBvZiB0aGUgYXJjIGZvciB7QGxpbmsgUElYSS5HcmFwaGljcy5hcmNUb30uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB4MSAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgb2YgdGhlIGFyY1xuICAgKiBAcGFyYW0geTEgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IG9mIHRoZSBhcmNcbiAgICogQHBhcmFtIHgyIC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb2YgdGhlIGFyY1xuICAgKiBAcGFyYW0geTIgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvZiB0aGUgYXJjXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBhcmNcbiAgICogQHBhcmFtIHBvaW50cyAtIENvbGxlY3Rpb24gb2YgcG9pbnRzIHRvIGFkZCB0b1xuICAgKiBAcmV0dXJucyAtIElmIHRoZSBhcmMgbGVuZ3RoIGlzIHZhbGlkLCByZXR1cm4gY2VudGVyIG9mIGNpcmNsZSwgcmFkaXVzIGFuZCBvdGhlciBpbmZvIG90aGVyd2lzZSBgbnVsbGAuXG4gICAqL1xuICBzdGF0aWMgY3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzLCBwb2ludHMpIHtcbiAgICBjb25zdCBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIGExID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSAtIHkxLCBiMSA9IGZyb21YIC0geDEsIGEyID0geTIgLSB5MSwgYjIgPSB4MiAtIHgxLCBtbSA9IE1hdGguYWJzKGExICogYjIgLSBiMSAqIGEyKTtcbiAgICBpZiAobW0gPCAxZS04IHx8IHJhZGl1cyA9PT0gMClcbiAgICAgIHJldHVybiAocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSAhPT0geDEgfHwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSAhPT0geTEpICYmIHBvaW50cy5wdXNoKHgxLCB5MSksIG51bGw7XG4gICAgY29uc3QgZGQgPSBhMSAqIGExICsgYjEgKiBiMSwgY2MgPSBhMiAqIGEyICsgYjIgKiBiMiwgdHQgPSBhMSAqIGEyICsgYjEgKiBiMiwgazEgPSByYWRpdXMgKiBNYXRoLnNxcnQoZGQpIC8gbW0sIGsyID0gcmFkaXVzICogTWF0aC5zcXJ0KGNjKSAvIG1tLCBqMSA9IGsxICogdHQgLyBkZCwgajIgPSBrMiAqIHR0IC8gY2MsIGN4ID0gazEgKiBiMiArIGsyICogYjEsIGN5ID0gazEgKiBhMiArIGsyICogYTEsIHB4ID0gYjEgKiAoazIgKyBqMSksIHB5ID0gYTEgKiAoazIgKyBqMSksIHF4ID0gYjIgKiAoazEgKyBqMiksIHF5ID0gYTIgKiAoazEgKyBqMiksIHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKHB5IC0gY3ksIHB4IC0gY3gpLCBlbmRBbmdsZSA9IE1hdGguYXRhbjIocXkgLSBjeSwgcXggLSBjeCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN4OiBjeCArIHgxLFxuICAgICAgY3k6IGN5ICsgeTEsXG4gICAgICByYWRpdXMsXG4gICAgICBzdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUsXG4gICAgICBhbnRpY2xvY2t3aXNlOiBiMSAqIGEyID4gYjIgKiBhMVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhcmMgbWV0aG9kIGNyZWF0ZXMgYW4gYXJjL2N1cnZlICh1c2VkIHRvIGNyZWF0ZSBjaXJjbGVzLCBvciBwYXJ0cyBvZiBjaXJjbGVzKS5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIF9zdGFydFggLSBTdGFydCB4IGxvY2F0aW9uIG9mIGFyY1xuICAgKiBAcGFyYW0gX3N0YXJ0WSAtIFN0YXJ0IHkgbG9jYXRpb24gb2YgYXJjXG4gICAqIEBwYXJhbSBjeCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gICAqIEBwYXJhbSBjeSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICogQHBhcmFtIHN0YXJ0QW5nbGUgLSBUaGUgc3RhcnRpbmcgYW5nbGUsIGluIHJhZGlhbnMgKDAgaXMgYXQgdGhlIDMgbydjbG9jayBwb3NpdGlvblxuICAgKiAgb2YgdGhlIGFyYydzIGNpcmNsZSlcbiAgICogQHBhcmFtIGVuZEFuZ2xlIC0gVGhlIGVuZGluZyBhbmdsZSwgaW4gcmFkaWFuc1xuICAgKiBAcGFyYW0gX2FudGljbG9ja3dpc2UgLSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZHJhd2luZyBzaG91bGQgYmVcbiAgICogIGNvdW50ZXItY2xvY2t3aXNlIG9yIGNsb2Nrd2lzZS4gRmFsc2UgaXMgZGVmYXVsdCwgYW5kIGluZGljYXRlcyBjbG9ja3dpc2UsIHdoaWxlIHRydWVcbiAgICogIGluZGljYXRlcyBjb3VudGVyLWNsb2Nrd2lzZS5cbiAgICogQHBhcmFtIHBvaW50cyAtIENvbGxlY3Rpb24gb2YgcG9pbnRzIHRvIGFkZCB0b1xuICAgKi9cbiAgc3RhdGljIGFyYyhfc3RhcnRYLCBfc3RhcnRZLCBjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIF9hbnRpY2xvY2t3aXNlLCBwb2ludHMpIHtcbiAgICBjb25zdCBzd2VlcCA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSwgbiA9IF9jb25zdC5jdXJ2ZXMuX3NlZ21lbnRzQ291bnQoXG4gICAgICBNYXRoLmFicyhzd2VlcCkgKiByYWRpdXMsXG4gICAgICBNYXRoLmNlaWwoTWF0aC5hYnMoc3dlZXApIC8gY29yZS5QSV8yKSAqIDQwXG4gICAgKSwgdGhldGEgPSBzd2VlcCAvIChuICogMiksIHRoZXRhMiA9IHRoZXRhICogMiwgY1RoZXRhID0gTWF0aC5jb3ModGhldGEpLCBzVGhldGEgPSBNYXRoLnNpbih0aGV0YSksIHNlZ01pbnVzID0gbiAtIDEsIHJlbWFpbmRlciA9IHNlZ01pbnVzICUgMSAvIHNlZ01pbnVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHNlZ01pbnVzOyArK2kpIHtcbiAgICAgIGNvbnN0IHJlYWwgPSBpICsgcmVtYWluZGVyICogaSwgYW5nbGUgPSB0aGV0YSArIHN0YXJ0QW5nbGUgKyB0aGV0YTIgKiByZWFsLCBjID0gTWF0aC5jb3MoYW5nbGUpLCBzID0gLU1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHBvaW50cy5wdXNoKFxuICAgICAgICAoY1RoZXRhICogYyArIHNUaGV0YSAqIHMpICogcmFkaXVzICsgY3gsXG4gICAgICAgIChjVGhldGEgKiAtcyArIHNUaGV0YSAqIGMpICogcmFkaXVzICsgY3lcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLkFyY1V0aWxzID0gQXJjVXRpbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcmNVdGlscy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgQmF0Y2hQYXJ0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG4gIC8qKlxuICAgKiBCZWdpbiBiYXRjaCBwYXJ0LlxuICAgKiBAcGFyYW0gc3R5bGVcbiAgICogQHBhcmFtIHN0YXJ0SW5kZXhcbiAgICogQHBhcmFtIGF0dHJpYlN0YXJ0XG4gICAqL1xuICBiZWdpbihzdHlsZSwgc3RhcnRJbmRleCwgYXR0cmliU3RhcnQpIHtcbiAgICB0aGlzLnJlc2V0KCksIHRoaXMuc3R5bGUgPSBzdHlsZSwgdGhpcy5zdGFydCA9IHN0YXJ0SW5kZXgsIHRoaXMuYXR0cmliU3RhcnQgPSBhdHRyaWJTdGFydDtcbiAgfVxuICAvKipcbiAgICogRW5kIGJhdGNoIHBhcnQuXG4gICAqIEBwYXJhbSBlbmRJbmRleFxuICAgKiBAcGFyYW0gZW5kQXR0cmliXG4gICAqL1xuICBlbmQoZW5kSW5kZXgsIGVuZEF0dHJpYikge1xuICAgIHRoaXMuYXR0cmliU2l6ZSA9IGVuZEF0dHJpYiAtIHRoaXMuYXR0cmliU3RhcnQsIHRoaXMuc2l6ZSA9IGVuZEluZGV4IC0gdGhpcy5zdGFydDtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnN0eWxlID0gbnVsbCwgdGhpcy5zaXplID0gMCwgdGhpcy5zdGFydCA9IDAsIHRoaXMuYXR0cmliU3RhcnQgPSAwLCB0aGlzLmF0dHJpYlNpemUgPSAwO1xuICB9XG59XG5leHBvcnRzLkJhdGNoUGFydCA9IEJhdGNoUGFydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoUGFydC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9jb25zdCA9IHJlcXVpcmUoXCIuLi9jb25zdC5qc1wiKTtcbmNsYXNzIEJlemllclV0aWxzIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBsZW5ndGggb2YgYmV6aWVyIGN1cnZlLlxuICAgKiBBbmFseXRpY2FsIHNvbHV0aW9uIGlzIGltcG9zc2libGUsIHNpbmNlIGl0IGludm9sdmVzIGFuIGludGVncmFsIHRoYXQgZG9lcyBub3QgaW50ZWdyYXRlIGluIGdlbmVyYWwuXG4gICAqIFRoZXJlZm9yZSBudW1lcmljYWwgc29sdXRpb24gaXMgdXNlZC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGZyb21YIC0gU3RhcnRpbmcgcG9pbnQgeFxuICAgKiBAcGFyYW0gZnJvbVkgLSBTdGFydGluZyBwb2ludCB5XG4gICAqIEBwYXJhbSBjcFggLSBDb250cm9sIHBvaW50IHhcbiAgICogQHBhcmFtIGNwWSAtIENvbnRyb2wgcG9pbnQgeVxuICAgKiBAcGFyYW0gY3BYMiAtIFNlY29uZCBDb250cm9sIHBvaW50IHhcbiAgICogQHBhcmFtIGNwWTIgLSBTZWNvbmQgQ29udHJvbCBwb2ludCB5XG4gICAqIEBwYXJhbSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XG4gICAqIEBwYXJhbSB0b1kgLSBEZXN0aW5hdGlvbiBwb2ludCB5XG4gICAqIEByZXR1cm5zIC0gTGVuZ3RoIG9mIGJlemllciBjdXJ2ZVxuICAgKi9cbiAgc3RhdGljIGN1cnZlTGVuZ3RoKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZKSB7XG4gICAgbGV0IHJlc3VsdCA9IDAsIHQgPSAwLCB0MiA9IDAsIHQzID0gMCwgbnQgPSAwLCBudDIgPSAwLCBudDMgPSAwLCB4ID0gMCwgeSA9IDAsIGR4ID0gMCwgZHkgPSAwLCBwcmV2WCA9IGZyb21YLCBwcmV2WSA9IGZyb21ZO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IDEwOyArK2kpXG4gICAgICB0ID0gaSAvIDEwLCB0MiA9IHQgKiB0LCB0MyA9IHQyICogdCwgbnQgPSAxIC0gdCwgbnQyID0gbnQgKiBudCwgbnQzID0gbnQyICogbnQsIHggPSBudDMgKiBmcm9tWCArIDMgKiBudDIgKiB0ICogY3BYICsgMyAqIG50ICogdDIgKiBjcFgyICsgdDMgKiB0b1gsIHkgPSBudDMgKiBmcm9tWSArIDMgKiBudDIgKiB0ICogY3BZICsgMyAqIG50ICogdDIgKiBjcFkyICsgdDMgKiB0b1ksIGR4ID0gcHJldlggLSB4LCBkeSA9IHByZXZZIC0geSwgcHJldlggPSB4LCBwcmV2WSA9IHksIHJlc3VsdCArPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIGJlemllciBjdXJ2ZSBhbmQgdGhlbiBkcmF3cyBpdC5cbiAgICpcbiAgICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4gICAqIEBpZ25vcmVcbiAgICogQHBhcmFtIGNwWCAtIENvbnRyb2wgcG9pbnQgeFxuICAgKiBAcGFyYW0gY3BZIC0gQ29udHJvbCBwb2ludCB5XG4gICAqIEBwYXJhbSBjcFgyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeFxuICAgKiBAcGFyYW0gY3BZMiAtIFNlY29uZCBDb250cm9sIHBvaW50IHlcbiAgICogQHBhcmFtIHRvWCAtIERlc3RpbmF0aW9uIHBvaW50IHhcbiAgICogQHBhcmFtIHRvWSAtIERlc3RpbmF0aW9uIHBvaW50IHlcbiAgICogQHBhcmFtIHBvaW50cyAtIFBhdGggYXJyYXkgdG8gcHVzaCBwb2ludHMgaW50b1xuICAgKi9cbiAgc3RhdGljIGN1cnZlVG8oY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZLCBwb2ludHMpIHtcbiAgICBjb25zdCBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICBwb2ludHMubGVuZ3RoIC09IDI7XG4gICAgY29uc3QgbiA9IF9jb25zdC5jdXJ2ZXMuX3NlZ21lbnRzQ291bnQoXG4gICAgICBCZXppZXJVdGlscy5jdXJ2ZUxlbmd0aChmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSlcbiAgICApO1xuICAgIGxldCBkdCA9IDAsIGR0MiA9IDAsIGR0MyA9IDAsIHQyID0gMCwgdDMgPSAwO1xuICAgIHBvaW50cy5wdXNoKGZyb21YLCBmcm9tWSk7XG4gICAgZm9yIChsZXQgaSA9IDEsIGogPSAwOyBpIDw9IG47ICsraSlcbiAgICAgIGogPSBpIC8gbiwgZHQgPSAxIC0gaiwgZHQyID0gZHQgKiBkdCwgZHQzID0gZHQyICogZHQsIHQyID0gaiAqIGosIHQzID0gdDIgKiBqLCBwb2ludHMucHVzaChcbiAgICAgICAgZHQzICogZnJvbVggKyAzICogZHQyICogaiAqIGNwWCArIDMgKiBkdCAqIHQyICogY3BYMiArIHQzICogdG9YLFxuICAgICAgICBkdDMgKiBmcm9tWSArIDMgKiBkdDIgKiBqICogY3BZICsgMyAqIGR0ICogdDIgKiBjcFkyICsgdDMgKiB0b1lcbiAgICAgICk7XG4gIH1cbn1cbmV4cG9ydHMuQmV6aWVyVXRpbHMgPSBCZXppZXJVdGlscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJlemllclV0aWxzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2NvbnN0ID0gcmVxdWlyZShcIi4uL2NvbnN0LmpzXCIpO1xuY2xhc3MgUXVhZHJhdGljVXRpbHMge1xuICAvKipcbiAgICogQ2FsY3VsYXRlIGxlbmd0aCBvZiBxdWFkcmF0aWMgY3VydmVcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5tYWxjemFrLmxpbnV4cGwuY29tL2Jsb2cvcXVhZHJhdGljLWJlemllci1jdXJ2ZS1sZW5ndGgvfVxuICAgKiBmb3IgdGhlIGRldGFpbGVkIGV4cGxhbmF0aW9uIG9mIG1hdGggYmVoaW5kIHRoaXMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBmcm9tWCAtIHgtY29vcmRpbmF0ZSBvZiBjdXJ2ZSBzdGFydCBwb2ludFxuICAgKiBAcGFyYW0gZnJvbVkgLSB5LWNvb3JkaW5hdGUgb2YgY3VydmUgc3RhcnQgcG9pbnRcbiAgICogQHBhcmFtIGNwWCAtIHgtY29vcmRpbmF0ZSBvZiBjdXJ2ZSBjb250cm9sIHBvaW50XG4gICAqIEBwYXJhbSBjcFkgLSB5LWNvb3JkaW5hdGUgb2YgY3VydmUgY29udHJvbCBwb2ludFxuICAgKiBAcGFyYW0gdG9YIC0geC1jb29yZGluYXRlIG9mIGN1cnZlIGVuZCBwb2ludFxuICAgKiBAcGFyYW0gdG9ZIC0geS1jb29yZGluYXRlIG9mIGN1cnZlIGVuZCBwb2ludFxuICAgKiBAcmV0dXJucyAtIExlbmd0aCBvZiBxdWFkcmF0aWMgY3VydmVcbiAgICovXG4gIHN0YXRpYyBjdXJ2ZUxlbmd0aChmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCB0b1gsIHRvWSkge1xuICAgIGNvbnN0IGF4ID0gZnJvbVggLSAyICogY3BYICsgdG9YLCBheSA9IGZyb21ZIC0gMiAqIGNwWSArIHRvWSwgYnggPSAyICogY3BYIC0gMiAqIGZyb21YLCBieSA9IDIgKiBjcFkgLSAyICogZnJvbVksIGEgPSA0ICogKGF4ICogYXggKyBheSAqIGF5KSwgYiA9IDQgKiAoYXggKiBieCArIGF5ICogYnkpLCBjID0gYnggKiBieCArIGJ5ICogYnksIHMgPSAyICogTWF0aC5zcXJ0KGEgKyBiICsgYyksIGEyID0gTWF0aC5zcXJ0KGEpLCBhMzIgPSAyICogYSAqIGEyLCBjMiA9IDIgKiBNYXRoLnNxcnQoYyksIGJhID0gYiAvIGEyO1xuICAgIHJldHVybiAoYTMyICogcyArIGEyICogYiAqIChzIC0gYzIpICsgKDQgKiBjICogYSAtIGIgKiBiKSAqIE1hdGgubG9nKCgyICogYTIgKyBiYSArIHMpIC8gKGJhICsgYzIpKSkgLyAoNCAqIGEzMik7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXG4gICAqIEJhc2VkIG9uOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODUwOTcvaG93LWRvLWktaW1wbGVtZW50LWEtYmV6aWVyLWN1cnZlLWluLWNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGNwWCAtIENvbnRyb2wgcG9pbnQgeFxuICAgKiBAcGFyYW0gY3BZIC0gQ29udHJvbCBwb2ludCB5XG4gICAqIEBwYXJhbSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XG4gICAqIEBwYXJhbSB0b1kgLSBEZXN0aW5hdGlvbiBwb2ludCB5XG4gICAqIEBwYXJhbSBwb2ludHMgLSBQb2ludHMgdG8gYWRkIHNlZ21lbnRzIHRvLlxuICAgKi9cbiAgc3RhdGljIGN1cnZlVG8oY3BYLCBjcFksIHRvWCwgdG9ZLCBwb2ludHMpIHtcbiAgICBjb25zdCBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSwgbiA9IF9jb25zdC5jdXJ2ZXMuX3NlZ21lbnRzQ291bnQoXG4gICAgICBRdWFkcmF0aWNVdGlscy5jdXJ2ZUxlbmd0aChmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCB0b1gsIHRvWSlcbiAgICApO1xuICAgIGxldCB4YSA9IDAsIHlhID0gMDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGNvbnN0IGogPSBpIC8gbjtcbiAgICAgIHhhID0gZnJvbVggKyAoY3BYIC0gZnJvbVgpICogaiwgeWEgPSBmcm9tWSArIChjcFkgLSBmcm9tWSkgKiBqLCBwb2ludHMucHVzaChcbiAgICAgICAgeGEgKyAoY3BYICsgKHRvWCAtIGNwWCkgKiBqIC0geGEpICogaixcbiAgICAgICAgeWEgKyAoY3BZICsgKHRvWSAtIGNwWSkgKiBqIC0geWEpICogalxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuUXVhZHJhdGljVXRpbHMgPSBRdWFkcmF0aWNVdGlscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1YWRyYXRpY1V0aWxzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpO1xuY29uc3QgYnVpbGRDaXJjbGUgPSB7XG4gIGJ1aWxkKGdyYXBoaWNzRGF0YSkge1xuICAgIGNvbnN0IHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgbGV0IHgsIHksIGR4LCBkeSwgcngsIHJ5O1xuICAgIGlmIChncmFwaGljc0RhdGEudHlwZSA9PT0gY29yZS5TSEFQRVMuQ0lSQykge1xuICAgICAgY29uc3QgY2lyY2xlID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgICAgeCA9IGNpcmNsZS54LCB5ID0gY2lyY2xlLnksIHJ4ID0gcnkgPSBjaXJjbGUucmFkaXVzLCBkeCA9IGR5ID0gMDtcbiAgICB9IGVsc2UgaWYgKGdyYXBoaWNzRGF0YS50eXBlID09PSBjb3JlLlNIQVBFUy5FTElQKSB7XG4gICAgICBjb25zdCBlbGxpcHNlID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgICAgeCA9IGVsbGlwc2UueCwgeSA9IGVsbGlwc2UueSwgcnggPSBlbGxpcHNlLndpZHRoLCByeSA9IGVsbGlwc2UuaGVpZ2h0LCBkeCA9IGR5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgcm91bmRlZFJlY3QgPSBncmFwaGljc0RhdGEuc2hhcGUsIGhhbGZXaWR0aCA9IHJvdW5kZWRSZWN0LndpZHRoIC8gMiwgaGFsZkhlaWdodCA9IHJvdW5kZWRSZWN0LmhlaWdodCAvIDI7XG4gICAgICB4ID0gcm91bmRlZFJlY3QueCArIGhhbGZXaWR0aCwgeSA9IHJvdW5kZWRSZWN0LnkgKyBoYWxmSGVpZ2h0LCByeCA9IHJ5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocm91bmRlZFJlY3QucmFkaXVzLCBNYXRoLm1pbihoYWxmV2lkdGgsIGhhbGZIZWlnaHQpKSksIGR4ID0gaGFsZldpZHRoIC0gcngsIGR5ID0gaGFsZkhlaWdodCAtIHJ5O1xuICAgIH1cbiAgICBpZiAoIShyeCA+PSAwICYmIHJ5ID49IDAgJiYgZHggPj0gMCAmJiBkeSA+PSAwKSkge1xuICAgICAgcG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG4gPSBNYXRoLmNlaWwoMi4zICogTWF0aC5zcXJ0KHJ4ICsgcnkpKSwgbSA9IG4gKiA4ICsgKGR4ID8gNCA6IDApICsgKGR5ID8gNCA6IDApO1xuICAgIGlmIChwb2ludHMubGVuZ3RoID0gbSwgbSA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgcG9pbnRzLmxlbmd0aCA9IDgsIHBvaW50c1swXSA9IHBvaW50c1s2XSA9IHggKyBkeCwgcG9pbnRzWzFdID0gcG9pbnRzWzNdID0geSArIGR5LCBwb2ludHNbMl0gPSBwb2ludHNbNF0gPSB4IC0gZHgsIHBvaW50c1s1XSA9IHBvaW50c1s3XSA9IHkgLSBkeTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGoxID0gMCwgajIgPSBuICogNCArIChkeCA/IDIgOiAwKSArIDIsIGozID0gajIsIGo0ID0gbTtcbiAgICB7XG4gICAgICBjb25zdCB4MCA9IGR4ICsgcngsIHkwID0gZHksIHgxID0geCArIHgwLCB4MiA9IHggLSB4MCwgeTEgPSB5ICsgeTA7XG4gICAgICBpZiAocG9pbnRzW2oxKytdID0geDEsIHBvaW50c1tqMSsrXSA9IHkxLCBwb2ludHNbLS1qMl0gPSB5MSwgcG9pbnRzWy0tajJdID0geDIsIGR5KSB7XG4gICAgICAgIGNvbnN0IHkyID0geSAtIHkwO1xuICAgICAgICBwb2ludHNbajMrK10gPSB4MiwgcG9pbnRzW2ozKytdID0geTIsIHBvaW50c1stLWo0XSA9IHkyLCBwb2ludHNbLS1qNF0gPSB4MTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IGEgPSBNYXRoLlBJIC8gMiAqIChpIC8gbiksIHgwID0gZHggKyBNYXRoLmNvcyhhKSAqIHJ4LCB5MCA9IGR5ICsgTWF0aC5zaW4oYSkgKiByeSwgeDEgPSB4ICsgeDAsIHgyID0geCAtIHgwLCB5MSA9IHkgKyB5MCwgeTIgPSB5IC0geTA7XG4gICAgICBwb2ludHNbajErK10gPSB4MSwgcG9pbnRzW2oxKytdID0geTEsIHBvaW50c1stLWoyXSA9IHkxLCBwb2ludHNbLS1qMl0gPSB4MiwgcG9pbnRzW2ozKytdID0geDIsIHBvaW50c1tqMysrXSA9IHkyLCBwb2ludHNbLS1qNF0gPSB5MiwgcG9pbnRzWy0tajRdID0geDE7XG4gICAgfVxuICAgIHtcbiAgICAgIGNvbnN0IHgwID0gZHgsIHkwID0gZHkgKyByeSwgeDEgPSB4ICsgeDAsIHgyID0geCAtIHgwLCB5MSA9IHkgKyB5MCwgeTIgPSB5IC0geTA7XG4gICAgICBwb2ludHNbajErK10gPSB4MSwgcG9pbnRzW2oxKytdID0geTEsIHBvaW50c1stLWo0XSA9IHkyLCBwb2ludHNbLS1qNF0gPSB4MSwgZHggJiYgKHBvaW50c1tqMSsrXSA9IHgyLCBwb2ludHNbajErK10gPSB5MSwgcG9pbnRzWy0tajRdID0geTIsIHBvaW50c1stLWo0XSA9IHgyKTtcbiAgICB9XG4gIH0sXG4gIHRyaWFuZ3VsYXRlKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICAgIGNvbnN0IHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHMsIHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHMsIGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgbGV0IHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyAyO1xuICAgIGNvbnN0IGNlbnRlciA9IHZlcnRQb3M7XG4gICAgbGV0IHgsIHk7XG4gICAgaWYgKGdyYXBoaWNzRGF0YS50eXBlICE9PSBjb3JlLlNIQVBFUy5SUkVDKSB7XG4gICAgICBjb25zdCBjaXJjbGUgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgICB4ID0gY2lyY2xlLngsIHkgPSBjaXJjbGUueTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgcm91bmRlZFJlY3QgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgICB4ID0gcm91bmRlZFJlY3QueCArIHJvdW5kZWRSZWN0LndpZHRoIC8gMiwgeSA9IHJvdW5kZWRSZWN0LnkgKyByb3VuZGVkUmVjdC5oZWlnaHQgLyAyO1xuICAgIH1cbiAgICBjb25zdCBtYXRyaXggPSBncmFwaGljc0RhdGEubWF0cml4O1xuICAgIHZlcnRzLnB1c2goXG4gICAgICBncmFwaGljc0RhdGEubWF0cml4ID8gbWF0cml4LmEgKiB4ICsgbWF0cml4LmMgKiB5ICsgbWF0cml4LnR4IDogeCxcbiAgICAgIGdyYXBoaWNzRGF0YS5tYXRyaXggPyBtYXRyaXguYiAqIHggKyBtYXRyaXguZCAqIHkgKyBtYXRyaXgudHkgOiB5XG4gICAgKSwgdmVydFBvcysrLCB2ZXJ0cy5wdXNoKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMilcbiAgICAgIHZlcnRzLnB1c2gocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKSwgaW5kaWNlcy5wdXNoKHZlcnRQb3MrKywgY2VudGVyLCB2ZXJ0UG9zKTtcbiAgICBpbmRpY2VzLnB1c2goY2VudGVyICsgMSwgY2VudGVyLCB2ZXJ0UG9zKTtcbiAgfVxufTtcbmV4cG9ydHMuYnVpbGRDaXJjbGUgPSBidWlsZENpcmNsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkQ2lyY2xlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCBfY29uc3QgPSByZXF1aXJlKFwiLi4vY29uc3QuanNcIik7XG5mdW5jdGlvbiBzcXVhcmUoeCwgeSwgbngsIG55LCBpbm5lcldlaWdodCwgb3V0ZXJXZWlnaHQsIGNsb2Nrd2lzZSwgdmVydHMpIHtcbiAgY29uc3QgaXggPSB4IC0gbnggKiBpbm5lcldlaWdodCwgaXkgPSB5IC0gbnkgKiBpbm5lcldlaWdodCwgb3ggPSB4ICsgbnggKiBvdXRlcldlaWdodCwgb3kgPSB5ICsgbnkgKiBvdXRlcldlaWdodDtcbiAgbGV0IGV4eCwgZXl5O1xuICBjbG9ja3dpc2UgPyAoZXh4ID0gbnksIGV5eSA9IC1ueCkgOiAoZXh4ID0gLW55LCBleXkgPSBueCk7XG4gIGNvbnN0IGVpeCA9IGl4ICsgZXh4LCBlaXkgPSBpeSArIGV5eSwgZW94ID0gb3ggKyBleHgsIGVveSA9IG95ICsgZXl5O1xuICByZXR1cm4gdmVydHMucHVzaChcbiAgICBlaXgsXG4gICAgZWl5LFxuICAgIGVveCxcbiAgICBlb3lcbiAgKSwgMjtcbn1cbmZ1bmN0aW9uIHJvdW5kKGN4LCBjeSwgc3gsIHN5LCBleCwgZXksIHZlcnRzLCBjbG9ja3dpc2UpIHtcbiAgY29uc3QgY3gycDB4ID0gc3ggLSBjeCwgY3kycDB5ID0gc3kgLSBjeTtcbiAgbGV0IGFuZ2xlMCA9IE1hdGguYXRhbjIoY3gycDB4LCBjeTJwMHkpLCBhbmdsZTEgPSBNYXRoLmF0YW4yKGV4IC0gY3gsIGV5IC0gY3kpO1xuICBjbG9ja3dpc2UgJiYgYW5nbGUwIDwgYW5nbGUxID8gYW5nbGUwICs9IE1hdGguUEkgKiAyIDogIWNsb2Nrd2lzZSAmJiBhbmdsZTAgPiBhbmdsZTEgJiYgKGFuZ2xlMSArPSBNYXRoLlBJICogMik7XG4gIGxldCBzdGFydEFuZ2xlID0gYW5nbGUwO1xuICBjb25zdCBhbmdsZURpZmYgPSBhbmdsZTEgLSBhbmdsZTAsIGFic0FuZ2xlRGlmZiA9IE1hdGguYWJzKGFuZ2xlRGlmZiksIHJhZGl1cyA9IE1hdGguc3FydChjeDJwMHggKiBjeDJwMHggKyBjeTJwMHkgKiBjeTJwMHkpLCBzZWdDb3VudCA9ICgxNSAqIGFic0FuZ2xlRGlmZiAqIE1hdGguc3FydChyYWRpdXMpIC8gTWF0aC5QSSA+PiAwKSArIDEsIGFuZ2xlSW5jID0gYW5nbGVEaWZmIC8gc2VnQ291bnQ7XG4gIGlmIChzdGFydEFuZ2xlICs9IGFuZ2xlSW5jLCBjbG9ja3dpc2UpIHtcbiAgICB2ZXJ0cy5wdXNoKFxuICAgICAgY3gsXG4gICAgICBjeSxcbiAgICAgIHN4LFxuICAgICAgc3lcbiAgICApO1xuICAgIGZvciAobGV0IGkgPSAxLCBhbmdsZSA9IHN0YXJ0QW5nbGU7IGkgPCBzZWdDb3VudDsgaSsrLCBhbmdsZSArPSBhbmdsZUluYylcbiAgICAgIHZlcnRzLnB1c2goXG4gICAgICAgIGN4LFxuICAgICAgICBjeSxcbiAgICAgICAgY3ggKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICAgIGN5ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzXG4gICAgICApO1xuICAgIHZlcnRzLnB1c2goXG4gICAgICBjeCxcbiAgICAgIGN5LFxuICAgICAgZXgsXG4gICAgICBleVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgdmVydHMucHVzaChcbiAgICAgIHN4LFxuICAgICAgc3ksXG4gICAgICBjeCxcbiAgICAgIGN5XG4gICAgKTtcbiAgICBmb3IgKGxldCBpID0gMSwgYW5nbGUgPSBzdGFydEFuZ2xlOyBpIDwgc2VnQ291bnQ7IGkrKywgYW5nbGUgKz0gYW5nbGVJbmMpXG4gICAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICBjeCArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgICAgY3kgKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICAgIGN4LFxuICAgICAgICBjeVxuICAgICAgKTtcbiAgICB2ZXJ0cy5wdXNoKFxuICAgICAgZXgsXG4gICAgICBleSxcbiAgICAgIGN4LFxuICAgICAgY3lcbiAgICApO1xuICB9XG4gIHJldHVybiBzZWdDb3VudCAqIDI7XG59XG5mdW5jdGlvbiBidWlsZE5vbk5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gIGNvbnN0IHNoYXBlID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICBsZXQgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cyB8fCBzaGFwZS5wb2ludHMuc2xpY2UoKTtcbiAgY29uc3QgZXBzID0gZ3JhcGhpY3NHZW9tZXRyeS5jbG9zZVBvaW50RXBzO1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm47XG4gIGNvbnN0IHN0eWxlID0gZ3JhcGhpY3NEYXRhLmxpbmVTdHlsZSwgZmlyc3RQb2ludCA9IG5ldyBjb3JlLlBvaW50KHBvaW50c1swXSwgcG9pbnRzWzFdKSwgbGFzdFBvaW50ID0gbmV3IGNvcmUuUG9pbnQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSksIGNsb3NlZFNoYXBlID0gc2hhcGUudHlwZSAhPT0gY29yZS5TSEFQRVMuUE9MWSB8fCBzaGFwZS5jbG9zZVN0cm9rZSwgY2xvc2VkUGF0aCA9IE1hdGguYWJzKGZpcnN0UG9pbnQueCAtIGxhc3RQb2ludC54KSA8IGVwcyAmJiBNYXRoLmFicyhmaXJzdFBvaW50LnkgLSBsYXN0UG9pbnQueSkgPCBlcHM7XG4gIGlmIChjbG9zZWRTaGFwZSkge1xuICAgIHBvaW50cyA9IHBvaW50cy5zbGljZSgpLCBjbG9zZWRQYXRoICYmIChwb2ludHMucG9wKCksIHBvaW50cy5wb3AoKSwgbGFzdFBvaW50LnNldChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKSk7XG4gICAgY29uc3QgbWlkUG9pbnRYID0gKGZpcnN0UG9pbnQueCArIGxhc3RQb2ludC54KSAqIDAuNSwgbWlkUG9pbnRZID0gKGxhc3RQb2ludC55ICsgZmlyc3RQb2ludC55KSAqIDAuNTtcbiAgICBwb2ludHMudW5zaGlmdChtaWRQb2ludFgsIG1pZFBvaW50WSksIHBvaW50cy5wdXNoKG1pZFBvaW50WCwgbWlkUG9pbnRZKTtcbiAgfVxuICBjb25zdCB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzLCBsZW5ndGggPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgbGV0IGluZGV4Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCBpbmRleFN0YXJ0ID0gdmVydHMubGVuZ3RoIC8gMiwgd2lkdGggPSBzdHlsZS53aWR0aCAvIDIsIHdpZHRoU3F1YXJlZCA9IHdpZHRoICogd2lkdGgsIG1pdGVyTGltaXRTcXVhcmVkID0gc3R5bGUubWl0ZXJMaW1pdCAqIHN0eWxlLm1pdGVyTGltaXQ7XG4gIGxldCB4MCA9IHBvaW50c1swXSwgeTAgPSBwb2ludHNbMV0sIHgxID0gcG9pbnRzWzJdLCB5MSA9IHBvaW50c1szXSwgeDIgPSAwLCB5MiA9IDAsIHBlcnB4ID0gLSh5MCAtIHkxKSwgcGVycHkgPSB4MCAtIHgxLCBwZXJwMXggPSAwLCBwZXJwMXkgPSAwLCBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4ICogcGVycHggKyBwZXJweSAqIHBlcnB5KTtcbiAgcGVycHggLz0gZGlzdCwgcGVycHkgLz0gZGlzdCwgcGVycHggKj0gd2lkdGgsIHBlcnB5ICo9IHdpZHRoO1xuICBjb25zdCByYXRpbyA9IHN0eWxlLmFsaWdubWVudCwgaW5uZXJXZWlnaHQgPSAoMSAtIHJhdGlvKSAqIDIsIG91dGVyV2VpZ2h0ID0gcmF0aW8gKiAyO1xuICBjbG9zZWRTaGFwZSB8fCAoc3R5bGUuY2FwID09PSBfY29uc3QuTElORV9DQVAuUk9VTkQgPyBpbmRleENvdW50ICs9IHJvdW5kKFxuICAgIHgwIC0gcGVycHggKiAoaW5uZXJXZWlnaHQgLSBvdXRlcldlaWdodCkgKiAwLjUsXG4gICAgeTAgLSBwZXJweSAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSxcbiAgICB4MCAtIHBlcnB4ICogaW5uZXJXZWlnaHQsXG4gICAgeTAgLSBwZXJweSAqIGlubmVyV2VpZ2h0LFxuICAgIHgwICsgcGVycHggKiBvdXRlcldlaWdodCxcbiAgICB5MCArIHBlcnB5ICogb3V0ZXJXZWlnaHQsXG4gICAgdmVydHMsXG4gICAgITBcbiAgKSArIDIgOiBzdHlsZS5jYXAgPT09IF9jb25zdC5MSU5FX0NBUC5TUVVBUkUgJiYgKGluZGV4Q291bnQgKz0gc3F1YXJlKHgwLCB5MCwgcGVycHgsIHBlcnB5LCBpbm5lcldlaWdodCwgb3V0ZXJXZWlnaHQsICEwLCB2ZXJ0cykpKSwgdmVydHMucHVzaChcbiAgICB4MCAtIHBlcnB4ICogaW5uZXJXZWlnaHQsXG4gICAgeTAgLSBwZXJweSAqIGlubmVyV2VpZ2h0LFxuICAgIHgwICsgcGVycHggKiBvdXRlcldlaWdodCxcbiAgICB5MCArIHBlcnB5ICogb3V0ZXJXZWlnaHRcbiAgKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGggLSAxOyArK2kpIHtcbiAgICB4MCA9IHBvaW50c1soaSAtIDEpICogMl0sIHkwID0gcG9pbnRzWyhpIC0gMSkgKiAyICsgMV0sIHgxID0gcG9pbnRzW2kgKiAyXSwgeTEgPSBwb2ludHNbaSAqIDIgKyAxXSwgeDIgPSBwb2ludHNbKGkgKyAxKSAqIDJdLCB5MiA9IHBvaW50c1soaSArIDEpICogMiArIDFdLCBwZXJweCA9IC0oeTAgLSB5MSksIHBlcnB5ID0geDAgLSB4MSwgZGlzdCA9IE1hdGguc3FydChwZXJweCAqIHBlcnB4ICsgcGVycHkgKiBwZXJweSksIHBlcnB4IC89IGRpc3QsIHBlcnB5IC89IGRpc3QsIHBlcnB4ICo9IHdpZHRoLCBwZXJweSAqPSB3aWR0aCwgcGVycDF4ID0gLSh5MSAtIHkyKSwgcGVycDF5ID0geDEgLSB4MiwgZGlzdCA9IE1hdGguc3FydChwZXJwMXggKiBwZXJwMXggKyBwZXJwMXkgKiBwZXJwMXkpLCBwZXJwMXggLz0gZGlzdCwgcGVycDF5IC89IGRpc3QsIHBlcnAxeCAqPSB3aWR0aCwgcGVycDF5ICo9IHdpZHRoO1xuICAgIGNvbnN0IGR4MCA9IHgxIC0geDAsIGR5MCA9IHkwIC0geTEsIGR4MSA9IHgxIC0geDIsIGR5MSA9IHkyIC0geTEsIGRvdCA9IGR4MCAqIGR4MSArIGR5MCAqIGR5MSwgY3Jvc3MgPSBkeTAgKiBkeDEgLSBkeTEgKiBkeDAsIGNsb2Nrd2lzZSA9IGNyb3NzIDwgMDtcbiAgICBpZiAoTWF0aC5hYnMoY3Jvc3MpIDwgMWUtMyAqIE1hdGguYWJzKGRvdCkpIHtcbiAgICAgIHZlcnRzLnB1c2goXG4gICAgICAgIHgxIC0gcGVycHggKiBpbm5lcldlaWdodCxcbiAgICAgICAgeTEgLSBwZXJweSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB4MSArIHBlcnB4ICogb3V0ZXJXZWlnaHQsXG4gICAgICAgIHkxICsgcGVycHkgKiBvdXRlcldlaWdodFxuICAgICAgKSwgZG90ID49IDAgJiYgKHN0eWxlLmpvaW4gPT09IF9jb25zdC5MSU5FX0pPSU4uUk9VTkQgPyBpbmRleENvdW50ICs9IHJvdW5kKFxuICAgICAgICB4MSxcbiAgICAgICAgeTEsXG4gICAgICAgIHgxIC0gcGVycHggKiBpbm5lcldlaWdodCxcbiAgICAgICAgeTEgLSBwZXJweSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB2ZXJ0cyxcbiAgICAgICAgITFcbiAgICAgICkgKyA0IDogaW5kZXhDb3VudCArPSAyLCB2ZXJ0cy5wdXNoKFxuICAgICAgICB4MSAtIHBlcnAxeCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICB5MSAtIHBlcnAxeSAqIG91dGVyV2VpZ2h0LFxuICAgICAgICB4MSArIHBlcnAxeCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB5MSArIHBlcnAxeSAqIGlubmVyV2VpZ2h0XG4gICAgICApKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjMSA9ICgtcGVycHggKyB4MCkgKiAoLXBlcnB5ICsgeTEpIC0gKC1wZXJweCArIHgxKSAqICgtcGVycHkgKyB5MCksIGMyID0gKC1wZXJwMXggKyB4MikgKiAoLXBlcnAxeSArIHkxKSAtICgtcGVycDF4ICsgeDEpICogKC1wZXJwMXkgKyB5MiksIHB4ID0gKGR4MCAqIGMyIC0gZHgxICogYzEpIC8gY3Jvc3MsIHB5ID0gKGR5MSAqIGMxIC0gZHkwICogYzIpIC8gY3Jvc3MsIHBkaXN0ID0gKHB4IC0geDEpICogKHB4IC0geDEpICsgKHB5IC0geTEpICogKHB5IC0geTEpLCBpbXggPSB4MSArIChweCAtIHgxKSAqIGlubmVyV2VpZ2h0LCBpbXkgPSB5MSArIChweSAtIHkxKSAqIGlubmVyV2VpZ2h0LCBvbXggPSB4MSAtIChweCAtIHgxKSAqIG91dGVyV2VpZ2h0LCBvbXkgPSB5MSAtIChweSAtIHkxKSAqIG91dGVyV2VpZ2h0LCBzbWFsbGVySW5zaWRlU2VnbWVudFNxID0gTWF0aC5taW4oZHgwICogZHgwICsgZHkwICogZHkwLCBkeDEgKiBkeDEgKyBkeTEgKiBkeTEpLCBpbnNpZGVXZWlnaHQgPSBjbG9ja3dpc2UgPyBpbm5lcldlaWdodCA6IG91dGVyV2VpZ2h0LCBzbWFsbGVySW5zaWRlRGlhZ29uYWxTcSA9IHNtYWxsZXJJbnNpZGVTZWdtZW50U3EgKyBpbnNpZGVXZWlnaHQgKiBpbnNpZGVXZWlnaHQgKiB3aWR0aFNxdWFyZWQsIGluc2lkZU1pdGVyT2sgPSBwZGlzdCA8PSBzbWFsbGVySW5zaWRlRGlhZ29uYWxTcTtcbiAgICBsZXQgam9pbiA9IHN0eWxlLmpvaW47XG4gICAgaWYgKGpvaW4gPT09IF9jb25zdC5MSU5FX0pPSU4uTUlURVIgJiYgcGRpc3QgLyB3aWR0aFNxdWFyZWQgPiBtaXRlckxpbWl0U3F1YXJlZCAmJiAoam9pbiA9IF9jb25zdC5MSU5FX0pPSU4uQkVWRUwpLCBpbnNpZGVNaXRlck9rKVxuICAgICAgc3dpdGNoIChqb2luKSB7XG4gICAgICAgIGNhc2UgX2NvbnN0LkxJTkVfSk9JTi5NSVRFUjoge1xuICAgICAgICAgIHZlcnRzLnB1c2goXG4gICAgICAgICAgICBpbXgsXG4gICAgICAgICAgICBpbXksXG4gICAgICAgICAgICBvbXgsXG4gICAgICAgICAgICBvbXlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgX2NvbnN0LkxJTkVfSk9JTi5CRVZFTDoge1xuICAgICAgICAgIGNsb2Nrd2lzZSA/IHZlcnRzLnB1c2goXG4gICAgICAgICAgICBpbXgsXG4gICAgICAgICAgICBpbXksXG4gICAgICAgICAgICAvLyBpbm5lciBtaXRlciBwb2ludFxuICAgICAgICAgICAgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgLy8gZmlyc3Qgc2VnbWVudCdzIG91dGVyIHZlcnRleFxuICAgICAgICAgICAgaW14LFxuICAgICAgICAgICAgaW15LFxuICAgICAgICAgICAgLy8gaW5uZXIgbWl0ZXIgcG9pbnRcbiAgICAgICAgICAgIHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSArIHBlcnAxeSAqIG91dGVyV2VpZ2h0XG4gICAgICAgICAgKSA6IHZlcnRzLnB1c2goXG4gICAgICAgICAgICB4MSAtIHBlcnB4ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICAvLyBmaXJzdCBzZWdtZW50J3MgaW5uZXIgdmVydGV4XG4gICAgICAgICAgICBvbXgsXG4gICAgICAgICAgICBvbXksXG4gICAgICAgICAgICAvLyBvdXRlciBtaXRlciBwb2ludFxuICAgICAgICAgICAgeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICAvLyBzZWNvbmQgc2VnbWVudCdzIG91dGVyIHZlcnRleFxuICAgICAgICAgICAgb214LFxuICAgICAgICAgICAgb215XG4gICAgICAgICAgKSwgaW5kZXhDb3VudCArPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgX2NvbnN0LkxJTkVfSk9JTi5ST1VORDoge1xuICAgICAgICAgIGNsb2Nrd2lzZSA/ICh2ZXJ0cy5wdXNoKFxuICAgICAgICAgICAgaW14LFxuICAgICAgICAgICAgaW15LFxuICAgICAgICAgICAgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0XG4gICAgICAgICAgKSwgaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICB4MSArIHBlcnB4ICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSArIHBlcnB5ICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB4MSArIHBlcnAxeCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgKyBwZXJwMXkgKiBvdXRlcldlaWdodCxcbiAgICAgICAgICAgIHZlcnRzLFxuICAgICAgICAgICAgITBcbiAgICAgICAgICApICsgNCwgdmVydHMucHVzaChcbiAgICAgICAgICAgIGlteCxcbiAgICAgICAgICAgIGlteSxcbiAgICAgICAgICAgIHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSArIHBlcnAxeSAqIG91dGVyV2VpZ2h0XG4gICAgICAgICAgKSkgOiAodmVydHMucHVzaChcbiAgICAgICAgICAgIHgxIC0gcGVycHggKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHkxIC0gcGVycHkgKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIG9teCxcbiAgICAgICAgICAgIG9teVxuICAgICAgICAgICksIGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgeDEgLSBwZXJweCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgLSBwZXJweSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB2ZXJ0cyxcbiAgICAgICAgICAgICExXG4gICAgICAgICAgKSArIDQsIHZlcnRzLnB1c2goXG4gICAgICAgICAgICB4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIG9teCxcbiAgICAgICAgICAgIG9teVxuICAgICAgICAgICkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzd2l0Y2ggKHZlcnRzLnB1c2goXG4gICAgICAgIHgxIC0gcGVycHggKiBpbm5lcldlaWdodCxcbiAgICAgICAgeTEgLSBwZXJweSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAvLyBmaXJzdCBzZWdtZW50J3MgaW5uZXIgdmVydGV4XG4gICAgICAgIHgxICsgcGVycHggKiBvdXRlcldlaWdodCxcbiAgICAgICAgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0XG4gICAgICApLCBqb2luKSB7XG4gICAgICAgIGNhc2UgX2NvbnN0LkxJTkVfSk9JTi5NSVRFUjoge1xuICAgICAgICAgIGNsb2Nrd2lzZSA/IHZlcnRzLnB1c2goXG4gICAgICAgICAgICBvbXgsXG4gICAgICAgICAgICBvbXksXG4gICAgICAgICAgICAvLyBpbm5lciBtaXRlciBwb2ludFxuICAgICAgICAgICAgb214LFxuICAgICAgICAgICAgb215XG4gICAgICAgICAgKSA6IHZlcnRzLnB1c2goXG4gICAgICAgICAgICBpbXgsXG4gICAgICAgICAgICBpbXksXG4gICAgICAgICAgICAvLyBvdXRlciBtaXRlciBwb2ludFxuICAgICAgICAgICAgaW14LFxuICAgICAgICAgICAgaW15XG4gICAgICAgICAgKSwgaW5kZXhDb3VudCArPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgX2NvbnN0LkxJTkVfSk9JTi5ST1VORDoge1xuICAgICAgICAgIGNsb2Nrd2lzZSA/IGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeDEgKyBwZXJwMXggKiBvdXRlcldlaWdodCxcbiAgICAgICAgICAgIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB2ZXJ0cyxcbiAgICAgICAgICAgICEwXG4gICAgICAgICAgKSArIDIgOiBpbmRleENvdW50ICs9IHJvdW5kKFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIHgxIC0gcGVycHggKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHkxIC0gcGVycHkgKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHgxIC0gcGVycDF4ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgdmVydHMsXG4gICAgICAgICAgICAhMVxuICAgICAgICAgICkgKyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICB4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAvLyBzZWNvbmQgc2VnbWVudCdzIGlubmVyIHZlcnRleFxuICAgICAgICB4MSArIHBlcnAxeCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICB5MSArIHBlcnAxeSAqIG91dGVyV2VpZ2h0XG4gICAgICApLCBpbmRleENvdW50ICs9IDI7XG4gICAgfVxuICB9XG4gIHgwID0gcG9pbnRzWyhsZW5ndGggLSAyKSAqIDJdLCB5MCA9IHBvaW50c1sobGVuZ3RoIC0gMikgKiAyICsgMV0sIHgxID0gcG9pbnRzWyhsZW5ndGggLSAxKSAqIDJdLCB5MSA9IHBvaW50c1sobGVuZ3RoIC0gMSkgKiAyICsgMV0sIHBlcnB4ID0gLSh5MCAtIHkxKSwgcGVycHkgPSB4MCAtIHgxLCBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4ICogcGVycHggKyBwZXJweSAqIHBlcnB5KSwgcGVycHggLz0gZGlzdCwgcGVycHkgLz0gZGlzdCwgcGVycHggKj0gd2lkdGgsIHBlcnB5ICo9IHdpZHRoLCB2ZXJ0cy5wdXNoKFxuICAgIHgxIC0gcGVycHggKiBpbm5lcldlaWdodCxcbiAgICB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsXG4gICAgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LFxuICAgIHkxICsgcGVycHkgKiBvdXRlcldlaWdodFxuICApLCBjbG9zZWRTaGFwZSB8fCAoc3R5bGUuY2FwID09PSBfY29uc3QuTElORV9DQVAuUk9VTkQgPyBpbmRleENvdW50ICs9IHJvdW5kKFxuICAgIHgxIC0gcGVycHggKiAoaW5uZXJXZWlnaHQgLSBvdXRlcldlaWdodCkgKiAwLjUsXG4gICAgeTEgLSBwZXJweSAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSxcbiAgICB4MSAtIHBlcnB4ICogaW5uZXJXZWlnaHQsXG4gICAgeTEgLSBwZXJweSAqIGlubmVyV2VpZ2h0LFxuICAgIHgxICsgcGVycHggKiBvdXRlcldlaWdodCxcbiAgICB5MSArIHBlcnB5ICogb3V0ZXJXZWlnaHQsXG4gICAgdmVydHMsXG4gICAgITFcbiAgKSArIDIgOiBzdHlsZS5jYXAgPT09IF9jb25zdC5MSU5FX0NBUC5TUVVBUkUgJiYgKGluZGV4Q291bnQgKz0gc3F1YXJlKHgxLCB5MSwgcGVycHgsIHBlcnB5LCBpbm5lcldlaWdodCwgb3V0ZXJXZWlnaHQsICExLCB2ZXJ0cykpKTtcbiAgY29uc3QgaW5kaWNlcyA9IGdyYXBoaWNzR2VvbWV0cnkuaW5kaWNlcywgZXBzMiA9IF9jb25zdC5jdXJ2ZXMuZXBzaWxvbiAqIF9jb25zdC5jdXJ2ZXMuZXBzaWxvbjtcbiAgZm9yIChsZXQgaSA9IGluZGV4U3RhcnQ7IGkgPCBpbmRleENvdW50ICsgaW5kZXhTdGFydCAtIDI7ICsraSlcbiAgICB4MCA9IHZlcnRzW2kgKiAyXSwgeTAgPSB2ZXJ0c1tpICogMiArIDFdLCB4MSA9IHZlcnRzWyhpICsgMSkgKiAyXSwgeTEgPSB2ZXJ0c1soaSArIDEpICogMiArIDFdLCB4MiA9IHZlcnRzWyhpICsgMikgKiAyXSwgeTIgPSB2ZXJ0c1soaSArIDIpICogMiArIDFdLCAhKE1hdGguYWJzKHgwICogKHkxIC0geTIpICsgeDEgKiAoeTIgLSB5MCkgKyB4MiAqICh5MCAtIHkxKSkgPCBlcHMyKSAmJiBpbmRpY2VzLnB1c2goaSwgaSArIDEsIGkgKyAyKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTmF0aXZlTGluZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBzaGFwZSA9IGdyYXBoaWNzRGF0YS5zaGFwZSwgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cyB8fCBzaGFwZS5wb2ludHMsIGNsb3NlZFNoYXBlID0gc2hhcGUudHlwZSAhPT0gY29yZS5TSEFQRVMuUE9MWSB8fCBzaGFwZS5jbG9zZVN0cm9rZTtcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuO1xuICBjb25zdCB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzLCBpbmRpY2VzID0gZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzLCBsZW5ndGggPSBwb2ludHMubGVuZ3RoIC8gMiwgc3RhcnRJbmRleCA9IHZlcnRzLmxlbmd0aCAvIDI7XG4gIGxldCBjdXJyZW50SW5kZXggPSBzdGFydEluZGV4O1xuICBmb3IgKHZlcnRzLnB1c2gocG9pbnRzWzBdLCBwb2ludHNbMV0pLCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKVxuICAgIHZlcnRzLnB1c2gocG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0pLCBpbmRpY2VzLnB1c2goY3VycmVudEluZGV4LCBjdXJyZW50SW5kZXggKyAxKSwgY3VycmVudEluZGV4Kys7XG4gIGNsb3NlZFNoYXBlICYmIGluZGljZXMucHVzaChjdXJyZW50SW5kZXgsIHN0YXJ0SW5kZXgpO1xufVxuZnVuY3Rpb24gYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICBncmFwaGljc0RhdGEubGluZVN0eWxlLm5hdGl2ZSA/IGJ1aWxkTmF0aXZlTGluZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIDogYnVpbGROb25OYXRpdmVMaW5lKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSk7XG59XG5leHBvcnRzLmJ1aWxkTGluZSA9IGJ1aWxkTGluZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkTGluZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKTtcbmZ1bmN0aW9uIGZpeE9yaWVudGF0aW9uKHBvaW50cywgaG9sZSA9ICExKSB7XG4gIGNvbnN0IG0gPSBwb2ludHMubGVuZ3RoO1xuICBpZiAobSA8IDYpXG4gICAgcmV0dXJuO1xuICBsZXQgYXJlYSA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCB4MSA9IHBvaW50c1ttIC0gMl0sIHkxID0gcG9pbnRzW20gLSAxXTsgaSA8IG07IGkgKz0gMikge1xuICAgIGNvbnN0IHgyID0gcG9pbnRzW2ldLCB5MiA9IHBvaW50c1tpICsgMV07XG4gICAgYXJlYSArPSAoeDIgLSB4MSkgKiAoeTIgKyB5MSksIHgxID0geDIsIHkxID0geTI7XG4gIH1cbiAgaWYgKCFob2xlICYmIGFyZWEgPiAwIHx8IGhvbGUgJiYgYXJlYSA8PSAwKSB7XG4gICAgY29uc3QgbiA9IG0gLyAyO1xuICAgIGZvciAobGV0IGkgPSBuICsgbiAlIDI7IGkgPCBtOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGkxID0gbSAtIGkgLSAyLCBpMiA9IG0gLSBpIC0gMSwgaTMgPSBpLCBpNCA9IGkgKyAxO1xuICAgICAgW3BvaW50c1tpMV0sIHBvaW50c1tpM11dID0gW3BvaW50c1tpM10sIHBvaW50c1tpMV1dLCBbcG9pbnRzW2kyXSwgcG9pbnRzW2k0XV0gPSBbcG9pbnRzW2k0XSwgcG9pbnRzW2kyXV07XG4gICAgfVxuICB9XG59XG5jb25zdCBidWlsZFBvbHkgPSB7XG4gIGJ1aWxkKGdyYXBoaWNzRGF0YSkge1xuICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSBncmFwaGljc0RhdGEuc2hhcGUucG9pbnRzLnNsaWNlKCk7XG4gIH0sXG4gIHRyaWFuZ3VsYXRlKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICAgIGxldCBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuICAgIGNvbnN0IGhvbGVzID0gZ3JhcGhpY3NEYXRhLmhvbGVzLCB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzLCBpbmRpY2VzID0gZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzO1xuICAgIGlmIChwb2ludHMubGVuZ3RoID49IDYpIHtcbiAgICAgIGZpeE9yaWVudGF0aW9uKHBvaW50cywgITEpO1xuICAgICAgY29uc3QgaG9sZUFycmF5ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGhvbGUgPSBob2xlc1tpXTtcbiAgICAgICAgZml4T3JpZW50YXRpb24oaG9sZS5wb2ludHMsICEwKSwgaG9sZUFycmF5LnB1c2gocG9pbnRzLmxlbmd0aCAvIDIpLCBwb2ludHMgPSBwb2ludHMuY29uY2F0KGhvbGUucG9pbnRzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyaWFuZ2xlcyA9IGNvcmUudXRpbHMuZWFyY3V0KHBvaW50cywgaG9sZUFycmF5LCAyKTtcbiAgICAgIGlmICghdHJpYW5nbGVzKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoIC8gMjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVydFBvcyksIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDFdICsgdmVydFBvcyksIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDJdICsgdmVydFBvcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgdmVydHMucHVzaChwb2ludHNbaV0pO1xuICAgIH1cbiAgfVxufTtcbmV4cG9ydHMuYnVpbGRQb2x5ID0gYnVpbGRQb2x5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRQb2x5LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBidWlsZFJlY3RhbmdsZSA9IHtcbiAgYnVpbGQoZ3JhcGhpY3NEYXRhKSB7XG4gICAgY29uc3QgcmVjdERhdGEgPSBncmFwaGljc0RhdGEuc2hhcGUsIHggPSByZWN0RGF0YS54LCB5ID0gcmVjdERhdGEueSwgd2lkdGggPSByZWN0RGF0YS53aWR0aCwgaGVpZ2h0ID0gcmVjdERhdGEuaGVpZ2h0LCBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuICAgIHBvaW50cy5sZW5ndGggPSAwLCB3aWR0aCA+PSAwICYmIGhlaWdodCA+PSAwICYmIHBvaW50cy5wdXNoKFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB4ICsgd2lkdGgsXG4gICAgICB5LFxuICAgICAgeCArIHdpZHRoLFxuICAgICAgeSArIGhlaWdodCxcbiAgICAgIHgsXG4gICAgICB5ICsgaGVpZ2h0XG4gICAgKTtcbiAgfSxcbiAgdHJpYW5ndWxhdGUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gICAgY29uc3QgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cywgdmVydHMgPSBncmFwaGljc0dlb21ldHJ5LnBvaW50cztcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoIC8gMjtcbiAgICB2ZXJ0cy5wdXNoKFxuICAgICAgcG9pbnRzWzBdLFxuICAgICAgcG9pbnRzWzFdLFxuICAgICAgcG9pbnRzWzJdLFxuICAgICAgcG9pbnRzWzNdLFxuICAgICAgcG9pbnRzWzZdLFxuICAgICAgcG9pbnRzWzddLFxuICAgICAgcG9pbnRzWzRdLFxuICAgICAgcG9pbnRzWzVdXG4gICAgKSwgZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzLnB1c2goXG4gICAgICB2ZXJ0UG9zLFxuICAgICAgdmVydFBvcyArIDEsXG4gICAgICB2ZXJ0UG9zICsgMixcbiAgICAgIHZlcnRQb3MgKyAxLFxuICAgICAgdmVydFBvcyArIDIsXG4gICAgICB2ZXJ0UG9zICsgM1xuICAgICk7XG4gIH1cbn07XG5leHBvcnRzLmJ1aWxkUmVjdGFuZ2xlID0gYnVpbGRSZWN0YW5nbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZFJlY3RhbmdsZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGJ1aWxkQ2lyY2xlID0gcmVxdWlyZShcIi4vYnVpbGRDaXJjbGUuanNcIik7XG5jb25zdCBidWlsZFJvdW5kZWRSZWN0YW5nbGUgPSB7XG4gIGJ1aWxkKGdyYXBoaWNzRGF0YSkge1xuICAgIGJ1aWxkQ2lyY2xlLmJ1aWxkQ2lyY2xlLmJ1aWxkKGdyYXBoaWNzRGF0YSk7XG4gIH0sXG4gIHRyaWFuZ3VsYXRlKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICAgIGJ1aWxkQ2lyY2xlLmJ1aWxkQ2lyY2xlLnRyaWFuZ3VsYXRlKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSk7XG4gIH1cbn07XG5leHBvcnRzLmJ1aWxkUm91bmRlZFJlY3RhbmdsZSA9IGJ1aWxkUm91bmRlZFJlY3RhbmdsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkUm91bmRlZFJlY3RhbmdsZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgYnVpbGRDaXJjbGUgPSByZXF1aXJlKFwiLi9idWlsZENpcmNsZS5qc1wiKSwgYnVpbGRQb2x5ID0gcmVxdWlyZShcIi4vYnVpbGRQb2x5LmpzXCIpLCBidWlsZFJlY3RhbmdsZSA9IHJlcXVpcmUoXCIuL2J1aWxkUmVjdGFuZ2xlLmpzXCIpLCBidWlsZFJvdW5kZWRSZWN0YW5nbGUgPSByZXF1aXJlKFwiLi9idWlsZFJvdW5kZWRSZWN0YW5nbGUuanNcIiksIEFyY1V0aWxzID0gcmVxdWlyZShcIi4vQXJjVXRpbHMuanNcIiksIEJhdGNoUGFydCA9IHJlcXVpcmUoXCIuL0JhdGNoUGFydC5qc1wiKSwgQmV6aWVyVXRpbHMgPSByZXF1aXJlKFwiLi9CZXppZXJVdGlscy5qc1wiKSwgYnVpbGRMaW5lID0gcmVxdWlyZShcIi4vYnVpbGRMaW5lLmpzXCIpLCBRdWFkcmF0aWNVdGlscyA9IHJlcXVpcmUoXCIuL1F1YWRyYXRpY1V0aWxzLmpzXCIpO1xuY29uc3QgRklMTF9DT01NQU5EUyA9IHtcbiAgW2NvcmUuU0hBUEVTLlBPTFldOiBidWlsZFBvbHkuYnVpbGRQb2x5LFxuICBbY29yZS5TSEFQRVMuQ0lSQ106IGJ1aWxkQ2lyY2xlLmJ1aWxkQ2lyY2xlLFxuICBbY29yZS5TSEFQRVMuRUxJUF06IGJ1aWxkQ2lyY2xlLmJ1aWxkQ2lyY2xlLFxuICBbY29yZS5TSEFQRVMuUkVDVF06IGJ1aWxkUmVjdGFuZ2xlLmJ1aWxkUmVjdGFuZ2xlLFxuICBbY29yZS5TSEFQRVMuUlJFQ106IGJ1aWxkUm91bmRlZFJlY3RhbmdsZS5idWlsZFJvdW5kZWRSZWN0YW5nbGVcbn0sIEJBVENIX1BPT0wgPSBbXSwgRFJBV19DQUxMX1BPT0wgPSBbXTtcbmV4cG9ydHMuYnVpbGRDaXJjbGUgPSBidWlsZENpcmNsZS5idWlsZENpcmNsZTtcbmV4cG9ydHMuYnVpbGRQb2x5ID0gYnVpbGRQb2x5LmJ1aWxkUG9seTtcbmV4cG9ydHMuYnVpbGRSZWN0YW5nbGUgPSBidWlsZFJlY3RhbmdsZS5idWlsZFJlY3RhbmdsZTtcbmV4cG9ydHMuYnVpbGRSb3VuZGVkUmVjdGFuZ2xlID0gYnVpbGRSb3VuZGVkUmVjdGFuZ2xlLmJ1aWxkUm91bmRlZFJlY3RhbmdsZTtcbmV4cG9ydHMuQXJjVXRpbHMgPSBBcmNVdGlscy5BcmNVdGlscztcbmV4cG9ydHMuQmF0Y2hQYXJ0ID0gQmF0Y2hQYXJ0LkJhdGNoUGFydDtcbmV4cG9ydHMuQmV6aWVyVXRpbHMgPSBCZXppZXJVdGlscy5CZXppZXJVdGlscztcbmV4cG9ydHMuYnVpbGRMaW5lID0gYnVpbGRMaW5lLmJ1aWxkTGluZTtcbmV4cG9ydHMuUXVhZHJhdGljVXRpbHMgPSBRdWFkcmF0aWNVdGlscy5RdWFkcmF0aWNVdGlscztcbmV4cG9ydHMuQkFUQ0hfUE9PTCA9IEJBVENIX1BPT0w7XG5leHBvcnRzLkRSQVdfQ0FMTF9QT09MID0gRFJBV19DQUxMX1BPT0w7XG5leHBvcnRzLkZJTExfQ09NTUFORFMgPSBGSUxMX0NPTU1BTkRTO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlQb2ludC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SVBvaW50RGF0YS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9jb25zdCA9IHJlcXVpcmUoXCIuL2NvbnN0LmpzXCIpLCBQb2ludCA9IHJlcXVpcmUoXCIuL1BvaW50LmpzXCIpO1xuY2xhc3MgTWF0cml4IHtcbiAgLyoqXG4gICAqIEBwYXJhbSBhIC0geCBzY2FsZVxuICAgKiBAcGFyYW0gYiAtIHkgc2tld1xuICAgKiBAcGFyYW0gYyAtIHggc2tld1xuICAgKiBAcGFyYW0gZCAtIHkgc2NhbGVcbiAgICogQHBhcmFtIHR4IC0geCB0cmFuc2xhdGlvblxuICAgKiBAcGFyYW0gdHkgLSB5IHRyYW5zbGF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhID0gMSwgYiA9IDAsIGMgPSAwLCBkID0gMSwgdHggPSAwLCB0eSA9IDApIHtcbiAgICB0aGlzLmFycmF5ID0gbnVsbCwgdGhpcy5hID0gYSwgdGhpcy5iID0gYiwgdGhpcy5jID0gYywgdGhpcy5kID0gZCwgdGhpcy50eCA9IHR4LCB0aGlzLnR5ID0gdHk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBNYXRyaXggb2JqZWN0IGJhc2VkIG9uIHRoZSBnaXZlbiBhcnJheS4gVGhlIEVsZW1lbnQgdG8gTWF0cml4IG1hcHBpbmcgb3JkZXIgaXMgYXMgZm9sbG93czpcbiAgICpcbiAgICogYSA9IGFycmF5WzBdXG4gICAqIGIgPSBhcnJheVsxXVxuICAgKiBjID0gYXJyYXlbM11cbiAgICogZCA9IGFycmF5WzRdXG4gICAqIHR4ID0gYXJyYXlbMl1cbiAgICogdHkgPSBhcnJheVs1XVxuICAgKiBAcGFyYW0gYXJyYXkgLSBUaGUgYXJyYXkgdGhhdCB0aGUgbWF0cml4IHdpbGwgYmUgcG9wdWxhdGVkIGZyb20uXG4gICAqL1xuICBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICB0aGlzLmEgPSBhcnJheVswXSwgdGhpcy5iID0gYXJyYXlbMV0sIHRoaXMuYyA9IGFycmF5WzNdLCB0aGlzLmQgPSBhcnJheVs0XSwgdGhpcy50eCA9IGFycmF5WzJdLCB0aGlzLnR5ID0gYXJyYXlbNV07XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1hdHJpeCBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gYSAtIE1hdHJpeCBjb21wb25lbnRcbiAgICogQHBhcmFtIGIgLSBNYXRyaXggY29tcG9uZW50XG4gICAqIEBwYXJhbSBjIC0gTWF0cml4IGNvbXBvbmVudFxuICAgKiBAcGFyYW0gZCAtIE1hdHJpeCBjb21wb25lbnRcbiAgICogQHBhcmFtIHR4IC0gTWF0cml4IGNvbXBvbmVudFxuICAgKiBAcGFyYW0gdHkgLSBNYXRyaXggY29tcG9uZW50XG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBzZXQoYSwgYiwgYywgZCwgdHgsIHR5KSB7XG4gICAgcmV0dXJuIHRoaXMuYSA9IGEsIHRoaXMuYiA9IGIsIHRoaXMuYyA9IGMsIHRoaXMuZCA9IGQsIHRoaXMudHggPSB0eCwgdGhpcy50eSA9IHR5LCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IGZyb20gdGhlIGN1cnJlbnQgTWF0cml4IG9iamVjdC5cbiAgICogQHBhcmFtIHRyYW5zcG9zZSAtIFdoZXRoZXIgd2UgbmVlZCB0byB0cmFuc3Bvc2UgdGhlIG1hdHJpeCBvciBub3RcbiAgICogQHBhcmFtIFtvdXQ9bmV3IEZsb2F0MzJBcnJheSg5KV0gLSBJZiBwcm92aWRlZCB0aGUgYXJyYXkgd2lsbCBiZSBhc3NpZ25lZCB0byBvdXRcbiAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgYXJyYXkgd2hpY2ggY29udGFpbnMgdGhlIG1hdHJpeFxuICAgKi9cbiAgdG9BcnJheSh0cmFuc3Bvc2UsIG91dCkge1xuICAgIHRoaXMuYXJyYXkgfHwgKHRoaXMuYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDkpKTtcbiAgICBjb25zdCBhcnJheSA9IG91dCB8fCB0aGlzLmFycmF5O1xuICAgIHJldHVybiB0cmFuc3Bvc2UgPyAoYXJyYXlbMF0gPSB0aGlzLmEsIGFycmF5WzFdID0gdGhpcy5iLCBhcnJheVsyXSA9IDAsIGFycmF5WzNdID0gdGhpcy5jLCBhcnJheVs0XSA9IHRoaXMuZCwgYXJyYXlbNV0gPSAwLCBhcnJheVs2XSA9IHRoaXMudHgsIGFycmF5WzddID0gdGhpcy50eSwgYXJyYXlbOF0gPSAxKSA6IChhcnJheVswXSA9IHRoaXMuYSwgYXJyYXlbMV0gPSB0aGlzLmMsIGFycmF5WzJdID0gdGhpcy50eCwgYXJyYXlbM10gPSB0aGlzLmIsIGFycmF5WzRdID0gdGhpcy5kLCBhcnJheVs1XSA9IHRoaXMudHksIGFycmF5WzZdID0gMCwgYXJyYXlbN10gPSAwLCBhcnJheVs4XSA9IDEpLCBhcnJheTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgbmV3IHBvc2l0aW9uIHdpdGggdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gYXBwbGllZC5cbiAgICogQ2FuIGJlIHVzZWQgdG8gZ28gZnJvbSBhIGNoaWxkJ3MgY29vcmRpbmF0ZSBzcGFjZSB0byB0aGUgd29ybGQgY29vcmRpbmF0ZSBzcGFjZS4gKGUuZy4gcmVuZGVyaW5nKVxuICAgKiBAcGFyYW0gcG9zIC0gVGhlIG9yaWdpblxuICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IFtuZXdQb3NdIC0gVGhlIHBvaW50IHRoYXQgdGhlIG5ldyBwb3NpdGlvbiBpcyBhc3NpZ25lZCB0byAoYWxsb3dlZCB0byBiZSBzYW1lIGFzIGlucHV0KVxuICAgKiBAcmV0dXJucyB7UElYSS5Qb2ludH0gVGhlIG5ldyBwb2ludCwgdHJhbnNmb3JtZWQgdGhyb3VnaCB0aGlzIG1hdHJpeFxuICAgKi9cbiAgYXBwbHkocG9zLCBuZXdQb3MpIHtcbiAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IFBvaW50LlBvaW50KCk7XG4gICAgY29uc3QgeCA9IHBvcy54LCB5ID0gcG9zLnk7XG4gICAgcmV0dXJuIG5ld1Bvcy54ID0gdGhpcy5hICogeCArIHRoaXMuYyAqIHkgKyB0aGlzLnR4LCBuZXdQb3MueSA9IHRoaXMuYiAqIHggKyB0aGlzLmQgKiB5ICsgdGhpcy50eSwgbmV3UG9zO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBuZXcgcG9zaXRpb24gd2l0aCB0aGUgaW52ZXJzZSBvZiB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkLlxuICAgKiBDYW4gYmUgdXNlZCB0byBnbyBmcm9tIHRoZSB3b3JsZCBjb29yZGluYXRlIHNwYWNlIHRvIGEgY2hpbGQncyBjb29yZGluYXRlIHNwYWNlLiAoZS5nLiBpbnB1dClcbiAgICogQHBhcmFtIHBvcyAtIFRoZSBvcmlnaW5cbiAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBbbmV3UG9zXSAtIFRoZSBwb2ludCB0aGF0IHRoZSBuZXcgcG9zaXRpb24gaXMgYXNzaWduZWQgdG8gKGFsbG93ZWQgdG8gYmUgc2FtZSBhcyBpbnB1dClcbiAgICogQHJldHVybnMge1BJWEkuUG9pbnR9IFRoZSBuZXcgcG9pbnQsIGludmVyc2UtdHJhbnNmb3JtZWQgdGhyb3VnaCB0aGlzIG1hdHJpeFxuICAgKi9cbiAgYXBwbHlJbnZlcnNlKHBvcywgbmV3UG9zKSB7XG4gICAgbmV3UG9zID0gbmV3UG9zIHx8IG5ldyBQb2ludC5Qb2ludCgpO1xuICAgIGNvbnN0IGlkID0gMSAvICh0aGlzLmEgKiB0aGlzLmQgKyB0aGlzLmMgKiAtdGhpcy5iKSwgeCA9IHBvcy54LCB5ID0gcG9zLnk7XG4gICAgcmV0dXJuIG5ld1Bvcy54ID0gdGhpcy5kICogaWQgKiB4ICsgLXRoaXMuYyAqIGlkICogeSArICh0aGlzLnR5ICogdGhpcy5jIC0gdGhpcy50eCAqIHRoaXMuZCkgKiBpZCwgbmV3UG9zLnkgPSB0aGlzLmEgKiBpZCAqIHkgKyAtdGhpcy5iICogaWQgKiB4ICsgKC10aGlzLnR5ICogdGhpcy5hICsgdGhpcy50eCAqIHRoaXMuYikgKiBpZCwgbmV3UG9zO1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2xhdGVzIHRoZSBtYXRyaXggb24gdGhlIHggYW5kIHkuXG4gICAqIEBwYXJhbSB4IC0gSG93IG11Y2ggdG8gdHJhbnNsYXRlIHggYnlcbiAgICogQHBhcmFtIHkgLSBIb3cgbXVjaCB0byB0cmFuc2xhdGUgeSBieVxuICAgKiBAcmV0dXJucyBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy50eCArPSB4LCB0aGlzLnR5ICs9IHksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBzY2FsZSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuICAgKiBAcGFyYW0geCAtIFRoZSBhbW91bnQgdG8gc2NhbGUgaG9yaXpvbnRhbGx5XG4gICAqIEBwYXJhbSB5IC0gVGhlIGFtb3VudCB0byBzY2FsZSB2ZXJ0aWNhbGx5XG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBzY2FsZSh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuYSAqPSB4LCB0aGlzLmQgKj0geSwgdGhpcy5jICo9IHgsIHRoaXMuYiAqPSB5LCB0aGlzLnR4ICo9IHgsIHRoaXMudHkgKj0geSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBhIHJvdGF0aW9uIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXG4gICAqIEBwYXJhbSBhbmdsZSAtIFRoZSBhbmdsZSBpbiByYWRpYW5zLlxuICAgKiBAcmV0dXJucyBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgcm90YXRlKGFuZ2xlKSB7XG4gICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpLCBzaW4gPSBNYXRoLnNpbihhbmdsZSksIGExID0gdGhpcy5hLCBjMSA9IHRoaXMuYywgdHgxID0gdGhpcy50eDtcbiAgICByZXR1cm4gdGhpcy5hID0gYTEgKiBjb3MgLSB0aGlzLmIgKiBzaW4sIHRoaXMuYiA9IGExICogc2luICsgdGhpcy5iICogY29zLCB0aGlzLmMgPSBjMSAqIGNvcyAtIHRoaXMuZCAqIHNpbiwgdGhpcy5kID0gYzEgKiBzaW4gKyB0aGlzLmQgKiBjb3MsIHRoaXMudHggPSB0eDEgKiBjb3MgLSB0aGlzLnR5ICogc2luLCB0aGlzLnR5ID0gdHgxICogc2luICsgdGhpcy50eSAqIGNvcywgdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZ2l2ZW4gTWF0cml4IHRvIHRoaXMgTWF0cml4LlxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBhcHBlbmQuXG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBhcHBlbmQobWF0cml4KSB7XG4gICAgY29uc3QgYTEgPSB0aGlzLmEsIGIxID0gdGhpcy5iLCBjMSA9IHRoaXMuYywgZDEgPSB0aGlzLmQ7XG4gICAgcmV0dXJuIHRoaXMuYSA9IG1hdHJpeC5hICogYTEgKyBtYXRyaXguYiAqIGMxLCB0aGlzLmIgPSBtYXRyaXguYSAqIGIxICsgbWF0cml4LmIgKiBkMSwgdGhpcy5jID0gbWF0cml4LmMgKiBhMSArIG1hdHJpeC5kICogYzEsIHRoaXMuZCA9IG1hdHJpeC5jICogYjEgKyBtYXRyaXguZCAqIGQxLCB0aGlzLnR4ID0gbWF0cml4LnR4ICogYTEgKyBtYXRyaXgudHkgKiBjMSArIHRoaXMudHgsIHRoaXMudHkgPSBtYXRyaXgudHggKiBiMSArIG1hdHJpeC50eSAqIGQxICsgdGhpcy50eSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWF0cml4IGJhc2VkIG9uIGFsbCB0aGUgYXZhaWxhYmxlIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHggLSBQb3NpdGlvbiBvbiB0aGUgeCBheGlzXG4gICAqIEBwYXJhbSB5IC0gUG9zaXRpb24gb24gdGhlIHkgYXhpc1xuICAgKiBAcGFyYW0gcGl2b3RYIC0gUGl2b3Qgb24gdGhlIHggYXhpc1xuICAgKiBAcGFyYW0gcGl2b3RZIC0gUGl2b3Qgb24gdGhlIHkgYXhpc1xuICAgKiBAcGFyYW0gc2NhbGVYIC0gU2NhbGUgb24gdGhlIHggYXhpc1xuICAgKiBAcGFyYW0gc2NhbGVZIC0gU2NhbGUgb24gdGhlIHkgYXhpc1xuICAgKiBAcGFyYW0gcm90YXRpb24gLSBSb3RhdGlvbiBpbiByYWRpYW5zXG4gICAqIEBwYXJhbSBza2V3WCAtIFNrZXcgb24gdGhlIHggYXhpc1xuICAgKiBAcGFyYW0gc2tld1kgLSBTa2V3IG9uIHRoZSB5IGF4aXNcbiAgICogQHJldHVybnMgVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICovXG4gIHNldFRyYW5zZm9ybSh4LCB5LCBwaXZvdFgsIHBpdm90WSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCBza2V3WCwgc2tld1kpIHtcbiAgICByZXR1cm4gdGhpcy5hID0gTWF0aC5jb3Mocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVgsIHRoaXMuYiA9IE1hdGguc2luKHJvdGF0aW9uICsgc2tld1kpICogc2NhbGVYLCB0aGlzLmMgPSAtTWF0aC5zaW4ocm90YXRpb24gLSBza2V3WCkgKiBzY2FsZVksIHRoaXMuZCA9IE1hdGguY29zKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZLCB0aGlzLnR4ID0geCAtIChwaXZvdFggKiB0aGlzLmEgKyBwaXZvdFkgKiB0aGlzLmMpLCB0aGlzLnR5ID0geSAtIChwaXZvdFggKiB0aGlzLmIgKyBwaXZvdFkgKiB0aGlzLmQpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gTWF0cml4IHRvIHRoaXMgTWF0cml4LlxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBwcmVwZW5kXG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBwcmVwZW5kKG1hdHJpeCkge1xuICAgIGNvbnN0IHR4MSA9IHRoaXMudHg7XG4gICAgaWYgKG1hdHJpeC5hICE9PSAxIHx8IG1hdHJpeC5iICE9PSAwIHx8IG1hdHJpeC5jICE9PSAwIHx8IG1hdHJpeC5kICE9PSAxKSB7XG4gICAgICBjb25zdCBhMSA9IHRoaXMuYSwgYzEgPSB0aGlzLmM7XG4gICAgICB0aGlzLmEgPSBhMSAqIG1hdHJpeC5hICsgdGhpcy5iICogbWF0cml4LmMsIHRoaXMuYiA9IGExICogbWF0cml4LmIgKyB0aGlzLmIgKiBtYXRyaXguZCwgdGhpcy5jID0gYzEgKiBtYXRyaXguYSArIHRoaXMuZCAqIG1hdHJpeC5jLCB0aGlzLmQgPSBjMSAqIG1hdHJpeC5iICsgdGhpcy5kICogbWF0cml4LmQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnR4ID0gdHgxICogbWF0cml4LmEgKyB0aGlzLnR5ICogbWF0cml4LmMgKyBtYXRyaXgudHgsIHRoaXMudHkgPSB0eDEgKiBtYXRyaXguYiArIHRoaXMudHkgKiBtYXRyaXguZCArIG1hdHJpeC50eSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogRGVjb21wb3NlcyB0aGUgbWF0cml4ICh4LCB5LCBzY2FsZVgsIHNjYWxlWSwgYW5kIHJvdGF0aW9uKSBhbmQgc2V0cyB0aGUgcHJvcGVydGllcyBvbiB0byBhIHRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIFRoZSB0cmFuc2Zvcm0gdG8gYXBwbHkgdGhlIHByb3BlcnRpZXMgdG8uXG4gICAqIEByZXR1cm5zIFRoZSB0cmFuc2Zvcm0gd2l0aCB0aGUgbmV3bHkgYXBwbGllZCBwcm9wZXJ0aWVzXG4gICAqL1xuICBkZWNvbXBvc2UodHJhbnNmb3JtKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuYSwgYiA9IHRoaXMuYiwgYyA9IHRoaXMuYywgZCA9IHRoaXMuZCwgcGl2b3QgPSB0cmFuc2Zvcm0ucGl2b3QsIHNrZXdYID0gLU1hdGguYXRhbjIoLWMsIGQpLCBza2V3WSA9IE1hdGguYXRhbjIoYiwgYSksIGRlbHRhID0gTWF0aC5hYnMoc2tld1ggKyBza2V3WSk7XG4gICAgcmV0dXJuIGRlbHRhIDwgMWUtNSB8fCBNYXRoLmFicyhfY29uc3QuUElfMiAtIGRlbHRhKSA8IDFlLTUgPyAodHJhbnNmb3JtLnJvdGF0aW9uID0gc2tld1ksIHRyYW5zZm9ybS5za2V3LnggPSB0cmFuc2Zvcm0uc2tldy55ID0gMCkgOiAodHJhbnNmb3JtLnJvdGF0aW9uID0gMCwgdHJhbnNmb3JtLnNrZXcueCA9IHNrZXdYLCB0cmFuc2Zvcm0uc2tldy55ID0gc2tld1kpLCB0cmFuc2Zvcm0uc2NhbGUueCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKSwgdHJhbnNmb3JtLnNjYWxlLnkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCksIHRyYW5zZm9ybS5wb3NpdGlvbi54ID0gdGhpcy50eCArIChwaXZvdC54ICogYSArIHBpdm90LnkgKiBjKSwgdHJhbnNmb3JtLnBvc2l0aW9uLnkgPSB0aGlzLnR5ICsgKHBpdm90LnggKiBiICsgcGl2b3QueSAqIGQpLCB0cmFuc2Zvcm07XG4gIH1cbiAgLyoqXG4gICAqIEludmVydHMgdGhpcyBtYXRyaXhcbiAgICogQHJldHVybnMgVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICovXG4gIGludmVydCgpIHtcbiAgICBjb25zdCBhMSA9IHRoaXMuYSwgYjEgPSB0aGlzLmIsIGMxID0gdGhpcy5jLCBkMSA9IHRoaXMuZCwgdHgxID0gdGhpcy50eCwgbiA9IGExICogZDEgLSBiMSAqIGMxO1xuICAgIHJldHVybiB0aGlzLmEgPSBkMSAvIG4sIHRoaXMuYiA9IC1iMSAvIG4sIHRoaXMuYyA9IC1jMSAvIG4sIHRoaXMuZCA9IGExIC8gbiwgdGhpcy50eCA9IChjMSAqIHRoaXMudHkgLSBkMSAqIHR4MSkgLyBuLCB0aGlzLnR5ID0gLShhMSAqIHRoaXMudHkgLSBiMSAqIHR4MSkgLyBuLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgdGhpcyBNYXRyaXggdG8gYW4gaWRlbnRpdHkgKGRlZmF1bHQpIG1hdHJpeC5cbiAgICogQHJldHVybnMgVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICovXG4gIGlkZW50aXR5KCkge1xuICAgIHJldHVybiB0aGlzLmEgPSAxLCB0aGlzLmIgPSAwLCB0aGlzLmMgPSAwLCB0aGlzLmQgPSAxLCB0aGlzLnR4ID0gMCwgdGhpcy50eSA9IDAsIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgTWF0cml4IG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZS5cbiAgICogQHJldHVybnMgQSBjb3B5IG9mIHRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgcmV0dXJuIG1hdHJpeC5hID0gdGhpcy5hLCBtYXRyaXguYiA9IHRoaXMuYiwgbWF0cml4LmMgPSB0aGlzLmMsIG1hdHJpeC5kID0gdGhpcy5kLCBtYXRyaXgudHggPSB0aGlzLnR4LCBtYXRyaXgudHkgPSB0aGlzLnR5LCBtYXRyaXg7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbWF0cml4IHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBvbmVzIGluIHRoaXMgbWF0cml4XG4gICAqIEBwYXJhbSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIGNvcHkgdG8uXG4gICAqIEByZXR1cm5zIFRoZSBtYXRyaXggZ2l2ZW4gaW4gcGFyYW1ldGVyIHdpdGggaXRzIHZhbHVlcyB1cGRhdGVkLlxuICAgKi9cbiAgY29weVRvKG1hdHJpeCkge1xuICAgIHJldHVybiBtYXRyaXguYSA9IHRoaXMuYSwgbWF0cml4LmIgPSB0aGlzLmIsIG1hdHJpeC5jID0gdGhpcy5jLCBtYXRyaXguZCA9IHRoaXMuZCwgbWF0cml4LnR4ID0gdGhpcy50eCwgbWF0cml4LnR5ID0gdGhpcy50eSwgbWF0cml4O1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIG1hdHJpeCB0byBiZSB0aGUgc2FtZSBhcyB0aGUgb25lcyBpbiBnaXZlbiBtYXRyaXhcbiAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBjb3B5IGZyb20uXG4gICAqIEByZXR1cm5zIHtQSVhJLk1hdHJpeH0gdGhpc1xuICAgKi9cbiAgY29weUZyb20obWF0cml4KSB7XG4gICAgcmV0dXJuIHRoaXMuYSA9IG1hdHJpeC5hLCB0aGlzLmIgPSBtYXRyaXguYiwgdGhpcy5jID0gbWF0cml4LmMsIHRoaXMuZCA9IG1hdHJpeC5kLCB0aGlzLnR4ID0gbWF0cml4LnR4LCB0aGlzLnR5ID0gbWF0cml4LnR5LCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBIGRlZmF1bHQgKGlkZW50aXR5KSBtYXRyaXhcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IElERU5USVRZKCkge1xuICAgIHJldHVybiBuZXcgTWF0cml4KCk7XG4gIH1cbiAgLyoqXG4gICAqIEEgdGVtcCBtYXRyaXhcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRFTVBfTUFUUklYKCkge1xuICAgIHJldHVybiBuZXcgTWF0cml4KCk7XG4gIH1cbn1cbk1hdHJpeC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGBbQHBpeGkvbWF0aDpNYXRyaXggYT0ke3RoaXMuYX0gYj0ke3RoaXMuYn0gYz0ke3RoaXMuY30gZD0ke3RoaXMuZH0gdHg9JHt0aGlzLnR4fSB0eT0ke3RoaXMudHl9XWA7XG59O1xuZXhwb3J0cy5NYXRyaXggPSBNYXRyaXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRyaXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIE9ic2VydmFibGVQb2ludCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBPYnNlcnZhYmxlUG9pbnRgXG4gICAqIEBwYXJhbSBjYiAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCB3aGVuIGB4YCBhbmQvb3IgYHlgIGFyZSBjaGFuZ2VkXG4gICAqIEBwYXJhbSBzY29wZSAtIG93bmVyIG9mIGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYiwgc2NvcGUsIHggPSAwLCB5ID0gMCkge1xuICAgIHRoaXMuX3ggPSB4LCB0aGlzLl95ID0geSwgdGhpcy5jYiA9IGNiLCB0aGlzLnNjb3BlID0gc2NvcGU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvaW50LlxuICAgKiBUaGUgY2FsbGJhY2sgYW5kIHNjb3BlIHBhcmFtcyBjYW4gYmUgb3ZlcnJpZGRlbiBvdGhlcndpc2UgdGhleSB3aWxsIGRlZmF1bHRcbiAgICogdG8gdGhlIGNsb25lIG9iamVjdCdzIHZhbHVlcy5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSBjYiAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgd2hlbiBgeGAgYW5kL29yIGB5YCBhcmUgY2hhbmdlZFxuICAgKiBAcGFyYW0gc2NvcGUgLSBUaGUgb3duZXIgb2YgdGhlIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIGEgY29weSBvZiB0aGlzIG9ic2VydmFibGUgcG9pbnRcbiAgICovXG4gIGNsb25lKGNiID0gdGhpcy5jYiwgc2NvcGUgPSB0aGlzLnNjb3BlKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlUG9pbnQoY2IsIHNjb3BlLCB0aGlzLl94LCB0aGlzLl95KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcG9pbnQgdG8gYSBuZXcgYHhgIGFuZCBgeWAgcG9zaXRpb24uXG4gICAqIElmIGB5YCBpcyBvbWl0dGVkLCBib3RoIGB4YCBhbmQgYHlgIHdpbGwgYmUgc2V0IHRvIGB4YC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5PXhdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXNcbiAgICogQHJldHVybnMgVGhlIG9ic2VydmFibGUgcG9pbnQgaW5zdGFuY2UgaXRzZWxmXG4gICAqL1xuICBzZXQoeCA9IDAsIHkgPSB4KSB7XG4gICAgcmV0dXJuICh0aGlzLl94ICE9PSB4IHx8IHRoaXMuX3kgIT09IHkpICYmICh0aGlzLl94ID0geCwgdGhpcy5feSA9IHksIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB4IGFuZCB5IGZyb20gdGhlIGdpdmVuIHBvaW50IChgcGApXG4gICAqIEBwYXJhbSBwIC0gVGhlIHBvaW50IHRvIGNvcHkgZnJvbS4gQ2FuIGJlIGFueSBvZiB0eXBlIHRoYXQgaXMgb3IgZXh0ZW5kcyBgSVBvaW50RGF0YWBcbiAgICogQHJldHVybnMgVGhlIG9ic2VydmFibGUgcG9pbnQgaW5zdGFuY2UgaXRzZWxmXG4gICAqL1xuICBjb3B5RnJvbShwKSB7XG4gICAgcmV0dXJuICh0aGlzLl94ICE9PSBwLnggfHwgdGhpcy5feSAhPT0gcC55KSAmJiAodGhpcy5feCA9IHAueCwgdGhpcy5feSA9IHAueSwgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgcG9pbnQncyB4IGFuZCB5IGludG8gdGhhdCBvZiB0aGUgZ2l2ZW4gcG9pbnQgKGBwYClcbiAgICogQHBhcmFtIHAgLSBUaGUgcG9pbnQgdG8gY29weSB0by4gQ2FuIGJlIGFueSBvZiB0eXBlIHRoYXQgaXMgb3IgZXh0ZW5kcyBgSVBvaW50RGF0YWBcbiAgICogQHJldHVybnMgVGhlIHBvaW50IChgcGApIHdpdGggdmFsdWVzIHVwZGF0ZWRcbiAgICovXG4gIGNvcHlUbyhwKSB7XG4gICAgcmV0dXJuIHAuc2V0KHRoaXMuX3gsIHRoaXMuX3kpLCBwO1xuICB9XG4gIC8qKlxuICAgKiBBY2NlcHRzIGFub3RoZXIgcG9pbnQgKGBwYCkgYW5kIHJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwb2ludCBpcyBlcXVhbCB0byB0aGlzIHBvaW50XG4gICAqIEBwYXJhbSBwIC0gVGhlIHBvaW50IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIFJldHVybnMgYHRydWVgIGlmIGJvdGggYHhgIGFuZCBgeWAgYXJlIGVxdWFsXG4gICAqL1xuICBlcXVhbHMocCkge1xuICAgIHJldHVybiBwLnggPT09IHRoaXMuX3ggJiYgcC55ID09PSB0aGlzLl95O1xuICB9XG4gIC8qKiBQb3NpdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBwb2ludCBvbiB0aGUgeCBheGlzLiAqL1xuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy5feDtcbiAgfVxuICBzZXQgeCh2YWx1ZSkge1xuICAgIHRoaXMuX3ggIT09IHZhbHVlICYmICh0aGlzLl94ID0gdmFsdWUsIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKSk7XG4gIH1cbiAgLyoqIFBvc2l0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHBvaW50IG9uIHRoZSB5IGF4aXMuICovXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLl95O1xuICB9XG4gIHNldCB5KHZhbHVlKSB7XG4gICAgdGhpcy5feSAhPT0gdmFsdWUgJiYgKHRoaXMuX3kgPSB2YWx1ZSwgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpKTtcbiAgfVxufVxuT2JzZXJ2YWJsZVBvaW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYFtAcGl4aS9tYXRoOk9ic2VydmFibGVQb2ludCB4PSR7dGhpcy54fSB5PSR7dGhpcy55fSBzY29wZT0ke3RoaXMuc2NvcGV9XWA7XG59O1xuZXhwb3J0cy5PYnNlcnZhYmxlUG9pbnQgPSBPYnNlcnZhYmxlUG9pbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlUG9pbnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIFBvaW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFBvaW50YFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xuICAgKi9cbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwKSB7XG4gICAgdGhpcy54ID0gMCwgdGhpcy55ID0gMCwgdGhpcy54ID0geCwgdGhpcy55ID0geTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgcG9pbnRcbiAgICogQHJldHVybnMgQSBjbG9uZSBvZiB0aGlzIHBvaW50XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGB4YCBhbmQgYHlgIGZyb20gdGhlIGdpdmVuIHBvaW50IGludG8gdGhpcyBwb2ludFxuICAgKiBAcGFyYW0gcCAtIFRoZSBwb2ludCB0byBjb3B5IGZyb21cbiAgICogQHJldHVybnMgVGhlIHBvaW50IGluc3RhbmNlIGl0c2VsZlxuICAgKi9cbiAgY29weUZyb20ocCkge1xuICAgIHJldHVybiB0aGlzLnNldChwLngsIHAueSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGlzIHBvaW50J3MgeCBhbmQgeSBpbnRvIHRoZSBnaXZlbiBwb2ludCAoYHBgKS5cbiAgICogQHBhcmFtIHAgLSBUaGUgcG9pbnQgdG8gY29weSB0by4gQ2FuIGJlIGFueSBvZiB0eXBlIHRoYXQgaXMgb3IgZXh0ZW5kcyBgSVBvaW50RGF0YWBcbiAgICogQHJldHVybnMgVGhlIHBvaW50IChgcGApIHdpdGggdmFsdWVzIHVwZGF0ZWRcbiAgICovXG4gIGNvcHlUbyhwKSB7XG4gICAgcmV0dXJuIHAuc2V0KHRoaXMueCwgdGhpcy55KSwgcDtcbiAgfVxuICAvKipcbiAgICogQWNjZXB0cyBhbm90aGVyIHBvaW50IChgcGApIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgZXF1YWwgdG8gdGhpcyBwb2ludFxuICAgKiBAcGFyYW0gcCAtIFRoZSBwb2ludCB0byBjaGVja1xuICAgKiBAcmV0dXJucyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGB4YCBhbmQgYHlgIGFyZSBlcXVhbFxuICAgKi9cbiAgZXF1YWxzKHApIHtcbiAgICByZXR1cm4gcC54ID09PSB0aGlzLnggJiYgcC55ID09PSB0aGlzLnk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvaW50IHRvIGEgbmV3IGB4YCBhbmQgYHlgIHBvc2l0aW9uLlxuICAgKiBJZiBgeWAgaXMgb21pdHRlZCwgYm90aCBgeGAgYW5kIGB5YCB3aWxsIGJlIHNldCB0byBgeGAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgYHhgIGF4aXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5PXhdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSBgeWAgYXhpc1xuICAgKiBAcmV0dXJucyBUaGUgcG9pbnQgaW5zdGFuY2UgaXRzZWxmXG4gICAqL1xuICBzZXQoeCA9IDAsIHkgPSB4KSB7XG4gICAgcmV0dXJuIHRoaXMueCA9IHgsIHRoaXMueSA9IHksIHRoaXM7XG4gIH1cbn1cblBvaW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYFtAcGl4aS9tYXRoOlBvaW50IHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9XWA7XG59O1xuZXhwb3J0cy5Qb2ludCA9IFBvaW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9pbnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBNYXRyaXggPSByZXF1aXJlKFwiLi9NYXRyaXguanNcIiksIE9ic2VydmFibGVQb2ludCA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVQb2ludC5qc1wiKTtcbmNvbnN0IF9UcmFuc2Zvcm0gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgTWF0cml4Lk1hdHJpeCgpLCB0aGlzLmxvY2FsVHJhbnNmb3JtID0gbmV3IE1hdHJpeC5NYXRyaXgoKSwgdGhpcy5wb3NpdGlvbiA9IG5ldyBPYnNlcnZhYmxlUG9pbnQuT2JzZXJ2YWJsZVBvaW50KHRoaXMub25DaGFuZ2UsIHRoaXMsIDAsIDApLCB0aGlzLnNjYWxlID0gbmV3IE9ic2VydmFibGVQb2ludC5PYnNlcnZhYmxlUG9pbnQodGhpcy5vbkNoYW5nZSwgdGhpcywgMSwgMSksIHRoaXMucGl2b3QgPSBuZXcgT2JzZXJ2YWJsZVBvaW50Lk9ic2VydmFibGVQb2ludCh0aGlzLm9uQ2hhbmdlLCB0aGlzLCAwLCAwKSwgdGhpcy5za2V3ID0gbmV3IE9ic2VydmFibGVQb2ludC5PYnNlcnZhYmxlUG9pbnQodGhpcy51cGRhdGVTa2V3LCB0aGlzLCAwLCAwKSwgdGhpcy5fcm90YXRpb24gPSAwLCB0aGlzLl9jeCA9IDEsIHRoaXMuX3N4ID0gMCwgdGhpcy5fY3kgPSAwLCB0aGlzLl9zeSA9IDEsIHRoaXMuX2xvY2FsSUQgPSAwLCB0aGlzLl9jdXJyZW50TG9jYWxJRCA9IDAsIHRoaXMuX3dvcmxkSUQgPSAwLCB0aGlzLl9wYXJlbnRJRCA9IDA7XG4gIH1cbiAgLyoqIENhbGxlZCB3aGVuIGEgdmFsdWUgY2hhbmdlcy4gKi9cbiAgb25DaGFuZ2UoKSB7XG4gICAgdGhpcy5fbG9jYWxJRCsrO1xuICB9XG4gIC8qKiBDYWxsZWQgd2hlbiB0aGUgc2tldyBvciB0aGUgcm90YXRpb24gY2hhbmdlcy4gKi9cbiAgdXBkYXRlU2tldygpIHtcbiAgICB0aGlzLl9jeCA9IE1hdGguY29zKHRoaXMuX3JvdGF0aW9uICsgdGhpcy5za2V3LnkpLCB0aGlzLl9zeCA9IE1hdGguc2luKHRoaXMuX3JvdGF0aW9uICsgdGhpcy5za2V3LnkpLCB0aGlzLl9jeSA9IC1NYXRoLnNpbih0aGlzLl9yb3RhdGlvbiAtIHRoaXMuc2tldy54KSwgdGhpcy5fc3kgPSBNYXRoLmNvcyh0aGlzLl9yb3RhdGlvbiAtIHRoaXMuc2tldy54KSwgdGhpcy5fbG9jYWxJRCsrO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSBsb2NhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguICovXG4gIHVwZGF0ZUxvY2FsVHJhbnNmb3JtKCkge1xuICAgIGNvbnN0IGx0ID0gdGhpcy5sb2NhbFRyYW5zZm9ybTtcbiAgICB0aGlzLl9sb2NhbElEICE9PSB0aGlzLl9jdXJyZW50TG9jYWxJRCAmJiAobHQuYSA9IHRoaXMuX2N4ICogdGhpcy5zY2FsZS54LCBsdC5iID0gdGhpcy5fc3ggKiB0aGlzLnNjYWxlLngsIGx0LmMgPSB0aGlzLl9jeSAqIHRoaXMuc2NhbGUueSwgbHQuZCA9IHRoaXMuX3N5ICogdGhpcy5zY2FsZS55LCBsdC50eCA9IHRoaXMucG9zaXRpb24ueCAtICh0aGlzLnBpdm90LnggKiBsdC5hICsgdGhpcy5waXZvdC55ICogbHQuYyksIGx0LnR5ID0gdGhpcy5wb3NpdGlvbi55IC0gKHRoaXMucGl2b3QueCAqIGx0LmIgKyB0aGlzLnBpdm90LnkgKiBsdC5kKSwgdGhpcy5fY3VycmVudExvY2FsSUQgPSB0aGlzLl9sb2NhbElELCB0aGlzLl9wYXJlbnRJRCA9IC0xKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbG9jYWwgYW5kIHRoZSB3b3JsZCB0cmFuc2Zvcm1hdGlvbiBtYXRyaWNlcy5cbiAgICogQHBhcmFtIHBhcmVudFRyYW5zZm9ybSAtIFRoZSBwYXJlbnQgdHJhbnNmb3JtXG4gICAqL1xuICB1cGRhdGVUcmFuc2Zvcm0ocGFyZW50VHJhbnNmb3JtKSB7XG4gICAgY29uc3QgbHQgPSB0aGlzLmxvY2FsVHJhbnNmb3JtO1xuICAgIGlmICh0aGlzLl9sb2NhbElEICE9PSB0aGlzLl9jdXJyZW50TG9jYWxJRCAmJiAobHQuYSA9IHRoaXMuX2N4ICogdGhpcy5zY2FsZS54LCBsdC5iID0gdGhpcy5fc3ggKiB0aGlzLnNjYWxlLngsIGx0LmMgPSB0aGlzLl9jeSAqIHRoaXMuc2NhbGUueSwgbHQuZCA9IHRoaXMuX3N5ICogdGhpcy5zY2FsZS55LCBsdC50eCA9IHRoaXMucG9zaXRpb24ueCAtICh0aGlzLnBpdm90LnggKiBsdC5hICsgdGhpcy5waXZvdC55ICogbHQuYyksIGx0LnR5ID0gdGhpcy5wb3NpdGlvbi55IC0gKHRoaXMucGl2b3QueCAqIGx0LmIgKyB0aGlzLnBpdm90LnkgKiBsdC5kKSwgdGhpcy5fY3VycmVudExvY2FsSUQgPSB0aGlzLl9sb2NhbElELCB0aGlzLl9wYXJlbnRJRCA9IC0xKSwgdGhpcy5fcGFyZW50SUQgIT09IHBhcmVudFRyYW5zZm9ybS5fd29ybGRJRCkge1xuICAgICAgY29uc3QgcHQgPSBwYXJlbnRUcmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0sIHd0ID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICAgIHd0LmEgPSBsdC5hICogcHQuYSArIGx0LmIgKiBwdC5jLCB3dC5iID0gbHQuYSAqIHB0LmIgKyBsdC5iICogcHQuZCwgd3QuYyA9IGx0LmMgKiBwdC5hICsgbHQuZCAqIHB0LmMsIHd0LmQgPSBsdC5jICogcHQuYiArIGx0LmQgKiBwdC5kLCB3dC50eCA9IGx0LnR4ICogcHQuYSArIGx0LnR5ICogcHQuYyArIHB0LnR4LCB3dC50eSA9IGx0LnR4ICogcHQuYiArIGx0LnR5ICogcHQuZCArIHB0LnR5LCB0aGlzLl9wYXJlbnRJRCA9IHBhcmVudFRyYW5zZm9ybS5fd29ybGRJRCwgdGhpcy5fd29ybGRJRCsrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVjb21wb3NlcyBhIG1hdHJpeCBhbmQgc2V0cyB0aGUgdHJhbnNmb3JtcyBwcm9wZXJ0aWVzIGJhc2VkIG9uIGl0LlxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBkZWNvbXBvc2VcbiAgICovXG4gIHNldEZyb21NYXRyaXgobWF0cml4KSB7XG4gICAgbWF0cml4LmRlY29tcG9zZSh0aGlzKSwgdGhpcy5fbG9jYWxJRCsrO1xuICB9XG4gIC8qKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLiAqL1xuICBnZXQgcm90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uO1xuICB9XG4gIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3JvdGF0aW9uICE9PSB2YWx1ZSAmJiAodGhpcy5fcm90YXRpb24gPSB2YWx1ZSwgdGhpcy51cGRhdGVTa2V3KCkpO1xuICB9XG59O1xuX1RyYW5zZm9ybS5JREVOVElUWSA9IG5ldyBfVHJhbnNmb3JtKCk7XG5sZXQgVHJhbnNmb3JtID0gX1RyYW5zZm9ybTtcblRyYW5zZm9ybS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGBbQHBpeGkvbWF0aDpUcmFuc2Zvcm0gcG9zaXRpb249KCR7dGhpcy5wb3NpdGlvbi54fSwgJHt0aGlzLnBvc2l0aW9uLnl9KSByb3RhdGlvbj0ke3RoaXMucm90YXRpb259IHNjYWxlPSgke3RoaXMuc2NhbGUueH0sICR7dGhpcy5zY2FsZS55fSkgc2tldz0oJHt0aGlzLnNrZXcueH0sICR7dGhpcy5za2V3Lnl9KSBdYDtcbn07XG5leHBvcnRzLlRyYW5zZm9ybSA9IFRyYW5zZm9ybTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zZm9ybS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgUElfMiA9IE1hdGguUEkgKiAyLCBSQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSSwgREVHX1RPX1JBRCA9IE1hdGguUEkgLyAxODA7XG52YXIgU0hBUEVTID0gLyogQF9fUFVSRV9fICovICgoU0hBUEVTMikgPT4gKFNIQVBFUzJbU0hBUEVTMi5QT0xZID0gMF0gPSBcIlBPTFlcIiwgU0hBUEVTMltTSEFQRVMyLlJFQ1QgPSAxXSA9IFwiUkVDVFwiLCBTSEFQRVMyW1NIQVBFUzIuQ0lSQyA9IDJdID0gXCJDSVJDXCIsIFNIQVBFUzJbU0hBUEVTMi5FTElQID0gM10gPSBcIkVMSVBcIiwgU0hBUEVTMltTSEFQRVMyLlJSRUMgPSA0XSA9IFwiUlJFQ1wiLCBTSEFQRVMyKSkoU0hBUEVTIHx8IHt9KTtcbmV4cG9ydHMuREVHX1RPX1JBRCA9IERFR19UT19SQUQ7XG5leHBvcnRzLlBJXzIgPSBQSV8yO1xuZXhwb3J0cy5SQURfVE9fREVHID0gUkFEX1RPX0RFRztcbmV4cG9ydHMuU0hBUEVTID0gU0hBUEVTO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBNYXRyaXggPSByZXF1aXJlKFwiLi9NYXRyaXguanNcIik7XG5jb25zdCB1eCA9IFsxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxXSwgdXkgPSBbMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMV0sIHZ4ID0gWzAsIC0xLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTFdLCB2eSA9IFsxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIC0xXSwgcm90YXRpb25DYXlsZXkgPSBbXSwgcm90YXRpb25NYXRyaWNlcyA9IFtdLCBzaWdudW0gPSBNYXRoLnNpZ247XG5mdW5jdGlvbiBpbml0KCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBjb25zdCByb3cgPSBbXTtcbiAgICByb3RhdGlvbkNheWxleS5wdXNoKHJvdyk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICBjb25zdCBfdXggPSBzaWdudW0odXhbaV0gKiB1eFtqXSArIHZ4W2ldICogdXlbal0pLCBfdXkgPSBzaWdudW0odXlbaV0gKiB1eFtqXSArIHZ5W2ldICogdXlbal0pLCBfdnggPSBzaWdudW0odXhbaV0gKiB2eFtqXSArIHZ4W2ldICogdnlbal0pLCBfdnkgPSBzaWdudW0odXlbaV0gKiB2eFtqXSArIHZ5W2ldICogdnlbal0pO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCAxNjsgaysrKVxuICAgICAgICBpZiAodXhba10gPT09IF91eCAmJiB1eVtrXSA9PT0gX3V5ICYmIHZ4W2tdID09PSBfdnggJiYgdnlba10gPT09IF92eSkge1xuICAgICAgICAgIHJvdy5wdXNoKGspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGNvbnN0IG1hdCA9IG5ldyBNYXRyaXguTWF0cml4KCk7XG4gICAgbWF0LnNldCh1eFtpXSwgdXlbaV0sIHZ4W2ldLCB2eVtpXSwgMCwgMCksIHJvdGF0aW9uTWF0cmljZXMucHVzaChtYXQpO1xuICB9XG59XG5pbml0KCk7XG5jb25zdCBncm91cEQ4ID0ge1xuICAvKipcbiAgICogfCBSb3RhdGlvbiB8IERpcmVjdGlvbiB8XG4gICAqIHwtLS0tLS0tLS0tfC0tLS0tLS0tLS0tfFxuICAgKiB8IDDCsCAgICAgICB8IEVhc3QgICAgICB8XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgRTogMCxcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gfCBEaXJlY3Rpb24gfFxuICAgKiB8LS0tLS0tLS0tLXwtLS0tLS0tLS0tLXxcbiAgICogfCA0NcKw4oa7ICAgICB8IFNvdXRoZWFzdCB8XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgU0U6IDEsXG4gIC8qKlxuICAgKiB8IFJvdGF0aW9uIHwgRGlyZWN0aW9uIHxcbiAgICogfC0tLS0tLS0tLS18LS0tLS0tLS0tLS18XG4gICAqIHwgOTDCsOKGuyAgICAgfCBTb3V0aCAgICAgfFxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIFM6IDIsXG4gIC8qKlxuICAgKiB8IFJvdGF0aW9uIHwgRGlyZWN0aW9uIHxcbiAgICogfC0tLS0tLS0tLS18LS0tLS0tLS0tLS18XG4gICAqIHwgMTM1wrDihrsgICAgfCBTb3V0aHdlc3QgfFxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIFNXOiAzLFxuICAvKipcbiAgICogfCBSb3RhdGlvbiB8IERpcmVjdGlvbiB8XG4gICAqIHwtLS0tLS0tLS0tfC0tLS0tLS0tLS0tfFxuICAgKiB8IDE4MMKwICAgICB8IFdlc3QgICAgICB8XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgVzogNCxcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gICAgfCBEaXJlY3Rpb24gICAgfFxuICAgKiB8LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLXxcbiAgICogfCAtMTM1wrAvMjI1wrDihrsgfCBOb3J0aHdlc3QgICAgfFxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIE5XOiA1LFxuICAvKipcbiAgICogfCBSb3RhdGlvbiAgICB8IERpcmVjdGlvbiAgICB8XG4gICAqIHwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tfFxuICAgKiB8IC05MMKwLzI3MMKw4oa7ICB8IE5vcnRoICAgICAgICB8XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgTjogNixcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gICAgfCBEaXJlY3Rpb24gICAgfFxuICAgKiB8LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLXxcbiAgICogfCAtNDXCsC8zMTXCsOKGuyAgfCBOb3J0aGVhc3QgICAgfFxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIE5FOiA3LFxuICAvKipcbiAgICogUmVmbGVjdGlvbiBhYm91dCBZLWF4aXMuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgTUlSUk9SX1ZFUlRJQ0FMOiA4LFxuICAvKipcbiAgICogUmVmbGVjdGlvbiBhYm91dCB0aGUgbWFpbiBkaWFnb25hbC5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBNQUlOX0RJQUdPTkFMOiAxMCxcbiAgLyoqXG4gICAqIFJlZmxlY3Rpb24gYWJvdXQgWC1heGlzLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIE1JUlJPUl9IT1JJWk9OVEFMOiAxMixcbiAgLyoqXG4gICAqIFJlZmxlY3Rpb24gYWJvdXQgcmV2ZXJzZSBkaWFnb25hbC5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBSRVZFUlNFX0RJQUdPTkFMOiAxNCxcbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5HRDhTeW1tZXRyeX0gaW5kIC0gc3ByaXRlIHJvdGF0aW9uIGFuZ2xlLlxuICAgKiBAcmV0dXJucyB7UElYSS5HRDhTeW1tZXRyeX0gVGhlIFgtY29tcG9uZW50IG9mIHRoZSBVLWF4aXNcbiAgICogICAgYWZ0ZXIgcm90YXRpbmcgdGhlIGF4ZXMuXG4gICAqL1xuICB1WDogKGluZCkgPT4gdXhbaW5kXSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5HRDhTeW1tZXRyeX0gaW5kIC0gc3ByaXRlIHJvdGF0aW9uIGFuZ2xlLlxuICAgKiBAcmV0dXJucyB7UElYSS5HRDhTeW1tZXRyeX0gVGhlIFktY29tcG9uZW50IG9mIHRoZSBVLWF4aXNcbiAgICogICAgYWZ0ZXIgcm90YXRpbmcgdGhlIGF4ZXMuXG4gICAqL1xuICB1WTogKGluZCkgPT4gdXlbaW5kXSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5HRDhTeW1tZXRyeX0gaW5kIC0gc3ByaXRlIHJvdGF0aW9uIGFuZ2xlLlxuICAgKiBAcmV0dXJucyB7UElYSS5HRDhTeW1tZXRyeX0gVGhlIFgtY29tcG9uZW50IG9mIHRoZSBWLWF4aXNcbiAgICogICAgYWZ0ZXIgcm90YXRpbmcgdGhlIGF4ZXMuXG4gICAqL1xuICB2WDogKGluZCkgPT4gdnhbaW5kXSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5HRDhTeW1tZXRyeX0gaW5kIC0gc3ByaXRlIHJvdGF0aW9uIGFuZ2xlLlxuICAgKiBAcmV0dXJucyB7UElYSS5HRDhTeW1tZXRyeX0gVGhlIFktY29tcG9uZW50IG9mIHRoZSBWLWF4aXNcbiAgICogICAgYWZ0ZXIgcm90YXRpbmcgdGhlIGF4ZXMuXG4gICAqL1xuICB2WTogKGluZCkgPT4gdnlbaW5kXSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5HRDhTeW1tZXRyeX0gcm90YXRpb24gLSBzeW1tZXRyeSB3aG9zZSBvcHBvc2l0ZVxuICAgKiAgIGlzIG5lZWRlZC4gT25seSByb3RhdGlvbnMgaGF2ZSBvcHBvc2l0ZSBzeW1tZXRyaWVzIHdoaWxlXG4gICAqICAgcmVmbGVjdGlvbnMgZG9uJ3QuXG4gICAqIEByZXR1cm5zIHtQSVhJLkdEOFN5bW1ldHJ5fSBUaGUgb3Bwb3NpdGUgc3ltbWV0cnkgb2YgYHJvdGF0aW9uYFxuICAgKi9cbiAgaW52OiAocm90YXRpb24pID0+IHJvdGF0aW9uICYgOCA/IHJvdGF0aW9uICYgMTUgOiAtcm90YXRpb24gJiA3LFxuICAvKipcbiAgICogQ29tcG9zZXMgdGhlIHR3byBEOCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBUYWtpbmcgYF5gIGFzIHJlZmxlY3Rpb246XG4gICAqXG4gICAqIHwgICAgICAgfCBFPTAgfCBTPTIgfCBXPTQgfCBOPTYgfCBFXj04IHwgU149MTAgfCBXXj0xMiB8IE5ePTE0IHxcbiAgICogfC0tLS0tLS18LS0tLS18LS0tLS18LS0tLS18LS0tLS18LS0tLS0tfC0tLS0tLS18LS0tLS0tLXwtLS0tLS0tfFxuICAgKiB8IEU9MCAgIHwgRSAgIHwgUyAgIHwgVyAgIHwgTiAgIHwgRV4gICB8IFNeICAgIHwgV14gICAgfCBOXiAgICB8XG4gICAqIHwgUz0yICAgfCBTICAgfCBXICAgfCBOICAgfCBFICAgfCBTXiAgIHwgV14gICAgfCBOXiAgICB8IEVeICAgIHxcbiAgICogfCBXPTQgICB8IFcgICB8IE4gICB8IEUgICB8IFMgICB8IFdeICAgfCBOXiAgICB8IEVeICAgIHwgU14gICAgfFxuICAgKiB8IE49NiAgIHwgTiAgIHwgRSAgIHwgUyAgIHwgVyAgIHwgTl4gICB8IEVeICAgIHwgU14gICAgfCBXXiAgICB8XG4gICAqIHwgRV49OCAgfCBFXiAgfCBOXiAgfCBXXiAgfCBTXiAgfCBFICAgIHwgTiAgICAgfCBXICAgICB8IFMgICAgIHxcbiAgICogfCBTXj0xMCB8IFNeICB8IEVeICB8IE5eICB8IFdeICB8IFMgICAgfCBFICAgICB8IE4gICAgIHwgVyAgICAgfFxuICAgKiB8IFdePTEyIHwgV14gIHwgU14gIHwgRV4gIHwgTl4gIHwgVyAgICB8IFMgICAgIHwgRSAgICAgfCBOICAgICB8XG4gICAqIHwgTl49MTQgfCBOXiAgfCBXXiAgfCBTXiAgfCBFXiAgfCBOICAgIHwgVyAgICAgfCBTICAgICB8IEUgICAgIHxcbiAgICpcbiAgICogW1RoaXMgaXMgYSBDYXlsZXkgdGFibGVde0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NheWxleV90YWJsZX1cbiAgICogQHBhcmFtIHtQSVhJLkdEOFN5bW1ldHJ5fSByb3RhdGlvblNlY29uZCAtIFNlY29uZCBvcGVyYXRpb24sIHdoaWNoXG4gICAqICAgaXMgdGhlIHJvdyBpbiB0aGUgYWJvdmUgY2F5bGV5IHRhYmxlLlxuICAgKiBAcGFyYW0ge1BJWEkuR0Q4U3ltbWV0cnl9IHJvdGF0aW9uRmlyc3QgLSBGaXJzdCBvcGVyYXRpb24sIHdoaWNoXG4gICAqICAgaXMgdGhlIGNvbHVtbiBpbiB0aGUgYWJvdmUgY2F5bGV5IHRhYmxlLlxuICAgKiBAcmV0dXJucyB7UElYSS5HRDhTeW1tZXRyeX0gQ29tcG9zZWQgb3BlcmF0aW9uXG4gICAqL1xuICBhZGQ6IChyb3RhdGlvblNlY29uZCwgcm90YXRpb25GaXJzdCkgPT4gcm90YXRpb25DYXlsZXlbcm90YXRpb25TZWNvbmRdW3JvdGF0aW9uRmlyc3RdLFxuICAvKipcbiAgICogUmV2ZXJzZSBvZiBgYWRkYC5cbiAgICogQHBhcmFtIHtQSVhJLkdEOFN5bW1ldHJ5fSByb3RhdGlvblNlY29uZCAtIFNlY29uZCBvcGVyYXRpb25cbiAgICogQHBhcmFtIHtQSVhJLkdEOFN5bW1ldHJ5fSByb3RhdGlvbkZpcnN0IC0gRmlyc3Qgb3BlcmF0aW9uXG4gICAqIEByZXR1cm5zIHtQSVhJLkdEOFN5bW1ldHJ5fSBSZXN1bHRcbiAgICovXG4gIHN1YjogKHJvdGF0aW9uU2Vjb25kLCByb3RhdGlvbkZpcnN0KSA9PiByb3RhdGlvbkNheWxleVtyb3RhdGlvblNlY29uZF1bZ3JvdXBEOC5pbnYocm90YXRpb25GaXJzdCldLFxuICAvKipcbiAgICogQWRkcyAxODAgZGVncmVlcyB0byByb3RhdGlvbiwgd2hpY2ggaXMgYSBjb21tdXRhdGl2ZVxuICAgKiBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiAtIFRoZSBudW1iZXIgdG8gcm90YXRlLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSb3RhdGVkIG51bWJlclxuICAgKi9cbiAgcm90YXRlMTgwOiAocm90YXRpb24pID0+IHJvdGF0aW9uIF4gNCxcbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcm90YXRpb24gYW5nbGUgaXMgdmVydGljYWwsIGkuZS4gc291dGhcbiAgICogb3Igbm9ydGguIEl0IGRvZXNuJ3Qgd29yayBmb3IgcmVmbGVjdGlvbnMuXG4gICAqIEBwYXJhbSB7UElYSS5HRDhTeW1tZXRyeX0gcm90YXRpb24gLSBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGRpcmVjdGlvbiBpcyB2ZXJ0aWNhbFxuICAgKi9cbiAgaXNWZXJ0aWNhbDogKHJvdGF0aW9uKSA9PiAocm90YXRpb24gJiAzKSA9PT0gMixcbiAgLy8gcm90YXRpb24gJSA0ID09PSAyXG4gIC8qKlxuICAgKiBBcHByb3hpbWF0ZXMgdGhlIHZlY3RvciBgVihkeCxkeSlgIGludG8gb25lIG9mIHRoZVxuICAgKiBlaWdodCBkaXJlY3Rpb25zIHByb3ZpZGVkIGJ5IGBncm91cEQ4YC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGR4IC0gWC1jb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHkgLSBZLWNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gICAqIEByZXR1cm5zIHtQSVhJLkdEOFN5bW1ldHJ5fSBBcHByb3hpbWF0aW9uIG9mIHRoZSB2ZWN0b3IgaW50b1xuICAgKiAgb25lIG9mIHRoZSBlaWdodCBzeW1tZXRyaWVzLlxuICAgKi9cbiAgYnlEaXJlY3Rpb246IChkeCwgZHkpID0+IE1hdGguYWJzKGR4KSAqIDIgPD0gTWF0aC5hYnMoZHkpID8gZHkgPj0gMCA/IGdyb3VwRDguUyA6IGdyb3VwRDguTiA6IE1hdGguYWJzKGR5KSAqIDIgPD0gTWF0aC5hYnMoZHgpID8gZHggPiAwID8gZ3JvdXBEOC5FIDogZ3JvdXBEOC5XIDogZHkgPiAwID8gZHggPiAwID8gZ3JvdXBEOC5TRSA6IGdyb3VwRDguU1cgOiBkeCA+IDAgPyBncm91cEQ4Lk5FIDogZ3JvdXBEOC5OVyxcbiAgLyoqXG4gICAqIEhlbHBzIHNwcml0ZSB0byBjb21wZW5zYXRlIHRleHR1cmUgcGFja2VyIHJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXggLSBzcHJpdGUgd29ybGQgbWF0cml4XG4gICAqIEBwYXJhbSB7UElYSS5HRDhTeW1tZXRyeX0gcm90YXRpb24gLSBUaGUgcm90YXRpb24gZmFjdG9yIHRvIHVzZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHR4IC0gc3ByaXRlIGFuY2hvcmluZ1xuICAgKiBAcGFyYW0ge251bWJlcn0gdHkgLSBzcHJpdGUgYW5jaG9yaW5nXG4gICAqL1xuICBtYXRyaXhBcHBlbmRSb3RhdGlvbkludjogKG1hdHJpeCwgcm90YXRpb24sIHR4ID0gMCwgdHkgPSAwKSA9PiB7XG4gICAgY29uc3QgbWF0ID0gcm90YXRpb25NYXRyaWNlc1tncm91cEQ4Lmludihyb3RhdGlvbildO1xuICAgIG1hdC50eCA9IHR4LCBtYXQudHkgPSB0eSwgbWF0cml4LmFwcGVuZChtYXQpO1xuICB9XG59O1xuZXhwb3J0cy5ncm91cEQ4ID0gZ3JvdXBEODtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3VwRDguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBDaXJjbGUgPSByZXF1aXJlKFwiLi9zaGFwZXMvQ2lyY2xlLmpzXCIpLCBFbGxpcHNlID0gcmVxdWlyZShcIi4vc2hhcGVzL0VsbGlwc2UuanNcIiksIFBvbHlnb24gPSByZXF1aXJlKFwiLi9zaGFwZXMvUG9seWdvbi5qc1wiKSwgUmVjdGFuZ2xlID0gcmVxdWlyZShcIi4vc2hhcGVzL1JlY3RhbmdsZS5qc1wiKSwgUm91bmRlZFJlY3RhbmdsZSA9IHJlcXVpcmUoXCIuL3NoYXBlcy9Sb3VuZGVkUmVjdGFuZ2xlLmpzXCIpLCBncm91cEQ4ID0gcmVxdWlyZShcIi4vZ3JvdXBEOC5qc1wiKTtcbnJlcXVpcmUoXCIuL0lQb2ludC5qc1wiKTtcbnJlcXVpcmUoXCIuL0lQb2ludERhdGEuanNcIik7XG52YXIgTWF0cml4ID0gcmVxdWlyZShcIi4vTWF0cml4LmpzXCIpLCBPYnNlcnZhYmxlUG9pbnQgPSByZXF1aXJlKFwiLi9PYnNlcnZhYmxlUG9pbnQuanNcIiksIFBvaW50ID0gcmVxdWlyZShcIi4vUG9pbnQuanNcIiksIFRyYW5zZm9ybSA9IHJlcXVpcmUoXCIuL1RyYW5zZm9ybS5qc1wiKSwgX2NvbnN0ID0gcmVxdWlyZShcIi4vY29uc3QuanNcIik7XG5leHBvcnRzLkNpcmNsZSA9IENpcmNsZS5DaXJjbGU7XG5leHBvcnRzLkVsbGlwc2UgPSBFbGxpcHNlLkVsbGlwc2U7XG5leHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uLlBvbHlnb247XG5leHBvcnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZS5SZWN0YW5nbGU7XG5leHBvcnRzLlJvdW5kZWRSZWN0YW5nbGUgPSBSb3VuZGVkUmVjdGFuZ2xlLlJvdW5kZWRSZWN0YW5nbGU7XG5leHBvcnRzLmdyb3VwRDggPSBncm91cEQ4Lmdyb3VwRDg7XG5leHBvcnRzLk1hdHJpeCA9IE1hdHJpeC5NYXRyaXg7XG5leHBvcnRzLk9ic2VydmFibGVQb2ludCA9IE9ic2VydmFibGVQb2ludC5PYnNlcnZhYmxlUG9pbnQ7XG5leHBvcnRzLlBvaW50ID0gUG9pbnQuUG9pbnQ7XG5leHBvcnRzLlRyYW5zZm9ybSA9IFRyYW5zZm9ybS5UcmFuc2Zvcm07XG5leHBvcnRzLkRFR19UT19SQUQgPSBfY29uc3QuREVHX1RPX1JBRDtcbmV4cG9ydHMuUElfMiA9IF9jb25zdC5QSV8yO1xuZXhwb3J0cy5SQURfVE9fREVHID0gX2NvbnN0LlJBRF9UT19ERUc7XG5leHBvcnRzLlNIQVBFUyA9IF9jb25zdC5TSEFQRVM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9jb25zdCA9IHJlcXVpcmUoXCIuLi9jb25zdC5qc1wiKSwgUmVjdGFuZ2xlID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlLmpzXCIpO1xuY2xhc3MgQ2lyY2xlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgY2lyY2xlXG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgY2lyY2xlXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgcmFkaXVzID0gMCkge1xuICAgIHRoaXMueCA9IHgsIHRoaXMueSA9IHksIHRoaXMucmFkaXVzID0gcmFkaXVzLCB0aGlzLnR5cGUgPSBfY29uc3QuU0hBUEVTLkNJUkM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIENpcmNsZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyBBIGNvcHkgb2YgdGhlIENpcmNsZVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDaXJjbGUodGhpcy54LCB0aGlzLnksIHRoaXMucmFkaXVzKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBjaXJjbGVcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIENpcmNsZVxuICAgKi9cbiAgY29udGFpbnMoeCwgeSkge1xuICAgIGlmICh0aGlzLnJhZGl1cyA8PSAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHIyID0gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cztcbiAgICBsZXQgZHggPSB0aGlzLnggLSB4LCBkeSA9IHRoaXMueSAtIHk7XG4gICAgcmV0dXJuIGR4ICo9IGR4LCBkeSAqPSBkeSwgZHggKyBkeSA8PSByMjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIGNpcmNsZSBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbiAgICogQHJldHVybnMgVGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4gICAqL1xuICBnZXRCb3VuZHMoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUuUmVjdGFuZ2xlKHRoaXMueCAtIHRoaXMucmFkaXVzLCB0aGlzLnkgLSB0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMgKiAyLCB0aGlzLnJhZGl1cyAqIDIpO1xuICB9XG59XG5DaXJjbGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBgW0BwaXhpL21hdGg6Q2lyY2xlIHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9IHJhZGl1cz0ke3RoaXMucmFkaXVzfV1gO1xufTtcbmV4cG9ydHMuQ2lyY2xlID0gQ2lyY2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2lyY2xlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2NvbnN0ID0gcmVxdWlyZShcIi4uL2NvbnN0LmpzXCIpLCBSZWN0YW5nbGUgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGUuanNcIik7XG5jbGFzcyBFbGxpcHNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgZWxsaXBzZVxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGVsbGlwc2VcbiAgICogQHBhcmFtIGhhbGZXaWR0aCAtIFRoZSBoYWxmIHdpZHRoIG9mIHRoaXMgZWxsaXBzZVxuICAgKiBAcGFyYW0gaGFsZkhlaWdodCAtIFRoZSBoYWxmIGhlaWdodCBvZiB0aGlzIGVsbGlwc2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgaGFsZldpZHRoID0gMCwgaGFsZkhlaWdodCA9IDApIHtcbiAgICB0aGlzLnggPSB4LCB0aGlzLnkgPSB5LCB0aGlzLndpZHRoID0gaGFsZldpZHRoLCB0aGlzLmhlaWdodCA9IGhhbGZIZWlnaHQsIHRoaXMudHlwZSA9IF9jb25zdC5TSEFQRVMuRUxJUDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgRWxsaXBzZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7UElYSS5FbGxpcHNlfSBBIGNvcHkgb2YgdGhlIGVsbGlwc2VcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgRWxsaXBzZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGVsbGlwc2VcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB4L3kgY29vcmRzIGFyZSB3aXRoaW4gdGhpcyBlbGxpcHNlXG4gICAqL1xuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGxldCBub3JteCA9ICh4IC0gdGhpcy54KSAvIHRoaXMud2lkdGgsIG5vcm15ID0gKHkgLSB0aGlzLnkpIC8gdGhpcy5oZWlnaHQ7XG4gICAgcmV0dXJuIG5vcm14ICo9IG5vcm14LCBub3JteSAqPSBub3JteSwgbm9ybXggKyBub3JteSA8PSAxO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgZWxsaXBzZSBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbiAgICogQHJldHVybnMgVGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4gICAqL1xuICBnZXRCb3VuZHMoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUuUmVjdGFuZ2xlKHRoaXMueCAtIHRoaXMud2lkdGgsIHRoaXMueSAtIHRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH1cbn1cbkVsbGlwc2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBgW0BwaXhpL21hdGg6RWxsaXBzZSB4PSR7dGhpcy54fSB5PSR7dGhpcy55fSB3aWR0aD0ke3RoaXMud2lkdGh9IGhlaWdodD0ke3RoaXMuaGVpZ2h0fV1gO1xufTtcbmV4cG9ydHMuRWxsaXBzZSA9IEVsbGlwc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbGxpcHNlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2NvbnN0ID0gcmVxdWlyZShcIi4uL2NvbnN0LmpzXCIpO1xuY2xhc3MgUG9seWdvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50RGF0YVtdfG51bWJlcltdfSBwb2ludHMgLSBUaGlzIGNhbiBiZSBhbiBhcnJheSBvZiBQb2ludHNcbiAgICogIHRoYXQgZm9ybSB0aGUgcG9seWdvbiwgYSBmbGF0IGFycmF5IG9mIG51bWJlcnMgdGhhdCB3aWxsIGJlIGludGVycHJldGVkIGFzIFt4LHksIHgseSwgLi4uXSwgb3JcbiAgICogIHRoZSBhcmd1bWVudHMgcGFzc2VkIGNhbiBiZSBhbGwgdGhlIHBvaW50cyBvZiB0aGUgcG9seWdvbiBlLmcuXG4gICAqICBgbmV3IFBvbHlnb24obmV3IFBvaW50KCksIG5ldyBQb2ludCgpLCAuLi4pYCwgb3IgdGhlIGFyZ3VtZW50cyBwYXNzZWQgY2FuIGJlIGZsYXRcbiAgICogIHgseSB2YWx1ZXMgZS5nLiBgbmV3IFBvbHlnb24oeCx5LCB4LHksIHgseSwgLi4uKWAgd2hlcmUgYHhgIGFuZCBgeWAgYXJlIE51bWJlcnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvciguLi5wb2ludHMpIHtcbiAgICBsZXQgZmxhdCA9IEFycmF5LmlzQXJyYXkocG9pbnRzWzBdKSA/IHBvaW50c1swXSA6IHBvaW50cztcbiAgICBpZiAodHlwZW9mIGZsYXRbMF0gIT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gZmxhdC5sZW5ndGg7IGkgPCBpbDsgaSsrKVxuICAgICAgICBwLnB1c2goZmxhdFtpXS54LCBmbGF0W2ldLnkpO1xuICAgICAgZmxhdCA9IHA7XG4gICAgfVxuICAgIHRoaXMucG9pbnRzID0gZmxhdCwgdGhpcy50eXBlID0gX2NvbnN0LlNIQVBFUy5QT0xZLCB0aGlzLmNsb3NlU3Ryb2tlID0gITA7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvbHlnb24uXG4gICAqIEByZXR1cm5zIC0gQSBjb3B5IG9mIHRoZSBwb2x5Z29uLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHMuc2xpY2UoKSwgcG9seWdvbiA9IG5ldyBQb2x5Z29uKHBvaW50cyk7XG4gICAgcmV0dXJuIHBvbHlnb24uY2xvc2VTdHJva2UgPSB0aGlzLmNsb3NlU3Ryb2tlLCBwb2x5Z29uO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdC5cbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyAtIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgcG9seWdvbi5cbiAgICovXG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBsZXQgaW5zaWRlID0gITE7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICAgIGNvbnN0IHhpID0gdGhpcy5wb2ludHNbaSAqIDJdLCB5aSA9IHRoaXMucG9pbnRzW2kgKiAyICsgMV0sIHhqID0gdGhpcy5wb2ludHNbaiAqIDJdLCB5aiA9IHRoaXMucG9pbnRzW2ogKiAyICsgMV07XG4gICAgICB5aSA+IHkgIT0geWogPiB5ICYmIHggPCAoeGogLSB4aSkgKiAoKHkgLSB5aSkgLyAoeWogLSB5aSkpICsgeGkgJiYgKGluc2lkZSA9ICFpbnNpZGUpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zaWRlO1xuICB9XG59XG5Qb2x5Z29uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYFtAcGl4aS9tYXRoOlBvbHlnb25jbG9zZVN0cm9rZT0ke3RoaXMuY2xvc2VTdHJva2V9cG9pbnRzPSR7dGhpcy5wb2ludHMucmVkdWNlKChwb2ludHNEZXNjLCBjdXJyZW50UG9pbnQpID0+IGAke3BvaW50c0Rlc2N9LCAke2N1cnJlbnRQb2ludH1gLCBcIlwiKX1dYDtcbn07XG5leHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9seWdvbi5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9jb25zdCA9IHJlcXVpcmUoXCIuLi9jb25zdC5qc1wiKSwgUG9pbnQgPSByZXF1aXJlKFwiLi4vUG9pbnQuanNcIik7XG5jb25zdCB0ZW1wUG9pbnRzID0gW25ldyBQb2ludC5Qb2ludCgpLCBuZXcgUG9pbnQuUG9pbnQoKSwgbmV3IFBvaW50LlBvaW50KCksIG5ldyBQb2ludC5Qb2ludCgpXTtcbmNsYXNzIFJlY3RhbmdsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB3aWR0aCAtIFRoZSBvdmVyYWxsIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICogQHBhcmFtIGhlaWdodCAtIFRoZSBvdmVyYWxsIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCkge1xuICAgIHRoaXMueCA9IE51bWJlcih4KSwgdGhpcy55ID0gTnVtYmVyKHkpLCB0aGlzLndpZHRoID0gTnVtYmVyKHdpZHRoKSwgdGhpcy5oZWlnaHQgPSBOdW1iZXIoaGVpZ2h0KSwgdGhpcy50eXBlID0gX2NvbnN0LlNIQVBFUy5SRUNUO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZS4gKi9cbiAgZ2V0IGxlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMueDtcbiAgfVxuICAvKiogUmV0dXJucyB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgcmVjdGFuZ2xlLiAqL1xuICBnZXQgcmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG4gIH1cbiAgLyoqIFJldHVybnMgdGhlIHRvcCBlZGdlIG9mIHRoZSByZWN0YW5nbGUuICovXG4gIGdldCB0b3AoKSB7XG4gICAgcmV0dXJuIHRoaXMueTtcbiAgfVxuICAvKiogUmV0dXJucyB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZS4gKi9cbiAgZ2V0IGJvdHRvbSgpIHtcbiAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gIH1cbiAgLyoqIEEgY29uc3RhbnQgZW1wdHkgcmVjdGFuZ2xlLiAqL1xuICBzdGF0aWMgZ2V0IEVNUFRZKCkge1xuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKDAsIDAsIDAsIDApO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBSZWN0YW5nbGVcbiAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoZSByZWN0YW5nbGVcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBhbm90aGVyIHJlY3RhbmdsZSB0byB0aGlzIG9uZS5cbiAgICogQHBhcmFtIHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gY29weSBmcm9tLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNvcHlGcm9tKHJlY3RhbmdsZSkge1xuICAgIHJldHVybiB0aGlzLnggPSByZWN0YW5nbGUueCwgdGhpcy55ID0gcmVjdGFuZ2xlLnksIHRoaXMud2lkdGggPSByZWN0YW5nbGUud2lkdGgsIHRoaXMuaGVpZ2h0ID0gcmVjdGFuZ2xlLmhlaWdodCwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgcmVjdGFuZ2xlIHRvIGFub3RoZXIgb25lLlxuICAgKiBAcGFyYW0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBjb3B5IHRvLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGdpdmVuIHBhcmFtZXRlci5cbiAgICovXG4gIGNvcHlUbyhyZWN0YW5nbGUpIHtcbiAgICByZXR1cm4gcmVjdGFuZ2xlLnggPSB0aGlzLngsIHJlY3RhbmdsZS55ID0gdGhpcy55LCByZWN0YW5nbGUud2lkdGggPSB0aGlzLndpZHRoLCByZWN0YW5nbGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQsIHJlY3RhbmdsZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBSZWN0YW5nbGVcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIFJlY3RhbmdsZVxuICAgKi9cbiAgY29udGFpbnMoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCA/ICExIDogeCA+PSB0aGlzLnggJiYgeCA8IHRoaXMueCArIHRoaXMud2lkdGggJiYgeSA+PSB0aGlzLnkgJiYgeSA8IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGBvdGhlcmAgUmVjdGFuZ2xlIHRyYW5zZm9ybWVkIGJ5IGB0cmFuc2Zvcm1gIGludGVyc2VjdHMgd2l0aCBgdGhpc2AgUmVjdGFuZ2xlIG9iamVjdC5cbiAgICogUmV0dXJucyB0cnVlIG9ubHkgaWYgdGhlIGFyZWEgb2YgdGhlIGludGVyc2VjdGlvbiBpcyA+MCwgdGhpcyBtZWFucyB0aGF0IFJlY3RhbmdsZXNcbiAgICogc2hhcmluZyBhIHNpZGUgYXJlIG5vdCBvdmVybGFwcGluZy4gQW5vdGhlciBzaWRlIGVmZmVjdCBpcyB0aGF0IGFuIGFyZWFsZXNzIHJlY3RhbmdsZVxuICAgKiAod2lkdGggb3IgaGVpZ2h0IGVxdWFsIHRvIHplcm8pIGNhbid0IGludGVyc2VjdCBhbnkgb3RoZXIgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gb3RoZXIgLSBUaGUgUmVjdGFuZ2xlIHRvIGludGVyc2VjdCB3aXRoIGB0aGlzYC5cbiAgICogQHBhcmFtIHtNYXRyaXh9IHRyYW5zZm9ybSAtIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgYG90aGVyYC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IEEgdmFsdWUgb2YgYHRydWVgIGlmIHRoZSB0cmFuc2Zvcm1lZCBgb3RoZXJgIFJlY3RhbmdsZSBpbnRlcnNlY3RzIHdpdGggYHRoaXNgOyBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICovXG4gIGludGVyc2VjdHMob3RoZXIsIHRyYW5zZm9ybSkge1xuICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICBjb25zdCB4MDIgPSB0aGlzLnggPCBvdGhlci54ID8gb3RoZXIueCA6IHRoaXMueDtcbiAgICAgIGlmICgodGhpcy5yaWdodCA+IG90aGVyLnJpZ2h0ID8gb3RoZXIucmlnaHQgOiB0aGlzLnJpZ2h0KSA8PSB4MDIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHkwMiA9IHRoaXMueSA8IG90aGVyLnkgPyBvdGhlci55IDogdGhpcy55O1xuICAgICAgcmV0dXJuICh0aGlzLmJvdHRvbSA+IG90aGVyLmJvdHRvbSA/IG90aGVyLmJvdHRvbSA6IHRoaXMuYm90dG9tKSA+IHkwMjtcbiAgICB9XG4gICAgY29uc3QgeDAgPSB0aGlzLmxlZnQsIHgxID0gdGhpcy5yaWdodCwgeTAgPSB0aGlzLnRvcCwgeTEgPSB0aGlzLmJvdHRvbTtcbiAgICBpZiAoeDEgPD0geDAgfHwgeTEgPD0geTApXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgbHQgPSB0ZW1wUG9pbnRzWzBdLnNldChvdGhlci5sZWZ0LCBvdGhlci50b3ApLCBsYiA9IHRlbXBQb2ludHNbMV0uc2V0KG90aGVyLmxlZnQsIG90aGVyLmJvdHRvbSksIHJ0ID0gdGVtcFBvaW50c1syXS5zZXQob3RoZXIucmlnaHQsIG90aGVyLnRvcCksIHJiID0gdGVtcFBvaW50c1szXS5zZXQob3RoZXIucmlnaHQsIG90aGVyLmJvdHRvbSk7XG4gICAgaWYgKHJ0LnggPD0gbHQueCB8fCBsYi55IDw9IGx0LnkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgcyA9IE1hdGguc2lnbih0cmFuc2Zvcm0uYSAqIHRyYW5zZm9ybS5kIC0gdHJhbnNmb3JtLmIgKiB0cmFuc2Zvcm0uYyk7XG4gICAgaWYgKHMgPT09IDAgfHwgKHRyYW5zZm9ybS5hcHBseShsdCwgbHQpLCB0cmFuc2Zvcm0uYXBwbHkobGIsIGxiKSwgdHJhbnNmb3JtLmFwcGx5KHJ0LCBydCksIHRyYW5zZm9ybS5hcHBseShyYiwgcmIpLCBNYXRoLm1heChsdC54LCBsYi54LCBydC54LCByYi54KSA8PSB4MCB8fCBNYXRoLm1pbihsdC54LCBsYi54LCBydC54LCByYi54KSA+PSB4MSB8fCBNYXRoLm1heChsdC55LCBsYi55LCBydC55LCByYi55KSA8PSB5MCB8fCBNYXRoLm1pbihsdC55LCBsYi55LCBydC55LCByYi55KSA+PSB5MSkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgbnggPSBzICogKGxiLnkgLSBsdC55KSwgbnkgPSBzICogKGx0LnggLSBsYi54KSwgbjAwID0gbnggKiB4MCArIG55ICogeTAsIG4xMCA9IG54ICogeDEgKyBueSAqIHkwLCBuMDEgPSBueCAqIHgwICsgbnkgKiB5MSwgbjExID0gbnggKiB4MSArIG55ICogeTE7XG4gICAgaWYgKE1hdGgubWF4KG4wMCwgbjEwLCBuMDEsIG4xMSkgPD0gbnggKiBsdC54ICsgbnkgKiBsdC55IHx8IE1hdGgubWluKG4wMCwgbjEwLCBuMDEsIG4xMSkgPj0gbnggKiByYi54ICsgbnkgKiByYi55KVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IG14ID0gcyAqIChsdC55IC0gcnQueSksIG15ID0gcyAqIChydC54IC0gbHQueCksIG0wMCA9IG14ICogeDAgKyBteSAqIHkwLCBtMTAgPSBteCAqIHgxICsgbXkgKiB5MCwgbTAxID0gbXggKiB4MCArIG15ICogeTEsIG0xMSA9IG14ICogeDEgKyBteSAqIHkxO1xuICAgIHJldHVybiAhKE1hdGgubWF4KG0wMCwgbTEwLCBtMDEsIG0xMSkgPD0gbXggKiBsdC54ICsgbXkgKiBsdC55IHx8IE1hdGgubWluKG0wMCwgbTEwLCBtMDEsIG0xMSkgPj0gbXggKiByYi54ICsgbXkgKiByYi55KTtcbiAgfVxuICAvKipcbiAgICogUGFkcyB0aGUgcmVjdGFuZ2xlIG1ha2luZyBpdCBncm93IGluIGFsbCBkaXJlY3Rpb25zLlxuICAgKiBJZiBwYWRkaW5nWSBpcyBvbWl0dGVkLCBib3RoIHBhZGRpbmdYIGFuZCBwYWRkaW5nWSB3aWxsIGJlIHNldCB0byBwYWRkaW5nWC5cbiAgICogQHBhcmFtIHBhZGRpbmdYIC0gVGhlIGhvcml6b250YWwgcGFkZGluZyBhbW91bnQuXG4gICAqIEBwYXJhbSBwYWRkaW5nWSAtIFRoZSB2ZXJ0aWNhbCBwYWRkaW5nIGFtb3VudC5cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBwYWQocGFkZGluZ1ggPSAwLCBwYWRkaW5nWSA9IHBhZGRpbmdYKSB7XG4gICAgcmV0dXJuIHRoaXMueCAtPSBwYWRkaW5nWCwgdGhpcy55IC09IHBhZGRpbmdZLCB0aGlzLndpZHRoICs9IHBhZGRpbmdYICogMiwgdGhpcy5oZWlnaHQgKz0gcGFkZGluZ1kgKiAyLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBGaXRzIHRoaXMgcmVjdGFuZ2xlIGFyb3VuZCB0aGUgcGFzc2VkIG9uZS5cbiAgICogQHBhcmFtIHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gZml0LlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGZpdChyZWN0YW5nbGUpIHtcbiAgICBjb25zdCB4MSA9IE1hdGgubWF4KHRoaXMueCwgcmVjdGFuZ2xlLngpLCB4MiA9IE1hdGgubWluKHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoKSwgeTEgPSBNYXRoLm1heCh0aGlzLnksIHJlY3RhbmdsZS55KSwgeTIgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdGFuZ2xlLnkgKyByZWN0YW5nbGUuaGVpZ2h0KTtcbiAgICByZXR1cm4gdGhpcy54ID0geDEsIHRoaXMud2lkdGggPSBNYXRoLm1heCh4MiAtIHgxLCAwKSwgdGhpcy55ID0geTEsIHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgoeTIgLSB5MSwgMCksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEVubGFyZ2VzIHJlY3RhbmdsZSB0aGF0IHdheSBpdHMgY29ybmVycyBsaWUgb24gZ3JpZFxuICAgKiBAcGFyYW0gcmVzb2x1dGlvbiAtIHJlc29sdXRpb25cbiAgICogQHBhcmFtIGVwcyAtIHByZWNpc2lvblxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNlaWwocmVzb2x1dGlvbiA9IDEsIGVwcyA9IDFlLTMpIHtcbiAgICBjb25zdCB4MiA9IE1hdGguY2VpbCgodGhpcy54ICsgdGhpcy53aWR0aCAtIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb24sIHkyID0gTWF0aC5jZWlsKCh0aGlzLnkgKyB0aGlzLmhlaWdodCAtIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgcmV0dXJuIHRoaXMueCA9IE1hdGguZmxvb3IoKHRoaXMueCArIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb24sIHRoaXMueSA9IE1hdGguZmxvb3IoKHRoaXMueSArIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb24sIHRoaXMud2lkdGggPSB4MiAtIHRoaXMueCwgdGhpcy5oZWlnaHQgPSB5MiAtIHRoaXMueSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogRW5sYXJnZXMgdGhpcyByZWN0YW5nbGUgdG8gaW5jbHVkZSB0aGUgcGFzc2VkIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gaW5jbHVkZS5cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBlbmxhcmdlKHJlY3RhbmdsZSkge1xuICAgIGNvbnN0IHgxID0gTWF0aC5taW4odGhpcy54LCByZWN0YW5nbGUueCksIHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdGFuZ2xlLnggKyByZWN0YW5nbGUud2lkdGgpLCB5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdGFuZ2xlLnkpLCB5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQpO1xuICAgIHJldHVybiB0aGlzLnggPSB4MSwgdGhpcy53aWR0aCA9IHgyIC0geDEsIHRoaXMueSA9IHkxLCB0aGlzLmhlaWdodCA9IHkyIC0geTEsIHRoaXM7XG4gIH1cbn1cblJlY3RhbmdsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGBbQHBpeGkvbWF0aDpSZWN0YW5nbGUgeD0ke3RoaXMueH0geT0ke3RoaXMueX0gd2lkdGg9JHt0aGlzLndpZHRofSBoZWlnaHQ9JHt0aGlzLmhlaWdodH1dYDtcbn07XG5leHBvcnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlY3RhbmdsZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9jb25zdCA9IHJlcXVpcmUoXCIuLi9jb25zdC5qc1wiKTtcbmNsYXNzIFJvdW5kZWRSZWN0YW5nbGUge1xuICAvKipcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGVcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGVcbiAgICogQHBhcmFtIHdpZHRoIC0gVGhlIG92ZXJhbGwgd2lkdGggb2YgdGhpcyByb3VuZGVkIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIG92ZXJhbGwgaGVpZ2h0IG9mIHRoaXMgcm91bmRlZCByZWN0YW5nbGVcbiAgICogQHBhcmFtIHJhZGl1cyAtIENvbnRyb2xzIHRoZSByYWRpdXMgb2YgdGhlIHJvdW5kZWQgY29ybmVyc1xuICAgKi9cbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDAsIHJhZGl1cyA9IDIwKSB7XG4gICAgdGhpcy54ID0geCwgdGhpcy55ID0geSwgdGhpcy53aWR0aCA9IHdpZHRoLCB0aGlzLmhlaWdodCA9IGhlaWdodCwgdGhpcy5yYWRpdXMgPSByYWRpdXMsIHRoaXMudHlwZSA9IF9jb25zdC5TSEFQRVMuUlJFQztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgUm91bmRlZCBSZWN0YW5nbGUuXG4gICAqIEByZXR1cm5zIC0gQSBjb3B5IG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZS5cbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUm91bmRlZFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucmFkaXVzKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBSb3VuZGVkIFJlY3RhbmdsZVxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3QuXG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdC5cbiAgICogQHJldHVybnMgLSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlLlxuICAgKi9cbiAgY29udGFpbnMoeCwgeSkge1xuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMClcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAoeCA+PSB0aGlzLnggJiYgeCA8PSB0aGlzLnggKyB0aGlzLndpZHRoICYmIHkgPj0gdGhpcy55ICYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQpIHtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMucmFkaXVzLCBNYXRoLm1pbih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkgLyAyKSk7XG4gICAgICBpZiAoeSA+PSB0aGlzLnkgKyByYWRpdXMgJiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodCAtIHJhZGl1cyB8fCB4ID49IHRoaXMueCArIHJhZGl1cyAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGggLSByYWRpdXMpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGxldCBkeCA9IHggLSAodGhpcy54ICsgcmFkaXVzKSwgZHkgPSB5IC0gKHRoaXMueSArIHJhZGl1cyk7XG4gICAgICBjb25zdCByYWRpdXMyID0gcmFkaXVzICogcmFkaXVzO1xuICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDw9IHJhZGl1czIgfHwgKGR4ID0geCAtICh0aGlzLnggKyB0aGlzLndpZHRoIC0gcmFkaXVzKSwgZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikgfHwgKGR5ID0geSAtICh0aGlzLnkgKyB0aGlzLmhlaWdodCAtIHJhZGl1cyksIGR4ICogZHggKyBkeSAqIGR5IDw9IHJhZGl1czIpIHx8IChkeCA9IHggLSAodGhpcy54ICsgcmFkaXVzKSwgZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5Sb3VuZGVkUmVjdGFuZ2xlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYFtAcGl4aS9tYXRoOlJvdW5kZWRSZWN0YW5nbGUgeD0ke3RoaXMueH0geT0ke3RoaXMueX13aWR0aD0ke3RoaXMud2lkdGh9IGhlaWdodD0ke3RoaXMuaGVpZ2h0fSByYWRpdXM9JHt0aGlzLnJhZGl1c31dYDtcbn07XG5leHBvcnRzLlJvdW5kZWRSZWN0YW5nbGUgPSBSb3VuZGVkUmVjdGFuZ2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Um91bmRlZFJlY3RhbmdsZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgU2ltcGxlUGxhbmUgPSByZXF1aXJlKFwiLi9TaW1wbGVQbGFuZS5qc1wiKTtcbmNvbnN0IERFRkFVTFRfQk9SREVSX1NJWkUgPSAxMDtcbmNsYXNzIE5pbmVTbGljZVBsYW5lIGV4dGVuZHMgU2ltcGxlUGxhbmUuU2ltcGxlUGxhbmUge1xuICAvKipcbiAgICogQHBhcmFtIHRleHR1cmUgLSBUaGUgdGV4dHVyZSB0byB1c2Ugb24gdGhlIE5pbmVTbGljZVBsYW5lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xlZnRXaWR0aD0xMF0gLSBzaXplIG9mIHRoZSBsZWZ0IHZlcnRpY2FsIGJhciAoQSlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0b3BIZWlnaHQ9MTBdIC0gc2l6ZSBvZiB0aGUgdG9wIGhvcml6b250YWwgYmFyIChDKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JpZ2h0V2lkdGg9MTBdIC0gc2l6ZSBvZiB0aGUgcmlnaHQgdmVydGljYWwgYmFyIChCKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2JvdHRvbUhlaWdodD0xMF0gLSBzaXplIG9mIHRoZSBib3R0b20gaG9yaXpvbnRhbCBiYXIgKEQpXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCBsZWZ0V2lkdGgsIHRvcEhlaWdodCwgcmlnaHRXaWR0aCwgYm90dG9tSGVpZ2h0KSB7XG4gICAgc3VwZXIoY29yZS5UZXh0dXJlLldISVRFLCA0LCA0KSwgdGhpcy5fb3JpZ1dpZHRoID0gdGV4dHVyZS5vcmlnLndpZHRoLCB0aGlzLl9vcmlnSGVpZ2h0ID0gdGV4dHVyZS5vcmlnLmhlaWdodCwgdGhpcy5fd2lkdGggPSB0aGlzLl9vcmlnV2lkdGgsIHRoaXMuX2hlaWdodCA9IHRoaXMuX29yaWdIZWlnaHQsIHRoaXMuX2xlZnRXaWR0aCA9IGxlZnRXaWR0aCA/PyB0ZXh0dXJlLmRlZmF1bHRCb3JkZXJzPy5sZWZ0ID8/IERFRkFVTFRfQk9SREVSX1NJWkUsIHRoaXMuX3JpZ2h0V2lkdGggPSByaWdodFdpZHRoID8/IHRleHR1cmUuZGVmYXVsdEJvcmRlcnM/LnJpZ2h0ID8/IERFRkFVTFRfQk9SREVSX1NJWkUsIHRoaXMuX3RvcEhlaWdodCA9IHRvcEhlaWdodCA/PyB0ZXh0dXJlLmRlZmF1bHRCb3JkZXJzPy50b3AgPz8gREVGQVVMVF9CT1JERVJfU0laRSwgdGhpcy5fYm90dG9tSGVpZ2h0ID0gYm90dG9tSGVpZ2h0ID8/IHRleHR1cmUuZGVmYXVsdEJvcmRlcnM/LmJvdHRvbSA/PyBERUZBVUxUX0JPUkRFUl9TSVpFLCB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICB9XG4gIHRleHR1cmVVcGRhdGVkKCkge1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IHRoaXMuc2hhZGVyLnRleHR1cmUuX3VwZGF0ZUlELCB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cbiAgZ2V0IHZlcnRpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKS5kYXRhO1xuICB9XG4gIHNldCB2ZXJ0aWNlcyh2YWx1ZSkge1xuICAgIHRoaXMuZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVZlcnRleFBvc2l0aW9uXCIpLmRhdGEgPSB2YWx1ZTtcbiAgfVxuICAvKiogVXBkYXRlcyB0aGUgaG9yaXpvbnRhbCB2ZXJ0aWNlcy4gKi9cbiAgdXBkYXRlSG9yaXpvbnRhbFZlcnRpY2VzKCkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcywgc2NhbGUgPSB0aGlzLl9nZXRNaW5TY2FsZSgpO1xuICAgIHZlcnRpY2VzWzldID0gdmVydGljZXNbMTFdID0gdmVydGljZXNbMTNdID0gdmVydGljZXNbMTVdID0gdGhpcy5fdG9wSGVpZ2h0ICogc2NhbGUsIHZlcnRpY2VzWzE3XSA9IHZlcnRpY2VzWzE5XSA9IHZlcnRpY2VzWzIxXSA9IHZlcnRpY2VzWzIzXSA9IHRoaXMuX2hlaWdodCAtIHRoaXMuX2JvdHRvbUhlaWdodCAqIHNjYWxlLCB2ZXJ0aWNlc1syNV0gPSB2ZXJ0aWNlc1syN10gPSB2ZXJ0aWNlc1syOV0gPSB2ZXJ0aWNlc1szMV0gPSB0aGlzLl9oZWlnaHQ7XG4gIH1cbiAgLyoqIFVwZGF0ZXMgdGhlIHZlcnRpY2FsIHZlcnRpY2VzLiAqL1xuICB1cGRhdGVWZXJ0aWNhbFZlcnRpY2VzKCkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcywgc2NhbGUgPSB0aGlzLl9nZXRNaW5TY2FsZSgpO1xuICAgIHZlcnRpY2VzWzJdID0gdmVydGljZXNbMTBdID0gdmVydGljZXNbMThdID0gdmVydGljZXNbMjZdID0gdGhpcy5fbGVmdFdpZHRoICogc2NhbGUsIHZlcnRpY2VzWzRdID0gdmVydGljZXNbMTJdID0gdmVydGljZXNbMjBdID0gdmVydGljZXNbMjhdID0gdGhpcy5fd2lkdGggLSB0aGlzLl9yaWdodFdpZHRoICogc2NhbGUsIHZlcnRpY2VzWzZdID0gdmVydGljZXNbMTRdID0gdmVydGljZXNbMjJdID0gdmVydGljZXNbMzBdID0gdGhpcy5fd2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNtYWxsZXIgb2YgYSBzZXQgb2YgdmVydGljYWwgYW5kIGhvcml6b250YWwgc2NhbGUgb2YgbmluZSBzbGljZSBjb3JuZXJzLlxuICAgKiBAcmV0dXJucyBTbWFsbGVyIG51bWJlciBvZiB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBzY2FsZS5cbiAgICovXG4gIF9nZXRNaW5TY2FsZSgpIHtcbiAgICBjb25zdCB3ID0gdGhpcy5fbGVmdFdpZHRoICsgdGhpcy5fcmlnaHRXaWR0aCwgc2NhbGVXID0gdGhpcy5fd2lkdGggPiB3ID8gMSA6IHRoaXMuX3dpZHRoIC8gdywgaCA9IHRoaXMuX3RvcEhlaWdodCArIHRoaXMuX2JvdHRvbUhlaWdodCwgc2NhbGVIID0gdGhpcy5faGVpZ2h0ID4gaCA/IDEgOiB0aGlzLl9oZWlnaHQgLyBoO1xuICAgIHJldHVybiBNYXRoLm1pbihzY2FsZVcsIHNjYWxlSCk7XG4gIH1cbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgTmluZVNsaWNlUGxhbmUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgdmVydGljZXMgYW5kIFVWJ3Mgb2YgdGhpcyBwbGFuZS4gKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLl93aWR0aCA9IHZhbHVlLCB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIE5pbmVTbGljZVBsYW5lLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHZlcnRpY2VzIGFuZCBVVidzIG9mIHRoaXMgcGxhbmUuICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5faGVpZ2h0ID0gdmFsdWUsIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICAvKiogVGhlIHdpZHRoIG9mIHRoZSBsZWZ0IGNvbHVtbi4gKi9cbiAgZ2V0IGxlZnRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVmdFdpZHRoO1xuICB9XG4gIHNldCBsZWZ0V2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLl9sZWZ0V2lkdGggPSB2YWx1ZSwgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIHJpZ2h0IGNvbHVtbi4gKi9cbiAgZ2V0IHJpZ2h0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JpZ2h0V2lkdGg7XG4gIH1cbiAgc2V0IHJpZ2h0V2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLl9yaWdodFdpZHRoID0gdmFsdWUsIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgdG9wIHJvdy4gKi9cbiAgZ2V0IHRvcEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9wSGVpZ2h0O1xuICB9XG4gIHNldCB0b3BIZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLl90b3BIZWlnaHQgPSB2YWx1ZSwgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBib3R0b20gcm93LiAqL1xuICBnZXQgYm90dG9tSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9ib3R0b21IZWlnaHQ7XG4gIH1cbiAgc2V0IGJvdHRvbUhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX2JvdHRvbUhlaWdodCA9IHZhbHVlLCB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cbiAgLyoqIFJlZnJlc2hlcyBOaW5lU2xpY2VQbGFuZSBjb29yZHMuIEFsbCBvZiB0aGVtLiAqL1xuICBfcmVmcmVzaCgpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlLCB1dnMgPSB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMV0uZGF0YTtcbiAgICB0aGlzLl9vcmlnV2lkdGggPSB0ZXh0dXJlLm9yaWcud2lkdGgsIHRoaXMuX29yaWdIZWlnaHQgPSB0ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICAgIGNvbnN0IF91dncgPSAxIC8gdGhpcy5fb3JpZ1dpZHRoLCBfdXZoID0gMSAvIHRoaXMuX29yaWdIZWlnaHQ7XG4gICAgdXZzWzBdID0gdXZzWzhdID0gdXZzWzE2XSA9IHV2c1syNF0gPSAwLCB1dnNbMV0gPSB1dnNbM10gPSB1dnNbNV0gPSB1dnNbN10gPSAwLCB1dnNbNl0gPSB1dnNbMTRdID0gdXZzWzIyXSA9IHV2c1szMF0gPSAxLCB1dnNbMjVdID0gdXZzWzI3XSA9IHV2c1syOV0gPSB1dnNbMzFdID0gMSwgdXZzWzJdID0gdXZzWzEwXSA9IHV2c1sxOF0gPSB1dnNbMjZdID0gX3V2dyAqIHRoaXMuX2xlZnRXaWR0aCwgdXZzWzRdID0gdXZzWzEyXSA9IHV2c1syMF0gPSB1dnNbMjhdID0gMSAtIF91dncgKiB0aGlzLl9yaWdodFdpZHRoLCB1dnNbOV0gPSB1dnNbMTFdID0gdXZzWzEzXSA9IHV2c1sxNV0gPSBfdXZoICogdGhpcy5fdG9wSGVpZ2h0LCB1dnNbMTddID0gdXZzWzE5XSA9IHV2c1syMV0gPSB1dnNbMjNdID0gMSAtIF91dmggKiB0aGlzLl9ib3R0b21IZWlnaHQsIHRoaXMudXBkYXRlSG9yaXpvbnRhbFZlcnRpY2VzKCksIHRoaXMudXBkYXRlVmVydGljYWxWZXJ0aWNlcygpLCB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMF0udXBkYXRlKCksIHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1sxXS51cGRhdGUoKTtcbiAgfVxufVxuZXhwb3J0cy5OaW5lU2xpY2VQbGFuZSA9IE5pbmVTbGljZVBsYW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmluZVNsaWNlUGxhbmUuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIG1lc2ggPSByZXF1aXJlKFwiQHBpeGkvbWVzaFwiKTtcbmNsYXNzIFNpbXBsZU1lc2ggZXh0ZW5kcyBtZXNoLk1lc2gge1xuICAvKipcbiAgICogQHBhcmFtIHRleHR1cmUgLSBUaGUgdGV4dHVyZSB0byB1c2VcbiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IFt2ZXJ0aWNlc10gLSBpZiB5b3Ugd2FudCB0byBzcGVjaWZ5IHRoZSB2ZXJ0aWNlc1xuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gW3V2c10gLSBpZiB5b3Ugd2FudCB0byBzcGVjaWZ5IHRoZSB1dnNcbiAgICogQHBhcmFtIHtVaW50MTZBcnJheX0gW2luZGljZXNdIC0gaWYgeW91IHdhbnQgdG8gc3BlY2lmeSB0aGUgaW5kaWNlc1xuICAgKiBAcGFyYW0gZHJhd01vZGUgLSB0aGUgZHJhd01vZGUsIGNhbiBiZSBhbnkgb2YgdGhlIE1lc2guRFJBV19NT0RFUyBjb25zdHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRleHR1cmUgPSBjb3JlLlRleHR1cmUuRU1QVFksIHZlcnRpY2VzLCB1dnMsIGluZGljZXMsIGRyYXdNb2RlKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgbWVzaC5NZXNoR2VvbWV0cnkodmVydGljZXMsIHV2cywgaW5kaWNlcyk7XG4gICAgZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVZlcnRleFBvc2l0aW9uXCIpLnN0YXRpYyA9ICExO1xuICAgIGNvbnN0IG1lc2hNYXRlcmlhbCA9IG5ldyBtZXNoLk1lc2hNYXRlcmlhbCh0ZXh0dXJlKTtcbiAgICBzdXBlcihnZW9tZXRyeSwgbWVzaE1hdGVyaWFsLCBudWxsLCBkcmF3TW9kZSksIHRoaXMuYXV0b1VwZGF0ZSA9ICEwO1xuICB9XG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIHZlcnRpY2VzIGRhdGEuXG4gICAqIEB0eXBlIHtGbG9hdDMyQXJyYXl9XG4gICAqL1xuICBnZXQgdmVydGljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVZlcnRleFBvc2l0aW9uXCIpLmRhdGE7XG4gIH1cbiAgc2V0IHZlcnRpY2VzKHZhbHVlKSB7XG4gICAgdGhpcy5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIikuZGF0YSA9IHZhbHVlO1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLmF1dG9VcGRhdGUgJiYgdGhpcy5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIikudXBkYXRlKCksIHN1cGVyLl9yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5leHBvcnRzLlNpbXBsZU1lc2ggPSBTaW1wbGVNZXNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2ltcGxlTWVzaC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgbWVzaCA9IHJlcXVpcmUoXCJAcGl4aS9tZXNoXCIpLCBQbGFuZUdlb21ldHJ5ID0gcmVxdWlyZShcIi4vZ2VvbWV0cnkvUGxhbmVHZW9tZXRyeS5qc1wiKTtcbmNsYXNzIFNpbXBsZVBsYW5lIGV4dGVuZHMgbWVzaC5NZXNoIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gVGhlIHRleHR1cmUgdG8gdXNlIG9uIHRoZSBTaW1wbGVQbGFuZS5cbiAgICogQHBhcmFtIHZlcnRpY2VzWCAtIFRoZSBudW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIHgtYXhpc1xuICAgKiBAcGFyYW0gdmVydGljZXNZIC0gVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgeS1heGlzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCB2ZXJ0aWNlc1gsIHZlcnRpY2VzWSkge1xuICAgIGNvbnN0IHBsYW5lR2VvbWV0cnkgPSBuZXcgUGxhbmVHZW9tZXRyeS5QbGFuZUdlb21ldHJ5KHRleHR1cmUud2lkdGgsIHRleHR1cmUuaGVpZ2h0LCB2ZXJ0aWNlc1gsIHZlcnRpY2VzWSksIG1lc2hNYXRlcmlhbCA9IG5ldyBtZXNoLk1lc2hNYXRlcmlhbChjb3JlLlRleHR1cmUuV0hJVEUpO1xuICAgIHN1cGVyKHBsYW5lR2VvbWV0cnksIG1lc2hNYXRlcmlhbCksIHRoaXMudGV4dHVyZSA9IHRleHR1cmUsIHRoaXMuYXV0b1Jlc2l6ZSA9ICEwO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCBmb3Igb3ZlcnJpZGVzLCB0byBkbyBzb21ldGhpbmcgaW4gY2FzZSB0ZXh0dXJlIGZyYW1lIHdhcyBjaGFuZ2VkLlxuICAgKiBNZXNoZXMgYmFzZWQgb24gcGxhbmUgY2FuIG92ZXJyaWRlIGl0IGFuZCBjaGFuZ2UgbW9yZSBkZXRhaWxzIGJhc2VkIG9uIHRleHR1cmUuXG4gICAqL1xuICB0ZXh0dXJlVXBkYXRlZCgpIHtcbiAgICB0aGlzLl90ZXh0dXJlSUQgPSB0aGlzLnNoYWRlci50ZXh0dXJlLl91cGRhdGVJRDtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnksIHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5zaGFkZXIudGV4dHVyZTtcbiAgICB0aGlzLmF1dG9SZXNpemUgJiYgKGdlb21ldHJ5LndpZHRoICE9PSB3aWR0aCB8fCBnZW9tZXRyeS5oZWlnaHQgIT09IGhlaWdodCkgJiYgKGdlb21ldHJ5LndpZHRoID0gdGhpcy5zaGFkZXIudGV4dHVyZS53aWR0aCwgZ2VvbWV0cnkuaGVpZ2h0ID0gdGhpcy5zaGFkZXIudGV4dHVyZS5oZWlnaHQsIGdlb21ldHJ5LmJ1aWxkKCkpO1xuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy5zaGFkZXIudGV4dHVyZSAhPT0gdmFsdWUgJiYgKHRoaXMuc2hhZGVyLnRleHR1cmUgPSB2YWx1ZSwgdGhpcy5fdGV4dHVyZUlEID0gLTEsIHZhbHVlLmJhc2VUZXh0dXJlLnZhbGlkID8gdGhpcy50ZXh0dXJlVXBkYXRlZCgpIDogdmFsdWUub25jZShcInVwZGF0ZVwiLCB0aGlzLnRleHR1cmVVcGRhdGVkLCB0aGlzKSk7XG4gIH1cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhZGVyLnRleHR1cmU7XG4gIH1cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIHRoaXMuX3RleHR1cmVJRCAhPT0gdGhpcy5zaGFkZXIudGV4dHVyZS5fdXBkYXRlSUQgJiYgdGhpcy50ZXh0dXJlVXBkYXRlZCgpLCBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICB0aGlzLnNoYWRlci50ZXh0dXJlLm9mZihcInVwZGF0ZVwiLCB0aGlzLnRleHR1cmVVcGRhdGVkLCB0aGlzKSwgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgfVxufVxuZXhwb3J0cy5TaW1wbGVQbGFuZSA9IFNpbXBsZVBsYW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2ltcGxlUGxhbmUuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIG1lc2ggPSByZXF1aXJlKFwiQHBpeGkvbWVzaFwiKSwgUm9wZUdlb21ldHJ5ID0gcmVxdWlyZShcIi4vZ2VvbWV0cnkvUm9wZUdlb21ldHJ5LmpzXCIpO1xuY2xhc3MgU2ltcGxlUm9wZSBleHRlbmRzIG1lc2guTWVzaCB7XG4gIC8qKlxuICAgKiBOb3RlOiBUaGUgd3JhcCBtb2RlIG9mIHRoZSB0ZXh0dXJlIGlzIHNldCB0byBSRVBFQVQgaWYgYHRleHR1cmVTY2FsZWAgaXMgcG9zaXRpdmUuXG4gICAqIEBwYXJhbSB0ZXh0dXJlIC0gVGhlIHRleHR1cmUgdG8gdXNlIG9uIHRoZSByb3BlLlxuICAgKiBAcGFyYW0gcG9pbnRzIC0gQW4gYXJyYXkgb2Yge0BsaW5rIFBJWEkuUG9pbnR9IG9iamVjdHMgdG8gY29uc3RydWN0IHRoaXMgcm9wZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRleHR1cmVTY2FsZSAtIE9wdGlvbmFsLiBQb3NpdGl2ZSB2YWx1ZXMgc2NhbGUgcm9wZSB0ZXh0dXJlXG4gICAqIGtlZXBpbmcgaXRzIGFzcGVjdCByYXRpby4gWW91IGNhbiByZWR1Y2UgYWxwaGEgY2hhbm5lbCBhcnRpZmFjdHMgYnkgcHJvdmlkaW5nIGEgbGFyZ2VyIHRleHR1cmVcbiAgICogYW5kIGRvd25zYW1wbGluZyBoZXJlLiBJZiBzZXQgdG8gemVybywgdGV4dHVyZSB3aWxsIGJlIHN0cmV0Y2hlZCBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4dHVyZSwgcG9pbnRzLCB0ZXh0dXJlU2NhbGUgPSAwKSB7XG4gICAgY29uc3Qgcm9wZUdlb21ldHJ5ID0gbmV3IFJvcGVHZW9tZXRyeS5Sb3BlR2VvbWV0cnkodGV4dHVyZS5oZWlnaHQsIHBvaW50cywgdGV4dHVyZVNjYWxlKSwgbWVzaE1hdGVyaWFsID0gbmV3IG1lc2guTWVzaE1hdGVyaWFsKHRleHR1cmUpO1xuICAgIHRleHR1cmVTY2FsZSA+IDAgJiYgKHRleHR1cmUuYmFzZVRleHR1cmUud3JhcE1vZGUgPSBjb3JlLldSQVBfTU9ERVMuUkVQRUFUKSwgc3VwZXIocm9wZUdlb21ldHJ5LCBtZXNoTWF0ZXJpYWwpLCB0aGlzLmF1dG9VcGRhdGUgPSAhMDtcbiAgfVxuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgICh0aGlzLmF1dG9VcGRhdGUgfHwgZ2VvbWV0cnkuX3dpZHRoICE9PSB0aGlzLnNoYWRlci50ZXh0dXJlLmhlaWdodCkgJiYgKGdlb21ldHJ5Ll93aWR0aCA9IHRoaXMuc2hhZGVyLnRleHR1cmUuaGVpZ2h0LCBnZW9tZXRyeS51cGRhdGUoKSksIHN1cGVyLl9yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5leHBvcnRzLlNpbXBsZVJvcGUgPSBTaW1wbGVSb3BlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2ltcGxlUm9wZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1lc2ggPSByZXF1aXJlKFwiQHBpeGkvbWVzaFwiKTtcbmNsYXNzIFBsYW5lR2VvbWV0cnkgZXh0ZW5kcyBtZXNoLk1lc2hHZW9tZXRyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHBsYW5lLlxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgcGxhbmUuXG4gICAqIEBwYXJhbSBzZWdXaWR0aCAtIE51bWJlciBvZiBob3Jpem9udGFsIHNlZ21lbnRzLlxuICAgKiBAcGFyYW0gc2VnSGVpZ2h0IC0gTnVtYmVyIG9mIHZlcnRpY2FsIHNlZ21lbnRzLlxuICAgKi9cbiAgY29uc3RydWN0b3Iod2lkdGggPSAxMDAsIGhlaWdodCA9IDEwMCwgc2VnV2lkdGggPSAxMCwgc2VnSGVpZ2h0ID0gMTApIHtcbiAgICBzdXBlcigpLCB0aGlzLnNlZ1dpZHRoID0gc2VnV2lkdGgsIHRoaXMuc2VnSGVpZ2h0ID0gc2VnSGVpZ2h0LCB0aGlzLndpZHRoID0gd2lkdGgsIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0LCB0aGlzLmJ1aWxkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlZnJlc2hlcyBwbGFuZSBjb29yZGluYXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYnVpbGQoKSB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLnNlZ1dpZHRoICogdGhpcy5zZWdIZWlnaHQsIHZlcnRzID0gW10sIHV2cyA9IFtdLCBpbmRpY2VzID0gW10sIHNlZ21lbnRzWCA9IHRoaXMuc2VnV2lkdGggLSAxLCBzZWdtZW50c1kgPSB0aGlzLnNlZ0hlaWdodCAtIDEsIHNpemVYID0gdGhpcy53aWR0aCAvIHNlZ21lbnRzWCwgc2l6ZVkgPSB0aGlzLmhlaWdodCAvIHNlZ21lbnRzWTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSBpICUgdGhpcy5zZWdXaWR0aCwgeSA9IGkgLyB0aGlzLnNlZ1dpZHRoIHwgMDtcbiAgICAgIHZlcnRzLnB1c2goeCAqIHNpemVYLCB5ICogc2l6ZVkpLCB1dnMucHVzaCh4IC8gc2VnbWVudHNYLCB5IC8gc2VnbWVudHNZKTtcbiAgICB9XG4gICAgY29uc3QgdG90YWxTdWIgPSBzZWdtZW50c1ggKiBzZWdtZW50c1k7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFN1YjsgaSsrKSB7XG4gICAgICBjb25zdCB4cG9zID0gaSAlIHNlZ21lbnRzWCwgeXBvcyA9IGkgLyBzZWdtZW50c1ggfCAwLCB2YWx1ZSA9IHlwb3MgKiB0aGlzLnNlZ1dpZHRoICsgeHBvcywgdmFsdWUyID0geXBvcyAqIHRoaXMuc2VnV2lkdGggKyB4cG9zICsgMSwgdmFsdWUzID0gKHlwb3MgKyAxKSAqIHRoaXMuc2VnV2lkdGggKyB4cG9zLCB2YWx1ZTQgPSAoeXBvcyArIDEpICogdGhpcy5zZWdXaWR0aCArIHhwb3MgKyAxO1xuICAgICAgaW5kaWNlcy5wdXNoKFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdmFsdWUyLFxuICAgICAgICB2YWx1ZTMsXG4gICAgICAgIHZhbHVlMixcbiAgICAgICAgdmFsdWU0LFxuICAgICAgICB2YWx1ZTNcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyc1swXS5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0cyksIHRoaXMuYnVmZmVyc1sxXS5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSh1dnMpLCB0aGlzLmluZGV4QnVmZmVyLmRhdGEgPSBuZXcgVWludDE2QXJyYXkoaW5kaWNlcyksIHRoaXMuYnVmZmVyc1swXS51cGRhdGUoKSwgdGhpcy5idWZmZXJzWzFdLnVwZGF0ZSgpLCB0aGlzLmluZGV4QnVmZmVyLnVwZGF0ZSgpO1xuICB9XG59XG5leHBvcnRzLlBsYW5lR2VvbWV0cnkgPSBQbGFuZUdlb21ldHJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGxhbmVHZW9tZXRyeS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1lc2ggPSByZXF1aXJlKFwiQHBpeGkvbWVzaFwiKTtcbmNsYXNzIFJvcGVHZW9tZXRyeSBleHRlbmRzIG1lc2guTWVzaEdlb21ldHJ5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB3aWR0aCAtIFRoZSB3aWR0aCAoaS5lLiwgdGhpY2tuZXNzKSBvZiB0aGUgcm9wZS5cbiAgICogQHBhcmFtIHBvaW50cyAtIEFuIGFycmF5IG9mIHtAbGluayBQSVhJLlBvaW50fSBvYmplY3RzIHRvIGNvbnN0cnVjdCB0aGlzIHJvcGUuXG4gICAqIEBwYXJhbSB0ZXh0dXJlU2NhbGUgLSBCeSBkZWZhdWx0IHRoZSByb3BlIHRleHR1cmUgd2lsbCBiZSBzdHJldGNoZWQgdG8gbWF0Y2hcbiAgICogICAgIHJvcGUgbGVuZ3RoLiBJZiB0ZXh0dXJlU2NhbGUgaXMgcG9zaXRpdmUgdGhpcyB2YWx1ZSB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBzY2FsaW5nXG4gICAqICAgICBmYWN0b3IgYW5kIHRoZSB0ZXh0dXJlIHdpbGwgcHJlc2VydmUgaXRzIGFzcGVjdCByYXRpbyBpbnN0ZWFkLiBUbyBjcmVhdGUgYSB0aWxpbmcgcm9wZVxuICAgKiAgICAgc2V0IGJhc2VUZXh0dXJlLndyYXBNb2RlIHRvIHtAbGluayBQSVhJLldSQVBfTU9ERVMuUkVQRUFUfSBhbmQgdXNlIGEgcG93ZXIgb2YgdHdvIHRleHR1cmUsXG4gICAqICAgICB0aGVuIHNldCB0ZXh0dXJlU2NhbGU9MSB0byBrZWVwIHRoZSBvcmlnaW5hbCB0ZXh0dXJlIHBpeGVsIHNpemUuXG4gICAqICAgICBJbiBvcmRlciB0byByZWR1Y2UgYWxwaGEgY2hhbm5lbCBhcnRpZmFjdHMgcHJvdmlkZSBhIGxhcmdlciB0ZXh0dXJlIGFuZCBkb3duc2FtcGxlIC1cbiAgICogICAgIGkuZS4gc2V0IHRleHR1cmVTY2FsZT0wLjUgdG8gc2NhbGUgaXQgZG93biB0d2ljZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHdpZHRoID0gMjAwLCBwb2ludHMsIHRleHR1cmVTY2FsZSA9IDApIHtcbiAgICBzdXBlcihcbiAgICAgIG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpLFxuICAgICAgbmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCksXG4gICAgICBuZXcgVWludDE2QXJyYXkoKHBvaW50cy5sZW5ndGggLSAxKSAqIDYpXG4gICAgKSwgdGhpcy5wb2ludHMgPSBwb2ludHMsIHRoaXMuX3dpZHRoID0gd2lkdGgsIHRoaXMudGV4dHVyZVNjYWxlID0gdGV4dHVyZVNjYWxlLCB0aGlzLmJ1aWxkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCAoaS5lLiwgdGhpY2tuZXNzKSBvZiB0aGUgcm9wZS5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9XG4gIC8qKiBSZWZyZXNoZXMgUm9wZSBpbmRpY2VzIGFuZCB1dnMgKi9cbiAgYnVpbGQoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgaWYgKCFwb2ludHMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdmVydGV4QnVmZmVyID0gdGhpcy5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIiksIHV2QnVmZmVyID0gdGhpcy5nZXRCdWZmZXIoXCJhVGV4dHVyZUNvb3JkXCIpLCBpbmRleEJ1ZmZlciA9IHRoaXMuZ2V0SW5kZXgoKTtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDEpXG4gICAgICByZXR1cm47XG4gICAgdmVydGV4QnVmZmVyLmRhdGEubGVuZ3RoIC8gNCAhPT0gcG9pbnRzLmxlbmd0aCAmJiAodmVydGV4QnVmZmVyLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KSwgdXZCdWZmZXIuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpLCBpbmRleEJ1ZmZlci5kYXRhID0gbmV3IFVpbnQxNkFycmF5KChwb2ludHMubGVuZ3RoIC0gMSkgKiA2KSk7XG4gICAgY29uc3QgdXZzID0gdXZCdWZmZXIuZGF0YSwgaW5kaWNlcyA9IGluZGV4QnVmZmVyLmRhdGE7XG4gICAgdXZzWzBdID0gMCwgdXZzWzFdID0gMCwgdXZzWzJdID0gMCwgdXZzWzNdID0gMTtcbiAgICBsZXQgYW1vdW50ID0gMCwgcHJldiA9IHBvaW50c1swXTtcbiAgICBjb25zdCB0ZXh0dXJlV2lkdGggPSB0aGlzLl93aWR0aCAqIHRoaXMudGV4dHVyZVNjYWxlLCB0b3RhbCA9IHBvaW50cy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGkgKiA0O1xuICAgICAgaWYgKHRoaXMudGV4dHVyZVNjYWxlID4gMCkge1xuICAgICAgICBjb25zdCBkeCA9IHByZXYueCAtIHBvaW50c1tpXS54LCBkeSA9IHByZXYueSAtIHBvaW50c1tpXS55LCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIHByZXYgPSBwb2ludHNbaV0sIGFtb3VudCArPSBkaXN0YW5jZSAvIHRleHR1cmVXaWR0aDtcbiAgICAgIH0gZWxzZVxuICAgICAgICBhbW91bnQgPSBpIC8gKHRvdGFsIC0gMSk7XG4gICAgICB1dnNbaW5kZXhdID0gYW1vdW50LCB1dnNbaW5kZXggKyAxXSA9IDAsIHV2c1tpbmRleCArIDJdID0gYW1vdW50LCB1dnNbaW5kZXggKyAzXSA9IDE7XG4gICAgfVxuICAgIGxldCBpbmRleENvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsIC0gMTsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGkgKiAyO1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXgsIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4ICsgMSwgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAyLCBpbmRpY2VzW2luZGV4Q291bnQrK10gPSBpbmRleCArIDIsIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4ICsgMSwgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAzO1xuICAgIH1cbiAgICB1dkJ1ZmZlci51cGRhdGUoKSwgaW5kZXhCdWZmZXIudXBkYXRlKCksIHRoaXMudXBkYXRlVmVydGljZXMoKTtcbiAgfVxuICAvKiogcmVmcmVzaGVzIHZlcnRpY2VzIG9mIFJvcGUgbWVzaCAqL1xuICB1cGRhdGVWZXJ0aWNlcygpIHtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDEpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGxhc3RQb2ludCA9IHBvaW50c1swXSwgbmV4dFBvaW50LCBwZXJwWCA9IDAsIHBlcnBZID0gMDtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMuYnVmZmVyc1swXS5kYXRhLCB0b3RhbCA9IHBvaW50cy5sZW5ndGgsIGhhbGZXaWR0aCA9IHRoaXMudGV4dHVyZVNjYWxlID4gMCA/IHRoaXMudGV4dHVyZVNjYWxlICogdGhpcy5fd2lkdGggLyAyIDogdGhpcy5fd2lkdGggLyAyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV0sIGluZGV4ID0gaSAqIDQ7XG4gICAgICBpIDwgcG9pbnRzLmxlbmd0aCAtIDEgPyBuZXh0UG9pbnQgPSBwb2ludHNbaSArIDFdIDogbmV4dFBvaW50ID0gcG9pbnQsIHBlcnBZID0gLShuZXh0UG9pbnQueCAtIGxhc3RQb2ludC54KSwgcGVycFggPSBuZXh0UG9pbnQueSAtIGxhc3RQb2ludC55O1xuICAgICAgbGV0IHJhdGlvID0gKDEgLSBpIC8gKHRvdGFsIC0gMSkpICogMTA7XG4gICAgICByYXRpbyA+IDEgJiYgKHJhdGlvID0gMSk7XG4gICAgICBjb25zdCBwZXJwTGVuZ3RoID0gTWF0aC5zcXJ0KHBlcnBYICogcGVycFggKyBwZXJwWSAqIHBlcnBZKTtcbiAgICAgIHBlcnBMZW5ndGggPCAxZS02ID8gKHBlcnBYID0gMCwgcGVycFkgPSAwKSA6IChwZXJwWCAvPSBwZXJwTGVuZ3RoLCBwZXJwWSAvPSBwZXJwTGVuZ3RoLCBwZXJwWCAqPSBoYWxmV2lkdGgsIHBlcnBZICo9IGhhbGZXaWR0aCksIHZlcnRpY2VzW2luZGV4XSA9IHBvaW50LnggKyBwZXJwWCwgdmVydGljZXNbaW5kZXggKyAxXSA9IHBvaW50LnkgKyBwZXJwWSwgdmVydGljZXNbaW5kZXggKyAyXSA9IHBvaW50LnggLSBwZXJwWCwgdmVydGljZXNbaW5kZXggKyAzXSA9IHBvaW50LnkgLSBwZXJwWSwgbGFzdFBvaW50ID0gcG9pbnQ7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyc1swXS51cGRhdGUoKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy50ZXh0dXJlU2NhbGUgPiAwID8gdGhpcy5idWlsZCgpIDogdGhpcy51cGRhdGVWZXJ0aWNlcygpO1xuICB9XG59XG5leHBvcnRzLlJvcGVHZW9tZXRyeSA9IFJvcGVHZW9tZXRyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJvcGVHZW9tZXRyeS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIFBsYW5lR2VvbWV0cnkgPSByZXF1aXJlKFwiLi9nZW9tZXRyeS9QbGFuZUdlb21ldHJ5LmpzXCIpLCBSb3BlR2VvbWV0cnkgPSByZXF1aXJlKFwiLi9nZW9tZXRyeS9Sb3BlR2VvbWV0cnkuanNcIiksIE5pbmVTbGljZVBsYW5lID0gcmVxdWlyZShcIi4vTmluZVNsaWNlUGxhbmUuanNcIiksIFNpbXBsZU1lc2ggPSByZXF1aXJlKFwiLi9TaW1wbGVNZXNoLmpzXCIpLCBTaW1wbGVQbGFuZSA9IHJlcXVpcmUoXCIuL1NpbXBsZVBsYW5lLmpzXCIpLCBTaW1wbGVSb3BlID0gcmVxdWlyZShcIi4vU2ltcGxlUm9wZS5qc1wiKTtcbmV4cG9ydHMuUGxhbmVHZW9tZXRyeSA9IFBsYW5lR2VvbWV0cnkuUGxhbmVHZW9tZXRyeTtcbmV4cG9ydHMuUm9wZUdlb21ldHJ5ID0gUm9wZUdlb21ldHJ5LlJvcGVHZW9tZXRyeTtcbmV4cG9ydHMuTmluZVNsaWNlUGxhbmUgPSBOaW5lU2xpY2VQbGFuZS5OaW5lU2xpY2VQbGFuZTtcbmV4cG9ydHMuU2ltcGxlTWVzaCA9IFNpbXBsZU1lc2guU2ltcGxlTWVzaDtcbmV4cG9ydHMuU2ltcGxlUGxhbmUgPSBTaW1wbGVQbGFuZS5TaW1wbGVQbGFuZTtcbmV4cG9ydHMuU2ltcGxlUm9wZSA9IFNpbXBsZVJvcGUuU2ltcGxlUm9wZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCBkaXNwbGF5ID0gcmVxdWlyZShcIkBwaXhpL2Rpc3BsYXlcIiksIE1lc2hCYXRjaFV2cyA9IHJlcXVpcmUoXCIuL01lc2hCYXRjaFV2cy5qc1wiKTtcbmNvbnN0IHRlbXBQb2ludCA9IG5ldyBjb3JlLlBvaW50KCksIHRlbXBQb2x5Z29uID0gbmV3IGNvcmUuUG9seWdvbigpLCBfTWVzaCA9IGNsYXNzIF9NZXNoMiBleHRlbmRzIGRpc3BsYXkuQ29udGFpbmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBnZW9tZXRyeSAtIFRoZSBnZW9tZXRyeSB0aGUgbWVzaCB3aWxsIHVzZS5cbiAgICogQHBhcmFtIHtQSVhJLk1lc2hNYXRlcmlhbH0gc2hhZGVyIC0gVGhlIHNoYWRlciB0aGUgbWVzaCB3aWxsIHVzZS5cbiAgICogQHBhcmFtIHN0YXRlIC0gVGhlIHN0YXRlIHRoYXQgdGhlIFdlYkdMIGNvbnRleHQgaXMgcmVxdWlyZWQgdG8gYmUgaW4gdG8gcmVuZGVyIHRoZSBtZXNoXG4gICAqICAgICAgICBpZiBubyBzdGF0ZSBpcyBwcm92aWRlZCwgdXNlcyB7QGxpbmsgUElYSS5TdGF0ZS5mb3IyZH0gdG8gY3JlYXRlIGEgMkQgc3RhdGUgZm9yIFBpeGlKUy5cbiAgICogQHBhcmFtIGRyYXdNb2RlIC0gVGhlIGRyYXdNb2RlLCBjYW4gYmUgYW55IG9mIHRoZSB7QGxpbmsgUElYSS5EUkFXX01PREVTfSBjb25zdGFudHMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihnZW9tZXRyeSwgc2hhZGVyLCBzdGF0ZSwgZHJhd01vZGUgPSBjb3JlLkRSQVdfTU9ERVMuVFJJQU5HTEVTKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5LCB0aGlzLnNoYWRlciA9IHNoYWRlciwgdGhpcy5zdGF0ZSA9IHN0YXRlIHx8IGNvcmUuU3RhdGUuZm9yMmQoKSwgdGhpcy5kcmF3TW9kZSA9IGRyYXdNb2RlLCB0aGlzLnN0YXJ0ID0gMCwgdGhpcy5zaXplID0gMCwgdGhpcy51dnMgPSBudWxsLCB0aGlzLmluZGljZXMgPSBudWxsLCB0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDEpLCB0aGlzLnZlcnRleERpcnR5ID0gLTEsIHRoaXMuX3RyYW5zZm9ybUlEID0gLTEsIHRoaXMuX3JvdW5kUGl4ZWxzID0gY29yZS5zZXR0aW5ncy5ST1VORF9QSVhFTFMsIHRoaXMuYmF0Y2hVdnMgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBJbmNsdWRlcyB2ZXJ0ZXggcG9zaXRpb25zLCBmYWNlIGluZGljZXMsIG5vcm1hbHMsIGNvbG9ycywgVVZzLCBhbmRcbiAgICogY3VzdG9tIGF0dHJpYnV0ZXMgd2l0aGluIGJ1ZmZlcnMsIHJlZHVjaW5nIHRoZSBjb3N0IG9mIHBhc3NpbmcgYWxsXG4gICAqIHRoaXMgZGF0YSB0byB0aGUgR1BVLiBDYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgTWVzaCBvYmplY3RzLlxuICAgKi9cbiAgZ2V0IGdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLl9nZW9tZXRyeTtcbiAgfVxuICBzZXQgZ2VvbWV0cnkodmFsdWUpIHtcbiAgICB0aGlzLl9nZW9tZXRyeSAhPT0gdmFsdWUgJiYgKHRoaXMuX2dlb21ldHJ5ICYmICh0aGlzLl9nZW9tZXRyeS5yZWZDb3VudC0tLCB0aGlzLl9nZW9tZXRyeS5yZWZDb3VudCA9PT0gMCAmJiB0aGlzLl9nZW9tZXRyeS5kaXNwb3NlKCkpLCB0aGlzLl9nZW9tZXRyeSA9IHZhbHVlLCB0aGlzLl9nZW9tZXRyeSAmJiB0aGlzLl9nZW9tZXRyeS5yZWZDb3VudCsrLCB0aGlzLnZlcnRleERpcnR5ID0gLTEpO1xuICB9XG4gIC8qKlxuICAgKiBUbyBjaGFuZ2UgbWVzaCB1didzLCBjaGFuZ2UgaXRzIHV2QnVmZmVyIGRhdGEgYW5kIGluY3JlbWVudCBpdHMgX3VwZGF0ZUlELlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB1dkJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5idWZmZXJzWzFdO1xuICB9XG4gIC8qKlxuICAgKiBUbyBjaGFuZ2UgbWVzaCB2ZXJ0aWNlcywgY2hhbmdlIGl0cyB1dkJ1ZmZlciBkYXRhIGFuZCBpbmNyZW1lbnQgaXRzIF91cGRhdGVJRC5cbiAgICogSW5jcmVtZW50aW5nIF91cGRhdGVJRCBpcyBvcHRpb25hbCBiZWNhdXNlIG1vc3Qgb2YgTWVzaCBvYmplY3RzIGRvIGl0IGFueXdheS5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdmVydGljZXNCdWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1swXTtcbiAgfVxuICAvKiogQWxpYXMgZm9yIHtAbGluayBQSVhJLk1lc2gjc2hhZGVyfS4gKi9cbiAgc2V0IG1hdGVyaWFsKHZhbHVlKSB7XG4gICAgdGhpcy5zaGFkZXIgPSB2YWx1ZTtcbiAgfVxuICBnZXQgbWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhZGVyO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBNZXNoLiBBcHBseSBhIHZhbHVlIG9mXG4gICAqIGBQSVhJLkJMRU5EX01PREVTLk5PUk1BTGAgdG8gcmVzZXQgdGhlIGJsZW5kIG1vZGUuXG4gICAqIEBkZWZhdWx0IFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMO1xuICAgKi9cbiAgc2V0IGJsZW5kTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuc3RhdGUuYmxlbmRNb2RlID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5ibGVuZE1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIElmIHRydWUgUGl4aUpTIHdpbGwgTWF0aC5mbG9vcigpIHgveSB2YWx1ZXMgd2hlbiByZW5kZXJpbmcsIHN0b3BwaW5nIHBpeGVsIGludGVycG9sYXRpb24uXG4gICAqIEFkdmFudGFnZXMgY2FuIGluY2x1ZGUgc2hhcnBlciBpbWFnZSBxdWFsaXR5IChsaWtlIHRleHQpIGFuZCBmYXN0ZXIgcmVuZGVyaW5nIG9uIGNhbnZhcy5cbiAgICogVGhlIG1haW4gZGlzYWR2YW50YWdlIGlzIG1vdmVtZW50IG9mIG9iamVjdHMgbWF5IGFwcGVhciBsZXNzIHNtb290aC5cbiAgICogVG8gc2V0IHRoZSBnbG9iYWwgZGVmYXVsdCwgY2hhbmdlIHtAbGluayBQSVhJLnNldHRpbmdzLlJPVU5EX1BJWEVMU31cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNldCByb3VuZFBpeGVscyh2YWx1ZSkge1xuICAgIHRoaXMuX3JvdW5kUGl4ZWxzICE9PSB2YWx1ZSAmJiAodGhpcy5fdHJhbnNmb3JtSUQgPSAtMSksIHRoaXMuX3JvdW5kUGl4ZWxzID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHJvdW5kUGl4ZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3VuZFBpeGVscztcbiAgfVxuICAvKipcbiAgICogVGhlIG11bHRpcGx5IHRpbnQgYXBwbGllZCB0byB0aGUgTWVzaC4gVGhpcyBpcyBhIGhleCB2YWx1ZS4gQSB2YWx1ZSBvZlxuICAgKiBgMHhGRkZGRkZgIHdpbGwgcmVtb3ZlIGFueSB0aW50IGVmZmVjdC5cbiAgICpcbiAgICogTnVsbCBmb3Igbm9uLU1lc2hNYXRlcmlhbCBzaGFkZXJzXG4gICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAqL1xuICBnZXQgdGludCgpIHtcbiAgICByZXR1cm4gXCJ0aW50XCIgaW4gdGhpcy5zaGFkZXIgPyB0aGlzLnNoYWRlci50aW50IDogbnVsbDtcbiAgfVxuICBzZXQgdGludCh2YWx1ZSkge1xuICAgIHRoaXMuc2hhZGVyLnRpbnQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHRpbnQgY29sb3IgYXMgYSBSR0IgaW50ZWdlclxuICAgKiBAaWdub3JlXG4gICAqL1xuICBnZXQgdGludFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnNoYWRlci50aW50VmFsdWU7XG4gIH1cbiAgLyoqIFRoZSB0ZXh0dXJlIHRoYXQgdGhlIE1lc2ggdXNlcy4gTnVsbCBmb3Igbm9uLU1lc2hNYXRlcmlhbCBzaGFkZXJzICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiBcInRleHR1cmVcIiBpbiB0aGlzLnNoYWRlciA/IHRoaXMuc2hhZGVyLnRleHR1cmUgOiBudWxsO1xuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy5zaGFkZXIudGV4dHVyZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTdGFuZGFyZCByZW5kZXJlciBkcmF3LlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBJbnN0YW5jZSB0byByZW5kZXJlci5cbiAgICovXG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1swXS5kYXRhO1xuICAgIHRoaXMuc2hhZGVyLmJhdGNoYWJsZSAmJiB0aGlzLmRyYXdNb2RlID09PSBjb3JlLkRSQVdfTU9ERVMuVFJJQU5HTEVTICYmIHZlcnRpY2VzLmxlbmd0aCA8IF9NZXNoMi5CQVRDSEFCTEVfU0laRSAqIDIgPyB0aGlzLl9yZW5kZXJUb0JhdGNoKHJlbmRlcmVyKSA6IHRoaXMuX3JlbmRlckRlZmF1bHQocmVuZGVyZXIpO1xuICB9XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBub24tYmF0Y2hpbmcgd2F5IG9mIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gSW5zdGFuY2UgdG8gcmVuZGVyZXIuXG4gICAqL1xuICBfcmVuZGVyRGVmYXVsdChyZW5kZXJlcikge1xuICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuICAgIHNoYWRlci5hbHBoYSA9IHRoaXMud29ybGRBbHBoYSwgc2hhZGVyLnVwZGF0ZSAmJiBzaGFkZXIudXBkYXRlKCksIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCksIHNoYWRlci51bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkoITApLCByZW5kZXJlci5zaGFkZXIuYmluZChzaGFkZXIpLCByZW5kZXJlci5zdGF0ZS5zZXQodGhpcy5zdGF0ZSksIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQodGhpcy5nZW9tZXRyeSwgc2hhZGVyKSwgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyh0aGlzLmRyYXdNb2RlLCB0aGlzLnNpemUsIHRoaXMuc3RhcnQsIHRoaXMuZ2VvbWV0cnkuaW5zdGFuY2VDb3VudCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcmluZyBieSB1c2luZyB0aGUgQmF0Y2ggc3lzdGVtLlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBJbnN0YW5jZSB0byByZW5kZXJlci5cbiAgICovXG4gIF9yZW5kZXJUb0JhdGNoKHJlbmRlcmVyKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5LCBzaGFkZXIgPSB0aGlzLnNoYWRlcjtcbiAgICBzaGFkZXIudXZNYXRyaXggJiYgKHNoYWRlci51dk1hdHJpeC51cGRhdGUoKSwgdGhpcy5jYWxjdWxhdGVVdnMoKSksIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKSwgdGhpcy5pbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXhCdWZmZXIuZGF0YSwgdGhpcy5fdGludFJHQiA9IHNoYWRlci5fdGludFJHQiwgdGhpcy5fdGV4dHVyZSA9IHNoYWRlci50ZXh0dXJlO1xuICAgIGNvbnN0IHBsdWdpbk5hbWUgPSB0aGlzLm1hdGVyaWFsLnBsdWdpbk5hbWU7XG4gICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2luc1twbHVnaW5OYW1lXSksIHJlbmRlcmVyLnBsdWdpbnNbcGx1Z2luTmFtZV0ucmVuZGVyKHRoaXMpO1xuICB9XG4gIC8qKiBVcGRhdGVzIHZlcnRleERhdGEgZmllbGQgYmFzZWQgb24gdHJhbnNmb3JtIGFuZCB2ZXJ0aWNlcy4gKi9cbiAgY2FsY3VsYXRlVmVydGljZXMoKSB7XG4gICAgY29uc3QgdmVydGljZXNCdWZmZXIgPSB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMF0sIHZlcnRpY2VzID0gdmVydGljZXNCdWZmZXIuZGF0YSwgdmVydGV4RGlydHlJZCA9IHZlcnRpY2VzQnVmZmVyLl91cGRhdGVJRDtcbiAgICBpZiAodmVydGV4RGlydHlJZCA9PT0gdGhpcy52ZXJ0ZXhEaXJ0eSAmJiB0aGlzLl90cmFuc2Zvcm1JRCA9PT0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fdHJhbnNmb3JtSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCwgdGhpcy52ZXJ0ZXhEYXRhLmxlbmd0aCAhPT0gdmVydGljZXMubGVuZ3RoICYmICh0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzLmxlbmd0aCkpO1xuICAgIGNvbnN0IHd0ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0sIGEgPSB3dC5hLCBiID0gd3QuYiwgYyA9IHd0LmMsIGQgPSB3dC5kLCB0eCA9IHd0LnR4LCB0eSA9IHd0LnR5LCB2ZXJ0ZXhEYXRhID0gdGhpcy52ZXJ0ZXhEYXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4RGF0YS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSB2ZXJ0aWNlc1tpICogMl0sIHkgPSB2ZXJ0aWNlc1tpICogMiArIDFdO1xuICAgICAgdmVydGV4RGF0YVtpICogMl0gPSBhICogeCArIGMgKiB5ICsgdHgsIHZlcnRleERhdGFbaSAqIDIgKyAxXSA9IGIgKiB4ICsgZCAqIHkgKyB0eTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JvdW5kUGl4ZWxzKSB7XG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gY29yZS5zZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICB2ZXJ0ZXhEYXRhW2ldID0gTWF0aC5yb3VuZCh2ZXJ0ZXhEYXRhW2ldICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgIH1cbiAgICB0aGlzLnZlcnRleERpcnR5ID0gdmVydGV4RGlydHlJZDtcbiAgfVxuICAvKiogVXBkYXRlcyB1diBmaWVsZCBiYXNlZCBvbiBmcm9tIGdlb21ldHJ5IHV2J3Mgb3IgYmF0Y2hVdnMuICovXG4gIGNhbGN1bGF0ZVV2cygpIHtcbiAgICBjb25zdCBnZW9tVXZzID0gdGhpcy5nZW9tZXRyeS5idWZmZXJzWzFdLCBzaGFkZXIgPSB0aGlzLnNoYWRlcjtcbiAgICBzaGFkZXIudXZNYXRyaXguaXNTaW1wbGUgPyB0aGlzLnV2cyA9IGdlb21VdnMuZGF0YSA6ICh0aGlzLmJhdGNoVXZzIHx8ICh0aGlzLmJhdGNoVXZzID0gbmV3IE1lc2hCYXRjaFV2cy5NZXNoQmF0Y2hVdnMoZ2VvbVV2cywgc2hhZGVyLnV2TWF0cml4KSksIHRoaXMuYmF0Y2hVdnMudXBkYXRlKCksIHRoaXMudXZzID0gdGhpcy5iYXRjaFV2cy5kYXRhKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYm91bmRzIG9mIHRoZSBtZXNoIGFzIGEgcmVjdGFuZ2xlLiBUaGUgYm91bmRzIGNhbGN1bGF0aW9uIHRha2VzIHRoZSB3b3JsZFRyYW5zZm9ybSBpbnRvIGFjY291bnQuXG4gICAqIHRoZXJlIG11c3QgYmUgYSBhVmVydGV4UG9zaXRpb24gYXR0cmlidXRlIHByZXNlbnQgaW4gdGhlIGdlb21ldHJ5IGZvciBib3VuZHMgdG8gYmUgY2FsY3VsYXRlZCBjb3JyZWN0bHkuXG4gICAqL1xuICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKSwgdGhpcy5fYm91bmRzLmFkZFZlcnRleERhdGEodGhpcy52ZXJ0ZXhEYXRhLCAwLCB0aGlzLnZlcnRleERhdGEubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogVGVzdHMgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhpcyBtZXNoLiBXb3JrcyBvbmx5IGZvciBQSVhJLkRSQVdfTU9ERVMuVFJJQU5HTEVTLlxuICAgKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gdGVzdC5cbiAgICogQHJldHVybnMgLSBUaGUgcmVzdWx0IG9mIHRoZSB0ZXN0LlxuICAgKi9cbiAgY29udGFpbnNQb2ludChwb2ludCkge1xuICAgIGlmICghdGhpcy5nZXRCb3VuZHMoKS5jb250YWlucyhwb2ludC54LCBwb2ludC55KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgdGVtcFBvaW50KTtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVZlcnRleFBvc2l0aW9uXCIpLmRhdGEsIHBvaW50cyA9IHRlbXBQb2x5Z29uLnBvaW50cywgaW5kaWNlcyA9IHRoaXMuZ2VvbWV0cnkuZ2V0SW5kZXgoKS5kYXRhLCBsZW4gPSBpbmRpY2VzLmxlbmd0aCwgc3RlcCA9IHRoaXMuZHJhd01vZGUgPT09IDQgPyAzIDogMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSArIDIgPCBsZW47IGkgKz0gc3RlcCkge1xuICAgICAgY29uc3QgaW5kMCA9IGluZGljZXNbaV0gKiAyLCBpbmQxID0gaW5kaWNlc1tpICsgMV0gKiAyLCBpbmQyID0gaW5kaWNlc1tpICsgMl0gKiAyO1xuICAgICAgaWYgKHBvaW50c1swXSA9IHZlcnRpY2VzW2luZDBdLCBwb2ludHNbMV0gPSB2ZXJ0aWNlc1tpbmQwICsgMV0sIHBvaW50c1syXSA9IHZlcnRpY2VzW2luZDFdLCBwb2ludHNbM10gPSB2ZXJ0aWNlc1tpbmQxICsgMV0sIHBvaW50c1s0XSA9IHZlcnRpY2VzW2luZDJdLCBwb2ludHNbNV0gPSB2ZXJ0aWNlc1tpbmQyICsgMV0sIHRlbXBQb2x5Z29uLmNvbnRhaW5zKHRlbXBQb2ludC54LCB0ZW1wUG9pbnQueSkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyksIHRoaXMuX2NhY2hlZFRleHR1cmUgJiYgKHRoaXMuX2NhY2hlZFRleHR1cmUuZGVzdHJveSgpLCB0aGlzLl9jYWNoZWRUZXh0dXJlID0gbnVsbCksIHRoaXMuZ2VvbWV0cnkgPSBudWxsLCB0aGlzLnNoYWRlciA9IG51bGwsIHRoaXMuc3RhdGUgPSBudWxsLCB0aGlzLnV2cyA9IG51bGwsIHRoaXMuaW5kaWNlcyA9IG51bGwsIHRoaXMudmVydGV4RGF0YSA9IG51bGw7XG4gIH1cbn07XG5fTWVzaC5CQVRDSEFCTEVfU0laRSA9IDEwMDtcbmxldCBNZXNoID0gX01lc2g7XG5leHBvcnRzLk1lc2ggPSBNZXNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgTWVzaEJhdGNoVXZzIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB1dkJ1ZmZlciAtIEJ1ZmZlciB3aXRoIG5vcm1hbGl6ZWQgdXYnc1xuICAgKiBAcGFyYW0gdXZNYXRyaXggLSBNYXRlcmlhbCBVViBtYXRyaXhcbiAgICovXG4gIGNvbnN0cnVjdG9yKHV2QnVmZmVyLCB1dk1hdHJpeCkge1xuICAgIHRoaXMudXZCdWZmZXIgPSB1dkJ1ZmZlciwgdGhpcy51dk1hdHJpeCA9IHV2TWF0cml4LCB0aGlzLmRhdGEgPSBudWxsLCB0aGlzLl9idWZmZXJVcGRhdGVJZCA9IC0xLCB0aGlzLl90ZXh0dXJlVXBkYXRlSWQgPSAtMSwgdGhpcy5fdXBkYXRlSUQgPSAwO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzXG4gICAqIEBwYXJhbSBmb3JjZVVwZGF0ZSAtIGZvcmNlIHRoZSB1cGRhdGVcbiAgICovXG4gIHVwZGF0ZShmb3JjZVVwZGF0ZSkge1xuICAgIGlmICghZm9yY2VVcGRhdGUgJiYgdGhpcy5fYnVmZmVyVXBkYXRlSWQgPT09IHRoaXMudXZCdWZmZXIuX3VwZGF0ZUlEICYmIHRoaXMuX3RleHR1cmVVcGRhdGVJZCA9PT0gdGhpcy51dk1hdHJpeC5fdXBkYXRlSUQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fYnVmZmVyVXBkYXRlSWQgPSB0aGlzLnV2QnVmZmVyLl91cGRhdGVJRCwgdGhpcy5fdGV4dHVyZVVwZGF0ZUlkID0gdGhpcy51dk1hdHJpeC5fdXBkYXRlSUQ7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMudXZCdWZmZXIuZGF0YTtcbiAgICAoIXRoaXMuZGF0YSB8fCB0aGlzLmRhdGEubGVuZ3RoICE9PSBkYXRhLmxlbmd0aCkgJiYgKHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5sZW5ndGgpKSwgdGhpcy51dk1hdHJpeC5tdWx0aXBseVV2cyhkYXRhLCB0aGlzLmRhdGEpLCB0aGlzLl91cGRhdGVJRCsrO1xuICB9XG59XG5leHBvcnRzLk1lc2hCYXRjaFV2cyA9IE1lc2hCYXRjaFV2cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc2hCYXRjaFV2cy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKTtcbmNsYXNzIE1lc2hHZW9tZXRyeSBleHRlbmRzIGNvcmUuR2VvbWV0cnkge1xuICAvKipcbiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8bnVtYmVyW119IFt2ZXJ0aWNlc10gLSBQb3NpdGlvbmFsIGRhdGEgb24gZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fG51bWJlcltdfSBbdXZzXSAtIFRleHR1cmUgVVZzLlxuICAgKiBAcGFyYW0ge1VpbnQxNkFycmF5fG51bWJlcltdfSBbaW5kZXhdIC0gSW5kZXhCdWZmZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZlcnRpY2VzLCB1dnMsIGluZGV4KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB2ZXJ0aWNlc0J1ZmZlciA9IG5ldyBjb3JlLkJ1ZmZlcih2ZXJ0aWNlcyksIHV2c0J1ZmZlciA9IG5ldyBjb3JlLkJ1ZmZlcih1dnMsICEwKSwgaW5kZXhCdWZmZXIgPSBuZXcgY29yZS5CdWZmZXIoaW5kZXgsICEwLCAhMCk7XG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJhVmVydGV4UG9zaXRpb25cIiwgdmVydGljZXNCdWZmZXIsIDIsICExLCBjb3JlLlRZUEVTLkZMT0FUKS5hZGRBdHRyaWJ1dGUoXCJhVGV4dHVyZUNvb3JkXCIsIHV2c0J1ZmZlciwgMiwgITEsIGNvcmUuVFlQRVMuRkxPQVQpLmFkZEluZGV4KGluZGV4QnVmZmVyKSwgdGhpcy5fdXBkYXRlSWQgPSAtMTtcbiAgfVxuICAvKipcbiAgICogSWYgdGhlIHZlcnRleCBwb3NpdGlvbiBpcyB1cGRhdGVkLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCB2ZXJ0ZXhEaXJ0eUlkKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlcnNbMF0uX3VwZGF0ZUlEO1xuICB9XG59XG5leHBvcnRzLk1lc2hHZW9tZXRyeSA9IE1lc2hHZW9tZXRyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc2hHZW9tZXRyeS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgbWVzaCQxID0gcmVxdWlyZShcIi4vc2hhZGVyL21lc2guZnJhZy5qc1wiKSwgbWVzaCA9IHJlcXVpcmUoXCIuL3NoYWRlci9tZXNoLnZlcnQuanNcIik7XG5jbGFzcyBNZXNoTWF0ZXJpYWwgZXh0ZW5kcyBjb3JlLlNoYWRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdVNhbXBsZXIgLSBUZXh0dXJlIHRoYXQgbWF0ZXJpYWwgdXNlcyB0byByZW5kZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5hbHBoYT0xXSAtIERlZmF1bHQgYWxwaGEuXG4gICAqIEBwYXJhbSB7UElYSS5Db2xvclNvdXJjZX0gW29wdGlvbnMudGludD0weEZGRkZGRl0gLSBEZWZhdWx0IHRpbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wbHVnaW5OYW1lPSdiYXRjaCddIC0gUmVuZGVyZXIgcGx1Z2luIGZvciBiYXRjaGluZy5cbiAgICogQHBhcmFtIHtQSVhJLlByb2dyYW19IFtvcHRpb25zLnByb2dyYW09MHhGRkZGRkZdIC0gQ3VzdG9tIHByb2dyYW0uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy51bmlmb3Jtc10gLSBDdXN0b20gdW5pZm9ybXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1U2FtcGxlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHVuaWZvcm1zID0ge1xuICAgICAgdVNhbXBsZXIsXG4gICAgICBhbHBoYTogMSxcbiAgICAgIHVUZXh0dXJlTWF0cml4OiBjb3JlLk1hdHJpeC5JREVOVElUWSxcbiAgICAgIHVDb2xvcjogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pXG4gICAgfTtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICB0aW50OiAxNjc3NzIxNSxcbiAgICAgIGFscGhhOiAxLFxuICAgICAgcGx1Z2luTmFtZTogXCJiYXRjaFwiXG4gICAgfSwgb3B0aW9ucyksIG9wdGlvbnMudW5pZm9ybXMgJiYgT2JqZWN0LmFzc2lnbih1bmlmb3Jtcywgb3B0aW9ucy51bmlmb3JtcyksIHN1cGVyKG9wdGlvbnMucHJvZ3JhbSB8fCBjb3JlLlByb2dyYW0uZnJvbShtZXNoLmRlZmF1bHQsIG1lc2gkMS5kZWZhdWx0KSwgdW5pZm9ybXMpLCB0aGlzLl9jb2xvckRpcnR5ID0gITEsIHRoaXMudXZNYXRyaXggPSBuZXcgY29yZS5UZXh0dXJlTWF0cml4KHVTYW1wbGVyKSwgdGhpcy5iYXRjaGFibGUgPSBvcHRpb25zLnByb2dyYW0gPT09IHZvaWQgMCwgdGhpcy5wbHVnaW5OYW1lID0gb3B0aW9ucy5wbHVnaW5OYW1lLCB0aGlzLl90aW50Q29sb3IgPSBuZXcgY29yZS5Db2xvcihvcHRpb25zLnRpbnQpLCB0aGlzLl90aW50UkdCID0gdGhpcy5fdGludENvbG9yLnRvTGl0dGxlRW5kaWFuTnVtYmVyKCksIHRoaXMuX2NvbG9yRGlydHkgPSAhMCwgdGhpcy5hbHBoYSA9IG9wdGlvbnMuYWxwaGE7XG4gIH1cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdGV4dHVyZSBiZWluZyByZW5kZXJlZC4gKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVNhbXBsZXI7XG4gIH1cbiAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVTYW1wbGVyICE9PSB2YWx1ZSAmJiAoIXRoaXMudW5pZm9ybXMudVNhbXBsZXIuYmFzZVRleHR1cmUuYWxwaGFNb2RlICE9ICF2YWx1ZS5iYXNlVGV4dHVyZS5hbHBoYU1vZGUgJiYgKHRoaXMuX2NvbG9yRGlydHkgPSAhMCksIHRoaXMudW5pZm9ybXMudVNhbXBsZXIgPSB2YWx1ZSwgdGhpcy51dk1hdHJpeC50ZXh0dXJlID0gdmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGdldHMgYXV0b21hdGljYWxseSBzZXQgYnkgdGhlIG9iamVjdCB1c2luZyB0aGlzLlxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBzZXQgYWxwaGEodmFsdWUpIHtcbiAgICB2YWx1ZSAhPT0gdGhpcy5fYWxwaGEgJiYgKHRoaXMuX2FscGhhID0gdmFsdWUsIHRoaXMuX2NvbG9yRGlydHkgPSAhMCk7XG4gIH1cbiAgZ2V0IGFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLl9hbHBoYTtcbiAgfVxuICAvKipcbiAgICogTXVsdGlwbHkgdGludCBmb3IgdGhlIG1hdGVyaWFsLlxuICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgKi9cbiAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICB2YWx1ZSAhPT0gdGhpcy50aW50ICYmICh0aGlzLl90aW50Q29sb3Iuc2V0VmFsdWUodmFsdWUpLCB0aGlzLl90aW50UkdCID0gdGhpcy5fdGludENvbG9yLnRvTGl0dGxlRW5kaWFuTnVtYmVyKCksIHRoaXMuX2NvbG9yRGlydHkgPSAhMCk7XG4gIH1cbiAgZ2V0IHRpbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbnRDb2xvci52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcm5hbCBudW1iZXIgZnJvbSB0aW50IGNvbG9yXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGdldCB0aW50VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbnRDb2xvci50b051bWJlcigpO1xuICB9XG4gIC8qKiBHZXRzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBNZXNoLiBJbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGZvciBjdXN0b20ge0BsaW5rIFBJWEkuTWVzaE1hdGVyaWFsfSBvYmplY3RzLiAqL1xuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuX2NvbG9yRGlydHkpIHtcbiAgICAgIHRoaXMuX2NvbG9yRGlydHkgPSAhMTtcbiAgICAgIGNvbnN0IGFwcGx5VG9DaGFubmVscyA9IHRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZS5hbHBoYU1vZGU7XG4gICAgICBjb3JlLkNvbG9yLnNoYXJlZC5zZXRWYWx1ZSh0aGlzLl90aW50Q29sb3IpLnByZW11bHRpcGx5KHRoaXMuX2FscGhhLCBhcHBseVRvQ2hhbm5lbHMpLnRvQXJyYXkodGhpcy51bmlmb3Jtcy51Q29sb3IpO1xuICAgIH1cbiAgICB0aGlzLnV2TWF0cml4LnVwZGF0ZSgpICYmICh0aGlzLnVuaWZvcm1zLnVUZXh0dXJlTWF0cml4ID0gdGhpcy51dk1hdHJpeC5tYXBDb29yZCk7XG4gIH1cbn1cbmV4cG9ydHMuTWVzaE1hdGVyaWFsID0gTWVzaE1hdGVyaWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaE1hdGVyaWFsLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgTWVzaCA9IHJlcXVpcmUoXCIuL01lc2guanNcIiksIE1lc2hCYXRjaFV2cyA9IHJlcXVpcmUoXCIuL01lc2hCYXRjaFV2cy5qc1wiKSwgTWVzaEdlb21ldHJ5ID0gcmVxdWlyZShcIi4vTWVzaEdlb21ldHJ5LmpzXCIpLCBNZXNoTWF0ZXJpYWwgPSByZXF1aXJlKFwiLi9NZXNoTWF0ZXJpYWwuanNcIik7XG5leHBvcnRzLk1lc2ggPSBNZXNoLk1lc2g7XG5leHBvcnRzLk1lc2hCYXRjaFV2cyA9IE1lc2hCYXRjaFV2cy5NZXNoQmF0Y2hVdnM7XG5leHBvcnRzLk1lc2hHZW9tZXRyeSA9IE1lc2hHZW9tZXRyeS5NZXNoR2VvbWV0cnk7XG5leHBvcnRzLk1lc2hNYXRlcmlhbCA9IE1lc2hNYXRlcmlhbC5NZXNoTWF0ZXJpYWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnZhciBmcmFnbWVudCA9IGB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XG5cbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuXG52b2lkIG1haW4odm9pZClcbntcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdUNvbG9yO1xufVxuYDtcbmV4cG9ydHMuZGVmYXVsdCA9IGZyYWdtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzaC5mcmFnLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIHZlcnRleCA9IGBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcbnVuaWZvcm0gbWF0MyB1VGV4dHVyZU1hdHJpeDtcblxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cbnZvaWQgbWFpbih2b2lkKVxue1xuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XG5cbiAgICB2VGV4dHVyZUNvb3JkID0gKHVUZXh0dXJlTWF0cml4ICogdmVjMyhhVGV4dHVyZUNvb3JkLCAxLjApKS54eTtcbn1cbmA7XG5leHBvcnRzLmRlZmF1bHQgPSB2ZXJ0ZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNoLnZlcnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIGRpc3BsYXkgPSByZXF1aXJlKFwiQHBpeGkvZGlzcGxheVwiKSwgc3ByaXRlID0gcmVxdWlyZShcIkBwaXhpL3Nwcml0ZVwiKTtcbmNvbnN0IF90ZW1wTWF0cml4ID0gbmV3IGNvcmUuTWF0cml4KCk7XG5kaXNwbGF5LkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZUFzQml0bWFwID0gITE7XG5kaXNwbGF5LkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZURhdGEgPSBudWxsO1xuZGlzcGxheS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FjaGVBc0JpdG1hcFJlc29sdXRpb24gPSBudWxsO1xuZGlzcGxheS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FjaGVBc0JpdG1hcE11bHRpc2FtcGxlID0gbnVsbDtcbmNsYXNzIENhY2hlRGF0YSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGV4dHVyZUNhY2hlSWQgPSBudWxsLCB0aGlzLm9yaWdpbmFsUmVuZGVyID0gbnVsbCwgdGhpcy5vcmlnaW5hbFJlbmRlckNhbnZhcyA9IG51bGwsIHRoaXMub3JpZ2luYWxDYWxjdWxhdGVCb3VuZHMgPSBudWxsLCB0aGlzLm9yaWdpbmFsR2V0TG9jYWxCb3VuZHMgPSBudWxsLCB0aGlzLm9yaWdpbmFsVXBkYXRlVHJhbnNmb3JtID0gbnVsbCwgdGhpcy5vcmlnaW5hbERlc3Ryb3kgPSBudWxsLCB0aGlzLm9yaWdpbmFsTWFzayA9IG51bGwsIHRoaXMub3JpZ2luYWxGaWx0ZXJBcmVhID0gbnVsbCwgdGhpcy5vcmlnaW5hbENvbnRhaW5zUG9pbnQgPSBudWxsLCB0aGlzLnNwcml0ZSA9IG51bGw7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGRpc3BsYXkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIFRoZSByZXNvbHV0aW9uIHRvIHVzZSBmb3IgY2FjaGVBc0JpdG1hcC4gQnkgZGVmYXVsdCB0aGlzIHdpbGwgdXNlIHRoZSByZW5kZXJlcidzIHJlc29sdXRpb25cbiAgICogYnV0IGNhbiBiZSBvdmVycmlkZW4gZm9yIHBlcmZvcm1hbmNlLiBMb3dlciB2YWx1ZXMgd2lsbCByZWR1Y2UgbWVtb3J5IHVzYWdlIGF0IHRoZSBleHBlbnNlXG4gICAqIG9mIHJlbmRlciBxdWFsaXR5LiBBIGZhbHNleSB2YWx1ZSBvZiBgbnVsbGAgb3IgYDBgIHdpbGwgZGVmYXVsdCB0byB0aGUgcmVuZGVyZXIncyByZXNvbHV0aW9uLlxuICAgKiBJZiBgY2FjaGVBc0JpdG1hcGAgaXMgc2V0IHRvIGB0cnVlYCwgdGhpcyB3aWxsIHJlLXJlbmRlciB3aXRoIHRoZSBuZXcgcmVzb2x1dGlvbi5cbiAgICogQG1lbWJlciB7bnVtYmVyfG51bGx9IGNhY2hlQXNCaXRtYXBSZXNvbHV0aW9uXG4gICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIGNhY2hlQXNCaXRtYXBSZXNvbHV0aW9uOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlQXNCaXRtYXBSZXNvbHV0aW9uO1xuICAgIH0sXG4gICAgc2V0KHJlc29sdXRpb24pIHtcbiAgICAgIHJlc29sdXRpb24gIT09IHRoaXMuX2NhY2hlQXNCaXRtYXBSZXNvbHV0aW9uICYmICh0aGlzLl9jYWNoZUFzQml0bWFwUmVzb2x1dGlvbiA9IHJlc29sdXRpb24sIHRoaXMuY2FjaGVBc0JpdG1hcCAmJiAodGhpcy5jYWNoZUFzQml0bWFwID0gITEsIHRoaXMuY2FjaGVBc0JpdG1hcCA9ICEwKSk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBzYW1wbGVzIHRvIHVzZSBmb3IgY2FjaGVBc0JpdG1hcC4gSWYgc2V0IHRvIGBudWxsYCwgdGhlIHJlbmRlcmVyJ3NcbiAgICogc2FtcGxlIGNvdW50IGlzIHVzZWQuXG4gICAqIElmIGBjYWNoZUFzQml0bWFwYCBpcyBzZXQgdG8gYHRydWVgLCB0aGlzIHdpbGwgcmUtcmVuZGVyIHdpdGggdGhlIG5ldyBudW1iZXIgb2Ygc2FtcGxlcy5cbiAgICogQG1lbWJlciB7bnVtYmVyfG51bGx9IGNhY2hlQXNCaXRtYXBNdWx0aXNhbXBsZVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICBjYWNoZUFzQml0bWFwTXVsdGlzYW1wbGU6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVBc0JpdG1hcE11bHRpc2FtcGxlO1xuICAgIH0sXG4gICAgc2V0KG11bHRpc2FtcGxlKSB7XG4gICAgICBtdWx0aXNhbXBsZSAhPT0gdGhpcy5fY2FjaGVBc0JpdG1hcE11bHRpc2FtcGxlICYmICh0aGlzLl9jYWNoZUFzQml0bWFwTXVsdGlzYW1wbGUgPSBtdWx0aXNhbXBsZSwgdGhpcy5jYWNoZUFzQml0bWFwICYmICh0aGlzLmNhY2hlQXNCaXRtYXAgPSAhMSwgdGhpcy5jYWNoZUFzQml0bWFwID0gITApKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIHlvdSB3YW50IHRoaXMgZGlzcGxheSBvYmplY3QgdG8gYmUgY2FjaGVkIGFzIGEgYml0bWFwLlxuICAgKiBUaGlzIGJhc2ljYWxseSB0YWtlcyBhIHNuYXBzaG90IG9mIHRoZSBkaXNwbGF5IG9iamVjdCBhcyBpdCBpcyBhdCB0aGF0IG1vbWVudC4gSXQgY2FuXG4gICAqIHByb3ZpZGUgYSBwZXJmb3JtYW5jZSBiZW5lZml0IGZvciBjb21wbGV4IHN0YXRpYyBkaXNwbGF5T2JqZWN0cy5cbiAgICogVG8gcmVtb3ZlIHNpbXBseSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBgZmFsc2VgXG4gICAqXG4gICAqIElNUE9SVEFOVCBHT1RDSEEgLSBNYWtlIHN1cmUgdGhhdCBhbGwgeW91ciB0ZXh0dXJlcyBhcmUgcHJlbG9hZGVkIEJFRk9SRSBzZXR0aW5nIHRoaXMgcHJvcGVydHkgdG8gdHJ1ZVxuICAgKiBhcyBpdCB3aWxsIHRha2UgYSBzbmFwc2hvdCBvZiB3aGF0IGlzIGN1cnJlbnRseSB0aGVyZS4gSWYgdGhlIHRleHR1cmVzIGhhdmUgbm90IGxvYWRlZCB0aGVuIHRoZXkgd2lsbCBub3QgYXBwZWFyLlxuICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgKi9cbiAgY2FjaGVBc0JpdG1hcDoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZUFzQml0bWFwO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fY2FjaGVBc0JpdG1hcCA9PT0gdmFsdWUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSB2YWx1ZTtcbiAgICAgIGxldCBkYXRhO1xuICAgICAgdmFsdWUgPyAodGhpcy5fY2FjaGVEYXRhIHx8ICh0aGlzLl9jYWNoZURhdGEgPSBuZXcgQ2FjaGVEYXRhKCkpLCBkYXRhID0gdGhpcy5fY2FjaGVEYXRhLCBkYXRhLm9yaWdpbmFsUmVuZGVyID0gdGhpcy5yZW5kZXIsIGRhdGEub3JpZ2luYWxSZW5kZXJDYW52YXMgPSB0aGlzLnJlbmRlckNhbnZhcywgZGF0YS5vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMudXBkYXRlVHJhbnNmb3JtLCBkYXRhLm9yaWdpbmFsQ2FsY3VsYXRlQm91bmRzID0gdGhpcy5jYWxjdWxhdGVCb3VuZHMsIGRhdGEub3JpZ2luYWxHZXRMb2NhbEJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMsIGRhdGEub3JpZ2luYWxEZXN0cm95ID0gdGhpcy5kZXN0cm95LCBkYXRhLm9yaWdpbmFsQ29udGFpbnNQb2ludCA9IHRoaXMuY29udGFpbnNQb2ludCwgZGF0YS5vcmlnaW5hbE1hc2sgPSB0aGlzLl9tYXNrLCBkYXRhLm9yaWdpbmFsRmlsdGVyQXJlYSA9IHRoaXMuZmlsdGVyQXJlYSwgdGhpcy5yZW5kZXIgPSB0aGlzLl9yZW5kZXJDYWNoZWQsIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fcmVuZGVyQ2FjaGVkQ2FudmFzLCB0aGlzLmRlc3Ryb3kgPSB0aGlzLl9jYWNoZUFzQml0bWFwRGVzdHJveSkgOiAoZGF0YSA9IHRoaXMuX2NhY2hlRGF0YSwgZGF0YS5zcHJpdGUgJiYgdGhpcy5fZGVzdHJveUNhY2hlZERpc3BsYXlPYmplY3QoKSwgdGhpcy5yZW5kZXIgPSBkYXRhLm9yaWdpbmFsUmVuZGVyLCB0aGlzLnJlbmRlckNhbnZhcyA9IGRhdGEub3JpZ2luYWxSZW5kZXJDYW52YXMsIHRoaXMuY2FsY3VsYXRlQm91bmRzID0gZGF0YS5vcmlnaW5hbENhbGN1bGF0ZUJvdW5kcywgdGhpcy5nZXRMb2NhbEJvdW5kcyA9IGRhdGEub3JpZ2luYWxHZXRMb2NhbEJvdW5kcywgdGhpcy5kZXN0cm95ID0gZGF0YS5vcmlnaW5hbERlc3Ryb3ksIHRoaXMudXBkYXRlVHJhbnNmb3JtID0gZGF0YS5vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybSwgdGhpcy5jb250YWluc1BvaW50ID0gZGF0YS5vcmlnaW5hbENvbnRhaW5zUG9pbnQsIHRoaXMuX21hc2sgPSBkYXRhLm9yaWdpbmFsTWFzaywgdGhpcy5maWx0ZXJBcmVhID0gZGF0YS5vcmlnaW5hbEZpbHRlckFyZWEpO1xuICAgIH1cbiAgfVxufSk7XG5kaXNwbGF5LkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9yZW5kZXJDYWNoZWQgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuICAhdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUgfHwgKHRoaXMuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0KHJlbmRlcmVyKSwgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS50cmFuc2Zvcm0uX3dvcmxkSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCwgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhLCB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLl9yZW5kZXIocmVuZGVyZXIpKTtcbn07XG5kaXNwbGF5LkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9pbml0Q2FjaGVkRGlzcGxheU9iamVjdCA9IGZ1bmN0aW9uKHJlbmRlcmVyKSB7XG4gIGlmICh0aGlzLl9jYWNoZURhdGE/LnNwcml0ZSlcbiAgICByZXR1cm47XG4gIGNvbnN0IGNhY2hlQWxwaGEgPSB0aGlzLmFscGhhO1xuICB0aGlzLmFscGhhID0gMSwgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcyhuZXcgY29yZS5SZWN0YW5nbGUoKSwgITApO1xuICBpZiAodGhpcy5maWx0ZXJzPy5sZW5ndGgpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5maWx0ZXJzWzBdLnBhZGRpbmc7XG4gICAgYm91bmRzLnBhZChwYWRkaW5nKTtcbiAgfVxuICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5jYWNoZUFzQml0bWFwUmVzb2x1dGlvbiB8fCByZW5kZXJlci5yZXNvbHV0aW9uO1xuICBib3VuZHMuY2VpbChyZXNvbHV0aW9uKSwgYm91bmRzLndpZHRoID0gTWF0aC5tYXgoYm91bmRzLndpZHRoLCAxIC8gcmVzb2x1dGlvbiksIGJvdW5kcy5oZWlnaHQgPSBNYXRoLm1heChib3VuZHMuaGVpZ2h0LCAxIC8gcmVzb2x1dGlvbik7XG4gIGNvbnN0IGNhY2hlZFJlbmRlclRleHR1cmUgPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmN1cnJlbnQsIGNhY2hlZFNvdXJjZUZyYW1lID0gcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5zb3VyY2VGcmFtZS5jbG9uZSgpLCBjYWNoZWREZXN0aW5hdGlvbkZyYW1lID0gcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5kZXN0aW5hdGlvbkZyYW1lLmNsb25lKCksIGNhY2hlZFByb2plY3Rpb25UcmFuc2Zvcm0gPSByZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSwgcmVuZGVyVGV4dHVyZSA9IGNvcmUuUmVuZGVyVGV4dHVyZS5jcmVhdGUoe1xuICAgIHdpZHRoOiBib3VuZHMud2lkdGgsXG4gICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0LFxuICAgIHJlc29sdXRpb24sXG4gICAgbXVsdGlzYW1wbGU6IHRoaXMuY2FjaGVBc0JpdG1hcE11bHRpc2FtcGxlID8/IHJlbmRlcmVyLm11bHRpc2FtcGxlXG4gIH0pLCB0ZXh0dXJlQ2FjaGVJZCA9IGBjYWNoZUFzQml0bWFwXyR7Y29yZS51dGlscy51aWQoKX1gO1xuICB0aGlzLl9jYWNoZURhdGEudGV4dHVyZUNhY2hlSWQgPSB0ZXh0dXJlQ2FjaGVJZCwgY29yZS5CYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUsIHRleHR1cmVDYWNoZUlkKSwgY29yZS5UZXh0dXJlLmFkZFRvQ2FjaGUocmVuZGVyVGV4dHVyZSwgdGV4dHVyZUNhY2hlSWQpO1xuICBjb25zdCBtID0gdGhpcy50cmFuc2Zvcm0ubG9jYWxUcmFuc2Zvcm0uY29weVRvKF90ZW1wTWF0cml4KS5pbnZlcnQoKS50cmFuc2xhdGUoLWJvdW5kcy54LCAtYm91bmRzLnkpO1xuICB0aGlzLnJlbmRlciA9IHRoaXMuX2NhY2hlRGF0YS5vcmlnaW5hbFJlbmRlciwgcmVuZGVyZXIucmVuZGVyKHRoaXMsIHsgcmVuZGVyVGV4dHVyZSwgY2xlYXI6ICEwLCB0cmFuc2Zvcm06IG0sIHNraXBVcGRhdGVUcmFuc2Zvcm06ICExIH0pLCByZW5kZXJlci5mcmFtZWJ1ZmZlci5ibGl0KCksIHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtID0gY2FjaGVkUHJvamVjdGlvblRyYW5zZm9ybSwgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKGNhY2hlZFJlbmRlclRleHR1cmUsIGNhY2hlZFNvdXJjZUZyYW1lLCBjYWNoZWREZXN0aW5hdGlvbkZyYW1lKSwgdGhpcy5yZW5kZXIgPSB0aGlzLl9yZW5kZXJDYWNoZWQsIHRoaXMudXBkYXRlVHJhbnNmb3JtID0gdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtLCB0aGlzLmNhbGN1bGF0ZUJvdW5kcyA9IHRoaXMuX2NhbGN1bGF0ZUNhY2hlZEJvdW5kcywgdGhpcy5nZXRMb2NhbEJvdW5kcyA9IHRoaXMuX2dldENhY2hlZExvY2FsQm91bmRzLCB0aGlzLl9tYXNrID0gbnVsbCwgdGhpcy5maWx0ZXJBcmVhID0gbnVsbCwgdGhpcy5hbHBoYSA9IGNhY2hlQWxwaGE7XG4gIGNvbnN0IGNhY2hlZFNwcml0ZSA9IG5ldyBzcHJpdGUuU3ByaXRlKHJlbmRlclRleHR1cmUpO1xuICBjYWNoZWRTcHJpdGUudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0sIGNhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oYm91bmRzLnggLyBib3VuZHMud2lkdGgpLCBjYWNoZWRTcHJpdGUuYW5jaG9yLnkgPSAtKGJvdW5kcy55IC8gYm91bmRzLmhlaWdodCksIGNhY2hlZFNwcml0ZS5hbHBoYSA9IGNhY2hlQWxwaGEsIGNhY2hlZFNwcml0ZS5fYm91bmRzID0gdGhpcy5fYm91bmRzLCB0aGlzLl9jYWNoZURhdGEuc3ByaXRlID0gY2FjaGVkU3ByaXRlLCB0aGlzLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMSwgdGhpcy5wYXJlbnQgPyB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpIDogKHRoaXMuZW5hYmxlVGVtcFBhcmVudCgpLCB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpLCB0aGlzLmRpc2FibGVUZW1wUGFyZW50KG51bGwpKSwgdGhpcy5jb250YWluc1BvaW50ID0gY2FjaGVkU3ByaXRlLmNvbnRhaW5zUG9pbnQuYmluZChjYWNoZWRTcHJpdGUpO1xufTtcbmRpc3BsYXkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX3JlbmRlckNhY2hlZENhbnZhcyA9IGZ1bmN0aW9uKHJlbmRlcmVyKSB7XG4gICF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMucmVuZGVyYWJsZSB8fCAodGhpcy5faW5pdENhY2hlZERpc3BsYXlPYmplY3RDYW52YXMocmVuZGVyZXIpLCB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLndvcmxkQWxwaGEgPSB0aGlzLndvcmxkQWxwaGEsIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuX3JlbmRlckNhbnZhcyhyZW5kZXJlcikpO1xufTtcbmRpc3BsYXkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0Q2FudmFzID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbiAgaWYgKHRoaXMuX2NhY2hlRGF0YT8uc3ByaXRlKVxuICAgIHJldHVybjtcbiAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcyhuZXcgY29yZS5SZWN0YW5nbGUoKSwgITApLCBjYWNoZUFscGhhID0gdGhpcy5hbHBoYTtcbiAgdGhpcy5hbHBoYSA9IDE7XG4gIGNvbnN0IGNhY2hlZFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmNhbnZhc0NvbnRleHQuYWN0aXZlQ29udGV4dCwgY2FjaGVkUHJvamVjdGlvblRyYW5zZm9ybSA9IHJlbmRlcmVyLl9wcm9qVHJhbnNmb3JtLCByZXNvbHV0aW9uID0gdGhpcy5jYWNoZUFzQml0bWFwUmVzb2x1dGlvbiB8fCByZW5kZXJlci5yZXNvbHV0aW9uO1xuICBib3VuZHMuY2VpbChyZXNvbHV0aW9uKSwgYm91bmRzLndpZHRoID0gTWF0aC5tYXgoYm91bmRzLndpZHRoLCAxIC8gcmVzb2x1dGlvbiksIGJvdW5kcy5oZWlnaHQgPSBNYXRoLm1heChib3VuZHMuaGVpZ2h0LCAxIC8gcmVzb2x1dGlvbik7XG4gIGNvbnN0IHJlbmRlclRleHR1cmUgPSBjb3JlLlJlbmRlclRleHR1cmUuY3JlYXRlKHtcbiAgICB3aWR0aDogYm91bmRzLndpZHRoLFxuICAgIGhlaWdodDogYm91bmRzLmhlaWdodCxcbiAgICByZXNvbHV0aW9uXG4gIH0pLCB0ZXh0dXJlQ2FjaGVJZCA9IGBjYWNoZUFzQml0bWFwXyR7Y29yZS51dGlscy51aWQoKX1gO1xuICB0aGlzLl9jYWNoZURhdGEudGV4dHVyZUNhY2hlSWQgPSB0ZXh0dXJlQ2FjaGVJZCwgY29yZS5CYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUsIHRleHR1cmVDYWNoZUlkKSwgY29yZS5UZXh0dXJlLmFkZFRvQ2FjaGUocmVuZGVyVGV4dHVyZSwgdGV4dHVyZUNhY2hlSWQpO1xuICBjb25zdCBtID0gX3RlbXBNYXRyaXg7XG4gIHRoaXMudHJhbnNmb3JtLmxvY2FsVHJhbnNmb3JtLmNvcHlUbyhtKSwgbS5pbnZlcnQoKSwgbS50eCAtPSBib3VuZHMueCwgbS50eSAtPSBib3VuZHMueSwgdGhpcy5yZW5kZXJDYW52YXMgPSB0aGlzLl9jYWNoZURhdGEub3JpZ2luYWxSZW5kZXJDYW52YXMsIHJlbmRlcmVyLnJlbmRlcih0aGlzLCB7IHJlbmRlclRleHR1cmUsIGNsZWFyOiAhMCwgdHJhbnNmb3JtOiBtLCBza2lwVXBkYXRlVHJhbnNmb3JtOiAhMSB9KSwgcmVuZGVyZXIuY2FudmFzQ29udGV4dC5hY3RpdmVDb250ZXh0ID0gY2FjaGVkUmVuZGVyVGFyZ2V0LCByZW5kZXJlci5fcHJvalRyYW5zZm9ybSA9IGNhY2hlZFByb2plY3Rpb25UcmFuc2Zvcm0sIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fcmVuZGVyQ2FjaGVkQ2FudmFzLCB0aGlzLnVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSwgdGhpcy5jYWxjdWxhdGVCb3VuZHMgPSB0aGlzLl9jYWxjdWxhdGVDYWNoZWRCb3VuZHMsIHRoaXMuZ2V0TG9jYWxCb3VuZHMgPSB0aGlzLl9nZXRDYWNoZWRMb2NhbEJvdW5kcywgdGhpcy5fbWFzayA9IG51bGwsIHRoaXMuZmlsdGVyQXJlYSA9IG51bGwsIHRoaXMuYWxwaGEgPSBjYWNoZUFscGhhO1xuICBjb25zdCBjYWNoZWRTcHJpdGUgPSBuZXcgc3ByaXRlLlNwcml0ZShyZW5kZXJUZXh0dXJlKTtcbiAgY2FjaGVkU3ByaXRlLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLCBjYWNoZWRTcHJpdGUuYW5jaG9yLnggPSAtKGJvdW5kcy54IC8gYm91bmRzLndpZHRoKSwgY2FjaGVkU3ByaXRlLmFuY2hvci55ID0gLShib3VuZHMueSAvIGJvdW5kcy5oZWlnaHQpLCBjYWNoZWRTcHJpdGUuYWxwaGEgPSBjYWNoZUFscGhhLCBjYWNoZWRTcHJpdGUuX2JvdW5kcyA9IHRoaXMuX2JvdW5kcywgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZSA9IGNhY2hlZFNwcml0ZSwgdGhpcy50cmFuc2Zvcm0uX3BhcmVudElEID0gLTEsIHRoaXMucGFyZW50ID8gdGhpcy51cGRhdGVUcmFuc2Zvcm0oKSA6ICh0aGlzLnBhcmVudCA9IHJlbmRlcmVyLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudCwgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKSwgdGhpcy5wYXJlbnQgPSBudWxsKSwgdGhpcy5jb250YWluc1BvaW50ID0gY2FjaGVkU3ByaXRlLmNvbnRhaW5zUG9pbnQuYmluZChjYWNoZWRTcHJpdGUpO1xufTtcbmRpc3BsYXkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2NhbGN1bGF0ZUNhY2hlZEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9ib3VuZHMuY2xlYXIoKSwgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS50cmFuc2Zvcm0uX3dvcmxkSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCwgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5fY2FsY3VsYXRlQm91bmRzKCksIHRoaXMuX2JvdW5kcy51cGRhdGVJRCA9IHRoaXMuX2JvdW5kc0lEO1xufTtcbmRpc3BsYXkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2dldENhY2hlZExvY2FsQm91bmRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLmdldExvY2FsQm91bmRzKG51bGwpO1xufTtcbmRpc3BsYXkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuX3RleHR1cmUuZGVzdHJveSghMCksIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUgPSBudWxsLCBjb3JlLkJhc2VUZXh0dXJlLnJlbW92ZUZyb21DYWNoZSh0aGlzLl9jYWNoZURhdGEudGV4dHVyZUNhY2hlSWQpLCBjb3JlLlRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCksIHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCA9IG51bGw7XG59O1xuZGlzcGxheS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FjaGVBc0JpdG1hcERlc3Ryb3kgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHRoaXMuY2FjaGVBc0JpdG1hcCA9ICExLCB0aGlzLmRlc3Ryb3kob3B0aW9ucyk7XG59O1xuZXhwb3J0cy5DYWNoZURhdGEgPSBDYWNoZURhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGRpc3BsYXkgPSByZXF1aXJlKFwiQHBpeGkvZGlzcGxheVwiKTtcbmRpc3BsYXkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUubmFtZSA9IG51bGw7XG5kaXNwbGF5LkNvbnRhaW5lci5wcm90b3R5cGUuZ2V0Q2hpbGRCeU5hbWUgPSBmdW5jdGlvbihuYW1lLCBkZWVwKSB7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgaWYgKHRoaXMuY2hpbGRyZW5baV0ubmFtZSA9PT0gbmFtZSlcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldO1xuICBpZiAoZGVlcClcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBpZiAoIWNoaWxkLmdldENoaWxkQnlOYW1lKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGNoaWxkLmdldENoaWxkQnlOYW1lKG5hbWUsICEwKTtcbiAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICByZXR1cm4gbnVsbDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgZGlzcGxheSA9IHJlcXVpcmUoXCJAcGl4aS9kaXNwbGF5XCIpO1xuZGlzcGxheS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5nZXRHbG9iYWxQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvaW50ID0gbmV3IGNvcmUuUG9pbnQoKSwgc2tpcFVwZGF0ZSA9ICExKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnRvR2xvYmFsKHRoaXMucG9zaXRpb24sIHBvaW50LCBza2lwVXBkYXRlKSA6IChwb2ludC54ID0gdGhpcy5wb3NpdGlvbi54LCBwb2ludC55ID0gdGhpcy5wb3NpdGlvbi55KSwgcG9pbnQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIik7XG5jbGFzcyBQYXJ0aWNsZUJ1ZmZlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllcyAtIFRoZSBwcm9wZXJ0aWVzIHRvIHVwbG9hZC5cbiAgICogQHBhcmFtIHtib29sZWFuW119IGR5bmFtaWNQcm9wZXJ0eUZsYWdzIC0gRmxhZ3MgZm9yIHdoaWNoIHByb3BlcnRpZXMgYXJlIGR5bmFtaWMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIC0gVGhlIHNpemUgb2YgdGhlIGJhdGNoLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIHNpemUpIHtcbiAgICB0aGlzLmdlb21ldHJ5ID0gbmV3IGNvcmUuR2VvbWV0cnkoKSwgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGwsIHRoaXMuc2l6ZSA9IHNpemUsIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMgPSBbXSwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsZXQgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgcHJvcGVydHkgPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IHByb3BlcnR5LmF0dHJpYnV0ZU5hbWUsXG4gICAgICAgIHNpemU6IHByb3BlcnR5LnNpemUsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiBwcm9wZXJ0eS51cGxvYWRGdW5jdGlvbixcbiAgICAgICAgdHlwZTogcHJvcGVydHkudHlwZSB8fCBjb3JlLlRZUEVTLkZMT0FULFxuICAgICAgICBvZmZzZXQ6IHByb3BlcnR5Lm9mZnNldFxuICAgICAgfSwgZHluYW1pY1Byb3BlcnR5RmxhZ3NbaV0gPyB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpIDogdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRpY1N0cmlkZSA9IDAsIHRoaXMuc3RhdGljQnVmZmVyID0gbnVsbCwgdGhpcy5zdGF0aWNEYXRhID0gbnVsbCwgdGhpcy5zdGF0aWNEYXRhVWludDMyID0gbnVsbCwgdGhpcy5keW5hbWljU3RyaWRlID0gMCwgdGhpcy5keW5hbWljQnVmZmVyID0gbnVsbCwgdGhpcy5keW5hbWljRGF0YSA9IG51bGwsIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBudWxsLCB0aGlzLl91cGRhdGVJRCA9IDAsIHRoaXMuaW5pdEJ1ZmZlcnMoKTtcbiAgfVxuICAvKiogU2V0cyB1cCB0aGUgcmVuZGVyZXIgY29udGV4dCBhbmQgbmVjZXNzYXJ5IGJ1ZmZlcnMuICovXG4gIGluaXRCdWZmZXJzKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICBsZXQgZHluYW1pY09mZnNldCA9IDA7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IG5ldyBjb3JlLkJ1ZmZlcihjb3JlLnV0aWxzLmNyZWF0ZUluZGljZXNGb3JRdWFkcyh0aGlzLnNpemUpLCAhMCwgITApLCBnZW9tZXRyeS5hZGRJbmRleCh0aGlzLmluZGV4QnVmZmVyKSwgdGhpcy5keW5hbWljU3RyaWRlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5keW5hbWljUHJvcGVydGllc1tpXTtcbiAgICAgIHByb3BlcnR5Lm9mZnNldCA9IGR5bmFtaWNPZmZzZXQsIGR5bmFtaWNPZmZzZXQgKz0gcHJvcGVydHkuc2l6ZSwgdGhpcy5keW5hbWljU3RyaWRlICs9IHByb3BlcnR5LnNpemU7XG4gICAgfVxuICAgIGNvbnN0IGR5bkJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLnNpemUgKiB0aGlzLmR5bmFtaWNTdHJpZGUgKiA0ICogNCk7XG4gICAgdGhpcy5keW5hbWljRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZHluQnVmZmVyKSwgdGhpcy5keW5hbWljRGF0YVVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShkeW5CdWZmZXIpLCB0aGlzLmR5bmFtaWNCdWZmZXIgPSBuZXcgY29yZS5CdWZmZXIodGhpcy5keW5hbWljRGF0YSwgITEsICExKTtcbiAgICBsZXQgc3RhdGljT2Zmc2V0ID0gMDtcbiAgICB0aGlzLnN0YXRpY1N0cmlkZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRpY1Byb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5zdGF0aWNQcm9wZXJ0aWVzW2ldO1xuICAgICAgcHJvcGVydHkub2Zmc2V0ID0gc3RhdGljT2Zmc2V0LCBzdGF0aWNPZmZzZXQgKz0gcHJvcGVydHkuc2l6ZSwgdGhpcy5zdGF0aWNTdHJpZGUgKz0gcHJvcGVydHkuc2l6ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdEJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLnNpemUgKiB0aGlzLnN0YXRpY1N0cmlkZSAqIDQgKiA0KTtcbiAgICB0aGlzLnN0YXRpY0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXRCdWZmZXIpLCB0aGlzLnN0YXRpY0RhdGFVaW50MzIgPSBuZXcgVWludDMyQXJyYXkoc3RhdEJ1ZmZlciksIHRoaXMuc3RhdGljQnVmZmVyID0gbmV3IGNvcmUuQnVmZmVyKHRoaXMuc3RhdGljRGF0YSwgITAsICExKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5keW5hbWljUHJvcGVydGllc1tpXTtcbiAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZShcbiAgICAgICAgcHJvcGVydHkuYXR0cmlidXRlTmFtZSxcbiAgICAgICAgdGhpcy5keW5hbWljQnVmZmVyLFxuICAgICAgICAwLFxuICAgICAgICBwcm9wZXJ0eS50eXBlID09PSBjb3JlLlRZUEVTLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHByb3BlcnR5LnR5cGUsXG4gICAgICAgIHRoaXMuZHluYW1pY1N0cmlkZSAqIDQsXG4gICAgICAgIHByb3BlcnR5Lm9mZnNldCAqIDRcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tpXTtcbiAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZShcbiAgICAgICAgcHJvcGVydHkuYXR0cmlidXRlTmFtZSxcbiAgICAgICAgdGhpcy5zdGF0aWNCdWZmZXIsXG4gICAgICAgIDAsXG4gICAgICAgIHByb3BlcnR5LnR5cGUgPT09IGNvcmUuVFlQRVMuVU5TSUdORURfQllURSxcbiAgICAgICAgcHJvcGVydHkudHlwZSxcbiAgICAgICAgdGhpcy5zdGF0aWNTdHJpZGUgKiA0LFxuICAgICAgICBwcm9wZXJ0eS5vZmZzZXQgKiA0XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBsb2FkcyB0aGUgZHluYW1pYyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gY2hpbGRyZW4gLSBUaGUgY2hpbGRyZW4gdG8gdXBsb2FkLlxuICAgKiBAcGFyYW0gc3RhcnRJbmRleCAtIFRoZSBpbmRleCB0byBzdGFydCBhdC5cbiAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBudW1iZXIgdG8gdXBsb2FkLlxuICAgKi9cbiAgdXBsb2FkRHluYW1pYyhjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV07XG4gICAgICBwcm9wZXJ0eS51cGxvYWRGdW5jdGlvbihcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgIGFtb3VudCxcbiAgICAgICAgcHJvcGVydHkudHlwZSA9PT0gY29yZS5UWVBFUy5VTlNJR05FRF9CWVRFID8gdGhpcy5keW5hbWljRGF0YVVpbnQzMiA6IHRoaXMuZHluYW1pY0RhdGEsXG4gICAgICAgIHRoaXMuZHluYW1pY1N0cmlkZSxcbiAgICAgICAgcHJvcGVydHkub2Zmc2V0XG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmR5bmFtaWNCdWZmZXIuX3VwZGF0ZUlEKys7XG4gIH1cbiAgLyoqXG4gICAqIFVwbG9hZHMgdGhlIHN0YXRpYyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gY2hpbGRyZW4gLSBUaGUgY2hpbGRyZW4gdG8gdXBsb2FkLlxuICAgKiBAcGFyYW0gc3RhcnRJbmRleCAtIFRoZSBpbmRleCB0byBzdGFydCBhdC5cbiAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBudW1iZXIgdG8gdXBsb2FkLlxuICAgKi9cbiAgdXBsb2FkU3RhdGljKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGljUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSB0aGlzLnN0YXRpY1Byb3BlcnRpZXNbaV07XG4gICAgICBwcm9wZXJ0eS51cGxvYWRGdW5jdGlvbihcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgIGFtb3VudCxcbiAgICAgICAgcHJvcGVydHkudHlwZSA9PT0gY29yZS5UWVBFUy5VTlNJR05FRF9CWVRFID8gdGhpcy5zdGF0aWNEYXRhVWludDMyIDogdGhpcy5zdGF0aWNEYXRhLFxuICAgICAgICB0aGlzLnN0YXRpY1N0cmlkZSxcbiAgICAgICAgcHJvcGVydHkub2Zmc2V0XG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnN0YXRpY0J1ZmZlci5fdXBkYXRlSUQrKztcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIFBhcnRpY2xlQnVmZmVyLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsLCB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gbnVsbCwgdGhpcy5keW5hbWljQnVmZmVyID0gbnVsbCwgdGhpcy5keW5hbWljRGF0YSA9IG51bGwsIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBudWxsLCB0aGlzLnN0YXRpY1Byb3BlcnRpZXMgPSBudWxsLCB0aGlzLnN0YXRpY0J1ZmZlciA9IG51bGwsIHRoaXMuc3RhdGljRGF0YSA9IG51bGwsIHRoaXMuc3RhdGljRGF0YVVpbnQzMiA9IG51bGwsIHRoaXMuZ2VvbWV0cnkuZGVzdHJveSgpO1xuICB9XG59XG5leHBvcnRzLlBhcnRpY2xlQnVmZmVyID0gUGFydGljbGVCdWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXJ0aWNsZUJ1ZmZlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgZGlzcGxheSA9IHJlcXVpcmUoXCJAcGl4aS9kaXNwbGF5XCIpO1xuY2xhc3MgUGFydGljbGVDb250YWluZXIgZXh0ZW5kcyBkaXNwbGF5LkNvbnRhaW5lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gbWF4U2l6ZSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwYXJ0aWNsZXMgdGhhdCBjYW4gYmUgcmVuZGVyZWQgYnkgdGhlIGNvbnRhaW5lci5cbiAgICogIEFmZmVjdHMgc2l6ZSBvZiBhbGxvY2F0ZWQgYnVmZmVycy5cbiAgICogQHBhcmFtIHByb3BlcnRpZXMgLSBUaGUgcHJvcGVydGllcyBvZiBjaGlsZHJlbiB0aGF0IHNob3VsZCBiZSB1cGxvYWRlZCB0byB0aGUgZ3B1IGFuZCBhcHBsaWVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wZXJ0aWVzLnZlcnRpY2VzPWZhbHNlXSAtIFdoZW4gdHJ1ZSwgdmVydGljZXMgYmUgdXBsb2FkZWQgYW5kIGFwcGxpZWQuXG4gICAqICAgICAgICAgICAgICAgICAgaWYgc3ByaXRlJ3MgYCBzY2FsZS9hbmNob3IvdHJpbS9mcmFtZS9vcmlnYCBpcyBkeW5hbWljLCBwbGVhc2Ugc2V0IGB0cnVlYC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbcHJvcGVydGllcy5wb3NpdGlvbj10cnVlXSAtIFdoZW4gdHJ1ZSwgcG9zaXRpb24gYmUgdXBsb2FkZWQgYW5kIGFwcGxpZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BlcnRpZXMucm90YXRpb249ZmFsc2VdIC0gV2hlbiB0cnVlLCByb3RhdGlvbiBiZSB1cGxvYWRlZCBhbmQgYXBwbGllZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbcHJvcGVydGllcy51dnM9ZmFsc2VdIC0gV2hlbiB0cnVlLCB1dnMgYmUgdXBsb2FkZWQgYW5kIGFwcGxpZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BlcnRpZXMudGludD1mYWxzZV0gLSBXaGVuIHRydWUsIGFscGhhIGFuZCB0aW50IGJlIHVwbG9hZGVkIGFuZCBhcHBsaWVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2JhdGNoU2l6ZT0xNjM4NF0gLSBOdW1iZXIgb2YgcGFydGljbGVzIHBlciBiYXRjaC4gSWYgbGVzcyB0aGFuIG1heFNpemUsIGl0IHVzZXMgbWF4U2l6ZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthdXRvUmVzaXplPWZhbHNlXSAtIElmIHRydWUsIGNvbnRhaW5lciBhbGxvY2F0ZXMgbW9yZSBiYXRjaGVzIGluIGNhc2VcbiAgICogIHRoZXJlIGFyZSBtb3JlIHRoYW4gYG1heFNpemVgIHBhcnRpY2xlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1heFNpemUgPSAxNTAwLCBwcm9wZXJ0aWVzLCBiYXRjaFNpemUgPSAxNjM4NCwgYXV0b1Jlc2l6ZSA9ICExKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBtYXhCYXRjaFNpemUgPSAxNjM4NDtcbiAgICBiYXRjaFNpemUgPiBtYXhCYXRjaFNpemUgJiYgKGJhdGNoU2l6ZSA9IG1heEJhdGNoU2l6ZSksIHRoaXMuX3Byb3BlcnRpZXMgPSBbITEsICEwLCAhMSwgITEsICExXSwgdGhpcy5fbWF4U2l6ZSA9IG1heFNpemUsIHRoaXMuX2JhdGNoU2l6ZSA9IGJhdGNoU2l6ZSwgdGhpcy5fYnVmZmVycyA9IG51bGwsIHRoaXMuX2J1ZmZlclVwZGF0ZUlEcyA9IFtdLCB0aGlzLl91cGRhdGVJRCA9IDAsIHRoaXMuaW50ZXJhY3RpdmVDaGlsZHJlbiA9ICExLCB0aGlzLmJsZW5kTW9kZSA9IGNvcmUuQkxFTkRfTU9ERVMuTk9STUFMLCB0aGlzLmF1dG9SZXNpemUgPSBhdXRvUmVzaXplLCB0aGlzLnJvdW5kUGl4ZWxzID0gITAsIHRoaXMuYmFzZVRleHR1cmUgPSBudWxsLCB0aGlzLnNldFByb3BlcnRpZXMocHJvcGVydGllcyksIHRoaXMuX3RpbnRDb2xvciA9IG5ldyBjb3JlLkNvbG9yKDApLCB0aGlzLnRpbnRSZ2IgPSBuZXcgRmxvYXQzMkFycmF5KDMpLCB0aGlzLnRpbnQgPSAxNjc3NzIxNTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcHJpdmF0ZSBwcm9wZXJ0aWVzIGFycmF5IHRvIGR5bmFtaWMgLyBzdGF0aWMgYmFzZWQgb24gdGhlIHBhc3NlZCBwcm9wZXJ0aWVzIG9iamVjdFxuICAgKiBAcGFyYW0gcHJvcGVydGllcyAtIFRoZSBwcm9wZXJ0aWVzIHRvIGJlIHVwbG9hZGVkXG4gICAqL1xuICBzZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICBwcm9wZXJ0aWVzICYmICh0aGlzLl9wcm9wZXJ0aWVzWzBdID0gXCJ2ZXJ0aWNlc1wiIGluIHByb3BlcnRpZXMgfHwgXCJzY2FsZVwiIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMudmVydGljZXMgfHwgISFwcm9wZXJ0aWVzLnNjYWxlIDogdGhpcy5fcHJvcGVydGllc1swXSwgdGhpcy5fcHJvcGVydGllc1sxXSA9IFwicG9zaXRpb25cIiBpbiBwcm9wZXJ0aWVzID8gISFwcm9wZXJ0aWVzLnBvc2l0aW9uIDogdGhpcy5fcHJvcGVydGllc1sxXSwgdGhpcy5fcHJvcGVydGllc1syXSA9IFwicm90YXRpb25cIiBpbiBwcm9wZXJ0aWVzID8gISFwcm9wZXJ0aWVzLnJvdGF0aW9uIDogdGhpcy5fcHJvcGVydGllc1syXSwgdGhpcy5fcHJvcGVydGllc1szXSA9IFwidXZzXCIgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy51dnMgOiB0aGlzLl9wcm9wZXJ0aWVzWzNdLCB0aGlzLl9wcm9wZXJ0aWVzWzRdID0gXCJ0aW50XCIgaW4gcHJvcGVydGllcyB8fCBcImFscGhhXCIgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy50aW50IHx8ICEhcHJvcGVydGllcy5hbHBoYSA6IHRoaXMuX3Byb3BlcnRpZXNbNF0pO1xuICB9XG4gIHVwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHRpbnQgYXBwbGllZCB0byB0aGUgY29udGFpbmVyLiBUaGlzIGlzIGEgaGV4IHZhbHVlLlxuICAgKiBBIHZhbHVlIG9mIDB4RkZGRkZGIHdpbGwgcmVtb3ZlIGFueSB0aW50IGVmZmVjdC5cbiAgICogSU1QT1JUQU5UOiBUaGlzIGlzIGEgV2ViR0wgb25seSBmZWF0dXJlIGFuZCB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIGNhbnZhcyByZW5kZXJlci5cbiAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICovXG4gIGdldCB0aW50KCkge1xuICAgIHJldHVybiB0aGlzLl90aW50Q29sb3IudmFsdWU7XG4gIH1cbiAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICB0aGlzLl90aW50Q29sb3Iuc2V0VmFsdWUodmFsdWUpLCB0aGlzLl90aW50Q29sb3IudG9SZ2JBcnJheSh0aGlzLnRpbnRSZ2IpO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250YWluZXIgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgV2ViR0wgcmVuZGVyZXIuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAhdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLmNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5yZW5kZXJhYmxlIHx8ICh0aGlzLmJhc2VUZXh0dXJlIHx8ICh0aGlzLmJhc2VUZXh0dXJlID0gdGhpcy5jaGlsZHJlblswXS5fdGV4dHVyZS5iYXNlVGV4dHVyZSwgdGhpcy5iYXNlVGV4dHVyZS52YWxpZCB8fCB0aGlzLmJhc2VUZXh0dXJlLm9uY2UoXCJ1cGRhdGVcIiwgKCkgPT4gdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKDApKSksIHJlbmRlcmVyLmJhdGNoLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnBsdWdpbnMucGFydGljbGUpLCByZW5kZXJlci5wbHVnaW5zLnBhcnRpY2xlLnJlbmRlcih0aGlzKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgZmxhZyB0aGF0IHN0YXRpYyBkYXRhIHNob3VsZCBiZSB1cGRhdGVkIHRvIHRydWVcbiAgICogQHBhcmFtIHNtYWxsZXN0Q2hpbGRJbmRleCAtIFRoZSBzbWFsbGVzdCBjaGlsZCBpbmRleC5cbiAgICovXG4gIG9uQ2hpbGRyZW5DaGFuZ2Uoc21hbGxlc3RDaGlsZEluZGV4KSB7XG4gICAgY29uc3QgYnVmZmVySW5kZXggPSBNYXRoLmZsb29yKHNtYWxsZXN0Q2hpbGRJbmRleCAvIHRoaXMuX2JhdGNoU2l6ZSk7XG4gICAgZm9yICg7IHRoaXMuX2J1ZmZlclVwZGF0ZUlEcy5sZW5ndGggPCBidWZmZXJJbmRleDsgKVxuICAgICAgdGhpcy5fYnVmZmVyVXBkYXRlSURzLnB1c2goMCk7XG4gICAgdGhpcy5fYnVmZmVyVXBkYXRlSURzW2J1ZmZlckluZGV4XSA9ICsrdGhpcy5fdXBkYXRlSUQ7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVycykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9idWZmZXJzLmxlbmd0aDsgKytpKVxuICAgICAgICB0aGlzLl9idWZmZXJzW2ldLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2J1ZmZlcnMgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbnRhaW5lclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoaWxkcmVuPWZhbHNlXSAtIGlmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZSB0aGVpclxuICAgKiAgZGVzdHJveSBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAqICBTaG91bGQgaXQgZGVzdHJveSB0aGUgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcbiAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgKi9cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKSwgdGhpcy5kaXNwb3NlKCksIHRoaXMuX3Byb3BlcnRpZXMgPSBudWxsLCB0aGlzLl9idWZmZXJzID0gbnVsbCwgdGhpcy5fYnVmZmVyVXBkYXRlSURzID0gbnVsbDtcbiAgfVxufVxuZXhwb3J0cy5QYXJ0aWNsZUNvbnRhaW5lciA9IFBhcnRpY2xlQ29udGFpbmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFydGljbGVDb250YWluZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIFBhcnRpY2xlQnVmZmVyID0gcmVxdWlyZShcIi4vUGFydGljbGVCdWZmZXIuanNcIiksIHBhcnRpY2xlcyQxID0gcmVxdWlyZShcIi4vcGFydGljbGVzLmZyYWcuanNcIiksIHBhcnRpY2xlcyA9IHJlcXVpcmUoXCIuL3BhcnRpY2xlcy52ZXJ0LmpzXCIpO1xuY2xhc3MgUGFydGljbGVSZW5kZXJlciBleHRlbmRzIGNvcmUuT2JqZWN0UmVuZGVyZXIge1xuICAvKipcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgc3ByaXRlIGJhdGNoIHdvcmtzIGZvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgc3VwZXIocmVuZGVyZXIpLCB0aGlzLnNoYWRlciA9IG51bGwsIHRoaXMucHJvcGVydGllcyA9IG51bGwsIHRoaXMudGVtcE1hdHJpeCA9IG5ldyBjb3JlLk1hdHJpeCgpLCB0aGlzLnByb3BlcnRpZXMgPSBbXG4gICAgICAvLyB2ZXJ0aWNlc0RhdGFcbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogXCJhVmVydGV4UG9zaXRpb25cIixcbiAgICAgICAgc2l6ZTogMixcbiAgICAgICAgdXBsb2FkRnVuY3Rpb246IHRoaXMudXBsb2FkVmVydGljZXMsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIC8vIHBvc2l0aW9uRGF0YVxuICAgICAge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBcImFQb3NpdGlvbkNvb3JkXCIsXG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFBvc2l0aW9uLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICAvLyByb3RhdGlvbkRhdGFcbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogXCJhUm90YXRpb25cIixcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgdXBsb2FkRnVuY3Rpb246IHRoaXMudXBsb2FkUm90YXRpb24sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIC8vIHV2c0RhdGFcbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogXCJhVGV4dHVyZUNvb3JkXCIsXG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFV2cyxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAgLy8gdGludERhdGFcbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogXCJhQ29sb3JcIixcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgdHlwZTogY29yZS5UWVBFUy5VTlNJR05FRF9CWVRFLFxuICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRUaW50LFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICBdLCB0aGlzLnNoYWRlciA9IGNvcmUuU2hhZGVyLmZyb20ocGFydGljbGVzLmRlZmF1bHQsIHBhcnRpY2xlcyQxLmRlZmF1bHQsIHt9KSwgdGhpcy5zdGF0ZSA9IGNvcmUuU3RhdGUuZm9yMmQoKTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcGFydGljbGUgY29udGFpbmVyIG9iamVjdC5cbiAgICogQHBhcmFtIGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlci5cbiAgICovXG4gIHJlbmRlcihjb250YWluZXIpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNvbnRhaW5lci5jaGlsZHJlbiwgbWF4U2l6ZSA9IGNvbnRhaW5lci5fbWF4U2l6ZSwgYmF0Y2hTaXplID0gY29udGFpbmVyLl9iYXRjaFNpemUsIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBsZXQgdG90YWxDaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBpZiAodG90YWxDaGlsZHJlbiA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICB0b3RhbENoaWxkcmVuID4gbWF4U2l6ZSAmJiAhY29udGFpbmVyLmF1dG9SZXNpemUgJiYgKHRvdGFsQ2hpbGRyZW4gPSBtYXhTaXplKTtcbiAgICBsZXQgYnVmZmVycyA9IGNvbnRhaW5lci5fYnVmZmVycztcbiAgICBidWZmZXJzIHx8IChidWZmZXJzID0gY29udGFpbmVyLl9idWZmZXJzID0gdGhpcy5nZW5lcmF0ZUJ1ZmZlcnMoY29udGFpbmVyKSk7XG4gICAgY29uc3QgYmFzZVRleHR1cmUgPSBjaGlsZHJlblswXS5fdGV4dHVyZS5iYXNlVGV4dHVyZSwgcHJlbXVsdGlwbGllZCA9IGJhc2VUZXh0dXJlLmFscGhhTW9kZSA+IDA7XG4gICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSBjb3JlLnV0aWxzLmNvcnJlY3RCbGVuZE1vZGUoY29udGFpbmVyLmJsZW5kTW9kZSwgcHJlbXVsdGlwbGllZCksIHJlbmRlcmVyLnN0YXRlLnNldCh0aGlzLnN0YXRlKTtcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdsLCBtID0gY29udGFpbmVyLndvcmxkVHJhbnNmb3JtLmNvcHlUbyh0aGlzLnRlbXBNYXRyaXgpO1xuICAgIG0ucHJlcGVuZChyZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4KSwgdGhpcy5zaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXggPSBtLnRvQXJyYXkoITApLCB0aGlzLnNoYWRlci51bmlmb3Jtcy51Q29sb3IgPSBjb3JlLkNvbG9yLnNoYXJlZC5zZXRWYWx1ZShjb250YWluZXIudGludFJnYikucHJlbXVsdGlwbHkoY29udGFpbmVyLndvcmxkQWxwaGEsIHByZW11bHRpcGxpZWQpLnRvQXJyYXkodGhpcy5zaGFkZXIudW5pZm9ybXMudUNvbG9yKSwgdGhpcy5zaGFkZXIudW5pZm9ybXMudVNhbXBsZXIgPSBiYXNlVGV4dHVyZSwgdGhpcy5yZW5kZXJlci5zaGFkZXIuYmluZCh0aGlzLnNoYWRlcik7XG4gICAgbGV0IHVwZGF0ZVN0YXRpYyA9ICExO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvdGFsQ2hpbGRyZW47IGkgKz0gYmF0Y2hTaXplLCBqICs9IDEpIHtcbiAgICAgIGxldCBhbW91bnQgPSB0b3RhbENoaWxkcmVuIC0gaTtcbiAgICAgIGFtb3VudCA+IGJhdGNoU2l6ZSAmJiAoYW1vdW50ID0gYmF0Y2hTaXplKSwgaiA+PSBidWZmZXJzLmxlbmd0aCAmJiBidWZmZXJzLnB1c2godGhpcy5fZ2VuZXJhdGVPbmVNb3JlQnVmZmVyKGNvbnRhaW5lcikpO1xuICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1tqXTtcbiAgICAgIGJ1ZmZlci51cGxvYWREeW5hbWljKGNoaWxkcmVuLCBpLCBhbW91bnQpO1xuICAgICAgY29uc3QgYmlkID0gY29udGFpbmVyLl9idWZmZXJVcGRhdGVJRHNbal0gfHwgMDtcbiAgICAgIHVwZGF0ZVN0YXRpYyA9IHVwZGF0ZVN0YXRpYyB8fCBidWZmZXIuX3VwZGF0ZUlEIDwgYmlkLCB1cGRhdGVTdGF0aWMgJiYgKGJ1ZmZlci5fdXBkYXRlSUQgPSBjb250YWluZXIuX3VwZGF0ZUlELCBidWZmZXIudXBsb2FkU3RhdGljKGNoaWxkcmVuLCBpLCBhbW91bnQpKSwgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChidWZmZXIuZ2VvbWV0cnkpLCBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBhbW91bnQgKiA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIG9uZSBwYXJ0aWNsZSBidWZmZXIgZm9yIGVhY2ggY2hpbGQgaW4gdGhlIGNvbnRhaW5lciB3ZSB3YW50IHRvIHJlbmRlciBhbmQgdXBkYXRlcyBpbnRlcm5hbCBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gY29udGFpbmVyIC0gVGhlIGNvbnRhaW5lciB0byByZW5kZXIgdXNpbmcgdGhpcyBQYXJ0aWNsZVJlbmRlcmVyXG4gICAqIEByZXR1cm5zIC0gVGhlIGJ1ZmZlcnNcbiAgICovXG4gIGdlbmVyYXRlQnVmZmVycyhjb250YWluZXIpIHtcbiAgICBjb25zdCBidWZmZXJzID0gW10sIHNpemUgPSBjb250YWluZXIuX21heFNpemUsIGJhdGNoU2l6ZSA9IGNvbnRhaW5lci5fYmF0Y2hTaXplLCBkeW5hbWljUHJvcGVydHlGbGFncyA9IGNvbnRhaW5lci5fcHJvcGVydGllcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkgKz0gYmF0Y2hTaXplKVxuICAgICAgYnVmZmVycy5wdXNoKG5ldyBQYXJ0aWNsZUJ1ZmZlci5QYXJ0aWNsZUJ1ZmZlcih0aGlzLnByb3BlcnRpZXMsIGR5bmFtaWNQcm9wZXJ0eUZsYWdzLCBiYXRjaFNpemUpKTtcbiAgICByZXR1cm4gYnVmZmVycztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBvbmUgbW9yZSBwYXJ0aWNsZSBidWZmZXIsIGJlY2F1c2UgY29udGFpbmVyIGhhcyBhdXRvUmVzaXplIGZlYXR1cmUuXG4gICAqIEBwYXJhbSBjb250YWluZXIgLSBUaGUgY29udGFpbmVyIHRvIHJlbmRlciB1c2luZyB0aGlzIFBhcnRpY2xlUmVuZGVyZXJcbiAgICogQHJldHVybnMgLSBUaGUgZ2VuZXJhdGVkIGJ1ZmZlclxuICAgKi9cbiAgX2dlbmVyYXRlT25lTW9yZUJ1ZmZlcihjb250YWluZXIpIHtcbiAgICBjb25zdCBiYXRjaFNpemUgPSBjb250YWluZXIuX2JhdGNoU2l6ZSwgZHluYW1pY1Byb3BlcnR5RmxhZ3MgPSBjb250YWluZXIuX3Byb3BlcnRpZXM7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNsZUJ1ZmZlci5QYXJ0aWNsZUJ1ZmZlcih0aGlzLnByb3BlcnRpZXMsIGR5bmFtaWNQcm9wZXJ0eUZsYWdzLCBiYXRjaFNpemUpO1xuICB9XG4gIC8qKlxuICAgKiBVcGxvYWRzIHRoZSB2ZXJ0aWNlcy5cbiAgICogQHBhcmFtIGNoaWxkcmVuIC0gdGhlIGFycmF5IG9mIHNwcml0ZXMgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSBzdGFydEluZGV4IC0gdGhlIGluZGV4IHRvIHN0YXJ0IGZyb20gaW4gdGhlIGNoaWxkcmVuIGFycmF5XG4gICAqIEBwYXJhbSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHZlcnRpY2VzIHVwbG9hZGVkXG4gICAqIEBwYXJhbSBhcnJheSAtIFRoZSB2ZXJ0aWNlcyB0byB1cGxvYWQuXG4gICAqIEBwYXJhbSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBPZmZzZXQgdG8gc3RhcnQgYXQuXG4gICAqL1xuICB1cGxvYWRWZXJ0aWNlcyhjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICBsZXQgdzAgPSAwLCB3MSA9IDAsIGgwID0gMCwgaDEgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHNwcml0ZSA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXSwgdGV4dHVyZSA9IHNwcml0ZS5fdGV4dHVyZSwgc3ggPSBzcHJpdGUuc2NhbGUueCwgc3kgPSBzcHJpdGUuc2NhbGUueSwgdHJpbSA9IHRleHR1cmUudHJpbSwgb3JpZyA9IHRleHR1cmUub3JpZztcbiAgICAgIHRyaW0gPyAodzEgPSB0cmltLnggLSBzcHJpdGUuYW5jaG9yLnggKiBvcmlnLndpZHRoLCB3MCA9IHcxICsgdHJpbS53aWR0aCwgaDEgPSB0cmltLnkgLSBzcHJpdGUuYW5jaG9yLnkgKiBvcmlnLmhlaWdodCwgaDAgPSBoMSArIHRyaW0uaGVpZ2h0KSA6ICh3MCA9IG9yaWcud2lkdGggKiAoMSAtIHNwcml0ZS5hbmNob3IueCksIHcxID0gb3JpZy53aWR0aCAqIC1zcHJpdGUuYW5jaG9yLngsIGgwID0gb3JpZy5oZWlnaHQgKiAoMSAtIHNwcml0ZS5hbmNob3IueSksIGgxID0gb3JpZy5oZWlnaHQgKiAtc3ByaXRlLmFuY2hvci55KSwgYXJyYXlbb2Zmc2V0XSA9IHcxICogc3gsIGFycmF5W29mZnNldCArIDFdID0gaDEgKiBzeSwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHcwICogc3gsIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gaDEgKiBzeSwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSB3MCAqIHN4LCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyICsgMV0gPSBoMCAqIHN5LCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHcxICogc3gsIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDMgKyAxXSA9IGgwICogc3ksIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBsb2FkcyB0aGUgcG9zaXRpb24uXG4gICAqIEBwYXJhbSBjaGlsZHJlbiAtIHRoZSBhcnJheSBvZiBzcHJpdGVzIHRvIHJlbmRlclxuICAgKiBAcGFyYW0gc3RhcnRJbmRleCAtIHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxuICAgKiBAcGFyYW0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciBwb3NpdGlvbnMgdXBsb2FkZWRcbiAgICogQHBhcmFtIGFycmF5IC0gVGhlIHZlcnRpY2VzIHRvIHVwbG9hZC5cbiAgICogQHBhcmFtIHN0cmlkZSAtIFN0cmlkZSB0byB1c2UgZm9yIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIG9mZnNldCAtIE9mZnNldCB0byBzdGFydCBhdC5cbiAgICovXG4gIHVwbG9hZFBvc2l0aW9uKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHNwcml0ZVBvc2l0aW9uID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldLnBvc2l0aW9uO1xuICAgICAgYXJyYXlbb2Zmc2V0XSA9IHNwcml0ZVBvc2l0aW9uLngsIGFycmF5W29mZnNldCArIDFdID0gc3ByaXRlUG9zaXRpb24ueSwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHNwcml0ZVBvc2l0aW9uLngsIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gc3ByaXRlUG9zaXRpb24ueSwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSBzcHJpdGVQb3NpdGlvbi54LCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55LCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHNwcml0ZVBvc2l0aW9uLngsIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDMgKyAxXSA9IHNwcml0ZVBvc2l0aW9uLnksIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBsb2FkcyB0aGUgcm90YXRpb24uXG4gICAqIEBwYXJhbSBjaGlsZHJlbiAtIHRoZSBhcnJheSBvZiBzcHJpdGVzIHRvIHJlbmRlclxuICAgKiBAcGFyYW0gc3RhcnRJbmRleCAtIHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxuICAgKiBAcGFyYW0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciByb3RhdGlvbiB1cGxvYWRlZFxuICAgKiBAcGFyYW0gYXJyYXkgLSBUaGUgdmVydGljZXMgdG8gdXBsb2FkLlxuICAgKiBAcGFyYW0gc3RyaWRlIC0gU3RyaWRlIHRvIHVzZSBmb3IgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gT2Zmc2V0IHRvIHN0YXJ0IGF0LlxuICAgKi9cbiAgdXBsb2FkUm90YXRpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuICAgICAgY29uc3Qgc3ByaXRlUm90YXRpb24gPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0ucm90YXRpb247XG4gICAgICBhcnJheVtvZmZzZXRdID0gc3ByaXRlUm90YXRpb24sIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSBzcHJpdGVSb3RhdGlvbiwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSBzcHJpdGVSb3RhdGlvbiwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSBzcHJpdGVSb3RhdGlvbiwgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGxvYWRzIHRoZSBVVnMuXG4gICAqIEBwYXJhbSBjaGlsZHJlbiAtIHRoZSBhcnJheSBvZiBzcHJpdGVzIHRvIHJlbmRlclxuICAgKiBAcGFyYW0gc3RhcnRJbmRleCAtIHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxuICAgKiBAcGFyYW0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciByb3RhdGlvbiB1cGxvYWRlZFxuICAgKiBAcGFyYW0gYXJyYXkgLSBUaGUgdmVydGljZXMgdG8gdXBsb2FkLlxuICAgKiBAcGFyYW0gc3RyaWRlIC0gU3RyaWRlIHRvIHVzZSBmb3IgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gT2Zmc2V0IHRvIHN0YXJ0IGF0LlxuICAgKi9cbiAgdXBsb2FkVXZzKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHRleHR1cmVVdnMgPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0uX3RleHR1cmUuX3V2cztcbiAgICAgIHRleHR1cmVVdnMgPyAoYXJyYXlbb2Zmc2V0XSA9IHRleHR1cmVVdnMueDAsIGFycmF5W29mZnNldCArIDFdID0gdGV4dHVyZVV2cy55MCwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHRleHR1cmVVdnMueDEsIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gdGV4dHVyZVV2cy55MSwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSB0ZXh0dXJlVXZzLngyLCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyICsgMV0gPSB0ZXh0dXJlVXZzLnkyLCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHRleHR1cmVVdnMueDMsIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDMgKyAxXSA9IHRleHR1cmVVdnMueTMsIG9mZnNldCArPSBzdHJpZGUgKiA0KSA6IChhcnJheVtvZmZzZXRdID0gMCwgYXJyYXlbb2Zmc2V0ICsgMV0gPSAwLCBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gMCwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSAwLCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IDAsIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDIgKyAxXSA9IDAsIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gMCwgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gMCwgb2Zmc2V0ICs9IHN0cmlkZSAqIDQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBsb2FkcyB0aGUgdGludC5cbiAgICogQHBhcmFtIGNoaWxkcmVuIC0gdGhlIGFycmF5IG9mIHNwcml0ZXMgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSBzdGFydEluZGV4IC0gdGhlIGluZGV4IHRvIHN0YXJ0IGZyb20gaW4gdGhlIGNoaWxkcmVuIGFycmF5XG4gICAqIEBwYXJhbSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHJvdGF0aW9uIHVwbG9hZGVkXG4gICAqIEBwYXJhbSBhcnJheSAtIFRoZSB2ZXJ0aWNlcyB0byB1cGxvYWQuXG4gICAqIEBwYXJhbSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBPZmZzZXQgdG8gc3RhcnQgYXQuXG4gICAqL1xuICB1cGxvYWRUaW50KGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHNwcml0ZSA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXSwgcmVzdWx0ID0gY29yZS5Db2xvci5zaGFyZWQuc2V0VmFsdWUoc3ByaXRlLl90aW50UkdCKS50b1ByZW11bHRpcGxpZWQoc3ByaXRlLmFscGhhLCBzcHJpdGUudGV4dHVyZS5iYXNlVGV4dHVyZS5hbHBoYU1vZGUgPiAwKTtcbiAgICAgIGFycmF5W29mZnNldF0gPSByZXN1bHQsIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSByZXN1bHQsIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gcmVzdWx0LCBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHJlc3VsdCwgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgfVxuICB9XG4gIC8qKiBEZXN0cm95cyB0aGUgUGFydGljbGVSZW5kZXJlci4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCksIHRoaXMuc2hhZGVyICYmICh0aGlzLnNoYWRlci5kZXN0cm95KCksIHRoaXMuc2hhZGVyID0gbnVsbCksIHRoaXMudGVtcE1hdHJpeCA9IG51bGw7XG4gIH1cbn1cblBhcnRpY2xlUmVuZGVyZXIuZXh0ZW5zaW9uID0ge1xuICBuYW1lOiBcInBhcnRpY2xlXCIsXG4gIHR5cGU6IGNvcmUuRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclBsdWdpblxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQoUGFydGljbGVSZW5kZXJlcik7XG5leHBvcnRzLlBhcnRpY2xlUmVuZGVyZXIgPSBQYXJ0aWNsZVJlbmRlcmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFydGljbGVSZW5kZXJlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIFBhcnRpY2xlQ29udGFpbmVyID0gcmVxdWlyZShcIi4vUGFydGljbGVDb250YWluZXIuanNcIiksIFBhcnRpY2xlUmVuZGVyZXIgPSByZXF1aXJlKFwiLi9QYXJ0aWNsZVJlbmRlcmVyLmpzXCIpO1xuZXhwb3J0cy5QYXJ0aWNsZUNvbnRhaW5lciA9IFBhcnRpY2xlQ29udGFpbmVyLlBhcnRpY2xlQ29udGFpbmVyO1xuZXhwb3J0cy5QYXJ0aWNsZVJlbmRlcmVyID0gUGFydGljbGVSZW5kZXJlci5QYXJ0aWNsZVJlbmRlcmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgZnJhZ21lbnQgPSBgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcblxudm9pZCBtYWluKHZvaWQpe1xuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yO1xuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xufWA7XG5leHBvcnRzLmRlZmF1bHQgPSBmcmFnbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnRpY2xlcy5mcmFnLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIHZlcnRleCA9IGBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xuXG5hdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb25Db29yZDtcbmF0dHJpYnV0ZSBmbG9hdCBhUm90YXRpb247XG5cbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XG5cbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xudmFyeWluZyB2ZWM0IHZDb2xvcjtcblxudm9pZCBtYWluKHZvaWQpe1xuICAgIGZsb2F0IHggPSAoYVZlcnRleFBvc2l0aW9uLngpICogY29zKGFSb3RhdGlvbikgLSAoYVZlcnRleFBvc2l0aW9uLnkpICogc2luKGFSb3RhdGlvbik7XG4gICAgZmxvYXQgeSA9IChhVmVydGV4UG9zaXRpb24ueCkgKiBzaW4oYVJvdGF0aW9uKSArIChhVmVydGV4UG9zaXRpb24ueSkgKiBjb3MoYVJvdGF0aW9uKTtcblxuICAgIHZlYzIgdiA9IHZlYzIoeCwgeSk7XG4gICAgdiA9IHYgKyBhUG9zaXRpb25Db29yZDtcblxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgodHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKHYsIDEuMCkpLnh5LCAwLjAsIDEuMCk7XG5cbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICB2Q29sb3IgPSBhQ29sb3IgKiB1Q29sb3I7XG59XG5gO1xuZXhwb3J0cy5kZWZhdWx0ID0gdmVydGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFydGljbGVzLnZlcnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIGRpc3BsYXkgPSByZXF1aXJlKFwiQHBpeGkvZGlzcGxheVwiKSwgdGV4dCA9IHJlcXVpcmUoXCJAcGl4aS90ZXh0XCIpLCBDb3VudExpbWl0ZXIgPSByZXF1aXJlKFwiLi9Db3VudExpbWl0ZXIuanNcIik7XG5mdW5jdGlvbiBmaW5kTXVsdGlwbGVCYXNlVGV4dHVyZXMoaXRlbSwgcXVldWUpIHtcbiAgbGV0IHJlc3VsdCA9ICExO1xuICBpZiAoaXRlbT8uX3RleHR1cmVzPy5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW0uX3RleHR1cmVzLmxlbmd0aDsgaSsrKVxuICAgICAgaWYgKGl0ZW0uX3RleHR1cmVzW2ldIGluc3RhbmNlb2YgY29yZS5UZXh0dXJlKSB7XG4gICAgICAgIGNvbnN0IGJhc2VUZXh0dXJlID0gaXRlbS5fdGV4dHVyZXNbaV0uYmFzZVRleHR1cmU7XG4gICAgICAgIHF1ZXVlLmluY2x1ZGVzKGJhc2VUZXh0dXJlKSB8fCAocXVldWUucHVzaChiYXNlVGV4dHVyZSksIHJlc3VsdCA9ICEwKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmluZEJhc2VUZXh0dXJlKGl0ZW0sIHF1ZXVlKSB7XG4gIGlmIChpdGVtLmJhc2VUZXh0dXJlIGluc3RhbmNlb2YgY29yZS5CYXNlVGV4dHVyZSkge1xuICAgIGNvbnN0IHRleHR1cmUgPSBpdGVtLmJhc2VUZXh0dXJlO1xuICAgIHJldHVybiBxdWV1ZS5pbmNsdWRlcyh0ZXh0dXJlKSB8fCBxdWV1ZS5wdXNoKHRleHR1cmUpLCAhMDtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBmaW5kVGV4dHVyZShpdGVtLCBxdWV1ZSkge1xuICBpZiAoaXRlbS5fdGV4dHVyZSAmJiBpdGVtLl90ZXh0dXJlIGluc3RhbmNlb2YgY29yZS5UZXh0dXJlKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IGl0ZW0uX3RleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgcmV0dXJuIHF1ZXVlLmluY2x1ZGVzKHRleHR1cmUpIHx8IHF1ZXVlLnB1c2godGV4dHVyZSksICEwO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGRyYXdUZXh0KF9oZWxwZXIsIGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiB0ZXh0LlRleHQgPyAoaXRlbS51cGRhdGVUZXh0KCEwKSwgITApIDogITE7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVUZXh0U3R5bGUoX2hlbHBlciwgaXRlbSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIHRleHQuVGV4dFN0eWxlKSB7XG4gICAgY29uc3QgZm9udCA9IGl0ZW0udG9Gb250U3RyaW5nKCk7XG4gICAgcmV0dXJuIHRleHQuVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQoZm9udCksICEwO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGZpbmRUZXh0KGl0ZW0sIHF1ZXVlKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgdGV4dC5UZXh0KSB7XG4gICAgcXVldWUuaW5jbHVkZXMoaXRlbS5zdHlsZSkgfHwgcXVldWUucHVzaChpdGVtLnN0eWxlKSwgcXVldWUuaW5jbHVkZXMoaXRlbSkgfHwgcXVldWUucHVzaChpdGVtKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gaXRlbS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICByZXR1cm4gcXVldWUuaW5jbHVkZXModGV4dHVyZSkgfHwgcXVldWUucHVzaCh0ZXh0dXJlKSwgITA7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gZmluZFRleHRTdHlsZShpdGVtLCBxdWV1ZSkge1xuICByZXR1cm4gaXRlbSBpbnN0YW5jZW9mIHRleHQuVGV4dFN0eWxlID8gKHF1ZXVlLmluY2x1ZGVzKGl0ZW0pIHx8IHF1ZXVlLnB1c2goaXRlbSksICEwKSA6ICExO1xufVxuY29uc3QgX0Jhc2VQcmVwYXJlID0gY2xhc3MgX0Jhc2VQcmVwYXJlMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1BJWEkuSVJlbmRlcmVyfSByZW5kZXJlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMubGltaXRlciA9IG5ldyBDb3VudExpbWl0ZXIuQ291bnRMaW1pdGVyKF9CYXNlUHJlcGFyZTIudXBsb2Fkc1BlckZyYW1lKSwgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyLCB0aGlzLnVwbG9hZEhvb2tIZWxwZXIgPSBudWxsLCB0aGlzLnF1ZXVlID0gW10sIHRoaXMuYWRkSG9va3MgPSBbXSwgdGhpcy51cGxvYWRIb29rcyA9IFtdLCB0aGlzLmNvbXBsZXRlcyA9IFtdLCB0aGlzLnRpY2tpbmcgPSAhMSwgdGhpcy5kZWxheWVkVGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMucXVldWUgJiYgdGhpcy5wcmVwYXJlSXRlbXMoKTtcbiAgICB9LCB0aGlzLnJlZ2lzdGVyRmluZEhvb2soZmluZFRleHQpLCB0aGlzLnJlZ2lzdGVyRmluZEhvb2soZmluZFRleHRTdHlsZSksIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kTXVsdGlwbGVCYXNlVGV4dHVyZXMpLCB0aGlzLnJlZ2lzdGVyRmluZEhvb2soZmluZEJhc2VUZXh0dXJlKSwgdGhpcy5yZWdpc3RlckZpbmRIb29rKGZpbmRUZXh0dXJlKSwgdGhpcy5yZWdpc3RlclVwbG9hZEhvb2soZHJhd1RleHQpLCB0aGlzLnJlZ2lzdGVyVXBsb2FkSG9vayhjYWxjdWxhdGVUZXh0U3R5bGUpO1xuICB9XG4gIC8qKlxuICAgKiBVcGxvYWQgYWxsIHRoZSB0ZXh0dXJlcyBhbmQgZ3JhcGhpY3MgdG8gdGhlIEdQVS5cbiAgICogQG1ldGhvZCBQSVhJLkJhc2VQcmVwYXJlI3VwbG9hZFxuICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdHxQSVhJLkNvbnRhaW5lcnxQSVhJLkJhc2VUZXh0dXJlfFBJWEkuVGV4dHVyZXxQSVhJLkdyYXBoaWNzfFBJWEkuVGV4dH0gW2l0ZW1dIC1cbiAgICogICAgICAgIENvbnRhaW5lciBvciBkaXNwbGF5IG9iamVjdCB0byBzZWFyY2ggZm9yIGl0ZW1zIHRvIHVwbG9hZCBvciB0aGUgaXRlbXMgdG8gdXBsb2FkIHRoZW1zZWx2ZXMsXG4gICAqICAgICAgICBvciBvcHRpb25hbGx5IG9tbWl0dGVkLCBpZiBpdGVtcyBoYXZlIGJlZW4gYWRkZWQgdXNpbmcge0BsaW5rIFBJWEkuQmFzZVByZXBhcmUjYWRkIGBwcmVwYXJlLmFkZGB9LlxuICAgKi9cbiAgdXBsb2FkKGl0ZW0pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGl0ZW0gJiYgdGhpcy5hZGQoaXRlbSksIHRoaXMucXVldWUubGVuZ3RoID8gKHRoaXMuY29tcGxldGVzLnB1c2gocmVzb2x2ZSksIHRoaXMudGlja2luZyB8fCAodGhpcy50aWNraW5nID0gITAsIGNvcmUuVGlja2VyLnN5c3RlbS5hZGRPbmNlKHRoaXMudGljaywgdGhpcywgY29yZS5VUERBVEVfUFJJT1JJVFkuVVRJTElUWSkpKSA6IHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIHRpY2sgdXBkYXRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aWNrKCkge1xuICAgIHNldFRpbWVvdXQodGhpcy5kZWxheWVkVGljaywgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEFjdHVhbGx5IHByZXBhcmUgaXRlbXMuIFRoaXMgaXMgaGFuZGxlZCBvdXRzaWRlIG9mIHRoZSB0aWNrIGJlY2F1c2UgaXQgd2lsbCB0YWtlIGEgd2hpbGVcbiAgICogYW5kIHdlIGRvIE5PVCB3YW50IHRvIGJsb2NrIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBmcmFtZSBmcm9tIHJlbmRlcmluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByZXBhcmVJdGVtcygpIHtcbiAgICBmb3IgKHRoaXMubGltaXRlci5iZWdpbkZyYW1lKCk7IHRoaXMucXVldWUubGVuZ3RoICYmIHRoaXMubGltaXRlci5hbGxvd2VkVG9VcGxvYWQoKTsgKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5xdWV1ZVswXTtcbiAgICAgIGxldCB1cGxvYWRlZCA9ICExO1xuICAgICAgaWYgKGl0ZW0gJiYgIWl0ZW0uX2Rlc3Ryb3llZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy51cGxvYWRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBpZiAodGhpcy51cGxvYWRIb29rc1tpXSh0aGlzLnVwbG9hZEhvb2tIZWxwZXIsIGl0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnNoaWZ0KCksIHVwbG9hZGVkID0gITA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICB1cGxvYWRlZCB8fCB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aClcbiAgICAgIGNvcmUuVGlja2VyLnN5c3RlbS5hZGRPbmNlKHRoaXMudGljaywgdGhpcywgY29yZS5VUERBVEVfUFJJT1JJVFkuVVRJTElUWSk7XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnRpY2tpbmcgPSAhMTtcbiAgICAgIGNvbnN0IGNvbXBsZXRlcyA9IHRoaXMuY29tcGxldGVzLnNsaWNlKDApO1xuICAgICAgdGhpcy5jb21wbGV0ZXMubGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjb21wbGV0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNvbXBsZXRlc1tpXSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkcyBob29rcyBmb3IgZmluZGluZyBpdGVtcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWRkSG9vayAtIEZ1bmN0aW9uIGNhbGwgdGhhdCB0YWtlcyB0d28gcGFyYW1ldGVyczogYGl0ZW06KiwgcXVldWU6QXJyYXlgXG4gICAqICAgICAgICAgIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGB0cnVlYCBpZiBpdCB3YXMgYWJsZSB0byBhZGQgaXRlbSB0byB0aGUgcXVldWUuXG4gICAqIEByZXR1cm5zIEluc3RhbmNlIG9mIHBsdWdpbiBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByZWdpc3RlckZpbmRIb29rKGFkZEhvb2spIHtcbiAgICByZXR1cm4gYWRkSG9vayAmJiB0aGlzLmFkZEhvb2tzLnB1c2goYWRkSG9vayksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgaG9va3MgZm9yIHVwbG9hZGluZyBpdGVtcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBsb2FkSG9vayAtIEZ1bmN0aW9uIGNhbGwgdGhhdCB0YWtlcyB0d28gcGFyYW1ldGVyczogYHByZXBhcmU6Q2FudmFzUHJlcGFyZSwgaXRlbToqYCBhbmRcbiAgICogICAgICAgICAgZnVuY3Rpb24gbXVzdCByZXR1cm4gYHRydWVgIGlmIGl0IHdhcyBhYmxlIHRvIGhhbmRsZSB1cGxvYWQgb2YgaXRlbS5cbiAgICogQHJldHVybnMgSW5zdGFuY2Ugb2YgcGx1Z2luIGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJlZ2lzdGVyVXBsb2FkSG9vayh1cGxvYWRIb29rKSB7XG4gICAgcmV0dXJuIHVwbG9hZEhvb2sgJiYgdGhpcy51cGxvYWRIb29rcy5wdXNoKHVwbG9hZEhvb2spLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBNYW51YWxseSBhZGQgYW4gaXRlbSB0byB0aGUgdXBsb2FkaW5nIHF1ZXVlLlxuICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdHxQSVhJLkNvbnRhaW5lcnxQSVhJLkJhc2VUZXh0dXJlfFBJWEkuVGV4dHVyZXxQSVhJLkdyYXBoaWNzfFBJWEkuVGV4dHwqfSBpdGVtIC0gT2JqZWN0IHRvXG4gICAqICAgICAgICBhZGQgdG8gdGhlIHF1ZXVlXG4gICAqIEByZXR1cm5zIEluc3RhbmNlIG9mIHBsdWdpbiBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhZGQoaXRlbSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmFkZEhvb2tzLmxlbmd0aDsgaSA8IGxlbiAmJiAhdGhpcy5hZGRIb29rc1tpXShpdGVtLCB0aGlzLnF1ZXVlKTsgaSsrKVxuICAgICAgO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgZGlzcGxheS5Db250YWluZXIpXG4gICAgICBmb3IgKGxldCBpID0gaXRlbS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgdGhpcy5hZGQoaXRlbS5jaGlsZHJlbltpXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoZSBwbHVnaW4sIGRvbid0IHVzZSBhZnRlciB0aGlzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMudGlja2luZyAmJiBjb3JlLlRpY2tlci5zeXN0ZW0ucmVtb3ZlKHRoaXMudGljaywgdGhpcyksIHRoaXMudGlja2luZyA9ICExLCB0aGlzLmFkZEhvb2tzID0gbnVsbCwgdGhpcy51cGxvYWRIb29rcyA9IG51bGwsIHRoaXMucmVuZGVyZXIgPSBudWxsLCB0aGlzLmNvbXBsZXRlcyA9IG51bGwsIHRoaXMucXVldWUgPSBudWxsLCB0aGlzLmxpbWl0ZXIgPSBudWxsLCB0aGlzLnVwbG9hZEhvb2tIZWxwZXIgPSBudWxsO1xuICB9XG59O1xuX0Jhc2VQcmVwYXJlLnVwbG9hZHNQZXJGcmFtZSA9IDQ7XG5sZXQgQmFzZVByZXBhcmUgPSBfQmFzZVByZXBhcmU7XG5leHBvcnRzLkJhc2VQcmVwYXJlID0gQmFzZVByZXBhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlUHJlcGFyZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgQ291bnRMaW1pdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBtYXhJdGVtc1BlckZyYW1lIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRoYXQgY2FuIGJlIHByZXBhcmVkIGVhY2ggZnJhbWUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYXhJdGVtc1BlckZyYW1lKSB7XG4gICAgdGhpcy5tYXhJdGVtc1BlckZyYW1lID0gbWF4SXRlbXNQZXJGcmFtZSwgdGhpcy5pdGVtc0xlZnQgPSAwO1xuICB9XG4gIC8qKiBSZXNldHMgYW55IGNvdW50aW5nIHByb3BlcnRpZXMgdG8gc3RhcnQgZnJlc2ggb24gYSBuZXcgZnJhbWUuICovXG4gIGJlZ2luRnJhbWUoKSB7XG4gICAgdGhpcy5pdGVtc0xlZnQgPSB0aGlzLm1heEl0ZW1zUGVyRnJhbWU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB0byBzZWUgaWYgYW5vdGhlciBpdGVtIGNhbiBiZSB1cGxvYWRlZC4gVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSBwZXIgaXRlbS5cbiAgICogQHJldHVybnMgSWYgdGhlIGl0ZW0gaXMgYWxsb3dlZCB0byBiZSB1cGxvYWRlZC5cbiAgICovXG4gIGFsbG93ZWRUb1VwbG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc0xlZnQtLSA+IDA7XG4gIH1cbn1cbmV4cG9ydHMuQ291bnRMaW1pdGVyID0gQ291bnRMaW1pdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q291bnRMaW1pdGVyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpLCBncmFwaGljcyA9IHJlcXVpcmUoXCJAcGl4aS9ncmFwaGljc1wiKSwgQmFzZVByZXBhcmUgPSByZXF1aXJlKFwiLi9CYXNlUHJlcGFyZS5qc1wiKTtcbmZ1bmN0aW9uIHVwbG9hZEJhc2VUZXh0dXJlcyhyZW5kZXJlciwgaXRlbSkge1xuICByZXR1cm4gaXRlbSBpbnN0YW5jZW9mIGNvcmUuQmFzZVRleHR1cmUgPyAoaXRlbS5fZ2xUZXh0dXJlc1tyZW5kZXJlci5DT05URVhUX1VJRF0gfHwgcmVuZGVyZXIudGV4dHVyZS5iaW5kKGl0ZW0pLCAhMCkgOiAhMTtcbn1cbmZ1bmN0aW9uIHVwbG9hZEdyYXBoaWNzKHJlbmRlcmVyLCBpdGVtKSB7XG4gIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBncmFwaGljcy5HcmFwaGljcykpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCB7IGdlb21ldHJ5IH0gPSBpdGVtO1xuICBpdGVtLmZpbmlzaFBvbHkoKSwgZ2VvbWV0cnkudXBkYXRlQmF0Y2hlcygpO1xuICBjb25zdCB7IGJhdGNoZXMgfSA9IGdlb21ldHJ5O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7IHRleHR1cmUgfSA9IGJhdGNoZXNbaV0uc3R5bGU7XG4gICAgdGV4dHVyZSAmJiB1cGxvYWRCYXNlVGV4dHVyZXMocmVuZGVyZXIsIHRleHR1cmUuYmFzZVRleHR1cmUpO1xuICB9XG4gIHJldHVybiBnZW9tZXRyeS5iYXRjaGFibGUgfHwgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChnZW9tZXRyeSwgaXRlbS5fcmVzb2x2ZURpcmVjdFNoYWRlcihyZW5kZXJlcikpLCAhMDtcbn1cbmZ1bmN0aW9uIGZpbmRHcmFwaGljcyhpdGVtLCBxdWV1ZSkge1xuICByZXR1cm4gaXRlbSBpbnN0YW5jZW9mIGdyYXBoaWNzLkdyYXBoaWNzID8gKHF1ZXVlLnB1c2goaXRlbSksICEwKSA6ICExO1xufVxuY2xhc3MgUHJlcGFyZSBleHRlbmRzIEJhc2VQcmVwYXJlLkJhc2VQcmVwYXJlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByZW5kZXJlclxuICAgKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICBzdXBlcihyZW5kZXJlciksIHRoaXMudXBsb2FkSG9va0hlbHBlciA9IHRoaXMucmVuZGVyZXIsIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kR3JhcGhpY3MpLCB0aGlzLnJlZ2lzdGVyVXBsb2FkSG9vayh1cGxvYWRCYXNlVGV4dHVyZXMpLCB0aGlzLnJlZ2lzdGVyVXBsb2FkSG9vayh1cGxvYWRHcmFwaGljcyk7XG4gIH1cbn1cblByZXBhcmUuZXh0ZW5zaW9uID0ge1xuICBuYW1lOiBcInByZXBhcmVcIixcbiAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtXG59O1xuY29yZS5leHRlbnNpb25zLmFkZChQcmVwYXJlKTtcbmV4cG9ydHMuUHJlcGFyZSA9IFByZXBhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QcmVwYXJlLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBUaW1lTGltaXRlciB7XG4gIC8qKiBAcGFyYW0gbWF4TWlsbGlzZWNvbmRzIC0gVGhlIG1heGltdW0gbWlsbGlzZWNvbmRzIHRoYXQgY2FuIGJlIHNwZW50IHByZXBhcmluZyBpdGVtcyBlYWNoIGZyYW1lLiAqL1xuICBjb25zdHJ1Y3RvcihtYXhNaWxsaXNlY29uZHMpIHtcbiAgICB0aGlzLm1heE1pbGxpc2Vjb25kcyA9IG1heE1pbGxpc2Vjb25kcywgdGhpcy5mcmFtZVN0YXJ0ID0gMDtcbiAgfVxuICAvKiogUmVzZXRzIGFueSBjb3VudGluZyBwcm9wZXJ0aWVzIHRvIHN0YXJ0IGZyZXNoIG9uIGEgbmV3IGZyYW1lLiAqL1xuICBiZWdpbkZyYW1lKCkge1xuICAgIHRoaXMuZnJhbWVTdGFydCA9IERhdGUubm93KCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB0byBzZWUgaWYgYW5vdGhlciBpdGVtIGNhbiBiZSB1cGxvYWRlZC4gVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSBwZXIgaXRlbS5cbiAgICogQHJldHVybnMgLSBJZiB0aGUgaXRlbSBpcyBhbGxvd2VkIHRvIGJlIHVwbG9hZGVkLlxuICAgKi9cbiAgYWxsb3dlZFRvVXBsb2FkKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5mcmFtZVN0YXJ0IDwgdGhpcy5tYXhNaWxsaXNlY29uZHM7XG4gIH1cbn1cbmV4cG9ydHMuVGltZUxpbWl0ZXIgPSBUaW1lTGltaXRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbWVMaW1pdGVyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5yZXF1aXJlKFwiLi9zZXR0aW5ncy5qc1wiKTtcbnZhciBCYXNlUHJlcGFyZSA9IHJlcXVpcmUoXCIuL0Jhc2VQcmVwYXJlLmpzXCIpLCBDb3VudExpbWl0ZXIgPSByZXF1aXJlKFwiLi9Db3VudExpbWl0ZXIuanNcIiksIFByZXBhcmUgPSByZXF1aXJlKFwiLi9QcmVwYXJlLmpzXCIpLCBUaW1lTGltaXRlciA9IHJlcXVpcmUoXCIuL1RpbWVMaW1pdGVyLmpzXCIpO1xuZXhwb3J0cy5CYXNlUHJlcGFyZSA9IEJhc2VQcmVwYXJlLkJhc2VQcmVwYXJlO1xuZXhwb3J0cy5Db3VudExpbWl0ZXIgPSBDb3VudExpbWl0ZXIuQ291bnRMaW1pdGVyO1xuZXhwb3J0cy5QcmVwYXJlID0gUHJlcGFyZS5QcmVwYXJlO1xuZXhwb3J0cy5UaW1lTGltaXRlciA9IFRpbWVMaW1pdGVyLlRpbWVMaW1pdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIEJhc2VQcmVwYXJlID0gcmVxdWlyZShcIi4vQmFzZVByZXBhcmUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb3JlLnNldHRpbmdzLCB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IG51bWJlciBvZiB1cGxvYWRzIHBlciBmcmFtZSB1c2luZyBwcmVwYXJlIHBsdWdpbi5cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAbmFtZSBVUExPQURTX1BFUl9GUkFNRVxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKiBAc2VlIFBJWEkuQmFzZVByZXBhcmUudXBsb2Fkc1BlckZyYW1lXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBVUExPQURTX1BFUl9GUkFNRToge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXNlUHJlcGFyZS5CYXNlUHJlcGFyZS51cGxvYWRzUGVyRnJhbWU7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGNvcmUudXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLlVQTE9BRFNfUEVSX0ZSQU1FIGlzIGRlcHJlY2F0ZWQsIHVzZSBwcmVwYXJlLkJhc2VQcmVwYXJlLnVwbG9hZHNQZXJGcmFtZVwiKSwgQmFzZVByZXBhcmUuQmFzZVByZXBhcmUudXBsb2Fkc1BlckZyYW1lID0gdmFsdWU7XG4gICAgfVxuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNldHRpbmdzXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcmUuc2V0dGluZ3M7XG4gIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0dGluZ3MuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIFJ1bm5lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBmdW5jdGlvbiBuYW1lIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBvbiB0aGUgbGlzdGVuZXJzIGFkZGVkIHRvIHRoaXMgUnVubmVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHRoaXMuaXRlbXMgPSBbXSwgdGhpcy5fbmFtZSA9IG5hbWUsIHRoaXMuX2FsaWFzQ291bnQgPSAwO1xuICB9XG4gIC8qIGVzbGludC1kaXNhYmxlIGpzZG9jL3JlcXVpcmUtcGFyYW0sIGpzZG9jL2NoZWNrLXBhcmFtLW5hbWVzICovXG4gIC8qKlxuICAgKiBEaXNwYXRjaC9Ccm9hZGNhc3QgUnVubmVyIHRvIGFsbCBsaXN0ZW5lcnMgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgKiBAcGFyYW0gey4uLmFueX0gcGFyYW1zIC0gKG9wdGlvbmFsKSBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gZWFjaCBsaXN0ZW5lclxuICAgKi9cbiAgLyogIGVzbGludC1lbmFibGUganNkb2MvcmVxdWlyZS1wYXJhbSwganNkb2MvY2hlY2stcGFyYW0tbmFtZXMgKi9cbiAgZW1pdChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXggYXJndW1lbnRzIHJlYWNoZWRcIik7XG4gICAgY29uc3QgeyBuYW1lLCBpdGVtcyB9ID0gdGhpcztcbiAgICB0aGlzLl9hbGlhc0NvdW50Kys7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgaXRlbXNbaV1bbmFtZV0oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KTtcbiAgICByZXR1cm4gaXRlbXMgPT09IHRoaXMuaXRlbXMgJiYgdGhpcy5fYWxpYXNDb3VudC0tLCB0aGlzO1xuICB9XG4gIGVuc3VyZU5vbkFsaWFzZWRJdGVtcygpIHtcbiAgICB0aGlzLl9hbGlhc0NvdW50ID4gMCAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+IDEgJiYgKHRoaXMuX2FsaWFzQ291bnQgPSAwLCB0aGlzLml0ZW1zID0gdGhpcy5pdGVtcy5zbGljZSgwKSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGxpc3RlbmVyIHRvIHRoZSBSdW5uZXJcbiAgICpcbiAgICogUnVubmVycyBkbyBub3QgbmVlZCB0byBoYXZlIHNjb3BlIG9yIGZ1bmN0aW9ucyBwYXNzZWQgdG8gdGhlbS5cbiAgICogQWxsIHRoYXQgaXMgcmVxdWlyZWQgaXMgdG8gcGFzcyB0aGUgbGlzdGVuaW5nIG9iamVjdCBhbmQgZW5zdXJlIHRoYXQgaXQgaGFzIGNvbnRhaW5zIGEgZnVuY3Rpb24gdGhhdCBoYXMgdGhlIHNhbWUgbmFtZVxuICAgKiBhcyB0aGUgbmFtZSBwcm92aWRlZCB0byB0aGUgUnVubmVyIHdoZW4gaXQgd2FzIGNyZWF0ZWQuXG4gICAqXG4gICAqIEUuZy4gQSBsaXN0ZW5lciBwYXNzZWQgdG8gdGhpcyBSdW5uZXIgd2lsbCByZXF1aXJlIGEgJ2NvbXBsZXRlJyBmdW5jdGlvbi5cbiAgICpcbiAgICogYGBganNcbiAgICogaW1wb3J0IHsgUnVubmVyIH0gZnJvbSAnQHBpeGkvcnVubmVyJztcbiAgICpcbiAgICogY29uc3QgY29tcGxldGUgPSBuZXcgUnVubmVyKCdjb21wbGV0ZScpO1xuICAgKiBgYGBcbiAgICpcbiAgICogVGhlIHNjb3BlIHVzZWQgd2lsbCBiZSB0aGUgb2JqZWN0IGl0c2VsZi5cbiAgICogQHBhcmFtIHthbnl9IGl0ZW0gLSBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSBsaXN0ZW5pbmcuXG4gICAqL1xuICBhZGQoaXRlbSkge1xuICAgIHJldHVybiBpdGVtW3RoaXMuX25hbWVdICYmICh0aGlzLmVuc3VyZU5vbkFsaWFzZWRJdGVtcygpLCB0aGlzLnJlbW92ZShpdGVtKSwgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGEgc2luZ2xlIGxpc3RlbmVyIGZyb20gdGhlIGRpc3BhdGNoIHF1ZXVlLlxuICAgKiBAcGFyYW0ge2FueX0gaXRlbSAtIFRoZSBsaXN0ZW5lciB0aGF0IHlvdSB3b3VsZCBsaWtlIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZShpdGVtKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgcmV0dXJuIGluZGV4ICE9PSAtMSAmJiAodGhpcy5lbnN1cmVOb25BbGlhc2VkSXRlbXMoKSwgdGhpcy5pdGVtcy5zcGxpY2UoaW5kZXgsIDEpKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBsaXN0ZW5lciBpcyBhbHJlYWR5IGluIHRoZSBSdW5uZXJcbiAgICogQHBhcmFtIHthbnl9IGl0ZW0gLSBUaGUgbGlzdGVuZXIgdGhhdCB5b3Ugd291bGQgbGlrZSB0byBjaGVjay5cbiAgICovXG4gIGNvbnRhaW5zKGl0ZW0pIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5pbmNsdWRlcyhpdGVtKTtcbiAgfVxuICAvKiogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZnJvbSB0aGUgUnVubmVyICovXG4gIHJlbW92ZUFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnN1cmVOb25BbGlhc2VkSXRlbXMoKSwgdGhpcy5pdGVtcy5sZW5ndGggPSAwLCB0aGlzO1xuICB9XG4gIC8qKiBSZW1vdmUgYWxsIHJlZmVyZW5jZXMsIGRvbid0IHVzZSBhZnRlciB0aGlzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlQWxsKCksIHRoaXMuaXRlbXMgPSBudWxsLCB0aGlzLl9uYW1lID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogYHRydWVgIGlmIHRoZXJlIGFyZSBubyB0aGlzIFJ1bm5lciBjb250YWlucyBubyBsaXN0ZW5lcnNcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoID09PSAwO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcnVubmVyLlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSdW5uZXIucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYGVtaXRgXG4gICAqIEBtZW1iZXJvZiBQSVhJLlJ1bm5lciNcbiAgICogQG1ldGhvZCBkaXNwYXRjaFxuICAgKiBAc2VlIFBJWEkuUnVubmVyI2VtaXRcbiAgICovXG4gIGRpc3BhdGNoOiB7IHZhbHVlOiBSdW5uZXIucHJvdG90eXBlLmVtaXQgfSxcbiAgLyoqXG4gICAqIEFsaWFzIGZvciBgZW1pdGBcbiAgICogQG1lbWJlcm9mIFBJWEkuUnVubmVyI1xuICAgKiBAbWV0aG9kIHJ1blxuICAgKiBAc2VlIFBJWEkuUnVubmVyI2VtaXRcbiAgICovXG4gIHJ1bjogeyB2YWx1ZTogUnVubmVyLnByb3RvdHlwZS5lbWl0IH1cbn0pO1xuZXhwb3J0cy5SdW5uZXIgPSBSdW5uZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SdW5uZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBSdW5uZXIgPSByZXF1aXJlKFwiLi9SdW5uZXIuanNcIik7XG5leHBvcnRzLlJ1bm5lciA9IFJ1bm5lci5SdW5uZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUNhbnZhcy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgQnJvd3NlckFkYXB0ZXIgPSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2FudmFzIGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNpemUuXG4gICAqIFRoaXMgY2FudmFzIGlzIGNyZWF0ZWQgdXNpbmcgdGhlIGJyb3dzZXIncyBuYXRpdmUgY2FudmFzIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB3aWR0aCAtIHdpZHRoIG9mIHRoZSBjYW52YXNcbiAgICogQHBhcmFtIGhlaWdodCAtIGhlaWdodCBvZiB0aGUgY2FudmFzXG4gICAqL1xuICBjcmVhdGVDYW52YXM6ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICByZXR1cm4gY2FudmFzLndpZHRoID0gd2lkdGgsIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQsIGNhbnZhcztcbiAgfSxcbiAgZ2V0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEOiAoKSA9PiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dDogKCkgPT4gV2ViR0xSZW5kZXJpbmdDb250ZXh0LFxuICBnZXROYXZpZ2F0b3I6ICgpID0+IG5hdmlnYXRvcixcbiAgZ2V0QmFzZVVybDogKCkgPT4gZG9jdW1lbnQuYmFzZVVSSSA/PyB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgZ2V0Rm9udEZhY2VTZXQ6ICgpID0+IGRvY3VtZW50LmZvbnRzLFxuICBmZXRjaDogKHVybCwgb3B0aW9ucykgPT4gZmV0Y2godXJsLCBvcHRpb25zKSxcbiAgcGFyc2VYTUw6ICh4bWwpID0+IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoeG1sLCBcInRleHQveG1sXCIpXG59O1xuZXhwb3J0cy5Ccm93c2VyQWRhcHRlciA9IEJyb3dzZXJBZGFwdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhcHRlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGFkYXB0ZXIgPSByZXF1aXJlKFwiLi9hZGFwdGVyLmpzXCIpO1xucmVxdWlyZShcIi4vSUNhbnZhcy5qc1wiKTtcbnJlcXVpcmUoXCIuL0lDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQuanNcIik7XG52YXIgc2V0dGluZ3MgPSByZXF1aXJlKFwiLi9zZXR0aW5ncy5qc1wiKSwgaXNNb2JpbGUgPSByZXF1aXJlKFwiLi91dGlscy9pc01vYmlsZS5qc1wiKTtcbmV4cG9ydHMuQnJvd3NlckFkYXB0ZXIgPSBhZGFwdGVyLkJyb3dzZXJBZGFwdGVyO1xuZXhwb3J0cy5zZXR0aW5ncyA9IHNldHRpbmdzLnNldHRpbmdzO1xuZXhwb3J0cy5pc01vYmlsZSA9IGlzTW9iaWxlLmlzTW9iaWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBhZGFwdGVyID0gcmVxdWlyZShcIi4vYWRhcHRlci5qc1wiKTtcbmNvbnN0IHNldHRpbmdzID0ge1xuICAvKipcbiAgICogVGhpcyBhZGFwdGVyIGlzIHVzZWQgdG8gY2FsbCBtZXRob2RzIHRoYXQgYXJlIHBsYXRmb3JtIGRlcGVuZGVudC5cbiAgICogRm9yIGV4YW1wbGUgYGRvY3VtZW50LmNyZWF0ZUVsZW1lbnRgIG9ubHkgcnVucyBvbiB0aGUgd2ViIGJ1dCBmYWlscyBpbiBub2RlIGVudmlyb25tZW50cy5cbiAgICogVGhpcyBhbGxvd3MgdXMgdG8gc3VwcG9ydCBtb3JlIHBsYXRmb3JtcyBieSBhYnN0cmFjdGluZyBhd2F5IHNwZWNpZmljIGltcGxlbWVudGF0aW9ucyBwZXIgcGxhdGZvcm0uXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhlIGFkYXB0ZXIgaXMgc2V0IHRvIHdvcmsgaW4gdGhlIGJyb3dzZXIuIEhvd2V2ZXIgeW91IGNhbiBjcmVhdGUgeW91ciBvd25cbiAgICogYnkgaW1wbGVtZW50aW5nIHRoZSBgSUFkYXB0ZXJgIGludGVyZmFjZS4gU2VlIGBJQWRhcHRlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqIEBuYW1lIEFEQVBURVJcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge1BJWEkuSUFkYXB0ZXJ9XG4gICAqIEBkZWZhdWx0IFBJWEkuQnJvd3NlckFkYXB0ZXJcbiAgICovXG4gIEFEQVBURVI6IGFkYXB0ZXIuQnJvd3NlckFkYXB0ZXIsXG4gIC8qKlxuICAgKiBEZWZhdWx0IHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIHJlbmRlcmVyLlxuICAgKiBAc3RhdGljXG4gICAqIEBuYW1lIFJFU09MVVRJT05cbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgUkVTT0xVVElPTjogMSxcbiAgLyoqXG4gICAqIEVuYWJsZXMgYml0bWFwIGNyZWF0aW9uIGJlZm9yZSBpbWFnZSBsb2FkLiBUaGlzIGZlYXR1cmUgaXMgZXhwZXJpbWVudGFsLlxuICAgKiBAc3RhdGljXG4gICAqIEBuYW1lIENSRUFURV9JTUFHRV9CSVRNQVBcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBDUkVBVEVfSU1BR0VfQklUTUFQOiAhMSxcbiAgLyoqXG4gICAqIElmIHRydWUgUGl4aUpTIHdpbGwgTWF0aC5mbG9vcigpIHgveSB2YWx1ZXMgd2hlbiByZW5kZXJpbmcsIHN0b3BwaW5nIHBpeGVsIGludGVycG9sYXRpb24uXG4gICAqIEFkdmFudGFnZXMgY2FuIGluY2x1ZGUgc2hhcnBlciBpbWFnZSBxdWFsaXR5IChsaWtlIHRleHQpIGFuZCBmYXN0ZXIgcmVuZGVyaW5nIG9uIGNhbnZhcy5cbiAgICogVGhlIG1haW4gZGlzYWR2YW50YWdlIGlzIG1vdmVtZW50IG9mIG9iamVjdHMgbWF5IGFwcGVhciBsZXNzIHNtb290aC5cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIFJPVU5EX1BJWEVMUzogITFcbn07XG5leHBvcnRzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXR0aW5ncy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzTW9iaWxlSnMgPSByZXF1aXJlKFwiaXNtb2JpbGVqc1wiKTtcbmNvbnN0IGlzTW9iaWxlQ2FsbCA9IGlzTW9iaWxlSnMuZGVmYXVsdCA/PyBpc01vYmlsZUpzLCBpc01vYmlsZSA9IGlzTW9iaWxlQ2FsbChnbG9iYWxUaGlzLm5hdmlnYXRvcik7XG5leHBvcnRzLmlzTW9iaWxlID0gaXNNb2JpbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc01vYmlsZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgc3ByaXRlID0gcmVxdWlyZShcIkBwaXhpL3Nwcml0ZVwiKTtcbmNsYXNzIEFuaW1hdGVkU3ByaXRlIGV4dGVuZHMgc3ByaXRlLlNwcml0ZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdGV4dHVyZXMgLSBBbiBhcnJheSBvZiB7QGxpbmsgUElYSS5UZXh0dXJlfSBvciBmcmFtZVxuICAgKiAgb2JqZWN0cyB0aGF0IG1ha2UgdXAgdGhlIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbYXV0b1VwZGF0ZT10cnVlXSAtIFdoZXRoZXIgdG8gdXNlIFRpY2tlci5zaGFyZWQgdG8gYXV0byB1cGRhdGUgYW5pbWF0aW9uIHRpbWUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlcywgYXV0b1VwZGF0ZSA9ICEwKSB7XG4gICAgc3VwZXIodGV4dHVyZXNbMF0gaW5zdGFuY2VvZiBjb3JlLlRleHR1cmUgPyB0ZXh0dXJlc1swXSA6IHRleHR1cmVzWzBdLnRleHR1cmUpLCB0aGlzLl90ZXh0dXJlcyA9IG51bGwsIHRoaXMuX2R1cmF0aW9ucyA9IG51bGwsIHRoaXMuX2F1dG9VcGRhdGUgPSBhdXRvVXBkYXRlLCB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gITEsIHRoaXMuYW5pbWF0aW9uU3BlZWQgPSAxLCB0aGlzLmxvb3AgPSAhMCwgdGhpcy51cGRhdGVBbmNob3IgPSAhMSwgdGhpcy5vbkNvbXBsZXRlID0gbnVsbCwgdGhpcy5vbkZyYW1lQ2hhbmdlID0gbnVsbCwgdGhpcy5vbkxvb3AgPSBudWxsLCB0aGlzLl9jdXJyZW50VGltZSA9IDAsIHRoaXMuX3BsYXlpbmcgPSAhMSwgdGhpcy5fcHJldmlvdXNGcmFtZSA9IG51bGwsIHRoaXMudGV4dHVyZXMgPSB0ZXh0dXJlcztcbiAgfVxuICAvKiogU3RvcHMgdGhlIEFuaW1hdGVkU3ByaXRlLiAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMuX3BsYXlpbmcgJiYgKHRoaXMuX3BsYXlpbmcgPSAhMSwgdGhpcy5fYXV0b1VwZGF0ZSAmJiB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyICYmIChjb3JlLlRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKSwgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciA9ICExKSk7XG4gIH1cbiAgLyoqIFBsYXlzIHRoZSBBbmltYXRlZFNwcml0ZS4gKi9cbiAgcGxheSgpIHtcbiAgICB0aGlzLl9wbGF5aW5nIHx8ICh0aGlzLl9wbGF5aW5nID0gITAsIHRoaXMuX2F1dG9VcGRhdGUgJiYgIXRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgJiYgKGNvcmUuVGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMsIGNvcmUuVVBEQVRFX1BSSU9SSVRZLkhJR0gpLCB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gITApKTtcbiAgfVxuICAvKipcbiAgICogU3RvcHMgdGhlIEFuaW1hdGVkU3ByaXRlIGFuZCBnb2VzIHRvIGEgc3BlY2lmaWMgZnJhbWUuXG4gICAqIEBwYXJhbSBmcmFtZU51bWJlciAtIEZyYW1lIGluZGV4IHRvIHN0b3AgYXQuXG4gICAqL1xuICBnb3RvQW5kU3RvcChmcmFtZU51bWJlcikge1xuICAgIHRoaXMuc3RvcCgpLCB0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lTnVtYmVyO1xuICB9XG4gIC8qKlxuICAgKiBHb2VzIHRvIGEgc3BlY2lmaWMgZnJhbWUgYW5kIGJlZ2lucyBwbGF5aW5nIHRoZSBBbmltYXRlZFNwcml0ZS5cbiAgICogQHBhcmFtIGZyYW1lTnVtYmVyIC0gRnJhbWUgaW5kZXggdG8gc3RhcnQgYXQuXG4gICAqL1xuICBnb3RvQW5kUGxheShmcmFtZU51bWJlcikge1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWVOdW1iZXIsIHRoaXMucGxheSgpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSBkZWx0YVRpbWUgLSBUaW1lIHNpbmNlIGxhc3QgdGljay5cbiAgICovXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuX3BsYXlpbmcpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZWxhcHNlZCA9IHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWUsIHByZXZpb3VzRnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgICBpZiAodGhpcy5fZHVyYXRpb25zICE9PSBudWxsKSB7XG4gICAgICBsZXQgbGFnID0gdGhpcy5fY3VycmVudFRpbWUgJSAxICogdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXTtcbiAgICAgIGZvciAobGFnICs9IGVsYXBzZWQgLyA2MCAqIDFlMzsgbGFnIDwgMDsgKVxuICAgICAgICB0aGlzLl9jdXJyZW50VGltZS0tLCBsYWcgKz0gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXTtcbiAgICAgIGNvbnN0IHNpZ24gPSBNYXRoLnNpZ24odGhpcy5hbmltYXRpb25TcGVlZCAqIGRlbHRhVGltZSk7XG4gICAgICBmb3IgKHRoaXMuX2N1cnJlbnRUaW1lID0gTWF0aC5mbG9vcih0aGlzLl9jdXJyZW50VGltZSk7IGxhZyA+PSB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdOyApXG4gICAgICAgIGxhZyAtPSB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdICogc2lnbiwgdGhpcy5fY3VycmVudFRpbWUgKz0gc2lnbjtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaW1lICs9IGxhZyAvIHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV07XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLl9jdXJyZW50VGltZSArPSBlbGFwc2VkO1xuICAgIHRoaXMuX2N1cnJlbnRUaW1lIDwgMCAmJiAhdGhpcy5sb29wID8gKHRoaXMuZ290b0FuZFN0b3AoMCksIHRoaXMub25Db21wbGV0ZSAmJiB0aGlzLm9uQ29tcGxldGUoKSkgOiB0aGlzLl9jdXJyZW50VGltZSA+PSB0aGlzLl90ZXh0dXJlcy5sZW5ndGggJiYgIXRoaXMubG9vcCA/ICh0aGlzLmdvdG9BbmRTdG9wKHRoaXMuX3RleHR1cmVzLmxlbmd0aCAtIDEpLCB0aGlzLm9uQ29tcGxldGUgJiYgdGhpcy5vbkNvbXBsZXRlKCkpIDogcHJldmlvdXNGcmFtZSAhPT0gdGhpcy5jdXJyZW50RnJhbWUgJiYgKHRoaXMubG9vcCAmJiB0aGlzLm9uTG9vcCAmJiAodGhpcy5hbmltYXRpb25TcGVlZCA+IDAgJiYgdGhpcy5jdXJyZW50RnJhbWUgPCBwcmV2aW91c0ZyYW1lIHx8IHRoaXMuYW5pbWF0aW9uU3BlZWQgPCAwICYmIHRoaXMuY3VycmVudEZyYW1lID4gcHJldmlvdXNGcmFtZSkgJiYgdGhpcy5vbkxvb3AoKSwgdGhpcy51cGRhdGVUZXh0dXJlKCkpO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSBkaXNwbGF5ZWQgdGV4dHVyZSB0byBtYXRjaCB0aGUgY3VycmVudCBmcmFtZSBpbmRleC4gKi9cbiAgdXBkYXRlVGV4dHVyZSgpIHtcbiAgICBjb25zdCBjdXJyZW50RnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgICB0aGlzLl9wcmV2aW91c0ZyYW1lICE9PSBjdXJyZW50RnJhbWUgJiYgKHRoaXMuX3ByZXZpb3VzRnJhbWUgPSBjdXJyZW50RnJhbWUsIHRoaXMuX3RleHR1cmUgPSB0aGlzLl90ZXh0dXJlc1tjdXJyZW50RnJhbWVdLCB0aGlzLl90ZXh0dXJlSUQgPSAtMSwgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IC0xLCB0aGlzLl9jYWNoZWRUaW50ID0gMTY3NzcyMTUsIHRoaXMudXZzID0gdGhpcy5fdGV4dHVyZS5fdXZzLnV2c0Zsb2F0MzIsIHRoaXMudXBkYXRlQW5jaG9yICYmIHRoaXMuX2FuY2hvci5jb3B5RnJvbSh0aGlzLl90ZXh0dXJlLmRlZmF1bHRBbmNob3IpLCB0aGlzLm9uRnJhbWVDaGFuZ2UgJiYgdGhpcy5vbkZyYW1lQ2hhbmdlKHRoaXMuY3VycmVudEZyYW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSBBbmltYXRlZFNwcml0ZSBhbmQgZGVzdHJveXMgaXQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBJZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgKiAgICAgIG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGwuXG4gICAqL1xuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICB0aGlzLnN0b3AoKSwgc3VwZXIuZGVzdHJveShvcHRpb25zKSwgdGhpcy5vbkNvbXBsZXRlID0gbnVsbCwgdGhpcy5vbkZyYW1lQ2hhbmdlID0gbnVsbCwgdGhpcy5vbkxvb3AgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBBIHNob3J0IGhhbmQgd2F5IG9mIGNyZWF0aW5nIGFuIEFuaW1hdGVkU3ByaXRlIGZyb20gYW4gYXJyYXkgb2YgZnJhbWUgaWRzLlxuICAgKiBAcGFyYW0gZnJhbWVzIC0gVGhlIGFycmF5IG9mIGZyYW1lcyBpZHMgdGhlIEFuaW1hdGVkU3ByaXRlIHdpbGwgdXNlIGFzIGl0cyB0ZXh0dXJlIGZyYW1lcy5cbiAgICogQHJldHVybnMgLSBUaGUgbmV3IGFuaW1hdGVkIHNwcml0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgZnJhbWVzLlxuICAgKi9cbiAgc3RhdGljIGZyb21GcmFtZXMoZnJhbWVzKSB7XG4gICAgY29uc3QgdGV4dHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgIHRleHR1cmVzLnB1c2goY29yZS5UZXh0dXJlLmZyb20oZnJhbWVzW2ldKSk7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRlZFNwcml0ZSh0ZXh0dXJlcyk7XG4gIH1cbiAgLyoqXG4gICAqIEEgc2hvcnQgaGFuZCB3YXkgb2YgY3JlYXRpbmcgYW4gQW5pbWF0ZWRTcHJpdGUgZnJvbSBhbiBhcnJheSBvZiBpbWFnZSBpZHMuXG4gICAqIEBwYXJhbSBpbWFnZXMgLSBUaGUgYXJyYXkgb2YgaW1hZ2UgdXJscyB0aGUgQW5pbWF0ZWRTcHJpdGUgd2lsbCB1c2UgYXMgaXRzIHRleHR1cmUgZnJhbWVzLlxuICAgKiBAcmV0dXJucyBUaGUgbmV3IGFuaW1hdGUgc3ByaXRlIHdpdGggdGhlIHNwZWNpZmllZCBpbWFnZXMgYXMgZnJhbWVzLlxuICAgKi9cbiAgc3RhdGljIGZyb21JbWFnZXMoaW1hZ2VzKSB7XG4gICAgY29uc3QgdGV4dHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlcy5sZW5ndGg7ICsraSlcbiAgICAgIHRleHR1cmVzLnB1c2goY29yZS5UZXh0dXJlLmZyb20oaW1hZ2VzW2ldKSk7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRlZFNwcml0ZSh0ZXh0dXJlcyk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBBbmltYXRlZFNwcml0ZS4gVGhpcyBpcyB0aGUgc2FtZSBhcyBudW1iZXIgb2YgdGV4dHVyZXNcbiAgICogYXNzaWduZWQgdG8gdGhlIEFuaW1hdGVkU3ByaXRlLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZ2V0IHRvdGFsRnJhbWVzKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0dXJlcy5sZW5ndGg7XG4gIH1cbiAgLyoqIFRoZSBhcnJheSBvZiB0ZXh0dXJlcyB1c2VkIGZvciB0aGlzIEFuaW1hdGVkU3ByaXRlLiAqL1xuICBnZXQgdGV4dHVyZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzO1xuICB9XG4gIHNldCB0ZXh0dXJlcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVswXSBpbnN0YW5jZW9mIGNvcmUuVGV4dHVyZSlcbiAgICAgIHRoaXMuX3RleHR1cmVzID0gdmFsdWUsIHRoaXMuX2R1cmF0aW9ucyA9IG51bGw7XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl90ZXh0dXJlcyA9IFtdLCB0aGlzLl9kdXJhdGlvbnMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgIHRoaXMuX3RleHR1cmVzLnB1c2godmFsdWVbaV0udGV4dHVyZSksIHRoaXMuX2R1cmF0aW9ucy5wdXNoKHZhbHVlW2ldLnRpbWUpO1xuICAgIH1cbiAgICB0aGlzLl9wcmV2aW91c0ZyYW1lID0gbnVsbCwgdGhpcy5nb3RvQW5kU3RvcCgwKSwgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG4gIH1cbiAgLyoqIFRoZSBBbmltYXRlZFNwcml0ZSdzIGN1cnJlbnQgZnJhbWUgaW5kZXguICovXG4gIGdldCBjdXJyZW50RnJhbWUoKSB7XG4gICAgbGV0IGN1cnJlbnRGcmFtZSA9IE1hdGguZmxvb3IodGhpcy5fY3VycmVudFRpbWUpICUgdGhpcy5fdGV4dHVyZXMubGVuZ3RoO1xuICAgIHJldHVybiBjdXJyZW50RnJhbWUgPCAwICYmIChjdXJyZW50RnJhbWUgKz0gdGhpcy5fdGV4dHVyZXMubGVuZ3RoKSwgY3VycmVudEZyYW1lO1xuICB9XG4gIHNldCBjdXJyZW50RnJhbWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gdGhpcy50b3RhbEZyYW1lcyAtIDEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFtBbmltYXRlZFNwcml0ZV06IEludmFsaWQgZnJhbWUgaW5kZXggdmFsdWUgJHt2YWx1ZX0sIGV4cGVjdGVkIHRvIGJlIGJldHdlZW4gMCBhbmQgdG90YWxGcmFtZXMgJHt0aGlzLnRvdGFsRnJhbWVzfS5gKTtcbiAgICBjb25zdCBwcmV2aW91c0ZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgdGhpcy5fY3VycmVudFRpbWUgPSB2YWx1ZSwgcHJldmlvdXNGcmFtZSAhPT0gdGhpcy5jdXJyZW50RnJhbWUgJiYgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgQW5pbWF0ZWRTcHJpdGUgaXMgY3VycmVudGx5IHBsYXlpbmcuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHBsYXlpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsYXlpbmc7XG4gIH1cbiAgLyoqIFdoZXRoZXIgdG8gdXNlIFRpY2tlci5zaGFyZWQgdG8gYXV0byB1cGRhdGUgYW5pbWF0aW9uIHRpbWUuICovXG4gIGdldCBhdXRvVXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9hdXRvVXBkYXRlO1xuICB9XG4gIHNldCBhdXRvVXBkYXRlKHZhbHVlKSB7XG4gICAgdmFsdWUgIT09IHRoaXMuX2F1dG9VcGRhdGUgJiYgKHRoaXMuX2F1dG9VcGRhdGUgPSB2YWx1ZSwgIXRoaXMuX2F1dG9VcGRhdGUgJiYgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciA/IChjb3JlLlRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKSwgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciA9ICExKSA6IHRoaXMuX2F1dG9VcGRhdGUgJiYgIXRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgJiYgdGhpcy5fcGxheWluZyAmJiAoY29yZS5UaWNrZXIuc2hhcmVkLmFkZCh0aGlzLnVwZGF0ZSwgdGhpcyksIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSAhMCkpO1xuICB9XG59XG5leHBvcnRzLkFuaW1hdGVkU3ByaXRlID0gQW5pbWF0ZWRTcHJpdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BbmltYXRlZFNwcml0ZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIEFuaW1hdGVkU3ByaXRlID0gcmVxdWlyZShcIi4vQW5pbWF0ZWRTcHJpdGUuanNcIik7XG5leHBvcnRzLkFuaW1hdGVkU3ByaXRlID0gQW5pbWF0ZWRTcHJpdGUuQW5pbWF0ZWRTcHJpdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgc3ByaXRlID0gcmVxdWlyZShcIkBwaXhpL3Nwcml0ZVwiKTtcbmNvbnN0IHRlbXBQb2ludCA9IG5ldyBjb3JlLlBvaW50KCk7XG5jbGFzcyBUaWxpbmdTcHJpdGUgZXh0ZW5kcyBzcHJpdGUuU3ByaXRlIHtcbiAgLyoqXG4gICAqIE5vdGU6IFRoZSB3cmFwIG1vZGUgb2YgdGhlIHRleHR1cmUgaXMgZm9yY2VkIHRvIFJFUEVBVCBvbiByZW5kZXIgaWYgdGhlIHNpemUgb2YgdGhlIHRleHR1cmVcbiAgICogaXMgYSBwb3dlciBvZiB0d28sIHRoZSB0ZXh0dXJlJ3Mgd3JhcCBtb2RlIGlzIENMQU1QLCBhbmQgdGhlIHRleHR1cmUgaGFzbid0IGJlZW4gYm91bmQgeWV0LlxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIG9mIHRoZSB0aWxpbmcgc3ByaXRlLlxuICAgKiBAcGFyYW0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHRpbGluZyBzcHJpdGUuXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSB0aWxpbmcgc3ByaXRlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4dHVyZSwgd2lkdGggPSAxMDAsIGhlaWdodCA9IDEwMCkge1xuICAgIHN1cGVyKHRleHR1cmUpLCB0aGlzLnRpbGVUcmFuc2Zvcm0gPSBuZXcgY29yZS5UcmFuc2Zvcm0oKSwgdGhpcy5fd2lkdGggPSB3aWR0aCwgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0LCB0aGlzLnV2TWF0cml4ID0gdGhpcy50ZXh0dXJlLnV2TWF0cml4IHx8IG5ldyBjb3JlLlRleHR1cmVNYXRyaXgodGV4dHVyZSksIHRoaXMucGx1Z2luTmFtZSA9IFwidGlsaW5nU3ByaXRlXCIsIHRoaXMudXZSZXNwZWN0QW5jaG9yID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgZnJhbWUgY2xhbXBpbmcgaW4gY29ycmVzcG9uZGluZyB0ZXh0dXJlVHJhbnNmb3JtLCBzaG9ydGN1dFxuICAgKiBDaGFuZ2UgdG8gLTAuNSB0byBhZGQgYSBwaXhlbCB0byB0aGUgZWRnZSwgcmVjb21tZW5kZWQgZm9yIHRyYW5zcGFyZW50IHRyaW1tZWQgdGV4dHVyZXMgaW4gYXRsYXNcbiAgICogQGRlZmF1bHQgMC41XG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICovXG4gIGdldCBjbGFtcE1hcmdpbigpIHtcbiAgICByZXR1cm4gdGhpcy51dk1hdHJpeC5jbGFtcE1hcmdpbjtcbiAgfVxuICBzZXQgY2xhbXBNYXJnaW4odmFsdWUpIHtcbiAgICB0aGlzLnV2TWF0cml4LmNsYW1wTWFyZ2luID0gdmFsdWUsIHRoaXMudXZNYXRyaXgudXBkYXRlKCEwKTtcbiAgfVxuICAvKiogVGhlIHNjYWxpbmcgb2YgdGhlIGltYWdlIHRoYXQgaXMgYmVpbmcgdGlsZWQuICovXG4gIGdldCB0aWxlU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZVRyYW5zZm9ybS5zY2FsZTtcbiAgfVxuICBzZXQgdGlsZVNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy50aWxlVHJhbnNmb3JtLnNjYWxlLmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICAvKiogVGhlIG9mZnNldCBvZiB0aGUgaW1hZ2UgdGhhdCBpcyBiZWluZyB0aWxlZC4gKi9cbiAgZ2V0IHRpbGVQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlVHJhbnNmb3JtLnBvc2l0aW9uO1xuICB9XG4gIHNldCB0aWxlUG9zaXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnRpbGVUcmFuc2Zvcm0ucG9zaXRpb24uY29weUZyb20odmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfb25UZXh0dXJlVXBkYXRlKCkge1xuICAgIHRoaXMudXZNYXRyaXggJiYgKHRoaXMudXZNYXRyaXgudGV4dHVyZSA9IHRoaXMuX3RleHR1cmUpLCB0aGlzLl9jYWNoZWRUaW50ID0gMTY3NzcyMTU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAqL1xuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gICAgIXRleHR1cmUgfHwgIXRleHR1cmUudmFsaWQgfHwgKHRoaXMudGlsZVRyYW5zZm9ybS51cGRhdGVMb2NhbFRyYW5zZm9ybSgpLCB0aGlzLnV2TWF0cml4LnVwZGF0ZSgpLCByZW5kZXJlci5iYXRjaC5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0pLCByZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0ucmVuZGVyKHRoaXMpKTtcbiAgfVxuICAvKiogVXBkYXRlcyB0aGUgYm91bmRzIG9mIHRoZSB0aWxpbmcgc3ByaXRlLiAqL1xuICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgIGNvbnN0IG1pblggPSB0aGlzLl93aWR0aCAqIC10aGlzLl9hbmNob3IuX3gsIG1pblkgPSB0aGlzLl9oZWlnaHQgKiAtdGhpcy5fYW5jaG9yLl95LCBtYXhYID0gdGhpcy5fd2lkdGggKiAoMSAtIHRoaXMuX2FuY2hvci5feCksIG1heFkgPSB0aGlzLl9oZWlnaHQgKiAoMSAtIHRoaXMuX2FuY2hvci5feSk7XG4gICAgdGhpcy5fYm91bmRzLmFkZEZyYW1lKHRoaXMudHJhbnNmb3JtLCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBzcHJpdGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gcmVjdCAtIE9wdGlvbmFsIG91dHB1dCByZWN0YW5nbGUuXG4gICAqIEByZXR1cm5zIFRoZSBib3VuZHMuXG4gICAqL1xuICBnZXRMb2NhbEJvdW5kcyhyZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gKHRoaXMuX2JvdW5kcy5taW5YID0gdGhpcy5fd2lkdGggKiAtdGhpcy5fYW5jaG9yLl94LCB0aGlzLl9ib3VuZHMubWluWSA9IHRoaXMuX2hlaWdodCAqIC10aGlzLl9hbmNob3IuX3ksIHRoaXMuX2JvdW5kcy5tYXhYID0gdGhpcy5fd2lkdGggKiAoMSAtIHRoaXMuX2FuY2hvci5feCksIHRoaXMuX2JvdW5kcy5tYXhZID0gdGhpcy5faGVpZ2h0ICogKDEgLSB0aGlzLl9hbmNob3IuX3kpLCByZWN0IHx8ICh0aGlzLl9sb2NhbEJvdW5kc1JlY3QgfHwgKHRoaXMuX2xvY2FsQm91bmRzUmVjdCA9IG5ldyBjb3JlLlJlY3RhbmdsZSgpKSwgcmVjdCA9IHRoaXMuX2xvY2FsQm91bmRzUmVjdCksIHRoaXMuX2JvdW5kcy5nZXRSZWN0YW5nbGUocmVjdCkpIDogc3VwZXIuZ2V0TG9jYWxCb3VuZHMuY2FsbCh0aGlzLCByZWN0KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgdGlsaW5nIHNwcml0ZS5cbiAgICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBXaGV0aGVyIG9yIG5vdCB0aGUgc3ByaXRlIGNvbnRhaW5zIHRoZSBwb2ludC5cbiAgICovXG4gIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgdGVtcFBvaW50KTtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3dpZHRoLCBoZWlnaHQgPSB0aGlzLl9oZWlnaHQsIHgxID0gLXdpZHRoICogdGhpcy5hbmNob3IuX3g7XG4gICAgaWYgKHRlbXBQb2ludC54ID49IHgxICYmIHRlbXBQb2ludC54IDwgeDEgKyB3aWR0aCkge1xuICAgICAgY29uc3QgeTEgPSAtaGVpZ2h0ICogdGhpcy5hbmNob3IuX3k7XG4gICAgICBpZiAodGVtcFBvaW50LnkgPj0geTEgJiYgdGVtcFBvaW50LnkgPCB5MSArIGhlaWdodClcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoaXMgc3ByaXRlIGFuZCBvcHRpb25hbGx5IGl0cyB0ZXh0dXJlIGFuZCBjaGlsZHJlblxuICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgKiAgICAgIG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iYXNlVGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgKi9cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKSwgdGhpcy50aWxlVHJhbnNmb3JtID0gbnVsbCwgdGhpcy51dk1hdHJpeCA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgdGlsaW5nIHNwcml0ZSBiYXNlZCBvbiB0aGUgc291cmNlIHlvdSBwcm92aWRlLlxuICAgKiBUaGUgc291cmNlIGNhbiBiZSAtIGZyYW1lIGlkLCBpbWFnZSB1cmwsIHZpZGVvIHVybCwgY2FudmFzIGVsZW1lbnQsIHZpZGVvIGVsZW1lbnQsIGJhc2UgdGV4dHVyZVxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfFBJWEkuVGV4dHVyZXxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBzb3VyY2UgLSBTb3VyY2UgdG8gY3JlYXRlIHRleHR1cmUgZnJvbVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFNlZSB7QGxpbmsgUElYSS5CYXNlVGV4dHVyZX0ncyBjb25zdHJ1Y3RvciBmb3Igb3B0aW9ucy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMud2lkdGggLSByZXF1aXJlZCB3aWR0aCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5oZWlnaHQgLSByZXF1aXJlZCBoZWlnaHQgb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICogQHJldHVybnMge1BJWEkuVGlsaW5nU3ByaXRlfSBUaGUgbmV3bHkgY3JlYXRlZCB0ZXh0dXJlXG4gICAqL1xuICBzdGF0aWMgZnJvbShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gc291cmNlIGluc3RhbmNlb2YgY29yZS5UZXh0dXJlID8gc291cmNlIDogY29yZS5UZXh0dXJlLmZyb20oc291cmNlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IFRpbGluZ1Nwcml0ZShcbiAgICAgIHRleHR1cmUsXG4gICAgICBvcHRpb25zLndpZHRoLFxuICAgICAgb3B0aW9ucy5oZWlnaHRcbiAgICApO1xuICB9XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXQuICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgfVxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgVGlsaW5nU3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldC4gKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgfVxufVxuZXhwb3J0cy5UaWxpbmdTcHJpdGUgPSBUaWxpbmdTcHJpdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxpbmdTcHJpdGUuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIHNwcml0ZVRpbGluZyQxID0gcmVxdWlyZShcIi4vc3ByaXRlLXRpbGluZy5mcmFnLmpzXCIpLCBzcHJpdGVUaWxpbmcgPSByZXF1aXJlKFwiLi9zcHJpdGUtdGlsaW5nLnZlcnQuanNcIiksIHNwcml0ZVRpbGluZ0ZhbGxiYWNrJDEgPSByZXF1aXJlKFwiLi9zcHJpdGUtdGlsaW5nLWZhbGxiYWNrLmZyYWcuanNcIiksIHNwcml0ZVRpbGluZ0ZhbGxiYWNrID0gcmVxdWlyZShcIi4vc3ByaXRlLXRpbGluZy1mYWxsYmFjay52ZXJ0LmpzXCIpLCBzcHJpdGVUaWxpbmdTaW1wbGUgPSByZXF1aXJlKFwiLi9zcHJpdGUtdGlsaW5nLXNpbXBsZS5mcmFnLmpzXCIpO1xuY29uc3QgdGVtcE1hdCA9IG5ldyBjb3JlLk1hdHJpeCgpO1xuY2xhc3MgVGlsaW5nU3ByaXRlUmVuZGVyZXIgZXh0ZW5kcyBjb3JlLk9iamVjdFJlbmRlcmVyIHtcbiAgLyoqXG4gICAqIGNvbnN0cnVjdG9yIGZvciByZW5kZXJlclxuICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgdGlsaW5nIGF3ZXNvbWVuZXNzIHdvcmtzIGZvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgc3VwZXIocmVuZGVyZXIpLCByZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UuYWRkKHRoaXMpLCB0aGlzLnF1YWQgPSBuZXcgY29yZS5RdWFkVXYoKSwgdGhpcy5zdGF0ZSA9IGNvcmUuU3RhdGUuZm9yMmQoKTtcbiAgfVxuICAvKiogQ3JlYXRlcyBzaGFkZXJzIHdoZW4gY29udGV4dCBpcyBpbml0aWFsaXplZC4gKi9cbiAgY29udGV4dENoYW5nZSgpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsIHVuaWZvcm1zID0geyBnbG9iYWxzOiByZW5kZXJlci5nbG9iYWxVbmlmb3JtcyB9O1xuICAgIHRoaXMuc2ltcGxlU2hhZGVyID0gY29yZS5TaGFkZXIuZnJvbShzcHJpdGVUaWxpbmdGYWxsYmFjay5kZWZhdWx0LCBzcHJpdGVUaWxpbmdTaW1wbGUuZGVmYXVsdCwgdW5pZm9ybXMpLCB0aGlzLnNoYWRlciA9IHJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID4gMSA/IGNvcmUuU2hhZGVyLmZyb20oc3ByaXRlVGlsaW5nLmRlZmF1bHQsIHNwcml0ZVRpbGluZyQxLmRlZmF1bHQsIHVuaWZvcm1zKSA6IGNvcmUuU2hhZGVyLmZyb20oc3ByaXRlVGlsaW5nRmFsbGJhY2suZGVmYXVsdCwgc3ByaXRlVGlsaW5nRmFsbGJhY2skMS5kZWZhdWx0LCB1bmlmb3Jtcyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7UElYSS5UaWxpbmdTcHJpdGV9IHRzIC0gdGlsaW5nU3ByaXRlIHRvIGJlIHJlbmRlcmVkXG4gICAqL1xuICByZW5kZXIodHMpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsIHF1YWQgPSB0aGlzLnF1YWQ7XG4gICAgbGV0IHZlcnRpY2VzID0gcXVhZC52ZXJ0aWNlcztcbiAgICB2ZXJ0aWNlc1swXSA9IHZlcnRpY2VzWzZdID0gdHMuX3dpZHRoICogLXRzLmFuY2hvci54LCB2ZXJ0aWNlc1sxXSA9IHZlcnRpY2VzWzNdID0gdHMuX2hlaWdodCAqIC10cy5hbmNob3IueSwgdmVydGljZXNbMl0gPSB2ZXJ0aWNlc1s0XSA9IHRzLl93aWR0aCAqICgxIC0gdHMuYW5jaG9yLngpLCB2ZXJ0aWNlc1s1XSA9IHZlcnRpY2VzWzddID0gdHMuX2hlaWdodCAqICgxIC0gdHMuYW5jaG9yLnkpO1xuICAgIGNvbnN0IGFuY2hvclggPSB0cy51dlJlc3BlY3RBbmNob3IgPyB0cy5hbmNob3IueCA6IDAsIGFuY2hvclkgPSB0cy51dlJlc3BlY3RBbmNob3IgPyB0cy5hbmNob3IueSA6IDA7XG4gICAgdmVydGljZXMgPSBxdWFkLnV2cywgdmVydGljZXNbMF0gPSB2ZXJ0aWNlc1s2XSA9IC1hbmNob3JYLCB2ZXJ0aWNlc1sxXSA9IHZlcnRpY2VzWzNdID0gLWFuY2hvclksIHZlcnRpY2VzWzJdID0gdmVydGljZXNbNF0gPSAxIC0gYW5jaG9yWCwgdmVydGljZXNbNV0gPSB2ZXJ0aWNlc1s3XSA9IDEgLSBhbmNob3JZLCBxdWFkLmludmFsaWRhdGUoKTtcbiAgICBjb25zdCB0ZXggPSB0cy5fdGV4dHVyZSwgYmFzZVRleCA9IHRleC5iYXNlVGV4dHVyZSwgcHJlbXVsdGlwbGllZCA9IGJhc2VUZXguYWxwaGFNb2RlID4gMCwgbHQgPSB0cy50aWxlVHJhbnNmb3JtLmxvY2FsVHJhbnNmb3JtLCB1diA9IHRzLnV2TWF0cml4O1xuICAgIGxldCBpc1NpbXBsZSA9IGJhc2VUZXguaXNQb3dlck9mVHdvICYmIHRleC5mcmFtZS53aWR0aCA9PT0gYmFzZVRleC53aWR0aCAmJiB0ZXguZnJhbWUuaGVpZ2h0ID09PSBiYXNlVGV4LmhlaWdodDtcbiAgICBpc1NpbXBsZSAmJiAoYmFzZVRleC5fZ2xUZXh0dXJlc1tyZW5kZXJlci5DT05URVhUX1VJRF0gPyBpc1NpbXBsZSA9IGJhc2VUZXgud3JhcE1vZGUgIT09IGNvcmUuV1JBUF9NT0RFUy5DTEFNUCA6IGJhc2VUZXgud3JhcE1vZGUgPT09IGNvcmUuV1JBUF9NT0RFUy5DTEFNUCAmJiAoYmFzZVRleC53cmFwTW9kZSA9IGNvcmUuV1JBUF9NT0RFUy5SRVBFQVQpKTtcbiAgICBjb25zdCBzaGFkZXIgPSBpc1NpbXBsZSA/IHRoaXMuc2ltcGxlU2hhZGVyIDogdGhpcy5zaGFkZXIsIHcgPSB0ZXgud2lkdGgsIGggPSB0ZXguaGVpZ2h0LCBXID0gdHMuX3dpZHRoLCBIID0gdHMuX2hlaWdodDtcbiAgICB0ZW1wTWF0LnNldChcbiAgICAgIGx0LmEgKiB3IC8gVyxcbiAgICAgIGx0LmIgKiB3IC8gSCxcbiAgICAgIGx0LmMgKiBoIC8gVyxcbiAgICAgIGx0LmQgKiBoIC8gSCxcbiAgICAgIGx0LnR4IC8gVyxcbiAgICAgIGx0LnR5IC8gSFxuICAgICksIHRlbXBNYXQuaW52ZXJ0KCksIGlzU2ltcGxlID8gdGVtcE1hdC5wcmVwZW5kKHV2Lm1hcENvb3JkKSA6IChzaGFkZXIudW5pZm9ybXMudU1hcENvb3JkID0gdXYubWFwQ29vcmQudG9BcnJheSghMCksIHNoYWRlci51bmlmb3Jtcy51Q2xhbXBGcmFtZSA9IHV2LnVDbGFtcEZyYW1lLCBzaGFkZXIudW5pZm9ybXMudUNsYW1wT2Zmc2V0ID0gdXYudUNsYW1wT2Zmc2V0KSwgc2hhZGVyLnVuaWZvcm1zLnVUcmFuc2Zvcm0gPSB0ZW1wTWF0LnRvQXJyYXkoITApLCBzaGFkZXIudW5pZm9ybXMudUNvbG9yID0gY29yZS5Db2xvci5zaGFyZWQuc2V0VmFsdWUodHMudGludCkucHJlbXVsdGlwbHkodHMud29ybGRBbHBoYSwgcHJlbXVsdGlwbGllZCkudG9BcnJheShzaGFkZXIudW5pZm9ybXMudUNvbG9yKSwgc2hhZGVyLnVuaWZvcm1zLnRyYW5zbGF0aW9uTWF0cml4ID0gdHMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkoITApLCBzaGFkZXIudW5pZm9ybXMudVNhbXBsZXIgPSB0ZXgsIHJlbmRlcmVyLnNoYWRlci5iaW5kKHNoYWRlciksIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQocXVhZCksIHRoaXMuc3RhdGUuYmxlbmRNb2RlID0gY29yZS51dGlscy5jb3JyZWN0QmxlbmRNb2RlKHRzLmJsZW5kTW9kZSwgcHJlbXVsdGlwbGllZCksIHJlbmRlcmVyLnN0YXRlLnNldCh0aGlzLnN0YXRlKSwgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyh0aGlzLnJlbmRlcmVyLmdsLlRSSUFOR0xFUywgNiwgMCk7XG4gIH1cbn1cblRpbGluZ1Nwcml0ZVJlbmRlcmVyLmV4dGVuc2lvbiA9IHtcbiAgbmFtZTogXCJ0aWxpbmdTcHJpdGVcIixcbiAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLlJlbmRlcmVyUGx1Z2luXG59O1xuY29yZS5leHRlbnNpb25zLmFkZChUaWxpbmdTcHJpdGVSZW5kZXJlcik7XG5leHBvcnRzLlRpbGluZ1Nwcml0ZVJlbmRlcmVyID0gVGlsaW5nU3ByaXRlUmVuZGVyZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxpbmdTcHJpdGVSZW5kZXJlci5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIFRpbGluZ1Nwcml0ZSA9IHJlcXVpcmUoXCIuL1RpbGluZ1Nwcml0ZS5qc1wiKSwgVGlsaW5nU3ByaXRlUmVuZGVyZXIgPSByZXF1aXJlKFwiLi9UaWxpbmdTcHJpdGVSZW5kZXJlci5qc1wiKTtcbmV4cG9ydHMuVGlsaW5nU3ByaXRlID0gVGlsaW5nU3ByaXRlLlRpbGluZ1Nwcml0ZTtcbmV4cG9ydHMuVGlsaW5nU3ByaXRlUmVuZGVyZXIgPSBUaWxpbmdTcHJpdGVSZW5kZXJlci5UaWxpbmdTcHJpdGVSZW5kZXJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIGdsMUZyYWdtZW50U3JjID0gYCN2ZXJzaW9uIDEwMFxuI2lmZGVmIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2RcbiAgICAjZXh0ZW5zaW9uIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QgOiBlbmFibGVcbiNlbmRpZlxuI2RlZmluZSBTSEFERVJfTkFNRSBUaWxpbmctU3ByaXRlLTEwMFxuXG5wcmVjaXNpb24gbG93cCBmbG9hdDtcblxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xudW5pZm9ybSB2ZWM0IHVDb2xvcjtcbnVuaWZvcm0gbWF0MyB1TWFwQ29vcmQ7XG51bmlmb3JtIHZlYzQgdUNsYW1wRnJhbWU7XG51bmlmb3JtIHZlYzIgdUNsYW1wT2Zmc2V0O1xuXG52b2lkIG1haW4odm9pZClcbntcbiAgICB2ZWMyIGNvb3JkID0gdlRleHR1cmVDb29yZCArIGNlaWwodUNsYW1wT2Zmc2V0IC0gdlRleHR1cmVDb29yZCk7XG4gICAgY29vcmQgPSAodU1hcENvb3JkICogdmVjMyhjb29yZCwgMS4wKSkueHk7XG4gICAgdmVjMiB1bmNsYW1wZWQgPSBjb29yZDtcbiAgICBjb29yZCA9IGNsYW1wKGNvb3JkLCB1Q2xhbXBGcmFtZS54eSwgdUNsYW1wRnJhbWUuencpO1xuXG4gICAgI2lmZGVmIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2RcbiAgICAgICAgdmVjNCB0ZXhTYW1wbGUgPSB1bmNsYW1wZWQgPT0gY29vcmRcbiAgICAgICAgICAgID8gdGV4dHVyZTJEKHVTYW1wbGVyLCBjb29yZCkgXG4gICAgICAgICAgICA6IHRleHR1cmUyRExvZEVYVCh1U2FtcGxlciwgY29vcmQsIDApO1xuICAgICNlbHNlXG4gICAgICAgIHZlYzQgdGV4U2FtcGxlID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjb29yZCk7XG4gICAgI2VuZGlmXG5cbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXhTYW1wbGUgKiB1Q29sb3I7XG59XG5gO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2wxRnJhZ21lbnRTcmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcHJpdGUtdGlsaW5nLWZhbGxiYWNrLmZyYWcuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgZ2wxVmVydGV4U3JjID0gYCN2ZXJzaW9uIDEwMFxuI2RlZmluZSBTSEFERVJfTkFNRSBUaWxpbmctU3ByaXRlLTEwMFxuXG5wcmVjaXNpb24gbG93cCBmbG9hdDtcblxuYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcblxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XG51bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XG51bmlmb3JtIG1hdDMgdVRyYW5zZm9ybTtcblxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cbnZvaWQgbWFpbih2b2lkKVxue1xuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XG5cbiAgICB2VGV4dHVyZUNvb3JkID0gKHVUcmFuc2Zvcm0gKiB2ZWMzKGFUZXh0dXJlQ29vcmQsIDEuMCkpLnh5O1xufVxuYDtcbmV4cG9ydHMuZGVmYXVsdCA9IGdsMVZlcnRleFNyYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZS10aWxpbmctZmFsbGJhY2sudmVydC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnZhciBmcmFnbWVudFNpbXBsZVNyYyA9IGAjdmVyc2lvbiAxMDBcbiNkZWZpbmUgU0hBREVSX05BTUUgVGlsaW5nLVNwcml0ZS1TaW1wbGUtMTAwXG5cbnByZWNpc2lvbiBsb3dwIGZsb2F0O1xuXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcblxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG51bmlmb3JtIHZlYzQgdUNvbG9yO1xuXG52b2lkIG1haW4odm9pZClcbntcbiAgICB2ZWM0IHRleFNhbXBsZSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4U2FtcGxlICogdUNvbG9yO1xufVxuYDtcbmV4cG9ydHMuZGVmYXVsdCA9IGZyYWdtZW50U2ltcGxlU3JjO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ByaXRlLXRpbGluZy1zaW1wbGUuZnJhZy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnZhciBnbDJGcmFnbWVudFNyYyA9IGAjdmVyc2lvbiAzMDAgZXNcbiNkZWZpbmUgU0hBREVSX05BTUUgVGlsaW5nLVNwcml0ZS0xMDBcblxucHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG5cbmluIHZlYzIgdlRleHR1cmVDb29yZDtcblxub3V0IHZlYzQgZnJhZ21lbnRDb2xvcjtcblxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG51bmlmb3JtIHZlYzQgdUNvbG9yO1xudW5pZm9ybSBtYXQzIHVNYXBDb29yZDtcbnVuaWZvcm0gdmVjNCB1Q2xhbXBGcmFtZTtcbnVuaWZvcm0gdmVjMiB1Q2xhbXBPZmZzZXQ7XG5cbnZvaWQgbWFpbih2b2lkKVxue1xuICAgIHZlYzIgY29vcmQgPSB2VGV4dHVyZUNvb3JkICsgY2VpbCh1Q2xhbXBPZmZzZXQgLSB2VGV4dHVyZUNvb3JkKTtcbiAgICBjb29yZCA9ICh1TWFwQ29vcmQgKiB2ZWMzKGNvb3JkLCAxLjApKS54eTtcbiAgICB2ZWMyIHVuY2xhbXBlZCA9IGNvb3JkO1xuICAgIGNvb3JkID0gY2xhbXAoY29vcmQsIHVDbGFtcEZyYW1lLnh5LCB1Q2xhbXBGcmFtZS56dyk7XG5cbiAgICB2ZWM0IHRleFNhbXBsZSA9IHRleHR1cmUodVNhbXBsZXIsIGNvb3JkLCB1bmNsYW1wZWQgPT0gY29vcmQgPyAwLjBmIDogLTMyLjBmKTsvLyBsb2QtYmlhcyB2ZXJ5IG5lZ2F0aXZlIHRvIGZvcmNlIGxvZCAwXG5cbiAgICBmcmFnbWVudENvbG9yID0gdGV4U2FtcGxlICogdUNvbG9yO1xufVxuYDtcbmV4cG9ydHMuZGVmYXVsdCA9IGdsMkZyYWdtZW50U3JjO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ByaXRlLXRpbGluZy5mcmFnLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIGdsMlZlcnRleFNyYyA9IGAjdmVyc2lvbiAzMDAgZXNcbiNkZWZpbmUgU0hBREVSX05BTUUgVGlsaW5nLVNwcml0ZS0zMDBcblxucHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG5cbmluIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuaW4gdmVjMiBhVGV4dHVyZUNvb3JkO1xuXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcbnVuaWZvcm0gbWF0MyB1VHJhbnNmb3JtO1xuXG5vdXQgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXG52b2lkIG1haW4odm9pZClcbntcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xuXG4gICAgdlRleHR1cmVDb29yZCA9ICh1VHJhbnNmb3JtICogdmVjMyhhVGV4dHVyZUNvb3JkLCAxLjApKS54eTtcbn1cbmA7XG5leHBvcnRzLmRlZmF1bHQgPSBnbDJWZXJ0ZXhTcmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcHJpdGUtdGlsaW5nLnZlcnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIGRpc3BsYXkgPSByZXF1aXJlKFwiQHBpeGkvZGlzcGxheVwiKTtcbmNvbnN0IHRlbXBQb2ludCA9IG5ldyBjb3JlLlBvaW50KCksIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDAsIDIsIDNdKTtcbmNsYXNzIFNwcml0ZSBleHRlbmRzIGRpc3BsYXkuQ29udGFpbmVyIHtcbiAgLyoqIEBwYXJhbSB0ZXh0dXJlIC0gVGhlIHRleHR1cmUgZm9yIHRoaXMgc3ByaXRlLiAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5fYW5jaG9yID0gbmV3IGNvcmUuT2JzZXJ2YWJsZVBvaW50KFxuICAgICAgdGhpcy5fb25BbmNob3JVcGRhdGUsXG4gICAgICB0aGlzLFxuICAgICAgdGV4dHVyZSA/IHRleHR1cmUuZGVmYXVsdEFuY2hvci54IDogMCxcbiAgICAgIHRleHR1cmUgPyB0ZXh0dXJlLmRlZmF1bHRBbmNob3IueSA6IDBcbiAgICApLCB0aGlzLl90ZXh0dXJlID0gbnVsbCwgdGhpcy5fd2lkdGggPSAwLCB0aGlzLl9oZWlnaHQgPSAwLCB0aGlzLl90aW50Q29sb3IgPSBuZXcgY29yZS5Db2xvcigxNjc3NzIxNSksIHRoaXMuX3RpbnRSR0IgPSBudWxsLCB0aGlzLnRpbnQgPSAxNjc3NzIxNSwgdGhpcy5ibGVuZE1vZGUgPSBjb3JlLkJMRU5EX01PREVTLk5PUk1BTCwgdGhpcy5fY2FjaGVkVGludCA9IDE2Nzc3MjE1LCB0aGlzLnV2cyA9IG51bGwsIHRoaXMudGV4dHVyZSA9IHRleHR1cmUgfHwgY29yZS5UZXh0dXJlLkVNUFRZLCB0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDgpLCB0aGlzLnZlcnRleFRyaW1tZWREYXRhID0gbnVsbCwgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMSwgdGhpcy5fdGV4dHVyZUlEID0gLTEsIHRoaXMuX3RyYW5zZm9ybVRyaW1tZWRJRCA9IC0xLCB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID0gLTEsIHRoaXMuaW5kaWNlcyA9IGluZGljZXMsIHRoaXMucGx1Z2luTmFtZSA9IFwiYmF0Y2hcIiwgdGhpcy5pc1Nwcml0ZSA9ICEwLCB0aGlzLl9yb3VuZFBpeGVscyA9IGNvcmUuc2V0dGluZ3MuUk9VTkRfUElYRUxTO1xuICB9XG4gIC8qKiBXaGVuIHRoZSB0ZXh0dXJlIGlzIHVwZGF0ZWQsIHRoaXMgZXZlbnQgd2lsbCBmaXJlIHRvIHVwZGF0ZSB0aGUgc2NhbGUgYW5kIGZyYW1lLiAqL1xuICBfb25UZXh0dXJlVXBkYXRlKCkge1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xLCB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID0gLTEsIHRoaXMuX2NhY2hlZFRpbnQgPSAxNjc3NzIxNSwgdGhpcy5fd2lkdGggJiYgKHRoaXMuc2NhbGUueCA9IGNvcmUudXRpbHMuc2lnbih0aGlzLnNjYWxlLngpICogdGhpcy5fd2lkdGggLyB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGgpLCB0aGlzLl9oZWlnaHQgJiYgKHRoaXMuc2NhbGUueSA9IGNvcmUudXRpbHMuc2lnbih0aGlzLnNjYWxlLnkpICogdGhpcy5faGVpZ2h0IC8gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodCk7XG4gIH1cbiAgLyoqIENhbGxlZCB3aGVuIHRoZSBhbmNob3IgcG9zaXRpb24gdXBkYXRlcy4gKi9cbiAgX29uQW5jaG9yVXBkYXRlKCkge1xuICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTEsIHRoaXMuX3RyYW5zZm9ybVRyaW1tZWRJRCA9IC0xO1xuICB9XG4gIC8qKiBDYWxjdWxhdGVzIHdvcmxkVHJhbnNmb3JtICogdmVydGljZXMsIHN0b3JlIGl0IGluIHZlcnRleERhdGEuICovXG4gIGNhbGN1bGF0ZVZlcnRpY2VzKCkge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuICAgIGlmICh0aGlzLl90cmFuc2Zvcm1JRCA9PT0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQgJiYgdGhpcy5fdGV4dHVyZUlEID09PSB0ZXh0dXJlLl91cGRhdGVJRClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl90ZXh0dXJlSUQgIT09IHRleHR1cmUuX3VwZGF0ZUlEICYmICh0aGlzLnV2cyA9IHRoaXMuX3RleHR1cmUuX3V2cy51dnNGbG9hdDMyKSwgdGhpcy5fdHJhbnNmb3JtSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCwgdGhpcy5fdGV4dHVyZUlEID0gdGV4dHVyZS5fdXBkYXRlSUQ7XG4gICAgY29uc3Qgd3QgPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSwgYSA9IHd0LmEsIGIgPSB3dC5iLCBjID0gd3QuYywgZCA9IHd0LmQsIHR4ID0gd3QudHgsIHR5ID0gd3QudHksIHZlcnRleERhdGEgPSB0aGlzLnZlcnRleERhdGEsIHRyaW0gPSB0ZXh0dXJlLnRyaW0sIG9yaWcgPSB0ZXh0dXJlLm9yaWcsIGFuY2hvciA9IHRoaXMuX2FuY2hvcjtcbiAgICBsZXQgdzAgPSAwLCB3MSA9IDAsIGgwID0gMCwgaDEgPSAwO1xuICAgIGlmICh0cmltID8gKHcxID0gdHJpbS54IC0gYW5jaG9yLl94ICogb3JpZy53aWR0aCwgdzAgPSB3MSArIHRyaW0ud2lkdGgsIGgxID0gdHJpbS55IC0gYW5jaG9yLl95ICogb3JpZy5oZWlnaHQsIGgwID0gaDEgKyB0cmltLmhlaWdodCkgOiAodzEgPSAtYW5jaG9yLl94ICogb3JpZy53aWR0aCwgdzAgPSB3MSArIG9yaWcud2lkdGgsIGgxID0gLWFuY2hvci5feSAqIG9yaWcuaGVpZ2h0LCBoMCA9IGgxICsgb3JpZy5oZWlnaHQpLCB2ZXJ0ZXhEYXRhWzBdID0gYSAqIHcxICsgYyAqIGgxICsgdHgsIHZlcnRleERhdGFbMV0gPSBkICogaDEgKyBiICogdzEgKyB0eSwgdmVydGV4RGF0YVsyXSA9IGEgKiB3MCArIGMgKiBoMSArIHR4LCB2ZXJ0ZXhEYXRhWzNdID0gZCAqIGgxICsgYiAqIHcwICsgdHksIHZlcnRleERhdGFbNF0gPSBhICogdzAgKyBjICogaDAgKyB0eCwgdmVydGV4RGF0YVs1XSA9IGQgKiBoMCArIGIgKiB3MCArIHR5LCB2ZXJ0ZXhEYXRhWzZdID0gYSAqIHcxICsgYyAqIGgwICsgdHgsIHZlcnRleERhdGFbN10gPSBkICogaDAgKyBiICogdzEgKyB0eSwgdGhpcy5fcm91bmRQaXhlbHMpIHtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBjb3JlLnNldHRpbmdzLlJFU09MVVRJT047XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgIHZlcnRleERhdGFbaV0gPSBNYXRoLnJvdW5kKHZlcnRleERhdGFbaV0gKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHdvcmxkVHJhbnNmb3JtICogdmVydGljZXMgZm9yIGEgbm9uIHRleHR1cmUgd2l0aCBhIHRyaW0uIHN0b3JlIGl0IGluIHZlcnRleFRyaW1tZWREYXRhLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIHRydWUgd2lkdGggYW5kIGhlaWdodCBvZiBhIHRyaW1tZWQgdGV4dHVyZSBpcyByZXNwZWN0ZWQuXG4gICAqL1xuICBjYWxjdWxhdGVUcmltbWVkVmVydGljZXMoKSB7XG4gICAgaWYgKCF0aGlzLnZlcnRleFRyaW1tZWREYXRhKVxuICAgICAgdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gICAgZWxzZSBpZiAodGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID09PSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCAmJiB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID09PSB0aGlzLl90ZXh0dXJlLl91cGRhdGVJRClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCwgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IHRoaXMuX3RleHR1cmUuX3VwZGF0ZUlEO1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlLCB2ZXJ0ZXhEYXRhID0gdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSwgb3JpZyA9IHRleHR1cmUub3JpZywgYW5jaG9yID0gdGhpcy5fYW5jaG9yLCB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLCBhID0gd3QuYSwgYiA9IHd0LmIsIGMgPSB3dC5jLCBkID0gd3QuZCwgdHggPSB3dC50eCwgdHkgPSB3dC50eSwgdzEgPSAtYW5jaG9yLl94ICogb3JpZy53aWR0aCwgdzAgPSB3MSArIG9yaWcud2lkdGgsIGgxID0gLWFuY2hvci5feSAqIG9yaWcuaGVpZ2h0LCBoMCA9IGgxICsgb3JpZy5oZWlnaHQ7XG4gICAgaWYgKHZlcnRleERhdGFbMF0gPSBhICogdzEgKyBjICogaDEgKyB0eCwgdmVydGV4RGF0YVsxXSA9IGQgKiBoMSArIGIgKiB3MSArIHR5LCB2ZXJ0ZXhEYXRhWzJdID0gYSAqIHcwICsgYyAqIGgxICsgdHgsIHZlcnRleERhdGFbM10gPSBkICogaDEgKyBiICogdzAgKyB0eSwgdmVydGV4RGF0YVs0XSA9IGEgKiB3MCArIGMgKiBoMCArIHR4LCB2ZXJ0ZXhEYXRhWzVdID0gZCAqIGgwICsgYiAqIHcwICsgdHksIHZlcnRleERhdGFbNl0gPSBhICogdzEgKyBjICogaDAgKyB0eCwgdmVydGV4RGF0YVs3XSA9IGQgKiBoMCArIGIgKiB3MSArIHR5LCB0aGlzLl9yb3VuZFBpeGVscykge1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IGNvcmUuc2V0dGluZ3MuUkVTT0xVVElPTjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4RGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgdmVydGV4RGF0YVtpXSA9IE1hdGgucm91bmQodmVydGV4RGF0YVtpXSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHdlYmdsIHJlbmRlcmVyIHRvIHVzZS5cbiAgICovXG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCksIHJlbmRlcmVyLmJhdGNoLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXSksIHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXS5yZW5kZXIodGhpcyk7XG4gIH1cbiAgLyoqIFVwZGF0ZXMgdGhlIGJvdW5kcyBvZiB0aGUgc3ByaXRlLiAqL1xuICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgIGNvbnN0IHRyaW0gPSB0aGlzLl90ZXh0dXJlLnRyaW0sIG9yaWcgPSB0aGlzLl90ZXh0dXJlLm9yaWc7XG4gICAgIXRyaW0gfHwgdHJpbS53aWR0aCA9PT0gb3JpZy53aWR0aCAmJiB0cmltLmhlaWdodCA9PT0gb3JpZy5oZWlnaHQgPyAodGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpLCB0aGlzLl9ib3VuZHMuYWRkUXVhZCh0aGlzLnZlcnRleERhdGEpKSA6ICh0aGlzLmNhbGN1bGF0ZVRyaW1tZWRWZXJ0aWNlcygpLCB0aGlzLl9ib3VuZHMuYWRkUXVhZCh0aGlzLnZlcnRleFRyaW1tZWREYXRhKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgc3ByaXRlIG9iamVjdC5cbiAgICogQHBhcmFtIHJlY3QgLSBPcHRpb25hbCBvdXRwdXQgcmVjdGFuZ2xlLlxuICAgKiBAcmV0dXJucyBUaGUgYm91bmRzLlxuICAgKi9cbiAgZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCA/ICh0aGlzLl9sb2NhbEJvdW5kcyB8fCAodGhpcy5fbG9jYWxCb3VuZHMgPSBuZXcgZGlzcGxheS5Cb3VuZHMoKSksIHRoaXMuX2xvY2FsQm91bmRzLm1pblggPSB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGggKiAtdGhpcy5fYW5jaG9yLl94LCB0aGlzLl9sb2NhbEJvdW5kcy5taW5ZID0gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodCAqIC10aGlzLl9hbmNob3IuX3ksIHRoaXMuX2xvY2FsQm91bmRzLm1heFggPSB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGggKiAoMSAtIHRoaXMuX2FuY2hvci5feCksIHRoaXMuX2xvY2FsQm91bmRzLm1heFkgPSB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0ICogKDEgLSB0aGlzLl9hbmNob3IuX3kpLCByZWN0IHx8ICh0aGlzLl9sb2NhbEJvdW5kc1JlY3QgfHwgKHRoaXMuX2xvY2FsQm91bmRzUmVjdCA9IG5ldyBjb3JlLlJlY3RhbmdsZSgpKSwgcmVjdCA9IHRoaXMuX2xvY2FsQm91bmRzUmVjdCksIHRoaXMuX2xvY2FsQm91bmRzLmdldFJlY3RhbmdsZShyZWN0KSkgOiBzdXBlci5nZXRMb2NhbEJvdW5kcy5jYWxsKHRoaXMsIHJlY3QpO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGluc2lkZSB0aGlzIHNwcml0ZVxuICAgKiBAcGFyYW0gcG9pbnQgLSB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSB0ZXN0XG4gICAqL1xuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9pbnQsIHRlbXBQb2ludCk7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGgsIGhlaWdodCA9IHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQsIHgxID0gLXdpZHRoICogdGhpcy5hbmNob3IueDtcbiAgICBsZXQgeTEgPSAwO1xuICAgIHJldHVybiB0ZW1wUG9pbnQueCA+PSB4MSAmJiB0ZW1wUG9pbnQueCA8IHgxICsgd2lkdGggJiYgKHkxID0gLWhlaWdodCAqIHRoaXMuYW5jaG9yLnksIHRlbXBQb2ludC55ID49IHkxICYmIHRlbXBQb2ludC55IDwgeTEgKyBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIHNwcml0ZSBhbmQgb3B0aW9uYWxseSBpdHMgdGV4dHVyZSBhbmQgY2hpbGRyZW4uXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xuICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAqIEBwYXJhbSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgKiAgICAgIG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxuICAgKiBAcGFyYW0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgY3VycmVudCB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgKiBAcGFyYW0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIGlmIChzdXBlci5kZXN0cm95KG9wdGlvbnMpLCB0aGlzLl90ZXh0dXJlLm9mZihcInVwZGF0ZVwiLCB0aGlzLl9vblRleHR1cmVVcGRhdGUsIHRoaXMpLCB0aGlzLl9hbmNob3IgPSBudWxsLCB0eXBlb2Ygb3B0aW9ucyA9PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiBvcHRpb25zPy50ZXh0dXJlKSB7XG4gICAgICBjb25zdCBkZXN0cm95QmFzZVRleHR1cmUgPSB0eXBlb2Ygb3B0aW9ucyA9PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiBvcHRpb25zPy5iYXNlVGV4dHVyZTtcbiAgICAgIHRoaXMuX3RleHR1cmUuZGVzdHJveSghIWRlc3Ryb3lCYXNlVGV4dHVyZSk7XG4gICAgfVxuICAgIHRoaXMuX3RleHR1cmUgPSBudWxsO1xuICB9XG4gIC8vIHNvbWUgaGVscGVyIGZ1bmN0aW9ucy4uXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IHNwcml0ZSBiYXNlZCBvbiB0aGUgc291cmNlIHlvdSBwcm92aWRlLlxuICAgKiBUaGUgc291cmNlIGNhbiBiZSAtIGZyYW1lIGlkLCBpbWFnZSB1cmwsIHZpZGVvIHVybCwgY2FudmFzIGVsZW1lbnQsIHZpZGVvIGVsZW1lbnQsIGJhc2UgdGV4dHVyZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xQSVhJLlRleHR1cmV8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEltYWdlQml0bWFwfFBJWEkuSUNhbnZhc30gc291cmNlXG4gICAqICAgICAtIFNvdXJjZSB0byBjcmVhdGUgdGV4dHVyZSBmcm9tXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIHNwcml0ZVxuICAgKi9cbiAgc3RhdGljIGZyb20oc291cmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHNvdXJjZSBpbnN0YW5jZW9mIGNvcmUuVGV4dHVyZSA/IHNvdXJjZSA6IGNvcmUuVGV4dHVyZS5mcm9tKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gIH1cbiAgLyoqXG4gICAqIElmIHRydWUgUGl4aUpTIHdpbGwgTWF0aC5mbG9vcigpIHgveSB2YWx1ZXMgd2hlbiByZW5kZXJpbmcsIHN0b3BwaW5nIHBpeGVsIGludGVycG9sYXRpb24uXG4gICAqXG4gICAqIEFkdmFudGFnZXMgY2FuIGluY2x1ZGUgc2hhcnBlciBpbWFnZSBxdWFsaXR5IChsaWtlIHRleHQpIGFuZCBmYXN0ZXIgcmVuZGVyaW5nIG9uIGNhbnZhcy5cbiAgICogVGhlIG1haW4gZGlzYWR2YW50YWdlIGlzIG1vdmVtZW50IG9mIG9iamVjdHMgbWF5IGFwcGVhciBsZXNzIHNtb290aC5cbiAgICpcbiAgICogVG8gc2V0IHRoZSBnbG9iYWwgZGVmYXVsdCwgY2hhbmdlIHtAbGluayBQSVhJLnNldHRpbmdzLlJPVU5EX1BJWEVMU30uXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBzZXQgcm91bmRQaXhlbHModmFsdWUpIHtcbiAgICB0aGlzLl9yb3VuZFBpeGVscyAhPT0gdmFsdWUgJiYgKHRoaXMuX3RyYW5zZm9ybUlEID0gLTEsIHRoaXMuX3RyYW5zZm9ybVRyaW1tZWRJRCA9IC0xKSwgdGhpcy5fcm91bmRQaXhlbHMgPSB2YWx1ZTtcbiAgfVxuICBnZXQgcm91bmRQaXhlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdW5kUGl4ZWxzO1xuICB9XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXQuICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS54KSAqIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICBjb25zdCBzID0gY29yZS51dGlscy5zaWduKHRoaXMuc2NhbGUueCkgfHwgMTtcbiAgICB0aGlzLnNjYWxlLnggPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGgsIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gIH1cbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIHNwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXQuICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuc2NhbGUueSkgKiB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICBjb25zdCBzID0gY29yZS51dGlscy5zaWduKHRoaXMuc2NhbGUueSkgfHwgMTtcbiAgICB0aGlzLnNjYWxlLnkgPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0LCB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFuY2hvciBzZXRzIHRoZSBvcmlnaW4gcG9pbnQgb2YgdGhlIHNwcml0ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgdGFrZW4gZnJvbSB0aGUge0BsaW5rIFBJWEkuVGV4dHVyZXxUZXh0dXJlfVxuICAgKiBhbmQgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogVGhlIGRlZmF1bHQgaXMgYCgwLDApYCwgdGhpcyBtZWFucyB0aGUgc3ByaXRlJ3Mgb3JpZ2luIGlzIHRoZSB0b3AgbGVmdC5cbiAgICpcbiAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIGAoMC41LDAuNSlgIG1lYW5zIHRoZSBzcHJpdGUncyBvcmlnaW4gaXMgY2VudGVyZWQuXG4gICAqXG4gICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byBgKDEsMSlgIHdvdWxkIG1lYW4gdGhlIHNwcml0ZSdzIG9yaWdpbiBwb2ludCB3aWxsIGJlIHRoZSBib3R0b20gcmlnaHQgY29ybmVyLlxuICAgKlxuICAgKiBJZiB5b3UgcGFzcyBvbmx5IHNpbmdsZSBwYXJhbWV0ZXIsIGl0IHdpbGwgc2V0IGJvdGggeCBhbmQgeSB0byB0aGUgc2FtZSB2YWx1ZSBhcyBzaG93biBpbiB0aGUgZXhhbXBsZSBiZWxvdy5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgU3ByaXRlIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGUoVGV4dHVyZS5XSElURSk7XG4gICAqIHNwcml0ZS5hbmNob3Iuc2V0KDAuNSk7IC8vIFRoaXMgd2lsbCBzZXQgdGhlIG9yaWdpbiB0byBjZW50ZXIuICgwLjUpIGlzIHNhbWUgYXMgKDAuNSwgMC41KS5cbiAgICovXG4gIGdldCBhbmNob3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FuY2hvcjtcbiAgfVxuICBzZXQgYW5jaG9yKHZhbHVlKSB7XG4gICAgdGhpcy5fYW5jaG9yLmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHRpbnQgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBUaGlzIGlzIGEgaGV4IHZhbHVlLlxuICAgKlxuICAgKiBBIHZhbHVlIG9mIDB4RkZGRkZGIHdpbGwgcmVtb3ZlIGFueSB0aW50IGVmZmVjdC5cbiAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICovXG4gIGdldCB0aW50KCkge1xuICAgIHJldHVybiB0aGlzLl90aW50Q29sb3IudmFsdWU7XG4gIH1cbiAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICB0aGlzLl90aW50Q29sb3Iuc2V0VmFsdWUodmFsdWUpLCB0aGlzLl90aW50UkdCID0gdGhpcy5fdGludENvbG9yLnRvTGl0dGxlRW5kaWFuTnVtYmVyKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdGludCBhcyBhIFJHQiBpbnRlZ2VyLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBnZXQgdGludFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl90aW50Q29sb3IudG9OdW1iZXIoKTtcbiAgfVxuICAvKiogVGhlIHRleHR1cmUgdGhhdCB0aGUgc3ByaXRlIGlzIHVzaW5nLiAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZTtcbiAgfVxuICBzZXQgdGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMuX3RleHR1cmUgIT09IHZhbHVlICYmICh0aGlzLl90ZXh0dXJlICYmIHRoaXMuX3RleHR1cmUub2ZmKFwidXBkYXRlXCIsIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSwgdGhpcyksIHRoaXMuX3RleHR1cmUgPSB2YWx1ZSB8fCBjb3JlLlRleHR1cmUuRU1QVFksIHRoaXMuX2NhY2hlZFRpbnQgPSAxNjc3NzIxNSwgdGhpcy5fdGV4dHVyZUlEID0gLTEsIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMSwgdmFsdWUgJiYgKHZhbHVlLmJhc2VUZXh0dXJlLnZhbGlkID8gdGhpcy5fb25UZXh0dXJlVXBkYXRlKCkgOiB2YWx1ZS5vbmNlKFwidXBkYXRlXCIsIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSwgdGhpcykpKTtcbiAgfVxufVxuZXhwb3J0cy5TcHJpdGUgPSBTcHJpdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TcHJpdGUuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTcHJpdGUgPSByZXF1aXJlKFwiLi9TcHJpdGUuanNcIik7XG5leHBvcnRzLlNwcml0ZSA9IFNwcml0ZS5TcHJpdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKTtcbmNvbnN0IF9TcHJpdGVzaGVldCA9IGNsYXNzIF9TcHJpdGVzaGVldDIge1xuICAvKipcbiAgICogQHBhcmFtIHRleHR1cmUgLSBSZWZlcmVuY2UgdG8gdGhlIHNvdXJjZSBCYXNlVGV4dHVyZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gU3ByaXRlc2hlZXQgaW1hZ2UgZGF0YS5cbiAgICogQHBhcmFtIHJlc29sdXRpb25GaWxlbmFtZSAtIFRoZSBmaWxlbmFtZSB0byBjb25zaWRlciB3aGVuIGRldGVybWluaW5nXG4gICAqICAgICAgICB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgc3ByaXRlc2hlZXQuIElmIG5vdCBwcm92aWRlZCwgdGhlIGltYWdlVXJsIHdpbGxcbiAgICogICAgICAgIGJlIHVzZWQgb24gdGhlIEJhc2VUZXh0dXJlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4dHVyZSwgZGF0YSwgcmVzb2x1dGlvbkZpbGVuYW1lID0gbnVsbCkge1xuICAgIHRoaXMubGlua2VkU2hlZXRzID0gW10sIHRoaXMuX3RleHR1cmUgPSB0ZXh0dXJlIGluc3RhbmNlb2YgY29yZS5UZXh0dXJlID8gdGV4dHVyZSA6IG51bGwsIHRoaXMuYmFzZVRleHR1cmUgPSB0ZXh0dXJlIGluc3RhbmNlb2YgY29yZS5CYXNlVGV4dHVyZSA/IHRleHR1cmUgOiB0aGlzLl90ZXh0dXJlLmJhc2VUZXh0dXJlLCB0aGlzLnRleHR1cmVzID0ge30sIHRoaXMuYW5pbWF0aW9ucyA9IHt9LCB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIGNvbnN0IHJlc291cmNlID0gdGhpcy5iYXNlVGV4dHVyZS5yZXNvdXJjZTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSB0aGlzLl91cGRhdGVSZXNvbHV0aW9uKHJlc29sdXRpb25GaWxlbmFtZSB8fCAocmVzb3VyY2UgPyByZXNvdXJjZS51cmwgOiBudWxsKSksIHRoaXMuX2ZyYW1lcyA9IHRoaXMuZGF0YS5mcmFtZXMsIHRoaXMuX2ZyYW1lS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2ZyYW1lcyksIHRoaXMuX2JhdGNoSW5kZXggPSAwLCB0aGlzLl9jYWxsYmFjayA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHRoZSByZXNvbHV0aW9uIGZyb20gdGhlIGZpbGVuYW1lIG9yIGZhbGxiYWNrXG4gICAqIHRvIHRoZSBtZXRhLnNjYWxlIGZpZWxkIG9mIHRoZSBKU09OIGRhdGEuXG4gICAqIEBwYXJhbSByZXNvbHV0aW9uRmlsZW5hbWUgLSBUaGUgZmlsZW5hbWUgdG8gdXNlIGZvciByZXNvbHZpbmdcbiAgICogICAgICAgIHRoZSBkZWZhdWx0IHJlc29sdXRpb24uXG4gICAqIEByZXR1cm5zIFJlc29sdXRpb24gdG8gdXNlIGZvciBzcHJpdGVzaGVldC5cbiAgICovXG4gIF91cGRhdGVSZXNvbHV0aW9uKHJlc29sdXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICBjb25zdCB7IHNjYWxlIH0gPSB0aGlzLmRhdGEubWV0YTtcbiAgICBsZXQgcmVzb2x1dGlvbiA9IGNvcmUudXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKHJlc29sdXRpb25GaWxlbmFtZSwgbnVsbCk7XG4gICAgcmV0dXJuIHJlc29sdXRpb24gPT09IG51bGwgJiYgKHJlc29sdXRpb24gPSBwYXJzZUZsb2F0KHNjYWxlID8/IFwiMVwiKSksIHJlc29sdXRpb24gIT09IDEgJiYgdGhpcy5iYXNlVGV4dHVyZS5zZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pLCByZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXIgc3ByaXRlc2hlZXQgZnJvbSBsb2FkZWQgZGF0YS4gVGhpcyBpcyBkb25lIGFzeW5jaHJvbm91c2x5XG4gICAqIHRvIHByZXZlbnQgY3JlYXRpbmcgdG9vIG1hbnkgVGV4dHVyZSB3aXRoaW4gYSBzaW5nbGUgcHJvY2Vzcy5cbiAgICogQG1ldGhvZCBQSVhJLlNwcml0ZXNoZWV0I3BhcnNlXG4gICAqL1xuICBwYXJzZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrID0gcmVzb2x2ZSwgdGhpcy5fYmF0Y2hJbmRleCA9IDAsIHRoaXMuX2ZyYW1lS2V5cy5sZW5ndGggPD0gX1Nwcml0ZXNoZWV0Mi5CQVRDSF9TSVpFID8gKHRoaXMuX3Byb2Nlc3NGcmFtZXMoMCksIHRoaXMuX3Byb2Nlc3NBbmltYXRpb25zKCksIHRoaXMuX3BhcnNlQ29tcGxldGUoKSkgOiB0aGlzLl9uZXh0QmF0Y2goKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBhIGJhdGNoIG9mIGZyYW1lc1xuICAgKiBAcGFyYW0gaW5pdGlhbEZyYW1lSW5kZXggLSBUaGUgaW5kZXggb2YgZnJhbWUgdG8gc3RhcnQuXG4gICAqL1xuICBfcHJvY2Vzc0ZyYW1lcyhpbml0aWFsRnJhbWVJbmRleCkge1xuICAgIGxldCBmcmFtZUluZGV4ID0gaW5pdGlhbEZyYW1lSW5kZXg7XG4gICAgY29uc3QgbWF4RnJhbWVzID0gX1Nwcml0ZXNoZWV0Mi5CQVRDSF9TSVpFO1xuICAgIGZvciAoOyBmcmFtZUluZGV4IC0gaW5pdGlhbEZyYW1lSW5kZXggPCBtYXhGcmFtZXMgJiYgZnJhbWVJbmRleCA8IHRoaXMuX2ZyYW1lS2V5cy5sZW5ndGg7ICkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2ZyYW1lS2V5c1tmcmFtZUluZGV4XSwgZGF0YSA9IHRoaXMuX2ZyYW1lc1tpXSwgcmVjdCA9IGRhdGEuZnJhbWU7XG4gICAgICBpZiAocmVjdCkge1xuICAgICAgICBsZXQgZnJhbWUgPSBudWxsLCB0cmltID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc291cmNlU2l6ZSA9IGRhdGEudHJpbW1lZCAhPT0gITEgJiYgZGF0YS5zb3VyY2VTaXplID8gZGF0YS5zb3VyY2VTaXplIDogZGF0YS5mcmFtZSwgb3JpZyA9IG5ldyBjb3JlLlJlY3RhbmdsZShcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgTWF0aC5mbG9vcihzb3VyY2VTaXplLncpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgIE1hdGguZmxvb3Ioc291cmNlU2l6ZS5oKSAvIHRoaXMucmVzb2x1dGlvblxuICAgICAgICApO1xuICAgICAgICBkYXRhLnJvdGF0ZWQgPyBmcmFtZSA9IG5ldyBjb3JlLlJlY3RhbmdsZShcbiAgICAgICAgICBNYXRoLmZsb29yKHJlY3QueCkgLyB0aGlzLnJlc29sdXRpb24sXG4gICAgICAgICAgTWF0aC5mbG9vcihyZWN0LnkpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgIE1hdGguZmxvb3IocmVjdC5oKSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb25cbiAgICAgICAgKSA6IGZyYW1lID0gbmV3IGNvcmUuUmVjdGFuZ2xlKFxuICAgICAgICAgIE1hdGguZmxvb3IocmVjdC54KSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICBNYXRoLmZsb29yKHJlY3QueSkgLyB0aGlzLnJlc29sdXRpb24sXG4gICAgICAgICAgTWF0aC5mbG9vcihyZWN0LncpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgIE1hdGguZmxvb3IocmVjdC5oKSAvIHRoaXMucmVzb2x1dGlvblxuICAgICAgICApLCBkYXRhLnRyaW1tZWQgIT09ICExICYmIGRhdGEuc3ByaXRlU291cmNlU2l6ZSAmJiAodHJpbSA9IG5ldyBjb3JlLlJlY3RhbmdsZShcbiAgICAgICAgICBNYXRoLmZsb29yKGRhdGEuc3ByaXRlU291cmNlU2l6ZS54KSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICBNYXRoLmZsb29yKGRhdGEuc3ByaXRlU291cmNlU2l6ZS55KSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24sXG4gICAgICAgICAgTWF0aC5mbG9vcihyZWN0LmgpIC8gdGhpcy5yZXNvbHV0aW9uXG4gICAgICAgICkpLCB0aGlzLnRleHR1cmVzW2ldID0gbmV3IGNvcmUuVGV4dHVyZShcbiAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLFxuICAgICAgICAgIGZyYW1lLFxuICAgICAgICAgIG9yaWcsXG4gICAgICAgICAgdHJpbSxcbiAgICAgICAgICBkYXRhLnJvdGF0ZWQgPyAyIDogMCxcbiAgICAgICAgICBkYXRhLmFuY2hvcixcbiAgICAgICAgICBkYXRhLmJvcmRlcnNcbiAgICAgICAgKSwgY29yZS5UZXh0dXJlLmFkZFRvQ2FjaGUodGhpcy50ZXh0dXJlc1tpXSwgaS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIGZyYW1lSW5kZXgrKztcbiAgICB9XG4gIH1cbiAgLyoqIFBhcnNlIGFuaW1hdGlvbnMgY29uZmlnLiAqL1xuICBfcHJvY2Vzc0FuaW1hdGlvbnMoKSB7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuZGF0YS5hbmltYXRpb25zIHx8IHt9O1xuICAgIGZvciAoY29uc3QgYW5pbU5hbWUgaW4gYW5pbWF0aW9ucykge1xuICAgICAgdGhpcy5hbmltYXRpb25zW2FuaW1OYW1lXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmltYXRpb25zW2FuaW1OYW1lXS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmcmFtZU5hbWUgPSBhbmltYXRpb25zW2FuaW1OYW1lXVtpXTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zW2FuaW1OYW1lXS5wdXNoKHRoaXMudGV4dHVyZXNbZnJhbWVOYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBUaGUgcGFyc2UgaGFzIGNvbXBsZXRlZC4gKi9cbiAgX3BhcnNlQ29tcGxldGUoKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjaztcbiAgICB0aGlzLl9jYWxsYmFjayA9IG51bGwsIHRoaXMuX2JhdGNoSW5kZXggPSAwLCBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMudGV4dHVyZXMpO1xuICB9XG4gIC8qKiBCZWdpbiB0aGUgbmV4dCBiYXRjaCBvZiB0ZXh0dXJlcy4gKi9cbiAgX25leHRCYXRjaCgpIHtcbiAgICB0aGlzLl9wcm9jZXNzRnJhbWVzKHRoaXMuX2JhdGNoSW5kZXggKiBfU3ByaXRlc2hlZXQyLkJBVENIX1NJWkUpLCB0aGlzLl9iYXRjaEluZGV4KyssIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fYmF0Y2hJbmRleCAqIF9TcHJpdGVzaGVldDIuQkFUQ0hfU0laRSA8IHRoaXMuX2ZyYW1lS2V5cy5sZW5ndGggPyB0aGlzLl9uZXh0QmF0Y2goKSA6ICh0aGlzLl9wcm9jZXNzQW5pbWF0aW9ucygpLCB0aGlzLl9wYXJzZUNvbXBsZXRlKCkpO1xuICAgIH0sIDApO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95IFNwcml0ZXNoZWV0IGFuZCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZGVzdHJveUJhc2U9ZmFsc2VdIC0gV2hldGhlciB0byBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgYXMgd2VsbFxuICAgKi9cbiAgZGVzdHJveShkZXN0cm95QmFzZSA9ICExKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMudGV4dHVyZXMpXG4gICAgICB0aGlzLnRleHR1cmVzW2ldLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9mcmFtZXMgPSBudWxsLCB0aGlzLl9mcmFtZUtleXMgPSBudWxsLCB0aGlzLmRhdGEgPSBudWxsLCB0aGlzLnRleHR1cmVzID0gbnVsbCwgZGVzdHJveUJhc2UgJiYgKHRoaXMuX3RleHR1cmU/LmRlc3Ryb3koKSwgdGhpcy5iYXNlVGV4dHVyZS5kZXN0cm95KCkpLCB0aGlzLl90ZXh0dXJlID0gbnVsbCwgdGhpcy5iYXNlVGV4dHVyZSA9IG51bGwsIHRoaXMubGlua2VkU2hlZXRzID0gW107XG4gIH1cbn07XG5fU3ByaXRlc2hlZXQuQkFUQ0hfU0laRSA9IDFlMztcbmxldCBTcHJpdGVzaGVldCA9IF9TcHJpdGVzaGVldDtcbmV4cG9ydHMuU3ByaXRlc2hlZXQgPSBTcHJpdGVzaGVldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNwcml0ZXNoZWV0LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgU3ByaXRlc2hlZXQgPSByZXF1aXJlKFwiLi9TcHJpdGVzaGVldC5qc1wiKSwgc3ByaXRlc2hlZXRBc3NldCA9IHJlcXVpcmUoXCIuL3Nwcml0ZXNoZWV0QXNzZXQuanNcIik7XG5leHBvcnRzLlNwcml0ZXNoZWV0ID0gU3ByaXRlc2hlZXQuU3ByaXRlc2hlZXQ7XG5leHBvcnRzLnNwcml0ZXNoZWV0QXNzZXQgPSBzcHJpdGVzaGVldEFzc2V0LnNwcml0ZXNoZWV0QXNzZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGFzc2V0cyA9IHJlcXVpcmUoXCJAcGl4aS9hc3NldHNcIiksIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgU3ByaXRlc2hlZXQgPSByZXF1aXJlKFwiLi9TcHJpdGVzaGVldC5qc1wiKTtcbmNvbnN0IHZhbGlkSW1hZ2VzID0gW1wianBnXCIsIFwicG5nXCIsIFwianBlZ1wiLCBcImF2aWZcIiwgXCJ3ZWJwXCJdO1xuZnVuY3Rpb24gZ2V0Q2FjaGVhYmxlQXNzZXRzKGtleXMsIGFzc2V0LCBpZ25vcmVNdWx0aVBhY2spIHtcbiAgY29uc3Qgb3V0ID0ge307XG4gIGlmIChrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIG91dFtrZXldID0gYXNzZXQ7XG4gIH0pLCBPYmplY3Qua2V5cyhhc3NldC50ZXh0dXJlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgb3V0W2tleV0gPSBhc3NldC50ZXh0dXJlc1trZXldO1xuICB9KSwgIWlnbm9yZU11bHRpUGFjaykge1xuICAgIGNvbnN0IGJhc2VQYXRoID0gY29yZS51dGlscy5wYXRoLmRpcm5hbWUoa2V5c1swXSk7XG4gICAgYXNzZXQubGlua2VkU2hlZXRzLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IG91dDIgPSBnZXRDYWNoZWFibGVBc3NldHMoW2Ake2Jhc2VQYXRofS8ke2Fzc2V0LmRhdGEubWV0YS5yZWxhdGVkX211bHRpX3BhY2tzW2ldfWBdLCBpdGVtLCAhMCk7XG4gICAgICBPYmplY3QuYXNzaWduKG91dCwgb3V0Mik7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmNvbnN0IHNwcml0ZXNoZWV0QXNzZXQgPSB7XG4gIGV4dGVuc2lvbjogY29yZS5FeHRlbnNpb25UeXBlLkFzc2V0LFxuICAvKiogSGFuZGxlIHRoZSBjYWNoaW5nIG9mIHRoZSByZWxhdGVkIFNwcml0ZXNoZWV0IFRleHR1cmVzICovXG4gIGNhY2hlOiB7XG4gICAgdGVzdDogKGFzc2V0KSA9PiBhc3NldCBpbnN0YW5jZW9mIFNwcml0ZXNoZWV0LlNwcml0ZXNoZWV0LFxuICAgIGdldENhY2hlYWJsZUFzc2V0czogKGtleXMsIGFzc2V0KSA9PiBnZXRDYWNoZWFibGVBc3NldHMoa2V5cywgYXNzZXQsICExKVxuICB9LFxuICAvKiogUmVzb2x2ZSB0aGUgdGhlIHJlc29sdXRpb24gb2YgdGhlIGFzc2V0LiAqL1xuICByZXNvbHZlcjoge1xuICAgIHRlc3Q6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3Qgc3BsaXQgPSB2YWx1ZS5zcGxpdChcIj9cIilbMF0uc3BsaXQoXCIuXCIpLCBleHRlbnNpb24gPSBzcGxpdC5wb3AoKSwgZm9ybWF0ID0gc3BsaXQucG9wKCk7XG4gICAgICByZXR1cm4gZXh0ZW5zaW9uID09PSBcImpzb25cIiAmJiB2YWxpZEltYWdlcy5pbmNsdWRlcyhmb3JtYXQpO1xuICAgIH0sXG4gICAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3Qgc3BsaXQgPSB2YWx1ZS5zcGxpdChcIi5cIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXNvbHV0aW9uOiBwYXJzZUZsb2F0KGNvcmUuc2V0dGluZ3MuUkVUSU5BX1BSRUZJWC5leGVjKHZhbHVlKT8uWzFdID8/IFwiMVwiKSxcbiAgICAgICAgZm9ybWF0OiBzcGxpdFtzcGxpdC5sZW5ndGggLSAyXSxcbiAgICAgICAgc3JjOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBMb2FkZXIgcGx1Z2luIHRoYXQgcGFyc2VzIHNwcml0ZSBzaGVldHMhXG4gICAqIG9uY2UgdGhlIEpTT04gaGFzIGJlZW4gbG9hZGVkIHRoaXMgY2hlY2tzIHRvIHNlZSBpZiB0aGUgSlNPTiBpcyBzcHJpdGVzaGVldCBkYXRhLlxuICAgKiBJZiBpdCBpcywgd2UgbG9hZCB0aGUgc3ByaXRlc2hlZXRzIGltYWdlIGFuZCBwYXJzZSB0aGUgZGF0YSBpbnRvIFBJWEkuU3ByaXRlc2hlZXRcbiAgICogQWxsIHRleHR1cmVzIGluIHRoZSBzcHJpdGUgc2hlZXQgYXJlIHRoZW4gYWRkZWQgdG8gdGhlIGNhY2hlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGxvYWRlcjoge1xuICAgIG5hbWU6IFwic3ByaXRlc2hlZXRMb2FkZXJcIixcbiAgICBleHRlbnNpb246IHtcbiAgICAgIHR5cGU6IGNvcmUuRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgICAgcHJpb3JpdHk6IGFzc2V0cy5Mb2FkZXJQYXJzZXJQcmlvcml0eS5Ob3JtYWxcbiAgICB9LFxuICAgIGFzeW5jIHRlc3RQYXJzZShhc3NldCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGNvcmUudXRpbHMucGF0aC5leHRuYW1lKG9wdGlvbnMuc3JjKS50b0xvd2VyQ2FzZSgpID09PSBcIi5qc29uXCIgJiYgISFhc3NldC5mcmFtZXM7XG4gICAgfSxcbiAgICBhc3luYyBwYXJzZShhc3NldCwgb3B0aW9ucywgbG9hZGVyKSB7XG4gICAgICBsZXQgYmFzZVBhdGggPSBjb3JlLnV0aWxzLnBhdGguZGlybmFtZShvcHRpb25zLnNyYyk7XG4gICAgICBiYXNlUGF0aCAmJiBiYXNlUGF0aC5sYXN0SW5kZXhPZihcIi9cIikgIT09IGJhc2VQYXRoLmxlbmd0aCAtIDEgJiYgKGJhc2VQYXRoICs9IFwiL1wiKTtcbiAgICAgIGxldCBpbWFnZVBhdGggPSBiYXNlUGF0aCArIGFzc2V0Lm1ldGEuaW1hZ2U7XG4gICAgICBpbWFnZVBhdGggPSBhc3NldHMuY29weVNlYXJjaFBhcmFtcyhpbWFnZVBhdGgsIG9wdGlvbnMuc3JjKTtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSAoYXdhaXQgbG9hZGVyLmxvYWQoW2ltYWdlUGF0aF0pKVtpbWFnZVBhdGhdLCBzcHJpdGVzaGVldCA9IG5ldyBTcHJpdGVzaGVldC5TcHJpdGVzaGVldChcbiAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZSxcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIG9wdGlvbnMuc3JjXG4gICAgICApO1xuICAgICAgYXdhaXQgc3ByaXRlc2hlZXQucGFyc2UoKTtcbiAgICAgIGNvbnN0IG11bHRpUGFja3MgPSBhc3NldD8ubWV0YT8ucmVsYXRlZF9tdWx0aV9wYWNrcztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG11bHRpUGFja3MpKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBtdWx0aVBhY2tzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBsZXQgaXRlbVVybCA9IGJhc2VQYXRoICsgaXRlbTtcbiAgICAgICAgICBvcHRpb25zLmRhdGE/Lmlnbm9yZU11bHRpUGFjayB8fCAoaXRlbVVybCA9IGFzc2V0cy5jb3B5U2VhcmNoUGFyYW1zKGl0ZW1VcmwsIG9wdGlvbnMuc3JjKSwgcHJvbWlzZXMucHVzaChsb2FkZXIubG9hZCh7XG4gICAgICAgICAgICBzcmM6IGl0ZW1VcmwsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGlnbm9yZU11bHRpUGFjazogITBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgc3ByaXRlc2hlZXQubGlua2VkU2hlZXRzID0gcmVzLCByZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgIGl0ZW0ubGlua2VkU2hlZXRzID0gW3Nwcml0ZXNoZWV0XS5jb25jYXQoc3ByaXRlc2hlZXQubGlua2VkU2hlZXRzLmZpbHRlcigoc3ApID0+IHNwICE9PSBpdGVtKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNwcml0ZXNoZWV0O1xuICAgIH0sXG4gICAgdW5sb2FkKHNwcml0ZXNoZWV0KSB7XG4gICAgICBzcHJpdGVzaGVldC5kZXN0cm95KCEwKTtcbiAgICB9XG4gIH1cbn07XG5jb3JlLmV4dGVuc2lvbnMuYWRkKHNwcml0ZXNoZWV0QXNzZXQpO1xuZXhwb3J0cy5zcHJpdGVzaGVldEFzc2V0ID0gc3ByaXRlc2hlZXRBc3NldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZXNoZWV0QXNzZXQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIHRleHQgPSByZXF1aXJlKFwiQHBpeGkvdGV4dFwiKSwgQml0bWFwRm9udERhdGEgPSByZXF1aXJlKFwiLi9CaXRtYXBGb250RGF0YS5qc1wiKSwgaW5kZXggPSByZXF1aXJlKFwiLi9mb3JtYXRzL2luZGV4LmpzXCIpO1xucmVxdWlyZShcIi4vdXRpbHMvaW5kZXguanNcIik7XG52YXIgcmVzb2x2ZUNoYXJhY3RlcnMgPSByZXF1aXJlKFwiLi91dGlscy9yZXNvbHZlQ2hhcmFjdGVycy5qc1wiKSwgZHJhd0dseXBoID0gcmVxdWlyZShcIi4vdXRpbHMvZHJhd0dseXBoLmpzXCIpLCBleHRyYWN0Q2hhckNvZGUgPSByZXF1aXJlKFwiLi91dGlscy9leHRyYWN0Q2hhckNvZGUuanNcIik7XG5jb25zdCBfQml0bWFwRm9udCA9IGNsYXNzIF9CaXRtYXBGb250MiB7XG4gIC8qKlxuICAgKiBAcGFyYW0gZGF0YVxuICAgKiBAcGFyYW0gdGV4dHVyZXNcbiAgICogQHBhcmFtIG93bnNUZXh0dXJlcyAtIFNldHRpbmcgdG8gYHRydWVgIHdpbGwgZGVzdHJveSBwYWdlIHRleHR1cmVzXG4gICAqICAgICAgICB3aGVuIHRoZSBmb250IGlzIHVuaW5zdGFsbGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSwgdGV4dHVyZXMsIG93bnNUZXh0dXJlcykge1xuICAgIGNvbnN0IFtpbmZvXSA9IGRhdGEuaW5mbywgW2NvbW1vbl0gPSBkYXRhLmNvbW1vbiwgW3BhZ2VdID0gZGF0YS5wYWdlLCBbZGlzdGFuY2VGaWVsZF0gPSBkYXRhLmRpc3RhbmNlRmllbGQsIHJlcyA9IGNvcmUudXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKHBhZ2UuZmlsZSksIHBhZ2VUZXh0dXJlcyA9IHt9O1xuICAgIHRoaXMuX293bnNUZXh0dXJlcyA9IG93bnNUZXh0dXJlcywgdGhpcy5mb250ID0gaW5mby5mYWNlLCB0aGlzLnNpemUgPSBpbmZvLnNpemUsIHRoaXMubGluZUhlaWdodCA9IGNvbW1vbi5saW5lSGVpZ2h0IC8gcmVzLCB0aGlzLmNoYXJzID0ge30sIHRoaXMucGFnZVRleHR1cmVzID0gcGFnZVRleHR1cmVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5wYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7IGlkLCBmaWxlIH0gPSBkYXRhLnBhZ2VbaV07XG4gICAgICBwYWdlVGV4dHVyZXNbaWRdID0gdGV4dHVyZXMgaW5zdGFuY2VvZiBBcnJheSA/IHRleHR1cmVzW2ldIDogdGV4dHVyZXNbZmlsZV0sIGRpc3RhbmNlRmllbGQ/LmZpZWxkVHlwZSAmJiBkaXN0YW5jZUZpZWxkLmZpZWxkVHlwZSAhPT0gXCJub25lXCIgJiYgKHBhZ2VUZXh0dXJlc1tpZF0uYmFzZVRleHR1cmUuYWxwaGFNb2RlID0gY29yZS5BTFBIQV9NT0RFUy5OT19QUkVNVUxUSVBMSUVEX0FMUEhBLCBwYWdlVGV4dHVyZXNbaWRdLmJhc2VUZXh0dXJlLm1pcG1hcCA9IGNvcmUuTUlQTUFQX01PREVTLk9GRik7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5jaGFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7IGlkLCBwYWdlOiBwYWdlMiB9ID0gZGF0YS5jaGFyW2ldO1xuICAgICAgbGV0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgeG9mZnNldCwgeW9mZnNldCwgeGFkdmFuY2UgfSA9IGRhdGEuY2hhcltpXTtcbiAgICAgIHggLz0gcmVzLCB5IC89IHJlcywgd2lkdGggLz0gcmVzLCBoZWlnaHQgLz0gcmVzLCB4b2Zmc2V0IC89IHJlcywgeW9mZnNldCAvPSByZXMsIHhhZHZhbmNlIC89IHJlcztcbiAgICAgIGNvbnN0IHJlY3QgPSBuZXcgY29yZS5SZWN0YW5nbGUoXG4gICAgICAgIHggKyBwYWdlVGV4dHVyZXNbcGFnZTJdLmZyYW1lLnggLyByZXMsXG4gICAgICAgIHkgKyBwYWdlVGV4dHVyZXNbcGFnZTJdLmZyYW1lLnkgLyByZXMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgICk7XG4gICAgICB0aGlzLmNoYXJzW2lkXSA9IHtcbiAgICAgICAgeE9mZnNldDogeG9mZnNldCxcbiAgICAgICAgeU9mZnNldDogeW9mZnNldCxcbiAgICAgICAgeEFkdmFuY2U6IHhhZHZhbmNlLFxuICAgICAgICBrZXJuaW5nOiB7fSxcbiAgICAgICAgdGV4dHVyZTogbmV3IGNvcmUuVGV4dHVyZShcbiAgICAgICAgICBwYWdlVGV4dHVyZXNbcGFnZTJdLmJhc2VUZXh0dXJlLFxuICAgICAgICAgIHJlY3RcbiAgICAgICAgKSxcbiAgICAgICAgcGFnZTogcGFnZTJcbiAgICAgIH07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5rZXJuaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgeyBmaXJzdCwgc2Vjb25kLCBhbW91bnQgfSA9IGRhdGEua2VybmluZ1tpXTtcbiAgICAgIGZpcnN0IC89IHJlcywgc2Vjb25kIC89IHJlcywgYW1vdW50IC89IHJlcywgdGhpcy5jaGFyc1tzZWNvbmRdICYmICh0aGlzLmNoYXJzW3NlY29uZF0ua2VybmluZ1tmaXJzdF0gPSBhbW91bnQpO1xuICAgIH1cbiAgICB0aGlzLmRpc3RhbmNlRmllbGRSYW5nZSA9IGRpc3RhbmNlRmllbGQ/LmRpc3RhbmNlUmFuZ2UsIHRoaXMuZGlzdGFuY2VGaWVsZFR5cGUgPSBkaXN0YW5jZUZpZWxkPy5maWVsZFR5cGU/LnRvTG93ZXJDYXNlKCkgPz8gXCJub25lXCI7XG4gIH1cbiAgLyoqIFJlbW92ZSByZWZlcmVuY2VzIHRvIGNyZWF0ZWQgZ2x5cGggdGV4dHVyZXMuICovXG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmNoYXJzKVxuICAgICAgdGhpcy5jaGFyc1tpZF0udGV4dHVyZS5kZXN0cm95KCksIHRoaXMuY2hhcnNbaWRdLnRleHR1cmUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy5wYWdlVGV4dHVyZXMpXG4gICAgICB0aGlzLl9vd25zVGV4dHVyZXMgJiYgdGhpcy5wYWdlVGV4dHVyZXNbaWRdLmRlc3Ryb3koITApLCB0aGlzLnBhZ2VUZXh0dXJlc1tpZF0gPSBudWxsO1xuICAgIHRoaXMuY2hhcnMgPSBudWxsLCB0aGlzLnBhZ2VUZXh0dXJlcyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgbmV3IGJpdG1hcCBmb250LlxuICAgKiBAcGFyYW0gZGF0YSAtIFRoZVxuICAgKiAgICAgICAgY2hhcmFjdGVycyBtYXAgdGhhdCBjb3VsZCBiZSBwcm92aWRlZCBhcyB4bWwgb3IgcmF3IHN0cmluZy5cbiAgICogQHBhcmFtIHRleHR1cmVzIC0gTGlzdCBvZiB0ZXh0dXJlcyBmb3IgZWFjaCBwYWdlLlxuICAgKiBAcGFyYW0gb3duc1RleHR1cmVzIC0gU2V0IHRvIGB0cnVlYCB0byBkZXN0cm95IHBhZ2UgdGV4dHVyZXNcbiAgICogICAgICAgIHdoZW4gdGhlIGZvbnQgaXMgdW5pbnN0YWxsZWQuIEJ5IGRlZmF1bHQgZm9udHMgY3JlYXRlZCB3aXRoXG4gICAqICAgICAgICBgQml0bWFwRm9udC5mcm9tYCBvciBmcm9tIHRoZSBgQml0bWFwRm9udExvYWRlcmAgYXJlIGB0cnVlYC5cbiAgICogQHJldHVybnMge1BJWEkuQml0bWFwRm9udH0gUmVzdWx0IGZvbnQgb2JqZWN0IHdpdGggZm9udCwgc2l6ZSwgbGluZUhlaWdodFxuICAgKiAgICAgICAgIGFuZCBjaGFyIGZpZWxkcy5cbiAgICovXG4gIHN0YXRpYyBpbnN0YWxsKGRhdGEsIHRleHR1cmVzLCBvd25zVGV4dHVyZXMpIHtcbiAgICBsZXQgZm9udERhdGE7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBCaXRtYXBGb250RGF0YS5CaXRtYXBGb250RGF0YSlcbiAgICAgIGZvbnREYXRhID0gZGF0YTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IGluZGV4LmF1dG9EZXRlY3RGb3JtYXQoZGF0YSk7XG4gICAgICBpZiAoIWZvcm1hdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGRhdGEgZm9ybWF0IGZvciBmb250LlwiKTtcbiAgICAgIGZvbnREYXRhID0gZm9ybWF0LnBhcnNlKGRhdGEpO1xuICAgIH1cbiAgICB0ZXh0dXJlcyBpbnN0YW5jZW9mIGNvcmUuVGV4dHVyZSAmJiAodGV4dHVyZXMgPSBbdGV4dHVyZXNdKTtcbiAgICBjb25zdCBmb250ID0gbmV3IF9CaXRtYXBGb250Mihmb250RGF0YSwgdGV4dHVyZXMsIG93bnNUZXh0dXJlcyk7XG4gICAgcmV0dXJuIF9CaXRtYXBGb250Mi5hdmFpbGFibGVbZm9udC5mb250XSA9IGZvbnQsIGZvbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBiaXRtYXAgZm9udCBieSBuYW1lLlxuICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgdGhlIGZvbnQgdG8gdW5pbnN0YWxsLlxuICAgKi9cbiAgc3RhdGljIHVuaW5zdGFsbChuYW1lKSB7XG4gICAgY29uc3QgZm9udCA9IF9CaXRtYXBGb250Mi5hdmFpbGFibGVbbmFtZV07XG4gICAgaWYgKCFmb250KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBmb250IGZvdW5kIG5hbWVkICcke25hbWV9J2ApO1xuICAgIGZvbnQuZGVzdHJveSgpLCBkZWxldGUgX0JpdG1hcEZvbnQyLmF2YWlsYWJsZVtuYW1lXTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgYml0bWFwLWZvbnQgZm9yIHRoZSBnaXZlbiBzdHlsZSBhbmQgY2hhcmFjdGVyIHNldC4gVGhpcyBkb2VzIG5vdCBzdXBwb3J0XG4gICAqIGtlcm5pbmdzIHlldC4gV2l0aCBgc3R5bGVgIHByb3BlcnRpZXMsIG9ubHkgdGhlIGZvbGxvd2luZyBub24tbGF5b3V0IHByb3BlcnRpZXMgYXJlIHVzZWQ6XG4gICAqXG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI2Ryb3BTaGFkb3d8ZHJvcFNoYWRvd31cbiAgICogLSB7QGxpbmsgUElYSS5UZXh0U3R5bGUjZHJvcFNoYWRvd0Rpc3RhbmNlfGRyb3BTaGFkb3dEaXN0YW5jZX1cbiAgICogLSB7QGxpbmsgUElYSS5UZXh0U3R5bGUjZHJvcFNoYWRvd0NvbG9yfGRyb3BTaGFkb3dDb2xvcn1cbiAgICogLSB7QGxpbmsgUElYSS5UZXh0U3R5bGUjZHJvcFNoYWRvd0JsdXJ8ZHJvcFNoYWRvd0JsdXJ9XG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI2Ryb3BTaGFkb3dBbmdsZXxkcm9wU2hhZG93QW5nbGV9XG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI2ZpbGx8ZmlsbH1cbiAgICogLSB7QGxpbmsgUElYSS5UZXh0U3R5bGUjZmlsbEdyYWRpZW50U3RvcHN8ZmlsbEdyYWRpZW50U3RvcHN9XG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI2ZpbGxHcmFkaWVudFR5cGV8ZmlsbEdyYWRpZW50VHlwZX1cbiAgICogLSB7QGxpbmsgUElYSS5UZXh0U3R5bGUjZm9udEZhbWlseXxmb250RmFtaWx5fVxuICAgKiAtIHtAbGluayBQSVhJLlRleHRTdHlsZSNmb250U2l6ZXxmb250U2l6ZX1cbiAgICogLSB7QGxpbmsgUElYSS5UZXh0U3R5bGUjZm9udFZhcmlhbnR8Zm9udFZhcmlhbnR9XG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI2ZvbnRXZWlnaHR8Zm9udFdlaWdodH1cbiAgICogLSB7QGxpbmsgUElYSS5UZXh0U3R5bGUjbGluZUpvaW58bGluZUpvaW59XG4gICAqIC0ge0BsaW5rIFBJWEkuVGV4dFN0eWxlI21pdGVyTGltaXR8bWl0ZXJMaW1pdH1cbiAgICogLSB7QGxpbmsgUElYSS5UZXh0U3R5bGUjc3Ryb2tlfHN0cm9rZX1cbiAgICogLSB7QGxpbmsgUElYSS5UZXh0U3R5bGUjc3Ryb2tlVGhpY2tuZXNzfHN0cm9rZVRoaWNrbmVzc31cbiAgICogLSB7QGxpbmsgUElYSS5UZXh0U3R5bGUjdGV4dEJhc2VsaW5lfHRleHRCYXNlbGluZX1cbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGZvbnQgdG8gdXNlIHdpdGggQml0bWFwVGV4dC5cbiAgICogQHBhcmFtIHRleHRTdHlsZSAtIFN0eWxlIG9wdGlvbnMgdG8gcmVuZGVyIHdpdGggQml0bWFwRm9udC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBTZXR1cCBvcHRpb25zIGZvciBmb250IG9yIG5hbWUgb2YgdGhlIGZvbnQuXG4gICAqIEByZXR1cm5zIEZvbnQgZ2VuZXJhdGVkIGJ5IHN0eWxlIG9wdGlvbnMuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEJpdG1hcEZvbnQsIEJpdG1hcFRleHQgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogQml0bWFwRm9udC5mcm9tKCdUaXRsZUZvbnQnLCB7XG4gICAqICAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxuICAgKiAgICAgZm9udFNpemU6IDEyLFxuICAgKiAgICAgc3Ryb2tlVGhpY2tuZXNzOiAyLFxuICAgKiAgICAgZmlsbDogJ3B1cnBsZScsXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCB0aXRsZSA9IG5ldyBCaXRtYXBUZXh0KCdUaGlzIGlzIHRoZSB0aXRsZScsIHsgZm9udE5hbWU6ICdUaXRsZUZvbnQnIH0pO1xuICAgKi9cbiAgc3RhdGljIGZyb20obmFtZSwgdGV4dFN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFuYW1lKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW0JpdG1hcEZvbnRdIFByb3BlcnR5IGBuYW1lYCBpcyByZXF1aXJlZC5cIik7XG4gICAgY29uc3Qge1xuICAgICAgY2hhcnMsXG4gICAgICBwYWRkaW5nLFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIHRleHR1cmVXaWR0aCxcbiAgICAgIHRleHR1cmVIZWlnaHQsXG4gICAgICAuLi5iYXNlT3B0aW9uc1xuICAgIH0gPSBPYmplY3QuYXNzaWduKHt9LCBfQml0bWFwRm9udDIuZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpLCBjaGFyc0xpc3QgPSByZXNvbHZlQ2hhcmFjdGVycy5yZXNvbHZlQ2hhcmFjdGVycyhjaGFycyksIHN0eWxlID0gdGV4dFN0eWxlIGluc3RhbmNlb2YgdGV4dC5UZXh0U3R5bGUgPyB0ZXh0U3R5bGUgOiBuZXcgdGV4dC5UZXh0U3R5bGUodGV4dFN0eWxlKSwgbGluZVdpZHRoID0gdGV4dHVyZVdpZHRoLCBmb250RGF0YSA9IG5ldyBCaXRtYXBGb250RGF0YS5CaXRtYXBGb250RGF0YSgpO1xuICAgIGZvbnREYXRhLmluZm9bMF0gPSB7XG4gICAgICBmYWNlOiBzdHlsZS5mb250RmFtaWx5LFxuICAgICAgc2l6ZTogc3R5bGUuZm9udFNpemVcbiAgICB9LCBmb250RGF0YS5jb21tb25bMF0gPSB7XG4gICAgICBsaW5lSGVpZ2h0OiBzdHlsZS5mb250U2l6ZVxuICAgIH07XG4gICAgbGV0IHBvc2l0aW9uWCA9IDAsIHBvc2l0aW9uWSA9IDAsIGNhbnZhcywgY29udGV4dCwgYmFzZVRleHR1cmUsIG1heENoYXJIZWlnaHQgPSAwO1xuICAgIGNvbnN0IGJhc2VUZXh0dXJlcyA9IFtdLCB0ZXh0dXJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnNMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW52YXMgfHwgKGNhbnZhcyA9IGNvcmUuc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoKSwgY2FudmFzLndpZHRoID0gdGV4dHVyZVdpZHRoLCBjYW52YXMuaGVpZ2h0ID0gdGV4dHVyZUhlaWdodCwgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksIGJhc2VUZXh0dXJlID0gbmV3IGNvcmUuQmFzZVRleHR1cmUoY2FudmFzLCB7IHJlc29sdXRpb24sIC4uLmJhc2VPcHRpb25zIH0pLCBiYXNlVGV4dHVyZXMucHVzaChiYXNlVGV4dHVyZSksIHRleHR1cmVzLnB1c2gobmV3IGNvcmUuVGV4dHVyZShiYXNlVGV4dHVyZSkpLCBmb250RGF0YS5wYWdlLnB1c2goe1xuICAgICAgICBpZDogdGV4dHVyZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgZmlsZTogXCJcIlxuICAgICAgfSkpO1xuICAgICAgY29uc3QgY2hhcmFjdGVyID0gY2hhcnNMaXN0W2ldLCBtZXRyaWNzID0gdGV4dC5UZXh0TWV0cmljcy5tZWFzdXJlVGV4dChjaGFyYWN0ZXIsIHN0eWxlLCAhMSwgY2FudmFzKSwgd2lkdGggPSBtZXRyaWNzLndpZHRoLCBoZWlnaHQgPSBNYXRoLmNlaWwobWV0cmljcy5oZWlnaHQpLCB0ZXh0dXJlR2x5cGhXaWR0aCA9IE1hdGguY2VpbCgoc3R5bGUuZm9udFN0eWxlID09PSBcIml0YWxpY1wiID8gMiA6IDEpICogd2lkdGgpO1xuICAgICAgaWYgKHBvc2l0aW9uWSA+PSB0ZXh0dXJlSGVpZ2h0IC0gaGVpZ2h0ICogcmVzb2x1dGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb25ZID09PSAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW0JpdG1hcEZvbnRdIHRleHR1cmVIZWlnaHQgJHt0ZXh0dXJlSGVpZ2h0fXB4IGlzIHRvbyBzbWFsbCAoZm9udEZhbWlseTogJyR7c3R5bGUuZm9udEZhbWlseX0nLCBmb250U2l6ZTogJHtzdHlsZS5mb250U2l6ZX1weCwgY2hhcjogJyR7Y2hhcmFjdGVyfScpYCk7XG4gICAgICAgIC0taSwgY2FudmFzID0gbnVsbCwgY29udGV4dCA9IG51bGwsIGJhc2VUZXh0dXJlID0gbnVsbCwgcG9zaXRpb25ZID0gMCwgcG9zaXRpb25YID0gMCwgbWF4Q2hhckhlaWdodCA9IDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG1heENoYXJIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQgKyBtZXRyaWNzLmZvbnRQcm9wZXJ0aWVzLmRlc2NlbnQsIG1heENoYXJIZWlnaHQpLCB0ZXh0dXJlR2x5cGhXaWR0aCAqIHJlc29sdXRpb24gKyBwb3NpdGlvblggPj0gbGluZVdpZHRoKSB7XG4gICAgICAgIGlmIChwb3NpdGlvblggPT09IDApXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbQml0bWFwRm9udF0gdGV4dHVyZVdpZHRoICR7dGV4dHVyZVdpZHRofXB4IGlzIHRvbyBzbWFsbCAoZm9udEZhbWlseTogJyR7c3R5bGUuZm9udEZhbWlseX0nLCBmb250U2l6ZTogJHtzdHlsZS5mb250U2l6ZX1weCwgY2hhcjogJyR7Y2hhcmFjdGVyfScpYCk7XG4gICAgICAgIC0taSwgcG9zaXRpb25ZICs9IG1heENoYXJIZWlnaHQgKiByZXNvbHV0aW9uLCBwb3NpdGlvblkgPSBNYXRoLmNlaWwocG9zaXRpb25ZKSwgcG9zaXRpb25YID0gMCwgbWF4Q2hhckhlaWdodCA9IDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZHJhd0dseXBoLmRyYXdHbHlwaChjYW52YXMsIGNvbnRleHQsIG1ldHJpY3MsIHBvc2l0aW9uWCwgcG9zaXRpb25ZLCByZXNvbHV0aW9uLCBzdHlsZSk7XG4gICAgICBjb25zdCBpZCA9IGV4dHJhY3RDaGFyQ29kZS5leHRyYWN0Q2hhckNvZGUobWV0cmljcy50ZXh0KTtcbiAgICAgIGZvbnREYXRhLmNoYXIucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBwYWdlOiB0ZXh0dXJlcy5sZW5ndGggLSAxLFxuICAgICAgICB4OiBwb3NpdGlvblggLyByZXNvbHV0aW9uLFxuICAgICAgICB5OiBwb3NpdGlvblkgLyByZXNvbHV0aW9uLFxuICAgICAgICB3aWR0aDogdGV4dHVyZUdseXBoV2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgeG9mZnNldDogMCxcbiAgICAgICAgeW9mZnNldDogMCxcbiAgICAgICAgeGFkdmFuY2U6IHdpZHRoIC0gKHN0eWxlLmRyb3BTaGFkb3cgPyBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgOiAwKSAtIChzdHlsZS5zdHJva2UgPyBzdHlsZS5zdHJva2VUaGlja25lc3MgOiAwKVxuICAgICAgfSksIHBvc2l0aW9uWCArPSAodGV4dHVyZUdseXBoV2lkdGggKyAyICogcGFkZGluZykgKiByZXNvbHV0aW9uLCBwb3NpdGlvblggPSBNYXRoLmNlaWwocG9zaXRpb25YKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zPy5za2lwS2VybmluZylcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjaGFyc0xpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgZmlyc3QgPSBjaGFyc0xpc3RbaV07XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBzZWNvbmQgPSBjaGFyc0xpc3Rbal0sIGMxID0gY29udGV4dC5tZWFzdXJlVGV4dChmaXJzdCkud2lkdGgsIGMyID0gY29udGV4dC5tZWFzdXJlVGV4dChzZWNvbmQpLndpZHRoLCBhbW91bnQgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGZpcnN0ICsgc2Vjb25kKS53aWR0aCAtIChjMSArIGMyKTtcbiAgICAgICAgICBhbW91bnQgJiYgZm9udERhdGEua2VybmluZy5wdXNoKHtcbiAgICAgICAgICAgIGZpcnN0OiBleHRyYWN0Q2hhckNvZGUuZXh0cmFjdENoYXJDb2RlKGZpcnN0KSxcbiAgICAgICAgICAgIHNlY29uZDogZXh0cmFjdENoYXJDb2RlLmV4dHJhY3RDaGFyQ29kZShzZWNvbmQpLFxuICAgICAgICAgICAgYW1vdW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBjb25zdCBmb250ID0gbmV3IF9CaXRtYXBGb250Mihmb250RGF0YSwgdGV4dHVyZXMsICEwKTtcbiAgICByZXR1cm4gX0JpdG1hcEZvbnQyLmF2YWlsYWJsZVtuYW1lXSAhPT0gdm9pZCAwICYmIF9CaXRtYXBGb250Mi51bmluc3RhbGwobmFtZSksIF9CaXRtYXBGb250Mi5hdmFpbGFibGVbbmFtZV0gPSBmb250LCBmb250O1xuICB9XG59O1xuX0JpdG1hcEZvbnQuQUxQSEEgPSBbW1wiYVwiLCBcInpcIl0sIFtcIkFcIiwgXCJaXCJdLCBcIiBcIl0sIC8qKlxuKiBUaGlzIGNoYXJhY3RlciBzZXQgaW5jbHVkZXMgYWxsIGRlY2ltYWwgZGlnaXRzIChmcm9tIDAgdG8gOSkuXG4qIEB0eXBlIHtzdHJpbmdbXVtdfVxuKiBAZXhhbXBsZVxuKiBCaXRtYXBGb250LmZyb20oJ0V4YW1wbGVGb250Jywgc3R5bGUsIHsgY2hhcnM6IEJpdG1hcEZvbnQuTlVNRVJJQyB9KVxuKi9cbl9CaXRtYXBGb250Lk5VTUVSSUMgPSBbW1wiMFwiLCBcIjlcIl1dLCAvKipcbiogVGhpcyBjaGFyYWN0ZXIgc2V0IGlzIHRoZSB1bmlvbiBvZiBgQml0bWFwRm9udC5BTFBIQWAgYW5kIGBCaXRtYXBGb250Lk5VTUVSSUNgLlxuKiBAdHlwZSB7c3RyaW5nW11bXX1cbiovXG5fQml0bWFwRm9udC5BTFBIQU5VTUVSSUMgPSBbW1wiYVwiLCBcInpcIl0sIFtcIkFcIiwgXCJaXCJdLCBbXCIwXCIsIFwiOVwiXSwgXCIgXCJdLCAvKipcbiogVGhpcyBjaGFyYWN0ZXIgc2V0IGNvbnNpc3RzIG9mIGFsbCB0aGUgQVNDSUkgdGFibGUuXG4qIEBtZW1iZXIge3N0cmluZ1tdW119XG4qIEBzZWUgaHR0cDovL3d3dy5hc2NpaXRhYmxlLmNvbS9cbiovXG5fQml0bWFwRm9udC5BU0NJSSA9IFtbXCIgXCIsIFwiflwiXV0sIC8qKlxuKiBDb2xsZWN0aW9uIG9mIGRlZmF1bHQgb3B0aW9ucyB3aGVuIHVzaW5nIGBCaXRtYXBGb250LmZyb21gLlxuKiBAcHJvcGVydHkge251bWJlcn0gW3Jlc29sdXRpb249MV0gLVxuKiBAcHJvcGVydHkge251bWJlcn0gW3RleHR1cmVXaWR0aD01MTJdIC1cbiogQHByb3BlcnR5IHtudW1iZXJ9IFt0ZXh0dXJlSGVpZ2h0PTUxMl0gLVxuKiBAcHJvcGVydHkge251bWJlcn0gW3BhZGRpbmc9NF0gLVxuKiBAcHJvcGVydHkge3N0cmluZ3xzdHJpbmdbXXxzdHJpbmdbXVtdfSBjaGFycyA9IFBJWEkuQml0bWFwRm9udC5BTFBIQU5VTUVSSUNcbiovXG5fQml0bWFwRm9udC5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgcmVzb2x1dGlvbjogMSxcbiAgdGV4dHVyZVdpZHRoOiA1MTIsXG4gIHRleHR1cmVIZWlnaHQ6IDUxMixcbiAgcGFkZGluZzogNCxcbiAgY2hhcnM6IF9CaXRtYXBGb250LkFMUEhBTlVNRVJJQ1xufSwgLyoqIENvbGxlY3Rpb24gb2YgYXZhaWxhYmxlL2luc3RhbGxlZCBmb250cy4gKi9cbl9CaXRtYXBGb250LmF2YWlsYWJsZSA9IHt9O1xubGV0IEJpdG1hcEZvbnQgPSBfQml0bWFwRm9udDtcbmV4cG9ydHMuQml0bWFwRm9udCA9IEJpdG1hcEZvbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaXRtYXBGb250LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCaXRtYXBGb250RGF0YSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5mbyA9IFtdLCB0aGlzLmNvbW1vbiA9IFtdLCB0aGlzLnBhZ2UgPSBbXSwgdGhpcy5jaGFyID0gW10sIHRoaXMua2VybmluZyA9IFtdLCB0aGlzLmRpc3RhbmNlRmllbGQgPSBbXTtcbiAgfVxufVxuZXhwb3J0cy5CaXRtYXBGb250RGF0YSA9IEJpdG1hcEZvbnREYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qml0bWFwRm9udERhdGEuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIGRpc3BsYXkgPSByZXF1aXJlKFwiQHBpeGkvZGlzcGxheVwiKSwgbWVzaCA9IHJlcXVpcmUoXCJAcGl4aS9tZXNoXCIpLCBCaXRtYXBGb250ID0gcmVxdWlyZShcIi4vQml0bWFwRm9udC5qc1wiKSwgbXNkZiQxID0gcmVxdWlyZShcIi4vc2hhZGVyL21zZGYuZnJhZy5qc1wiKSwgbXNkZiA9IHJlcXVpcmUoXCIuL3NoYWRlci9tc2RmLnZlcnQuanNcIik7XG5yZXF1aXJlKFwiLi91dGlscy9pbmRleC5qc1wiKTtcbnZhciBzcGxpdFRleHRUb0NoYXJhY3RlcnMgPSByZXF1aXJlKFwiLi91dGlscy9zcGxpdFRleHRUb0NoYXJhY3RlcnMuanNcIiksIGV4dHJhY3RDaGFyQ29kZSA9IHJlcXVpcmUoXCIuL3V0aWxzL2V4dHJhY3RDaGFyQ29kZS5qc1wiKTtcbmNvbnN0IHBhZ2VNZXNoRGF0YURlZmF1bHRQYWdlTWVzaERhdGEgPSBbXSwgcGFnZU1lc2hEYXRhTVNERlBhZ2VNZXNoRGF0YSA9IFtdLCBjaGFyUmVuZGVyRGF0YVBvb2wgPSBbXSwgX0JpdG1hcFRleHQgPSBjbGFzcyBfQml0bWFwVGV4dDIgZXh0ZW5kcyBkaXNwbGF5LkNvbnRhaW5lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdGV4dCAtIEEgc3RyaW5nIHRoYXQgeW91IHdvdWxkIGxpa2UgdGhlIHRleHQgdG8gZGlzcGxheS5cbiAgICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZS5mb250TmFtZSAtIFRoZSBpbnN0YWxsZWQgQml0bWFwRm9udCBuYW1lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0eWxlLmZvbnRTaXplXSAtIFRoZSBzaXplIG9mIHRoZSBmb250IGluIHBpeGVscywgZS5nLiAyNC4gSWYgdW5kZWZpbmVkLFxuICAgKi4gICAgIHRoaXMgd2lsbCBkZWZhdWx0IHRvIHRoZSBCaXRtYXBGb250IHNpemUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3R5bGUuYWxpZ249J2xlZnQnXSAtIEFsaWdubWVudCBmb3IgbXVsdGlsaW5lIHRleHQgKCdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCcgb3IgJ2p1c3RpZnknKSxcbiAgICogICAgICBkb2VzIG5vdCBhZmZlY3Qgc2luZ2xlIGxpbmUgdGV4dC5cbiAgICogQHBhcmFtIHtQSVhJLkNvbG9yU291cmNlfSBbc3R5bGUudGludD0weEZGRkZGRl0gLSBUaGUgdGludCBjb2xvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHlsZS5sZXR0ZXJTcGFjaW5nPTBdIC0gVGhlIGFtb3VudCBvZiBzcGFjaW5nIGJldHdlZW4gbGV0dGVycy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHlsZS5tYXhXaWR0aD0wXSAtIFRoZSBtYXggd2lkdGggb2YgdGhlIHRleHQgYmVmb3JlIGxpbmUgd3JhcHBpbmcuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0LCBzdHlsZSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB7IGFsaWduLCB0aW50LCBtYXhXaWR0aCwgbGV0dGVyU3BhY2luZywgZm9udE5hbWUsIGZvbnRTaXplIH0gPSBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICBfQml0bWFwVGV4dDIuc3R5bGVEZWZhdWx0cyxcbiAgICAgIHN0eWxlXG4gICAgKTtcbiAgICBpZiAoIUJpdG1hcEZvbnQuQml0bWFwRm9udC5hdmFpbGFibGVbZm9udE5hbWVdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIEJpdG1hcEZvbnQgXCIke2ZvbnROYW1lfVwiYCk7XG4gICAgdGhpcy5fYWN0aXZlUGFnZXNNZXNoRGF0YSA9IFtdLCB0aGlzLl90ZXh0V2lkdGggPSAwLCB0aGlzLl90ZXh0SGVpZ2h0ID0gMCwgdGhpcy5fYWxpZ24gPSBhbGlnbiwgdGhpcy5fdGludENvbG9yID0gbmV3IGNvcmUuQ29sb3IodGludCksIHRoaXMuX2ZvbnQgPSB2b2lkIDAsIHRoaXMuX2ZvbnROYW1lID0gZm9udE5hbWUsIHRoaXMuX2ZvbnRTaXplID0gZm9udFNpemUsIHRoaXMudGV4dCA9IHRleHQsIHRoaXMuX21heFdpZHRoID0gbWF4V2lkdGgsIHRoaXMuX21heExpbmVIZWlnaHQgPSAwLCB0aGlzLl9sZXR0ZXJTcGFjaW5nID0gbGV0dGVyU3BhY2luZywgdGhpcy5fYW5jaG9yID0gbmV3IGNvcmUuT2JzZXJ2YWJsZVBvaW50KCgpID0+IHtcbiAgICAgIHRoaXMuZGlydHkgPSAhMDtcbiAgICB9LCB0aGlzLCAwLCAwKSwgdGhpcy5fcm91bmRQaXhlbHMgPSBjb3JlLnNldHRpbmdzLlJPVU5EX1BJWEVMUywgdGhpcy5kaXJ0eSA9ICEwLCB0aGlzLl9yZXNvbHV0aW9uID0gY29yZS5zZXR0aW5ncy5SRVNPTFVUSU9OLCB0aGlzLl9hdXRvUmVzb2x1dGlvbiA9ICEwLCB0aGlzLl90ZXh0dXJlQ2FjaGUgPSB7fTtcbiAgfVxuICAvKiogUmVuZGVycyB0ZXh0IGFuZCB1cGRhdGVzIGl0IHdoZW4gbmVlZGVkLiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiB0aGUgQml0bWFwRm9udCBpcyByZWdlbmVyYXRlZC4gKi9cbiAgdXBkYXRlVGV4dCgpIHtcbiAgICBjb25zdCBkYXRhID0gQml0bWFwRm9udC5CaXRtYXBGb250LmF2YWlsYWJsZVt0aGlzLl9mb250TmFtZV0sIGZvbnRTaXplID0gdGhpcy5mb250U2l6ZSwgc2NhbGUgPSBmb250U2l6ZSAvIGRhdGEuc2l6ZSwgcG9zID0gbmV3IGNvcmUuUG9pbnQoKSwgY2hhcnMgPSBbXSwgbGluZVdpZHRocyA9IFtdLCBsaW5lU3BhY2VzID0gW10sIHRleHQgPSB0aGlzLl90ZXh0LnJlcGxhY2UoLyg/OlxcclxcbnxcXHIpL2csIGBcbmApIHx8IFwiIFwiLCBjaGFyc0lucHV0ID0gc3BsaXRUZXh0VG9DaGFyYWN0ZXJzLnNwbGl0VGV4dFRvQ2hhcmFjdGVycyh0ZXh0KSwgbWF4V2lkdGggPSB0aGlzLl9tYXhXaWR0aCAqIGRhdGEuc2l6ZSAvIGZvbnRTaXplLCBwYWdlTWVzaERhdGFQb29sID0gZGF0YS5kaXN0YW5jZUZpZWxkVHlwZSA9PT0gXCJub25lXCIgPyBwYWdlTWVzaERhdGFEZWZhdWx0UGFnZU1lc2hEYXRhIDogcGFnZU1lc2hEYXRhTVNERlBhZ2VNZXNoRGF0YTtcbiAgICBsZXQgcHJldkNoYXJDb2RlID0gbnVsbCwgbGFzdExpbmVXaWR0aCA9IDAsIG1heExpbmVXaWR0aCA9IDAsIGxpbmUgPSAwLCBsYXN0QnJlYWtQb3MgPSAtMSwgbGFzdEJyZWFrV2lkdGggPSAwLCBzcGFjZXNSZW1vdmVkID0gMCwgbWF4TGluZUhlaWdodCA9IDAsIHNwYWNlQ291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnNJbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJzSW5wdXRbaV0sIGNoYXJDb2RlID0gZXh0cmFjdENoYXJDb2RlLmV4dHJhY3RDaGFyQ29kZShjaGFyKTtcbiAgICAgIGlmICgvKD86XFxzKS8udGVzdChjaGFyKSAmJiAobGFzdEJyZWFrUG9zID0gaSwgbGFzdEJyZWFrV2lkdGggPSBsYXN0TGluZVdpZHRoLCBzcGFjZUNvdW50KyspLCBjaGFyID09PSBcIlxcclwiIHx8IGNoYXIgPT09IGBcbmApIHtcbiAgICAgICAgbGluZVdpZHRocy5wdXNoKGxhc3RMaW5lV2lkdGgpLCBsaW5lU3BhY2VzLnB1c2goLTEpLCBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxhc3RMaW5lV2lkdGgpLCArK2xpbmUsICsrc3BhY2VzUmVtb3ZlZCwgcG9zLnggPSAwLCBwb3MueSArPSBkYXRhLmxpbmVIZWlnaHQsIHByZXZDaGFyQ29kZSA9IG51bGwsIHNwYWNlQ291bnQgPSAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYXJEYXRhID0gZGF0YS5jaGFyc1tjaGFyQ29kZV07XG4gICAgICBpZiAoIWNoYXJEYXRhKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHByZXZDaGFyQ29kZSAmJiBjaGFyRGF0YS5rZXJuaW5nW3ByZXZDaGFyQ29kZV0gJiYgKHBvcy54ICs9IGNoYXJEYXRhLmtlcm5pbmdbcHJldkNoYXJDb2RlXSk7XG4gICAgICBjb25zdCBjaGFyUmVuZGVyRGF0YSA9IGNoYXJSZW5kZXJEYXRhUG9vbC5wb3AoKSB8fCB7XG4gICAgICAgIHRleHR1cmU6IGNvcmUuVGV4dHVyZS5FTVBUWSxcbiAgICAgICAgbGluZTogMCxcbiAgICAgICAgY2hhckNvZGU6IDAsXG4gICAgICAgIHByZXZTcGFjZXM6IDAsXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgY29yZS5Qb2ludCgpXG4gICAgICB9O1xuICAgICAgY2hhclJlbmRlckRhdGEudGV4dHVyZSA9IGNoYXJEYXRhLnRleHR1cmUsIGNoYXJSZW5kZXJEYXRhLmxpbmUgPSBsaW5lLCBjaGFyUmVuZGVyRGF0YS5jaGFyQ29kZSA9IGNoYXJDb2RlLCBjaGFyUmVuZGVyRGF0YS5wb3NpdGlvbi54ID0gTWF0aC5yb3VuZChwb3MueCArIGNoYXJEYXRhLnhPZmZzZXQgKyB0aGlzLl9sZXR0ZXJTcGFjaW5nIC8gMiksIGNoYXJSZW5kZXJEYXRhLnBvc2l0aW9uLnkgPSBNYXRoLnJvdW5kKHBvcy55ICsgY2hhckRhdGEueU9mZnNldCksIGNoYXJSZW5kZXJEYXRhLnByZXZTcGFjZXMgPSBzcGFjZUNvdW50LCBjaGFycy5wdXNoKGNoYXJSZW5kZXJEYXRhKSwgbGFzdExpbmVXaWR0aCA9IGNoYXJSZW5kZXJEYXRhLnBvc2l0aW9uLnggKyBNYXRoLm1heChjaGFyRGF0YS54QWR2YW5jZSAtIGNoYXJEYXRhLnhPZmZzZXQsIGNoYXJEYXRhLnRleHR1cmUub3JpZy53aWR0aCksIHBvcy54ICs9IGNoYXJEYXRhLnhBZHZhbmNlICsgdGhpcy5fbGV0dGVyU3BhY2luZywgbWF4TGluZUhlaWdodCA9IE1hdGgubWF4KG1heExpbmVIZWlnaHQsIGNoYXJEYXRhLnlPZmZzZXQgKyBjaGFyRGF0YS50ZXh0dXJlLmhlaWdodCksIHByZXZDaGFyQ29kZSA9IGNoYXJDb2RlLCBsYXN0QnJlYWtQb3MgIT09IC0xICYmIG1heFdpZHRoID4gMCAmJiBwb3MueCA+IG1heFdpZHRoICYmICgrK3NwYWNlc1JlbW92ZWQsIGNvcmUudXRpbHMucmVtb3ZlSXRlbXMoY2hhcnMsIDEgKyBsYXN0QnJlYWtQb3MgLSBzcGFjZXNSZW1vdmVkLCAxICsgaSAtIGxhc3RCcmVha1BvcyksIGkgPSBsYXN0QnJlYWtQb3MsIGxhc3RCcmVha1BvcyA9IC0xLCBsaW5lV2lkdGhzLnB1c2gobGFzdEJyZWFrV2lkdGgpLCBsaW5lU3BhY2VzLnB1c2goY2hhcnMubGVuZ3RoID4gMCA/IGNoYXJzW2NoYXJzLmxlbmd0aCAtIDFdLnByZXZTcGFjZXMgOiAwKSwgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsYXN0QnJlYWtXaWR0aCksIGxpbmUrKywgcG9zLnggPSAwLCBwb3MueSArPSBkYXRhLmxpbmVIZWlnaHQsIHByZXZDaGFyQ29kZSA9IG51bGwsIHNwYWNlQ291bnQgPSAwKTtcbiAgICB9XG4gICAgY29uc3QgbGFzdENoYXIgPSBjaGFyc0lucHV0W2NoYXJzSW5wdXQubGVuZ3RoIC0gMV07XG4gICAgbGFzdENoYXIgIT09IFwiXFxyXCIgJiYgbGFzdENoYXIgIT09IGBcbmAgJiYgKC8oPzpcXHMpLy50ZXN0KGxhc3RDaGFyKSAmJiAobGFzdExpbmVXaWR0aCA9IGxhc3RCcmVha1dpZHRoKSwgbGluZVdpZHRocy5wdXNoKGxhc3RMaW5lV2lkdGgpLCBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxhc3RMaW5lV2lkdGgpLCBsaW5lU3BhY2VzLnB1c2goLTEpKTtcbiAgICBjb25zdCBsaW5lQWxpZ25PZmZzZXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGluZTsgaSsrKSB7XG4gICAgICBsZXQgYWxpZ25PZmZzZXQgPSAwO1xuICAgICAgdGhpcy5fYWxpZ24gPT09IFwicmlnaHRcIiA/IGFsaWduT2Zmc2V0ID0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXSA6IHRoaXMuX2FsaWduID09PSBcImNlbnRlclwiID8gYWxpZ25PZmZzZXQgPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXSkgLyAyIDogdGhpcy5fYWxpZ24gPT09IFwianVzdGlmeVwiICYmIChhbGlnbk9mZnNldCA9IGxpbmVTcGFjZXNbaV0gPCAwID8gMCA6IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldKSAvIGxpbmVTcGFjZXNbaV0pLCBsaW5lQWxpZ25PZmZzZXRzLnB1c2goYWxpZ25PZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBsZW5DaGFycyA9IGNoYXJzLmxlbmd0aCwgcGFnZXNNZXNoRGF0YSA9IHt9LCBuZXdQYWdlc01lc2hEYXRhID0gW10sIGFjdGl2ZVBhZ2VzTWVzaERhdGEgPSB0aGlzLl9hY3RpdmVQYWdlc01lc2hEYXRhO1xuICAgIHBhZ2VNZXNoRGF0YVBvb2wucHVzaCguLi5hY3RpdmVQYWdlc01lc2hEYXRhKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbkNoYXJzOyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBjaGFyc1tpXS50ZXh0dXJlLCBiYXNlVGV4dHVyZVVpZCA9IHRleHR1cmUuYmFzZVRleHR1cmUudWlkO1xuICAgICAgaWYgKCFwYWdlc01lc2hEYXRhW2Jhc2VUZXh0dXJlVWlkXSkge1xuICAgICAgICBsZXQgcGFnZU1lc2hEYXRhID0gcGFnZU1lc2hEYXRhUG9vbC5wb3AoKTtcbiAgICAgICAgaWYgKCFwYWdlTWVzaERhdGEpIHtcbiAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBtZXNoLk1lc2hHZW9tZXRyeSgpO1xuICAgICAgICAgIGxldCBtYXRlcmlhbCwgbWVzaEJsZW5kTW9kZTtcbiAgICAgICAgICBkYXRhLmRpc3RhbmNlRmllbGRUeXBlID09PSBcIm5vbmVcIiA/IChtYXRlcmlhbCA9IG5ldyBtZXNoLk1lc2hNYXRlcmlhbChjb3JlLlRleHR1cmUuRU1QVFkpLCBtZXNoQmxlbmRNb2RlID0gY29yZS5CTEVORF9NT0RFUy5OT1JNQUwpIDogKG1hdGVyaWFsID0gbmV3IG1lc2guTWVzaE1hdGVyaWFsKFxuICAgICAgICAgICAgY29yZS5UZXh0dXJlLkVNUFRZLFxuICAgICAgICAgICAgeyBwcm9ncmFtOiBjb3JlLlByb2dyYW0uZnJvbShtc2RmLmRlZmF1bHQsIG1zZGYkMS5kZWZhdWx0KSwgdW5pZm9ybXM6IHsgdUZXaWR0aDogMCB9IH1cbiAgICAgICAgICApLCBtZXNoQmxlbmRNb2RlID0gY29yZS5CTEVORF9NT0RFUy5OT1JNQUxfTlBNKTtcbiAgICAgICAgICBjb25zdCBtZXNoJDEgPSBuZXcgbWVzaC5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgbWVzaCQxLmJsZW5kTW9kZSA9IG1lc2hCbGVuZE1vZGUsIHBhZ2VNZXNoRGF0YSA9IHtcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgaW5kZXhDb3VudDogMCxcbiAgICAgICAgICAgIHZlcnRleENvdW50OiAwLFxuICAgICAgICAgICAgdXZzQ291bnQ6IDAsXG4gICAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICAgIG1lc2g6IG1lc2gkMSxcbiAgICAgICAgICAgIHZlcnRpY2VzOiBudWxsLFxuICAgICAgICAgICAgdXZzOiBudWxsLFxuICAgICAgICAgICAgaW5kaWNlczogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcGFnZU1lc2hEYXRhLmluZGV4ID0gMCwgcGFnZU1lc2hEYXRhLmluZGV4Q291bnQgPSAwLCBwYWdlTWVzaERhdGEudmVydGV4Q291bnQgPSAwLCBwYWdlTWVzaERhdGEudXZzQ291bnQgPSAwLCBwYWdlTWVzaERhdGEudG90YWwgPSAwO1xuICAgICAgICBjb25zdCB7IF90ZXh0dXJlQ2FjaGUgfSA9IHRoaXM7XG4gICAgICAgIF90ZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmVVaWRdID0gX3RleHR1cmVDYWNoZVtiYXNlVGV4dHVyZVVpZF0gfHwgbmV3IGNvcmUuVGV4dHVyZSh0ZXh0dXJlLmJhc2VUZXh0dXJlKSwgcGFnZU1lc2hEYXRhLm1lc2gudGV4dHVyZSA9IF90ZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmVVaWRdLCBwYWdlTWVzaERhdGEubWVzaC50aW50ID0gdGhpcy5fdGludENvbG9yLnZhbHVlLCBuZXdQYWdlc01lc2hEYXRhLnB1c2gocGFnZU1lc2hEYXRhKSwgcGFnZXNNZXNoRGF0YVtiYXNlVGV4dHVyZVVpZF0gPSBwYWdlTWVzaERhdGE7XG4gICAgICB9XG4gICAgICBwYWdlc01lc2hEYXRhW2Jhc2VUZXh0dXJlVWlkXS50b3RhbCsrO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZVBhZ2VzTWVzaERhdGEubGVuZ3RoOyBpKyspXG4gICAgICBuZXdQYWdlc01lc2hEYXRhLmluY2x1ZGVzKGFjdGl2ZVBhZ2VzTWVzaERhdGFbaV0pIHx8IHRoaXMucmVtb3ZlQ2hpbGQoYWN0aXZlUGFnZXNNZXNoRGF0YVtpXS5tZXNoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1BhZ2VzTWVzaERhdGEubGVuZ3RoOyBpKyspXG4gICAgICBuZXdQYWdlc01lc2hEYXRhW2ldLm1lc2gucGFyZW50ICE9PSB0aGlzICYmIHRoaXMuYWRkQ2hpbGQobmV3UGFnZXNNZXNoRGF0YVtpXS5tZXNoKTtcbiAgICB0aGlzLl9hY3RpdmVQYWdlc01lc2hEYXRhID0gbmV3UGFnZXNNZXNoRGF0YTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gcGFnZXNNZXNoRGF0YSkge1xuICAgICAgY29uc3QgcGFnZU1lc2hEYXRhID0gcGFnZXNNZXNoRGF0YVtpXSwgdG90YWwgPSBwYWdlTWVzaERhdGEudG90YWw7XG4gICAgICBpZiAoIShwYWdlTWVzaERhdGEuaW5kaWNlcz8ubGVuZ3RoID4gNiAqIHRvdGFsKSB8fCBwYWdlTWVzaERhdGEudmVydGljZXMubGVuZ3RoIDwgbWVzaC5NZXNoLkJBVENIQUJMRV9TSVpFICogMilcbiAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSg0ICogMiAqIHRvdGFsKSwgcGFnZU1lc2hEYXRhLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoNCAqIDIgKiB0b3RhbCksIHBhZ2VNZXNoRGF0YS5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KDYgKiB0b3RhbCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdG90YWwyID0gcGFnZU1lc2hEYXRhLnRvdGFsLCB2ZXJ0aWNlcyA9IHBhZ2VNZXNoRGF0YS52ZXJ0aWNlcztcbiAgICAgICAgZm9yIChsZXQgaTIgPSB0b3RhbDIgKiA0ICogMjsgaTIgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkyKyspXG4gICAgICAgICAgdmVydGljZXNbaTJdID0gMDtcbiAgICAgIH1cbiAgICAgIHBhZ2VNZXNoRGF0YS5tZXNoLnNpemUgPSA2ICogdG90YWw7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuQ2hhcnM7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgbGV0IG9mZnNldCA9IGNoYXIucG9zaXRpb24ueCArIGxpbmVBbGlnbk9mZnNldHNbY2hhci5saW5lXSAqICh0aGlzLl9hbGlnbiA9PT0gXCJqdXN0aWZ5XCIgPyBjaGFyLnByZXZTcGFjZXMgOiAxKTtcbiAgICAgIHRoaXMuX3JvdW5kUGl4ZWxzICYmIChvZmZzZXQgPSBNYXRoLnJvdW5kKG9mZnNldCkpO1xuICAgICAgY29uc3QgeFBvcyA9IG9mZnNldCAqIHNjYWxlLCB5UG9zID0gY2hhci5wb3NpdGlvbi55ICogc2NhbGUsIHRleHR1cmUgPSBjaGFyLnRleHR1cmUsIHBhZ2VNZXNoID0gcGFnZXNNZXNoRGF0YVt0ZXh0dXJlLmJhc2VUZXh0dXJlLnVpZF0sIHRleHR1cmVGcmFtZSA9IHRleHR1cmUuZnJhbWUsIHRleHR1cmVVdnMgPSB0ZXh0dXJlLl91dnMsIGluZGV4ID0gcGFnZU1lc2guaW5kZXgrKztcbiAgICAgIHBhZ2VNZXNoLmluZGljZXNbaW5kZXggKiA2ICsgMF0gPSAwICsgaW5kZXggKiA0LCBwYWdlTWVzaC5pbmRpY2VzW2luZGV4ICogNiArIDFdID0gMSArIGluZGV4ICogNCwgcGFnZU1lc2guaW5kaWNlc1tpbmRleCAqIDYgKyAyXSA9IDIgKyBpbmRleCAqIDQsIHBhZ2VNZXNoLmluZGljZXNbaW5kZXggKiA2ICsgM10gPSAwICsgaW5kZXggKiA0LCBwYWdlTWVzaC5pbmRpY2VzW2luZGV4ICogNiArIDRdID0gMiArIGluZGV4ICogNCwgcGFnZU1lc2guaW5kaWNlc1tpbmRleCAqIDYgKyA1XSA9IDMgKyBpbmRleCAqIDQsIHBhZ2VNZXNoLnZlcnRpY2VzW2luZGV4ICogOCArIDBdID0geFBvcywgcGFnZU1lc2gudmVydGljZXNbaW5kZXggKiA4ICsgMV0gPSB5UG9zLCBwYWdlTWVzaC52ZXJ0aWNlc1tpbmRleCAqIDggKyAyXSA9IHhQb3MgKyB0ZXh0dXJlRnJhbWUud2lkdGggKiBzY2FsZSwgcGFnZU1lc2gudmVydGljZXNbaW5kZXggKiA4ICsgM10gPSB5UG9zLCBwYWdlTWVzaC52ZXJ0aWNlc1tpbmRleCAqIDggKyA0XSA9IHhQb3MgKyB0ZXh0dXJlRnJhbWUud2lkdGggKiBzY2FsZSwgcGFnZU1lc2gudmVydGljZXNbaW5kZXggKiA4ICsgNV0gPSB5UG9zICsgdGV4dHVyZUZyYW1lLmhlaWdodCAqIHNjYWxlLCBwYWdlTWVzaC52ZXJ0aWNlc1tpbmRleCAqIDggKyA2XSA9IHhQb3MsIHBhZ2VNZXNoLnZlcnRpY2VzW2luZGV4ICogOCArIDddID0geVBvcyArIHRleHR1cmVGcmFtZS5oZWlnaHQgKiBzY2FsZSwgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDBdID0gdGV4dHVyZVV2cy54MCwgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDFdID0gdGV4dHVyZVV2cy55MCwgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDJdID0gdGV4dHVyZVV2cy54MSwgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDNdID0gdGV4dHVyZVV2cy55MSwgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDRdID0gdGV4dHVyZVV2cy54MiwgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDVdID0gdGV4dHVyZVV2cy55MiwgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDZdID0gdGV4dHVyZVV2cy54MywgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDddID0gdGV4dHVyZVV2cy55MztcbiAgICB9XG4gICAgdGhpcy5fdGV4dFdpZHRoID0gbWF4TGluZVdpZHRoICogc2NhbGUsIHRoaXMuX3RleHRIZWlnaHQgPSAocG9zLnkgKyBkYXRhLmxpbmVIZWlnaHQpICogc2NhbGU7XG4gICAgZm9yIChjb25zdCBpIGluIHBhZ2VzTWVzaERhdGEpIHtcbiAgICAgIGNvbnN0IHBhZ2VNZXNoRGF0YSA9IHBhZ2VzTWVzaERhdGFbaV07XG4gICAgICBpZiAodGhpcy5hbmNob3IueCAhPT0gMCB8fCB0aGlzLmFuY2hvci55ICE9PSAwKSB7XG4gICAgICAgIGxldCB2ZXJ0ZXhDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IGFuY2hvck9mZnNldFggPSB0aGlzLl90ZXh0V2lkdGggKiB0aGlzLmFuY2hvci54LCBhbmNob3JPZmZzZXRZID0gdGhpcy5fdGV4dEhlaWdodCAqIHRoaXMuYW5jaG9yLnk7XG4gICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBwYWdlTWVzaERhdGEudG90YWw7IGkyKyspXG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFgsIHBhZ2VNZXNoRGF0YS52ZXJ0aWNlc1t2ZXJ0ZXhDb3VudCsrXSAtPSBhbmNob3JPZmZzZXRZLCBwYWdlTWVzaERhdGEudmVydGljZXNbdmVydGV4Q291bnQrK10gLT0gYW5jaG9yT2Zmc2V0WCwgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFksIHBhZ2VNZXNoRGF0YS52ZXJ0aWNlc1t2ZXJ0ZXhDb3VudCsrXSAtPSBhbmNob3JPZmZzZXRYLCBwYWdlTWVzaERhdGEudmVydGljZXNbdmVydGV4Q291bnQrK10gLT0gYW5jaG9yT2Zmc2V0WSwgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFgsIHBhZ2VNZXNoRGF0YS52ZXJ0aWNlc1t2ZXJ0ZXhDb3VudCsrXSAtPSBhbmNob3JPZmZzZXRZO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWF4TGluZUhlaWdodCA9IG1heExpbmVIZWlnaHQgKiBzY2FsZTtcbiAgICAgIGNvbnN0IHZlcnRleEJ1ZmZlciA9IHBhZ2VNZXNoRGF0YS5tZXNoLmdlb21ldHJ5LmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKSwgdGV4dHVyZUJ1ZmZlciA9IHBhZ2VNZXNoRGF0YS5tZXNoLmdlb21ldHJ5LmdldEJ1ZmZlcihcImFUZXh0dXJlQ29vcmRcIiksIGluZGV4QnVmZmVyID0gcGFnZU1lc2hEYXRhLm1lc2guZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICAgIHZlcnRleEJ1ZmZlci5kYXRhID0gcGFnZU1lc2hEYXRhLnZlcnRpY2VzLCB0ZXh0dXJlQnVmZmVyLmRhdGEgPSBwYWdlTWVzaERhdGEudXZzLCBpbmRleEJ1ZmZlci5kYXRhID0gcGFnZU1lc2hEYXRhLmluZGljZXMsIHZlcnRleEJ1ZmZlci51cGRhdGUoKSwgdGV4dHVyZUJ1ZmZlci51cGRhdGUoKSwgaW5kZXhCdWZmZXIudXBkYXRlKCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspXG4gICAgICBjaGFyUmVuZGVyRGF0YVBvb2wucHVzaChjaGFyc1tpXSk7XG4gICAgdGhpcy5fZm9udCA9IGRhdGEsIHRoaXMuZGlydHkgPSAhMTtcbiAgfVxuICB1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy52YWxpZGF0ZSgpLCB0aGlzLmNvbnRhaW5lclVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9hdXRvUmVzb2x1dGlvbiAmJiB0aGlzLl9yZXNvbHV0aW9uICE9PSByZW5kZXJlci5yZXNvbHV0aW9uICYmICh0aGlzLl9yZXNvbHV0aW9uID0gcmVuZGVyZXIucmVzb2x1dGlvbiwgdGhpcy5kaXJ0eSA9ICEwKTtcbiAgICBjb25zdCB7IGRpc3RhbmNlRmllbGRSYW5nZSwgZGlzdGFuY2VGaWVsZFR5cGUsIHNpemUgfSA9IEJpdG1hcEZvbnQuQml0bWFwRm9udC5hdmFpbGFibGVbdGhpcy5fZm9udE5hbWVdO1xuICAgIGlmIChkaXN0YW5jZUZpZWxkVHlwZSAhPT0gXCJub25lXCIpIHtcbiAgICAgIGNvbnN0IHsgYSwgYiwgYywgZCB9ID0gdGhpcy53b3JsZFRyYW5zZm9ybSwgZHggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYiksIGR5ID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpLCB3b3JsZFNjYWxlID0gKE1hdGguYWJzKGR4KSArIE1hdGguYWJzKGR5KSkgLyAyLCBmb250U2NhbGUgPSB0aGlzLmZvbnRTaXplIC8gc2l6ZSwgcmVzb2x1dGlvbiA9IHJlbmRlcmVyLl92aWV3LnJlc29sdXRpb247XG4gICAgICBmb3IgKGNvbnN0IG1lc2gyIG9mIHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEpXG4gICAgICAgIG1lc2gyLm1lc2guc2hhZGVyLnVuaWZvcm1zLnVGV2lkdGggPSB3b3JsZFNjYWxlICogZGlzdGFuY2VGaWVsZFJhbmdlICogZm9udFNjYWxlICogcmVzb2x1dGlvbjtcbiAgICB9XG4gICAgc3VwZXIuX3JlbmRlcihyZW5kZXJlcik7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0ZXh0IGJlZm9yZSBjYWxsaW5nIHBhcmVudCdzIGdldExvY2FsQm91bmRzXG4gICAqIEByZXR1cm5zIC0gVGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWFcbiAgICovXG4gIGdldExvY2FsQm91bmRzKCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKCksIHN1cGVyLmdldExvY2FsQm91bmRzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGV4dCB3aGVuIG5lZWRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRhdGUoKSB7XG4gICAgY29uc3QgZm9udCA9IEJpdG1hcEZvbnQuQml0bWFwRm9udC5hdmFpbGFibGVbdGhpcy5fZm9udE5hbWVdO1xuICAgIGlmICghZm9udClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBCaXRtYXBGb250IFwiJHt0aGlzLl9mb250TmFtZX1cImApO1xuICAgIHRoaXMuX2ZvbnQgIT09IGZvbnQgJiYgKHRoaXMuZGlydHkgPSAhMCksIHRoaXMuZGlydHkgJiYgdGhpcy51cGRhdGVUZXh0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0aW50IG9mIHRoZSBCaXRtYXBUZXh0IG9iamVjdC5cbiAgICogQGRlZmF1bHQgMHhmZmZmZmZcbiAgICovXG4gIGdldCB0aW50KCkge1xuICAgIHJldHVybiB0aGlzLl90aW50Q29sb3IudmFsdWU7XG4gIH1cbiAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICBpZiAodGhpcy50aW50ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fdGludENvbG9yLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYWN0aXZlUGFnZXNNZXNoRGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAgdGhpcy5fYWN0aXZlUGFnZXNNZXNoRGF0YVtpXS5tZXNoLnRpbnQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbGlnbm1lbnQgb2YgdGhlIEJpdG1hcFRleHQgb2JqZWN0LlxuICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdsZWZ0J1xuICAgKi9cbiAgZ2V0IGFsaWduKCkge1xuICAgIHJldHVybiB0aGlzLl9hbGlnbjtcbiAgfVxuICBzZXQgYWxpZ24odmFsdWUpIHtcbiAgICB0aGlzLl9hbGlnbiAhPT0gdmFsdWUgJiYgKHRoaXMuX2FsaWduID0gdmFsdWUsIHRoaXMuZGlydHkgPSAhMCk7XG4gIH1cbiAgLyoqIFRoZSBuYW1lIG9mIHRoZSBCaXRtYXBGb250LiAqL1xuICBnZXQgZm9udE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnROYW1lO1xuICB9XG4gIHNldCBmb250TmFtZSh2YWx1ZSkge1xuICAgIGlmICghQml0bWFwRm9udC5CaXRtYXBGb250LmF2YWlsYWJsZVt2YWx1ZV0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgQml0bWFwRm9udCBcIiR7dmFsdWV9XCJgKTtcbiAgICB0aGlzLl9mb250TmFtZSAhPT0gdmFsdWUgJiYgKHRoaXMuX2ZvbnROYW1lID0gdmFsdWUsIHRoaXMuZGlydHkgPSAhMCk7XG4gIH1cbiAgLyoqIFRoZSBzaXplIG9mIHRoZSBmb250IHRvIGRpc3BsYXkuICovXG4gIGdldCBmb250U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFNpemUgPz8gQml0bWFwRm9udC5CaXRtYXBGb250LmF2YWlsYWJsZVt0aGlzLl9mb250TmFtZV0uc2l6ZTtcbiAgfVxuICBzZXQgZm9udFNpemUodmFsdWUpIHtcbiAgICB0aGlzLl9mb250U2l6ZSAhPT0gdmFsdWUgJiYgKHRoaXMuX2ZvbnRTaXplID0gdmFsdWUsIHRoaXMuZGlydHkgPSAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbmNob3Igc2V0cyB0aGUgb3JpZ2luIHBvaW50IG9mIHRoZSB0ZXh0LlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBpcyBgKDAsMClgLCB0aGlzIG1lYW5zIHRoZSB0ZXh0J3Mgb3JpZ2luIGlzIHRoZSB0b3AgbGVmdC5cbiAgICpcbiAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIGAoMC41LDAuNSlgIG1lYW5zIHRoZSB0ZXh0J3Mgb3JpZ2luIGlzIGNlbnRlcmVkLlxuICAgKlxuICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gYCgxLDEpYCB3b3VsZCBtZWFuIHRoZSB0ZXh0J3Mgb3JpZ2luIHBvaW50IHdpbGwgYmUgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIuXG4gICAqL1xuICBnZXQgYW5jaG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9hbmNob3I7XG4gIH1cbiAgc2V0IGFuY2hvcih2YWx1ZSkge1xuICAgIHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gdGhpcy5fYW5jaG9yLnNldCh2YWx1ZSkgOiB0aGlzLl9hbmNob3IuY29weUZyb20odmFsdWUpO1xuICB9XG4gIC8qKiBUaGUgdGV4dCBvZiB0aGUgQml0bWFwVGV4dCBvYmplY3QuICovXG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICB9XG4gIHNldCB0ZXh0KHRleHQpIHtcbiAgICB0ZXh0ID0gU3RyaW5nKHRleHQgPz8gXCJcIiksIHRoaXMuX3RleHQgIT09IHRleHQgJiYgKHRoaXMuX3RleHQgPSB0ZXh0LCB0aGlzLmRpcnR5ID0gITApO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWF4IHdpZHRoIG9mIHRoaXMgYml0bWFwIHRleHQgaW4gcGl4ZWxzLiBJZiB0aGUgdGV4dCBwcm92aWRlZCBpcyBsb25nZXIgdGhhbiB0aGVcbiAgICogdmFsdWUgcHJvdmlkZWQsIGxpbmUgYnJlYWtzIHdpbGwgYmUgYXV0b21hdGljYWxseSBpbnNlcnRlZCBpbiB0aGUgbGFzdCB3aGl0ZXNwYWNlLlxuICAgKiBEaXNhYmxlIGJ5IHNldHRpbmcgdGhlIHZhbHVlIHRvIDAuXG4gICAqL1xuICBnZXQgbWF4V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heFdpZHRoO1xuICB9XG4gIHNldCBtYXhXaWR0aCh2YWx1ZSkge1xuICAgIHRoaXMuX21heFdpZHRoICE9PSB2YWx1ZSAmJiAodGhpcy5fbWF4V2lkdGggPSB2YWx1ZSwgdGhpcy5kaXJ0eSA9ICEwKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1heCBsaW5lIGhlaWdodC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB0cnlpbmcgdG8gdXNlIHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIFRleHQsXG4gICAqIGkuZS4gd2hlbiB0cnlpbmcgdG8gdmVydGljYWxseSBhbGlnbi5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbWF4TGluZUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZSgpLCB0aGlzLl9tYXhMaW5lSGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGhlIG92ZXJhbGwgdGV4dCwgZGlmZmVyZW50IGZyb20gZm9udFNpemUsXG4gICAqIHdoaWNoIGlzIGRlZmluZWQgaW4gdGhlIHN0eWxlIG9iamVjdC5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdGV4dFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKCksIHRoaXMuX3RleHRXaWR0aDtcbiAgfVxuICAvKiogQWRkaXRpb25hbCBzcGFjZSBiZXR3ZWVuIGNoYXJhY3RlcnMuICovXG4gIGdldCBsZXR0ZXJTcGFjaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9sZXR0ZXJTcGFjaW5nO1xuICB9XG4gIHNldCBsZXR0ZXJTcGFjaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5fbGV0dGVyU3BhY2luZyAhPT0gdmFsdWUgJiYgKHRoaXMuX2xldHRlclNwYWNpbmcgPSB2YWx1ZSwgdGhpcy5kaXJ0eSA9ICEwKTtcbiAgfVxuICAvKipcbiAgICogSWYgdHJ1ZSBQaXhpSlMgd2lsbCBNYXRoLmZsb29yKCkgeC95IHZhbHVlcyB3aGVuIHJlbmRlcmluZywgc3RvcHBpbmcgcGl4ZWwgaW50ZXJwb2xhdGlvbi5cbiAgICogQWR2YW50YWdlcyBjYW4gaW5jbHVkZSBzaGFycGVyIGltYWdlIHF1YWxpdHkgKGxpa2UgdGV4dCkgYW5kIGZhc3RlciByZW5kZXJpbmcgb24gY2FudmFzLlxuICAgKiBUaGUgbWFpbiBkaXNhZHZhbnRhZ2UgaXMgbW92ZW1lbnQgb2Ygb2JqZWN0cyBtYXkgYXBwZWFyIGxlc3Mgc21vb3RoLlxuICAgKiBUbyBzZXQgdGhlIGdsb2JhbCBkZWZhdWx0LCBjaGFuZ2Uge0BsaW5rIFBJWEkuc2V0dGluZ3MuUk9VTkRfUElYRUxTfVxuICAgKiBAZGVmYXVsdCBQSVhJLnNldHRpbmdzLlJPVU5EX1BJWEVMU1xuICAgKi9cbiAgZ2V0IHJvdW5kUGl4ZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3VuZFBpeGVscztcbiAgfVxuICBzZXQgcm91bmRQaXhlbHModmFsdWUpIHtcbiAgICB2YWx1ZSAhPT0gdGhpcy5fcm91bmRQaXhlbHMgJiYgKHRoaXMuX3JvdW5kUGl4ZWxzID0gdmFsdWUsIHRoaXMuZGlydHkgPSAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBoZWlnaHQgb2YgdGhlIG92ZXJhbGwgdGV4dCwgZGlmZmVyZW50IGZyb20gZm9udFNpemUsXG4gICAqIHdoaWNoIGlzIGRlZmluZWQgaW4gdGhlIHN0eWxlIG9iamVjdC5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdGV4dEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZSgpLCB0aGlzLl90ZXh0SGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgY2FudmFzLlxuICAgKlxuICAgKiBUaGlzIGlzIHNldCB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIHRoZSByZW5kZXJlciByZXNvbHV0aW9uIGJ5IGRlZmF1bHQsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIG1hbnVhbGx5LlxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbjtcbiAgfVxuICBzZXQgcmVzb2x1dGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX2F1dG9SZXNvbHV0aW9uID0gITEsIHRoaXMuX3Jlc29sdXRpb24gIT09IHZhbHVlICYmICh0aGlzLl9yZXNvbHV0aW9uID0gdmFsdWUsIHRoaXMuZGlydHkgPSAhMCk7XG4gIH1cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBfdGV4dHVyZUNhY2hlIH0gPSB0aGlzLCBwYWdlTWVzaERhdGFQb29sID0gQml0bWFwRm9udC5CaXRtYXBGb250LmF2YWlsYWJsZVt0aGlzLl9mb250TmFtZV0uZGlzdGFuY2VGaWVsZFR5cGUgPT09IFwibm9uZVwiID8gcGFnZU1lc2hEYXRhRGVmYXVsdFBhZ2VNZXNoRGF0YSA6IHBhZ2VNZXNoRGF0YU1TREZQYWdlTWVzaERhdGE7XG4gICAgcGFnZU1lc2hEYXRhUG9vbC5wdXNoKC4uLnRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEpO1xuICAgIGZvciAoY29uc3QgcGFnZU1lc2hEYXRhIG9mIHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEpXG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKHBhZ2VNZXNoRGF0YS5tZXNoKTtcbiAgICB0aGlzLl9hY3RpdmVQYWdlc01lc2hEYXRhID0gW10sIHBhZ2VNZXNoRGF0YVBvb2wuZmlsdGVyKChwYWdlKSA9PiBfdGV4dHVyZUNhY2hlW3BhZ2UubWVzaC50ZXh0dXJlLmJhc2VUZXh0dXJlLnVpZF0pLmZvckVhY2goKHBhZ2UpID0+IHtcbiAgICAgIHBhZ2UubWVzaC50ZXh0dXJlID0gY29yZS5UZXh0dXJlLkVNUFRZO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3QgaWQgaW4gX3RleHR1cmVDYWNoZSlcbiAgICAgIF90ZXh0dXJlQ2FjaGVbaWRdLmRlc3Ryb3koKSwgZGVsZXRlIF90ZXh0dXJlQ2FjaGVbaWRdO1xuICAgIHRoaXMuX2ZvbnQgPSBudWxsLCB0aGlzLl90aW50Q29sb3IgPSBudWxsLCB0aGlzLl90ZXh0dXJlQ2FjaGUgPSBudWxsLCBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICB9XG59O1xuX0JpdG1hcFRleHQuc3R5bGVEZWZhdWx0cyA9IHtcbiAgYWxpZ246IFwibGVmdFwiLFxuICB0aW50OiAxNjc3NzIxNSxcbiAgbWF4V2lkdGg6IDAsXG4gIGxldHRlclNwYWNpbmc6IDBcbn07XG5sZXQgQml0bWFwVGV4dCA9IF9CaXRtYXBUZXh0O1xuZXhwb3J0cy5CaXRtYXBUZXh0ID0gQml0bWFwVGV4dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpdG1hcFRleHQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpdG1hcFRleHRTdHlsZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIEJpdG1hcEZvbnREYXRhID0gcmVxdWlyZShcIi4uL0JpdG1hcEZvbnREYXRhLmpzXCIpO1xuY2xhc3MgVGV4dEZvcm1hdCB7XG4gIC8qKlxuICAgKiBDaGVjayBpZiByZXNvdXJjZSByZWZlcnMgdG8gdHh0IGZvbnQgZGF0YS5cbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHJldHVybnMgLSBUcnVlIGlmIHJlc291cmNlIGNvdWxkIGJlIHRyZWF0ZWQgYXMgZm9udCBkYXRhLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBzdGF0aWMgdGVzdChkYXRhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIgJiYgZGF0YS5zdGFydHNXaXRoKFwiaW5mbyBmYWNlPVwiKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0ZXh0IGZvbnQgZGF0YSB0byBhIGphdmFzY3JpcHQgb2JqZWN0LlxuICAgKiBAcGFyYW0gdHh0IC0gUmF3IHN0cmluZyBkYXRhIHRvIGJlIGNvbnZlcnRlZFxuICAgKiBAcmV0dXJucyAtIFBhcnNlZCBmb250IGRhdGFcbiAgICovXG4gIHN0YXRpYyBwYXJzZSh0eHQpIHtcbiAgICBjb25zdCBpdGVtcyA9IHR4dC5tYXRjaCgvXlthLXpdK1xccysuKyQvZ20pLCByYXdEYXRhID0ge1xuICAgICAgaW5mbzogW10sXG4gICAgICBjb21tb246IFtdLFxuICAgICAgcGFnZTogW10sXG4gICAgICBjaGFyOiBbXSxcbiAgICAgIGNoYXJzOiBbXSxcbiAgICAgIGtlcm5pbmc6IFtdLFxuICAgICAga2VybmluZ3M6IFtdLFxuICAgICAgZGlzdGFuY2VGaWVsZDogW11cbiAgICB9O1xuICAgIGZvciAoY29uc3QgaSBpbiBpdGVtcykge1xuICAgICAgY29uc3QgbmFtZSA9IGl0ZW1zW2ldLm1hdGNoKC9eW2Etel0rL2dtKVswXSwgYXR0cmlidXRlTGlzdCA9IGl0ZW1zW2ldLm1hdGNoKC9bYS16QS1aXSs9KFteXFxzXCInXSt8XCIoW15cIl0qKVwiKS9nbSksIGl0ZW1EYXRhID0ge307XG4gICAgICBmb3IgKGNvbnN0IGkyIGluIGF0dHJpYnV0ZUxpc3QpIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBhdHRyaWJ1dGVMaXN0W2kyXS5zcGxpdChcIj1cIiksIGtleSA9IHNwbGl0WzBdLCBzdHJWYWx1ZSA9IHNwbGl0WzFdLnJlcGxhY2UoL1wiL2dtLCBcIlwiKSwgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQoc3RyVmFsdWUpLCB2YWx1ZSA9IGlzTmFOKGZsb2F0VmFsdWUpID8gc3RyVmFsdWUgOiBmbG9hdFZhbHVlO1xuICAgICAgICBpdGVtRGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByYXdEYXRhW25hbWVdLnB1c2goaXRlbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmb250ID0gbmV3IEJpdG1hcEZvbnREYXRhLkJpdG1hcEZvbnREYXRhKCk7XG4gICAgcmV0dXJuIHJhd0RhdGEuaW5mby5mb3JFYWNoKChpbmZvKSA9PiBmb250LmluZm8ucHVzaCh7XG4gICAgICBmYWNlOiBpbmZvLmZhY2UsXG4gICAgICBzaXplOiBwYXJzZUludChpbmZvLnNpemUsIDEwKVxuICAgIH0pKSwgcmF3RGF0YS5jb21tb24uZm9yRWFjaCgoY29tbW9uKSA9PiBmb250LmNvbW1vbi5wdXNoKHtcbiAgICAgIGxpbmVIZWlnaHQ6IHBhcnNlSW50KGNvbW1vbi5saW5lSGVpZ2h0LCAxMClcbiAgICB9KSksIHJhd0RhdGEucGFnZS5mb3JFYWNoKChwYWdlKSA9PiBmb250LnBhZ2UucHVzaCh7XG4gICAgICBpZDogcGFyc2VJbnQocGFnZS5pZCwgMTApLFxuICAgICAgZmlsZTogcGFnZS5maWxlXG4gICAgfSkpLCByYXdEYXRhLmNoYXIuZm9yRWFjaCgoY2hhcikgPT4gZm9udC5jaGFyLnB1c2goe1xuICAgICAgaWQ6IHBhcnNlSW50KGNoYXIuaWQsIDEwKSxcbiAgICAgIHBhZ2U6IHBhcnNlSW50KGNoYXIucGFnZSwgMTApLFxuICAgICAgeDogcGFyc2VJbnQoY2hhci54LCAxMCksXG4gICAgICB5OiBwYXJzZUludChjaGFyLnksIDEwKSxcbiAgICAgIHdpZHRoOiBwYXJzZUludChjaGFyLndpZHRoLCAxMCksXG4gICAgICBoZWlnaHQ6IHBhcnNlSW50KGNoYXIuaGVpZ2h0LCAxMCksXG4gICAgICB4b2Zmc2V0OiBwYXJzZUludChjaGFyLnhvZmZzZXQsIDEwKSxcbiAgICAgIHlvZmZzZXQ6IHBhcnNlSW50KGNoYXIueW9mZnNldCwgMTApLFxuICAgICAgeGFkdmFuY2U6IHBhcnNlSW50KGNoYXIueGFkdmFuY2UsIDEwKVxuICAgIH0pKSwgcmF3RGF0YS5rZXJuaW5nLmZvckVhY2goKGtlcm5pbmcpID0+IGZvbnQua2VybmluZy5wdXNoKHtcbiAgICAgIGZpcnN0OiBwYXJzZUludChrZXJuaW5nLmZpcnN0LCAxMCksXG4gICAgICBzZWNvbmQ6IHBhcnNlSW50KGtlcm5pbmcuc2Vjb25kLCAxMCksXG4gICAgICBhbW91bnQ6IHBhcnNlSW50KGtlcm5pbmcuYW1vdW50LCAxMClcbiAgICB9KSksIHJhd0RhdGEuZGlzdGFuY2VGaWVsZC5mb3JFYWNoKChkZikgPT4gZm9udC5kaXN0YW5jZUZpZWxkLnB1c2goe1xuICAgICAgZGlzdGFuY2VSYW5nZTogcGFyc2VJbnQoZGYuZGlzdGFuY2VSYW5nZSwgMTApLFxuICAgICAgZmllbGRUeXBlOiBkZi5maWVsZFR5cGVcbiAgICB9KSksIGZvbnQ7XG4gIH1cbn1cbmV4cG9ydHMuVGV4dEZvcm1hdCA9IFRleHRGb3JtYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0Rm9ybWF0LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQml0bWFwRm9udERhdGEgPSByZXF1aXJlKFwiLi4vQml0bWFwRm9udERhdGEuanNcIik7XG5jbGFzcyBYTUxGb3JtYXQge1xuICAvKipcbiAgICogQ2hlY2sgaWYgcmVzb3VyY2UgcmVmZXJzIHRvIHhtbCBmb250IGRhdGEuXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiByZXNvdXJjZSBjb3VsZCBiZSB0cmVhdGVkIGFzIGZvbnQgZGF0YSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIHRlc3QoZGF0YSkge1xuICAgIGNvbnN0IHhtbCA9IGRhdGE7XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhICE9IFwic3RyaW5nXCIgJiYgXCJnZXRFbGVtZW50c0J5VGFnTmFtZVwiIGluIGRhdGEgJiYgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFnZVwiKS5sZW5ndGggJiYgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5mb1wiKVswXS5nZXRBdHRyaWJ1dGUoXCJmYWNlXCIpICE9PSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBYTUwgaW50byBCaXRtYXBGb250RGF0YSB0aGF0IHdlIGNhbiB1c2UuXG4gICAqIEBwYXJhbSB4bWxcbiAgICogQHJldHVybnMgLSBEYXRhIHRvIHVzZSBmb3IgQml0bWFwRm9udFxuICAgKi9cbiAgc3RhdGljIHBhcnNlKHhtbCkge1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgQml0bWFwRm9udERhdGEuQml0bWFwRm9udERhdGEoKSwgaW5mbyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImluZm9cIiksIGNvbW1vbiA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNvbW1vblwiKSwgcGFnZSA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhZ2VcIiksIGNoYXIgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjaGFyXCIpLCBrZXJuaW5nID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwia2VybmluZ1wiKSwgZGlzdGFuY2VGaWVsZCA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpc3RhbmNlRmllbGRcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmZvLmxlbmd0aDsgaSsrKVxuICAgICAgZGF0YS5pbmZvLnB1c2goe1xuICAgICAgICBmYWNlOiBpbmZvW2ldLmdldEF0dHJpYnV0ZShcImZhY2VcIiksXG4gICAgICAgIHNpemU6IHBhcnNlSW50KGluZm9baV0uZ2V0QXR0cmlidXRlKFwic2l6ZVwiKSwgMTApXG4gICAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1vbi5sZW5ndGg7IGkrKylcbiAgICAgIGRhdGEuY29tbW9uLnB1c2goe1xuICAgICAgICBsaW5lSGVpZ2h0OiBwYXJzZUludChjb21tb25baV0uZ2V0QXR0cmlidXRlKFwibGluZUhlaWdodFwiKSwgMTApXG4gICAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2UubGVuZ3RoOyBpKyspXG4gICAgICBkYXRhLnBhZ2UucHVzaCh7XG4gICAgICAgIGlkOiBwYXJzZUludChwYWdlW2ldLmdldEF0dHJpYnV0ZShcImlkXCIpLCAxMCkgfHwgMCxcbiAgICAgICAgZmlsZTogcGFnZVtpXS5nZXRBdHRyaWJ1dGUoXCJmaWxlXCIpXG4gICAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxldHRlciA9IGNoYXJbaV07XG4gICAgICBkYXRhLmNoYXIucHVzaCh7XG4gICAgICAgIGlkOiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwiaWRcIiksIDEwKSxcbiAgICAgICAgcGFnZTogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcInBhZ2VcIiksIDEwKSB8fCAwLFxuICAgICAgICB4OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieFwiKSwgMTApLFxuICAgICAgICB5OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieVwiKSwgMTApLFxuICAgICAgICB3aWR0aDogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpLCAxMCksXG4gICAgICAgIGhlaWdodDogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSwgMTApLFxuICAgICAgICB4b2Zmc2V0OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieG9mZnNldFwiKSwgMTApLFxuICAgICAgICB5b2Zmc2V0OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieW9mZnNldFwiKSwgMTApLFxuICAgICAgICB4YWR2YW5jZTogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcInhhZHZhbmNlXCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5pbmcubGVuZ3RoOyBpKyspXG4gICAgICBkYXRhLmtlcm5pbmcucHVzaCh7XG4gICAgICAgIGZpcnN0OiBwYXJzZUludChrZXJuaW5nW2ldLmdldEF0dHJpYnV0ZShcImZpcnN0XCIpLCAxMCksXG4gICAgICAgIHNlY29uZDogcGFyc2VJbnQoa2VybmluZ1tpXS5nZXRBdHRyaWJ1dGUoXCJzZWNvbmRcIiksIDEwKSxcbiAgICAgICAgYW1vdW50OiBwYXJzZUludChrZXJuaW5nW2ldLmdldEF0dHJpYnV0ZShcImFtb3VudFwiKSwgMTApXG4gICAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpc3RhbmNlRmllbGQubGVuZ3RoOyBpKyspXG4gICAgICBkYXRhLmRpc3RhbmNlRmllbGQucHVzaCh7XG4gICAgICAgIGZpZWxkVHlwZTogZGlzdGFuY2VGaWVsZFtpXS5nZXRBdHRyaWJ1dGUoXCJmaWVsZFR5cGVcIiksXG4gICAgICAgIGRpc3RhbmNlUmFuZ2U6IHBhcnNlSW50KGRpc3RhbmNlRmllbGRbaV0uZ2V0QXR0cmlidXRlKFwiZGlzdGFuY2VSYW5nZVwiKSwgMTApXG4gICAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufVxuZXhwb3J0cy5YTUxGb3JtYXQgPSBYTUxGb3JtYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1YTUxGb3JtYXQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIFhNTEZvcm1hdCA9IHJlcXVpcmUoXCIuL1hNTEZvcm1hdC5qc1wiKTtcbmNsYXNzIFhNTFN0cmluZ0Zvcm1hdCB7XG4gIC8qKlxuICAgKiBDaGVjayBpZiByZXNvdXJjZSByZWZlcnMgdG8gdGV4dCB4bWwgZm9udCBkYXRhLlxuICAgKiBAcGFyYW0gZGF0YVxuICAgKiBAcmV0dXJucyAtIFRydWUgaWYgcmVzb3VyY2UgY291bGQgYmUgdHJlYXRlZCBhcyBmb250IGRhdGEsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyB0ZXN0KGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIiAmJiBkYXRhLmluY2x1ZGVzKFwiPGZvbnQ+XCIpID8gWE1MRm9ybWF0LlhNTEZvcm1hdC50ZXN0KGNvcmUuc2V0dGluZ3MuQURBUFRFUi5wYXJzZVhNTChkYXRhKSkgOiAhMTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0aGUgdGV4dCBYTUwgaW50byBCaXRtYXBGb250RGF0YSB0aGF0IHdlIGNhbiB1c2UuXG4gICAqIEBwYXJhbSB4bWxUeHRcbiAgICogQHJldHVybnMgLSBEYXRhIHRvIHVzZSBmb3IgQml0bWFwRm9udFxuICAgKi9cbiAgc3RhdGljIHBhcnNlKHhtbFR4dCkge1xuICAgIHJldHVybiBYTUxGb3JtYXQuWE1MRm9ybWF0LnBhcnNlKGNvcmUuc2V0dGluZ3MuQURBUFRFUi5wYXJzZVhNTCh4bWxUeHQpKTtcbiAgfVxufVxuZXhwb3J0cy5YTUxTdHJpbmdGb3JtYXQgPSBYTUxTdHJpbmdGb3JtYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1YTUxTdHJpbmdGb3JtYXQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBUZXh0Rm9ybWF0ID0gcmVxdWlyZShcIi4vVGV4dEZvcm1hdC5qc1wiKSwgWE1MRm9ybWF0ID0gcmVxdWlyZShcIi4vWE1MRm9ybWF0LmpzXCIpLCBYTUxTdHJpbmdGb3JtYXQgPSByZXF1aXJlKFwiLi9YTUxTdHJpbmdGb3JtYXQuanNcIik7XG5jb25zdCBmb3JtYXRzID0gW1xuICBUZXh0Rm9ybWF0LlRleHRGb3JtYXQsXG4gIFhNTEZvcm1hdC5YTUxGb3JtYXQsXG4gIFhNTFN0cmluZ0Zvcm1hdC5YTUxTdHJpbmdGb3JtYXRcbl07XG5mdW5jdGlvbiBhdXRvRGV0ZWN0Rm9ybWF0KGRhdGEpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXRzLmxlbmd0aDsgaSsrKVxuICAgIGlmIChmb3JtYXRzW2ldLnRlc3QoZGF0YSkpXG4gICAgICByZXR1cm4gZm9ybWF0c1tpXTtcbiAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLlRleHRGb3JtYXQgPSBUZXh0Rm9ybWF0LlRleHRGb3JtYXQ7XG5leHBvcnRzLlhNTEZvcm1hdCA9IFhNTEZvcm1hdC5YTUxGb3JtYXQ7XG5leHBvcnRzLlhNTFN0cmluZ0Zvcm1hdCA9IFhNTFN0cmluZ0Zvcm1hdC5YTUxTdHJpbmdGb3JtYXQ7XG5leHBvcnRzLmF1dG9EZXRlY3RGb3JtYXQgPSBhdXRvRGV0ZWN0Rm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBCaXRtYXBGb250ID0gcmVxdWlyZShcIi4vQml0bWFwRm9udC5qc1wiKSwgQml0bWFwRm9udERhdGEgPSByZXF1aXJlKFwiLi9CaXRtYXBGb250RGF0YS5qc1wiKSwgQml0bWFwVGV4dCA9IHJlcXVpcmUoXCIuL0JpdG1hcFRleHQuanNcIik7XG5yZXF1aXJlKFwiLi9CaXRtYXBUZXh0U3R5bGUuanNcIik7XG52YXIgaW5kZXggPSByZXF1aXJlKFwiLi9mb3JtYXRzL2luZGV4LmpzXCIpLCBsb2FkQml0bWFwRm9udCA9IHJlcXVpcmUoXCIuL2xvYWRCaXRtYXBGb250LmpzXCIpLCBUZXh0Rm9ybWF0ID0gcmVxdWlyZShcIi4vZm9ybWF0cy9UZXh0Rm9ybWF0LmpzXCIpLCBYTUxGb3JtYXQgPSByZXF1aXJlKFwiLi9mb3JtYXRzL1hNTEZvcm1hdC5qc1wiKSwgWE1MU3RyaW5nRm9ybWF0ID0gcmVxdWlyZShcIi4vZm9ybWF0cy9YTUxTdHJpbmdGb3JtYXQuanNcIik7XG5leHBvcnRzLkJpdG1hcEZvbnQgPSBCaXRtYXBGb250LkJpdG1hcEZvbnQ7XG5leHBvcnRzLkJpdG1hcEZvbnREYXRhID0gQml0bWFwRm9udERhdGEuQml0bWFwRm9udERhdGE7XG5leHBvcnRzLkJpdG1hcFRleHQgPSBCaXRtYXBUZXh0LkJpdG1hcFRleHQ7XG5leHBvcnRzLmF1dG9EZXRlY3RGb3JtYXQgPSBpbmRleC5hdXRvRGV0ZWN0Rm9ybWF0O1xuZXhwb3J0cy5sb2FkQml0bWFwRm9udCA9IGxvYWRCaXRtYXBGb250LmxvYWRCaXRtYXBGb250O1xuZXhwb3J0cy5UZXh0Rm9ybWF0ID0gVGV4dEZvcm1hdC5UZXh0Rm9ybWF0O1xuZXhwb3J0cy5YTUxGb3JtYXQgPSBYTUxGb3JtYXQuWE1MRm9ybWF0O1xuZXhwb3J0cy5YTUxTdHJpbmdGb3JtYXQgPSBYTUxTdHJpbmdGb3JtYXQuWE1MU3RyaW5nRm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBhc3NldHMgPSByZXF1aXJlKFwiQHBpeGkvYXNzZXRzXCIpLCBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIEJpdG1hcEZvbnQgPSByZXF1aXJlKFwiLi9CaXRtYXBGb250LmpzXCIpO1xucmVxdWlyZShcIi4vZm9ybWF0cy9pbmRleC5qc1wiKTtcbnZhciBUZXh0Rm9ybWF0ID0gcmVxdWlyZShcIi4vZm9ybWF0cy9UZXh0Rm9ybWF0LmpzXCIpLCBYTUxTdHJpbmdGb3JtYXQgPSByZXF1aXJlKFwiLi9mb3JtYXRzL1hNTFN0cmluZ0Zvcm1hdC5qc1wiKTtcbmNvbnN0IHZhbGlkRXh0ZW5zaW9ucyA9IFtcIi54bWxcIiwgXCIuZm50XCJdLCBsb2FkQml0bWFwRm9udCA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogY29yZS5FeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IGFzc2V0cy5Mb2FkZXJQYXJzZXJQcmlvcml0eS5Ob3JtYWxcbiAgfSxcbiAgbmFtZTogXCJsb2FkQml0bWFwRm9udFwiLFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiB2YWxpZEV4dGVuc2lvbnMuaW5jbHVkZXMoY29yZS51dGlscy5wYXRoLmV4dG5hbWUodXJsKS50b0xvd2VyQ2FzZSgpKTtcbiAgfSxcbiAgYXN5bmMgdGVzdFBhcnNlKGRhdGEpIHtcbiAgICByZXR1cm4gVGV4dEZvcm1hdC5UZXh0Rm9ybWF0LnRlc3QoZGF0YSkgfHwgWE1MU3RyaW5nRm9ybWF0LlhNTFN0cmluZ0Zvcm1hdC50ZXN0KGRhdGEpO1xuICB9LFxuICBhc3luYyBwYXJzZShhc3NldCwgZGF0YSwgbG9hZGVyKSB7XG4gICAgY29uc3QgZm9udERhdGEgPSBUZXh0Rm9ybWF0LlRleHRGb3JtYXQudGVzdChhc3NldCkgPyBUZXh0Rm9ybWF0LlRleHRGb3JtYXQucGFyc2UoYXNzZXQpIDogWE1MU3RyaW5nRm9ybWF0LlhNTFN0cmluZ0Zvcm1hdC5wYXJzZShhc3NldCksIHsgc3JjIH0gPSBkYXRhLCB7IHBhZ2U6IHBhZ2VzIH0gPSBmb250RGF0YSwgdGV4dHVyZVVybHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBwYWdlRmlsZSA9IHBhZ2VzW2ldLmZpbGU7XG4gICAgICBsZXQgaW1hZ2VQYXRoID0gY29yZS51dGlscy5wYXRoLmpvaW4oY29yZS51dGlscy5wYXRoLmRpcm5hbWUoc3JjKSwgcGFnZUZpbGUpO1xuICAgICAgaW1hZ2VQYXRoID0gYXNzZXRzLmNvcHlTZWFyY2hQYXJhbXMoaW1hZ2VQYXRoLCBzcmMpLCB0ZXh0dXJlVXJscy5wdXNoKGltYWdlUGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRlZFRleHR1cmVzID0gYXdhaXQgbG9hZGVyLmxvYWQodGV4dHVyZVVybHMpLCB0ZXh0dXJlcyA9IHRleHR1cmVVcmxzLm1hcCgodXJsKSA9PiBsb2FkZWRUZXh0dXJlc1t1cmxdKTtcbiAgICByZXR1cm4gQml0bWFwRm9udC5CaXRtYXBGb250Lmluc3RhbGwoZm9udERhdGEsIHRleHR1cmVzLCAhMCk7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBfb3B0aW9ucykge1xuICAgIHJldHVybiAoYXdhaXQgY29yZS5zZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCkpLnRleHQoKTtcbiAgfSxcbiAgdW5sb2FkKGJpdG1hcEZvbnQpIHtcbiAgICBiaXRtYXBGb250LmRlc3Ryb3koKTtcbiAgfVxufTtcbmNvcmUuZXh0ZW5zaW9ucy5hZGQobG9hZEJpdG1hcEZvbnQpO1xuZXhwb3J0cy5sb2FkQml0bWFwRm9udCA9IGxvYWRCaXRtYXBGb250O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZEJpdG1hcEZvbnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgbXNkZkZyYWcgPSBgLy8gUGl4aSB0ZXh0dXJlIGluZm9cXHJcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxyXG5cXHJcbi8vIFRpbnRcXHJcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxyXG5cXHJcbi8vIG9uIDJEIGFwcGxpY2F0aW9ucyBmd2lkdGggaXMgc2NyZWVuU2NhbGUgLyBnbHlwaEF0bGFzU2NhbGUgKiBkaXN0YW5jZUZpZWxkUmFuZ2VcXHJcbnVuaWZvcm0gZmxvYXQgdUZXaWR0aDtcXHJcblxcclxudm9pZCBtYWluKHZvaWQpIHtcXHJcblxcclxuICAvLyBUbyBzdGFjayBNU0RGIGFuZCBTREYgd2UgbmVlZCBhIG5vbi1wcmUtbXVsdGlwbGllZC1hbHBoYSB0ZXh0dXJlLlxcclxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcblxcclxuICAvLyBNU0RGXFxyXG4gIGZsb2F0IG1lZGlhbiA9IHRleENvbG9yLnIgKyB0ZXhDb2xvci5nICsgdGV4Q29sb3IuYiAtXFxyXG4gICAgICAgICAgICAgICAgICBtaW4odGV4Q29sb3IuciwgbWluKHRleENvbG9yLmcsIHRleENvbG9yLmIpKSAtXFxyXG4gICAgICAgICAgICAgICAgICBtYXgodGV4Q29sb3IuciwgbWF4KHRleENvbG9yLmcsIHRleENvbG9yLmIpKTtcXHJcbiAgLy8gU0RGXFxyXG4gIG1lZGlhbiA9IG1pbihtZWRpYW4sIHRleENvbG9yLmEpO1xcclxuXFxyXG4gIGZsb2F0IHNjcmVlblB4RGlzdGFuY2UgPSB1RldpZHRoICogKG1lZGlhbiAtIDAuNSk7XFxyXG4gIGZsb2F0IGFscGhhID0gY2xhbXAoc2NyZWVuUHhEaXN0YW5jZSArIDAuNSwgMC4wLCAxLjApO1xcclxuICBpZiAobWVkaWFuIDwgMC4wMSkge1xcclxuICAgIGFscGhhID0gMC4wO1xcclxuICB9IGVsc2UgaWYgKG1lZGlhbiA+IDAuOTkpIHtcXHJcbiAgICBhbHBoYSA9IDEuMDtcXHJcbiAgfVxcclxuXFxyXG4gIC8vIEdhbW1hIGNvcnJlY3Rpb24gZm9yIGNvdmVyYWdlLWxpa2UgYWxwaGFcXHJcbiAgZmxvYXQgbHVtYSA9IGRvdCh1Q29sb3IucmdiLCB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpKTtcXHJcbiAgZmxvYXQgZ2FtbWEgPSBtaXgoMS4wLCAxLjAgLyAyLjIsIGx1bWEpO1xcclxuICBmbG9hdCBjb3ZlcmFnZSA9IHBvdyh1Q29sb3IuYSAqIGFscGhhLCBnYW1tYSk7ICBcXHJcblxcclxuICAvLyBOUE0gVGV4dHVyZXMsIE5QTSBvdXRwdXRzXFxyXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQodUNvbG9yLnJnYiwgY292ZXJhZ2UpO1xcclxufVxcclxuYDtcbmV4cG9ydHMuZGVmYXVsdCA9IG1zZGZGcmFnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXNkZi5mcmFnLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIG1zZGZWZXJ0ID0gYC8vIE1lc2ggbWF0ZXJpYWwgZGVmYXVsdCBmcmFnbWVudFxcclxuYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXHJcblxcclxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxyXG51bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XFxyXG51bmlmb3JtIG1hdDMgdVRleHR1cmVNYXRyaXg7XFxyXG5cXHJcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxuXFxyXG52b2lkIG1haW4odm9pZClcXHJcbntcXHJcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcclxuXFxyXG4gICAgdlRleHR1cmVDb29yZCA9ICh1VGV4dHVyZU1hdHJpeCAqIHZlYzMoYVRleHR1cmVDb29yZCwgMS4wKSkueHk7XFxyXG59XFxyXG5gO1xuZXhwb3J0cy5kZWZhdWx0ID0gbXNkZlZlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tc2RmLnZlcnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIGdlbmVyYXRlRmlsbFN0eWxlID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVGaWxsU3R5bGUuanNcIik7XG5mdW5jdGlvbiBkcmF3R2x5cGgoY2FudmFzLCBjb250ZXh0LCBtZXRyaWNzLCB4LCB5LCByZXNvbHV0aW9uLCBzdHlsZSkge1xuICBjb25zdCBjaGFyID0gbWV0cmljcy50ZXh0LCBmb250UHJvcGVydGllcyA9IG1ldHJpY3MuZm9udFByb3BlcnRpZXM7XG4gIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpLCBjb250ZXh0LnNjYWxlKHJlc29sdXRpb24sIHJlc29sdXRpb24pO1xuICBjb25zdCB0eCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAvIDIsIHR5ID0gLShzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyKTtcbiAgaWYgKGNvbnRleHQuZm9udCA9IHN0eWxlLnRvRm9udFN0cmluZygpLCBjb250ZXh0LmxpbmVXaWR0aCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcywgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmUsIGNvbnRleHQubGluZUpvaW4gPSBzdHlsZS5saW5lSm9pbiwgY29udGV4dC5taXRlckxpbWl0ID0gc3R5bGUubWl0ZXJMaW1pdCwgY29udGV4dC5maWxsU3R5bGUgPSBnZW5lcmF0ZUZpbGxTdHlsZS5nZW5lcmF0ZUZpbGxTdHlsZShjYW52YXMsIGNvbnRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBbY2hhcl0sIG1ldHJpY3MpLCBjb250ZXh0LnN0cm9rZVN0eWxlID0gc3R5bGUuc3Ryb2tlLCBzdHlsZS5kcm9wU2hhZG93KSB7XG4gICAgY29uc3QgZHJvcFNoYWRvd0NvbG9yID0gc3R5bGUuZHJvcFNoYWRvd0NvbG9yLCBkcm9wU2hhZG93Qmx1ciA9IHN0eWxlLmRyb3BTaGFkb3dCbHVyICogcmVzb2x1dGlvbiwgZHJvcFNoYWRvd0Rpc3RhbmNlID0gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlICogcmVzb2x1dGlvbjtcbiAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gY29yZS5Db2xvci5zaGFyZWQuc2V0VmFsdWUoZHJvcFNoYWRvd0NvbG9yKS5zZXRBbHBoYShzdHlsZS5kcm9wU2hhZG93QWxwaGEpLnRvUmdiYVN0cmluZygpLCBjb250ZXh0LnNoYWRvd0JsdXIgPSBkcm9wU2hhZG93Qmx1ciwgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gTWF0aC5jb3Moc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZSwgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gTWF0aC5zaW4oc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgfSBlbHNlXG4gICAgY29udGV4dC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIiwgY29udGV4dC5zaGFkb3dCbHVyID0gMCwgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMCwgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgc3R5bGUuc3Ryb2tlICYmIHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAmJiBjb250ZXh0LnN0cm9rZVRleHQoY2hhciwgdHgsIHR5ICsgbWV0cmljcy5saW5lSGVpZ2h0IC0gZm9udFByb3BlcnRpZXMuZGVzY2VudCksIHN0eWxlLmZpbGwgJiYgY29udGV4dC5maWxsVGV4dChjaGFyLCB0eCwgdHkgKyBtZXRyaWNzLmxpbmVIZWlnaHQgLSBmb250UHJvcGVydGllcy5kZXNjZW50KSwgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCksIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDApXCI7XG59XG5leHBvcnRzLmRyYXdHbHlwaCA9IGRyYXdHbHlwaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYXdHbHlwaC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZXh0cmFjdENoYXJDb2RlKHN0cikge1xuICByZXR1cm4gc3RyLmNvZGVQb2ludEF0ID8gc3RyLmNvZGVQb2ludEF0KDApIDogc3RyLmNoYXJDb2RlQXQoMCk7XG59XG5leHBvcnRzLmV4dHJhY3RDaGFyQ29kZSA9IGV4dHJhY3RDaGFyQ29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RDaGFyQ29kZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHRleHQgPSByZXF1aXJlKFwiQHBpeGkvdGV4dFwiKTtcbmZ1bmN0aW9uIGdlbmVyYXRlRmlsbFN0eWxlKGNhbnZhcywgY29udGV4dCwgc3R5bGUsIHJlc29sdXRpb24sIGxpbmVzLCBtZXRyaWNzKSB7XG4gIGNvbnN0IGZpbGxTdHlsZSA9IHN0eWxlLmZpbGw7XG4gIGlmIChBcnJheS5pc0FycmF5KGZpbGxTdHlsZSkpIHtcbiAgICBpZiAoZmlsbFN0eWxlLmxlbmd0aCA9PT0gMSlcbiAgICAgIHJldHVybiBmaWxsU3R5bGVbMF07XG4gIH0gZWxzZVxuICAgIHJldHVybiBmaWxsU3R5bGU7XG4gIGxldCBncmFkaWVudDtcbiAgY29uc3QgZHJvcFNoYWRvd0NvcnJlY3Rpb24gPSBzdHlsZS5kcm9wU2hhZG93ID8gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlIDogMCwgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcgfHwgMCwgd2lkdGggPSBjYW52YXMud2lkdGggLyByZXNvbHV0aW9uIC0gZHJvcFNoYWRvd0NvcnJlY3Rpb24gLSBwYWRkaW5nICogMiwgaGVpZ2h0ID0gY2FudmFzLmhlaWdodCAvIHJlc29sdXRpb24gLSBkcm9wU2hhZG93Q29ycmVjdGlvbiAtIHBhZGRpbmcgKiAyLCBmaWxsID0gZmlsbFN0eWxlLnNsaWNlKCksIGZpbGxHcmFkaWVudFN0b3BzID0gc3R5bGUuZmlsbEdyYWRpZW50U3RvcHMuc2xpY2UoKTtcbiAgaWYgKCFmaWxsR3JhZGllbnRTdG9wcy5sZW5ndGgpIHtcbiAgICBjb25zdCBsZW5ndGhQbHVzMSA9IGZpbGwubGVuZ3RoICsgMTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aFBsdXMxOyArK2kpXG4gICAgICBmaWxsR3JhZGllbnRTdG9wcy5wdXNoKGkgLyBsZW5ndGhQbHVzMSk7XG4gIH1cbiAgaWYgKGZpbGwudW5zaGlmdChmaWxsU3R5bGVbMF0pLCBmaWxsR3JhZGllbnRTdG9wcy51bnNoaWZ0KDApLCBmaWxsLnB1c2goZmlsbFN0eWxlW2ZpbGxTdHlsZS5sZW5ndGggLSAxXSksIGZpbGxHcmFkaWVudFN0b3BzLnB1c2goMSksIHN0eWxlLmZpbGxHcmFkaWVudFR5cGUgPT09IHRleHQuVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwpIHtcbiAgICBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQod2lkdGggLyAyLCBwYWRkaW5nLCB3aWR0aCAvIDIsIGhlaWdodCArIHBhZGRpbmcpO1xuICAgIGxldCBsYXN0SXRlcmF0aW9uU3RvcCA9IDA7XG4gICAgY29uc3QgZ3JhZFN0b3BMaW5lSGVpZ2h0ID0gKG1ldHJpY3MuZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHlsZS5zdHJva2VUaGlja25lc3MpIC8gaGVpZ2h0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRoaXNMaW5lVG9wID0gbWV0cmljcy5saW5lSGVpZ2h0ICogaTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmlsbC5sZW5ndGg7IGorKykge1xuICAgICAgICBsZXQgbGluZVN0b3AgPSAwO1xuICAgICAgICB0eXBlb2YgZmlsbEdyYWRpZW50U3RvcHNbal0gPT0gXCJudW1iZXJcIiA/IGxpbmVTdG9wID0gZmlsbEdyYWRpZW50U3RvcHNbal0gOiBsaW5lU3RvcCA9IGogLyBmaWxsLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZ2xvYmFsU3RvcCA9IHRoaXNMaW5lVG9wIC8gaGVpZ2h0ICsgbGluZVN0b3AgKiBncmFkU3RvcExpbmVIZWlnaHQ7XG4gICAgICAgIGxldCBjbGFtcGVkU3RvcCA9IE1hdGgubWF4KGxhc3RJdGVyYXRpb25TdG9wLCBnbG9iYWxTdG9wKTtcbiAgICAgICAgY2xhbXBlZFN0b3AgPSBNYXRoLm1pbihjbGFtcGVkU3RvcCwgMSksIGdyYWRpZW50LmFkZENvbG9yU3RvcChjbGFtcGVkU3RvcCwgZmlsbFtqXSksIGxhc3RJdGVyYXRpb25TdG9wID0gY2xhbXBlZFN0b3A7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChwYWRkaW5nLCBoZWlnaHQgLyAyLCB3aWR0aCArIHBhZGRpbmcsIGhlaWdodCAvIDIpO1xuICAgIGNvbnN0IHRvdGFsSXRlcmF0aW9ucyA9IGZpbGwubGVuZ3RoICsgMTtcbiAgICBsZXQgY3VycmVudEl0ZXJhdGlvbiA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc3RvcDtcbiAgICAgIHR5cGVvZiBmaWxsR3JhZGllbnRTdG9wc1tpXSA9PSBcIm51bWJlclwiID8gc3RvcCA9IGZpbGxHcmFkaWVudFN0b3BzW2ldIDogc3RvcCA9IGN1cnJlbnRJdGVyYXRpb24gLyB0b3RhbEl0ZXJhdGlvbnMsIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLCBmaWxsW2ldKSwgY3VycmVudEl0ZXJhdGlvbisrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ3JhZGllbnQ7XG59XG5leHBvcnRzLmdlbmVyYXRlRmlsbFN0eWxlID0gZ2VuZXJhdGVGaWxsU3R5bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZUZpbGxTdHlsZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGRyYXdHbHlwaCA9IHJlcXVpcmUoXCIuL2RyYXdHbHlwaC5qc1wiKSwgZXh0cmFjdENoYXJDb2RlID0gcmVxdWlyZShcIi4vZXh0cmFjdENoYXJDb2RlLmpzXCIpLCBnZW5lcmF0ZUZpbGxTdHlsZSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlRmlsbFN0eWxlLmpzXCIpLCByZXNvbHZlQ2hhcmFjdGVycyA9IHJlcXVpcmUoXCIuL3Jlc29sdmVDaGFyYWN0ZXJzLmpzXCIpLCBzcGxpdFRleHRUb0NoYXJhY3RlcnMgPSByZXF1aXJlKFwiLi9zcGxpdFRleHRUb0NoYXJhY3RlcnMuanNcIik7XG5leHBvcnRzLmRyYXdHbHlwaCA9IGRyYXdHbHlwaC5kcmF3R2x5cGg7XG5leHBvcnRzLmV4dHJhY3RDaGFyQ29kZSA9IGV4dHJhY3RDaGFyQ29kZS5leHRyYWN0Q2hhckNvZGU7XG5leHBvcnRzLmdlbmVyYXRlRmlsbFN0eWxlID0gZ2VuZXJhdGVGaWxsU3R5bGUuZ2VuZXJhdGVGaWxsU3R5bGU7XG5leHBvcnRzLnJlc29sdmVDaGFyYWN0ZXJzID0gcmVzb2x2ZUNoYXJhY3RlcnMucmVzb2x2ZUNoYXJhY3RlcnM7XG5leHBvcnRzLnNwbGl0VGV4dFRvQ2hhcmFjdGVycyA9IHNwbGl0VGV4dFRvQ2hhcmFjdGVycy5zcGxpdFRleHRUb0NoYXJhY3RlcnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHNwbGl0VGV4dFRvQ2hhcmFjdGVycyA9IHJlcXVpcmUoXCIuL3NwbGl0VGV4dFRvQ2hhcmFjdGVycy5qc1wiKTtcbmZ1bmN0aW9uIHJlc29sdmVDaGFyYWN0ZXJzKGNoYXJzKSB7XG4gIHR5cGVvZiBjaGFycyA9PSBcInN0cmluZ1wiICYmIChjaGFycyA9IFtjaGFyc10pO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBjaGFycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBjb25zdCBpdGVtID0gY2hhcnNbaV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgIGlmIChpdGVtLmxlbmd0aCAhPT0gMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbQml0bWFwRm9udF06IEludmFsaWQgY2hhcmFjdGVyIHJhbmdlIGxlbmd0aCwgZXhwZWN0aW5nIDIgZ290ICR7aXRlbS5sZW5ndGh9LmApO1xuICAgICAgY29uc3Qgc3RhcnRDb2RlID0gaXRlbVswXS5jaGFyQ29kZUF0KDApLCBlbmRDb2RlID0gaXRlbVsxXS5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGVuZENvZGUgPCBzdGFydENvZGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltCaXRtYXBGb250XTogSW52YWxpZCBjaGFyYWN0ZXIgcmFuZ2UuXCIpO1xuICAgICAgZm9yIChsZXQgaTIgPSBzdGFydENvZGUsIGoyID0gZW5kQ29kZTsgaTIgPD0gajI7IGkyKyspXG4gICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaTIpKTtcbiAgICB9IGVsc2VcbiAgICAgIHJlc3VsdC5wdXNoKC4uLnNwbGl0VGV4dFRvQ2hhcmFjdGVycy5zcGxpdFRleHRUb0NoYXJhY3RlcnMoaXRlbSkpO1xuICB9XG4gIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIltCaXRtYXBGb250XTogRW1wdHkgc2V0IHdoZW4gcmVzb2x2aW5nIGNoYXJhY3RlcnMuXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5yZXNvbHZlQ2hhcmFjdGVycyA9IHJlc29sdmVDaGFyYWN0ZXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZUNoYXJhY3RlcnMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHNwbGl0VGV4dFRvQ2hhcmFjdGVycyh0ZXh0KSB7XG4gIHJldHVybiBBcnJheS5mcm9tID8gQXJyYXkuZnJvbSh0ZXh0KSA6IHRleHQuc3BsaXQoXCJcIik7XG59XG5leHBvcnRzLnNwbGl0VGV4dFRvQ2hhcmFjdGVycyA9IHNwbGl0VGV4dFRvQ2hhcmFjdGVycztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwbGl0VGV4dFRvQ2hhcmFjdGVycy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgc3ByaXRlID0gcmVxdWlyZShcIkBwaXhpL3Nwcml0ZVwiKSwgdGV4dCA9IHJlcXVpcmUoXCJAcGl4aS90ZXh0XCIpLCBIVE1MVGV4dFN0eWxlID0gcmVxdWlyZShcIi4vSFRNTFRleHRTdHlsZS5qc1wiKTtcbmNvbnN0IF9IVE1MVGV4dCA9IGNsYXNzIF9IVE1MVGV4dDIgZXh0ZW5kcyBzcHJpdGUuU3ByaXRlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dF0gLSBUZXh0IGNvbnRlbnRzXG4gICAqIEBwYXJhbSB7UElYSS5IVE1MVGV4dFN0eWxlfFBJWEkuVGV4dFN0eWxlfFBJWEkuSVRleHRTdHlsZX0gW3N0eWxlXSAtIFN0eWxlIHNldHRpbmcgdG8gdXNlLlxuICAgKiAgICAgICAgU3Ryb25nbHkgcmVjb21tZW5kIHVzaW5nIGFuIEhUTUxUZXh0U3R5bGUgb2JqZWN0LiBQcm92aWRpbmcgYSBQSVhJLlRleHRTdHlsZVxuICAgKiAgICAgICAgd2lsbCBjb252ZXJ0IHRoZSBUZXh0U3R5bGUgdG8gYW4gSFRNTFRleHRTdHlsZSBhbmQgd2lsbCBubyBsb25nZXIgYmUgbGlua2VkLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4dDIgPSBcIlwiLCBzdHlsZSA9IHt9KSB7XG4gICAgc3VwZXIoY29yZS5UZXh0dXJlLkVNUFRZKSwgdGhpcy5fdGV4dCA9IG51bGwsIHRoaXMuX3N0eWxlID0gbnVsbCwgdGhpcy5fYXV0b1Jlc29sdXRpb24gPSAhMCwgdGhpcy5sb2NhbFN0eWxlSUQgPSAtMSwgdGhpcy5kaXJ0eSA9ICExLCB0aGlzLl91cGRhdGVJRCA9IDAsIHRoaXMub3duc1N0eWxlID0gITE7XG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKSwgdGV4dHVyZSA9IGNvcmUuVGV4dHVyZS5mcm9tKGltYWdlLCB7XG4gICAgICBzY2FsZU1vZGU6IGNvcmUuc2V0dGluZ3MuU0NBTEVfTU9ERSxcbiAgICAgIHJlc291cmNlT3B0aW9uczoge1xuICAgICAgICBhdXRvTG9hZDogITFcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0ZXh0dXJlLm9yaWcgPSBuZXcgY29yZS5SZWN0YW5nbGUoKSwgdGV4dHVyZS50cmltID0gbmV3IGNvcmUuUmVjdGFuZ2xlKCksIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgY29uc3QgbnNzdmcgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIG5zeGh0bWwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgc3ZnUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuc3N2ZywgXCJzdmdcIiksIGZvcmVpZ25PYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnNzdmcsIFwiZm9yZWlnbk9iamVjdFwiKSwgZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuc3hodG1sLCBcImRpdlwiKSwgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zeGh0bWwsIFwic3R5bGVcIik7XG4gICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjEwMDAwXCIpLCBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjEwMDAwXCIpLCBmb3JlaWduT2JqZWN0LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIiwgc3ZnUm9vdC5hcHBlbmRDaGlsZChmb3JlaWduT2JqZWN0KSwgdGhpcy5tYXhXaWR0aCA9IF9IVE1MVGV4dDIuZGVmYXVsdE1heFdpZHRoLCB0aGlzLm1heEhlaWdodCA9IF9IVE1MVGV4dDIuZGVmYXVsdE1heEhlaWdodCwgdGhpcy5fZG9tRWxlbWVudCA9IGRvbUVsZW1lbnQsIHRoaXMuX3N0eWxlRWxlbWVudCA9IHN0eWxlRWxlbWVudCwgdGhpcy5fc3ZnUm9vdCA9IHN2Z1Jvb3QsIHRoaXMuX2ZvcmVpZ25PYmplY3QgPSBmb3JlaWduT2JqZWN0LCB0aGlzLl9mb3JlaWduT2JqZWN0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCksIHRoaXMuX2ZvcmVpZ25PYmplY3QuYXBwZW5kQ2hpbGQoZG9tRWxlbWVudCksIHRoaXMuX2ltYWdlID0gaW1hZ2UsIHRoaXMuX2xvYWRJbWFnZSA9IG5ldyBJbWFnZSgpLCB0aGlzLl9hdXRvUmVzb2x1dGlvbiA9IF9IVE1MVGV4dDIuZGVmYXVsdEF1dG9SZXNvbHV0aW9uLCB0aGlzLl9yZXNvbHV0aW9uID0gX0hUTUxUZXh0Mi5kZWZhdWx0UmVzb2x1dGlvbiA/PyBjb3JlLnNldHRpbmdzLlJFU09MVVRJT04sIHRoaXMudGV4dCA9IHRleHQyLCB0aGlzLnN0eWxlID0gc3R5bGU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgc2l6ZSBvZiB0aGUgb3V0cHV0IHRleHQgd2l0aG91dCBhY3R1YWxseSBkcmF3aW5nIGl0LlxuICAgKiBUaGlzIGluY2x1ZGVzIHRoZSBgcGFkZGluZ2AgaW4gdGhlIGBzdHlsZWAgb2JqZWN0LlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIGFzIGEgZmFzdC1wYXNzIHRvIGRvIHRoaW5ncyBsaWtlIHRleHQtZml0dGluZy5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvdmVycmlkZXNdIC0gT3ZlcnJpZGVzIGZvciB0aGUgdGV4dCwgc3R5bGUsIGFuZCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW292ZXJyaWRlcy50ZXh0XSAtIFRoZSB0ZXh0IHRvIG1lYXN1cmUsIGlmIG5vdCBzcGVjaWZpZWQsIHRoZSBjdXJyZW50IHRleHQgaXMgdXNlZC5cbiAgICogQHBhcmFtIHtQSVhJLkhUTUxUZXh0U3R5bGV9IFtvdmVycmlkZXMuc3R5bGVdIC0gVGhlIHN0eWxlIHRvIG1lYXN1cmUsIGlmIG5vdCBzcGVjaWZpZWQsIHRoZSBjdXJyZW50IHN0eWxlIGlzIHVzZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3ZlcnJpZGVzLnJlc29sdXRpb25dIC0gVGhlIHJlc29sdXRpb24gdG8gbWVhc3VyZSwgaWYgbm90IHNwZWNpZmllZCwgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBpcyB1c2VkLlxuICAgKiBAcmV0dXJucyB7UElYSS5JU2l6ZX0gV2lkdGggYW5kIGhlaWdodCBvZiB0aGUgbWVhc3VyZWQgdGV4dC5cbiAgICovXG4gIG1lYXN1cmVUZXh0KG92ZXJyaWRlcykge1xuICAgIGNvbnN0IHsgdGV4dDogdGV4dDIsIHN0eWxlLCByZXNvbHV0aW9uIH0gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHRleHQ6IHRoaXMuX3RleHQsXG4gICAgICBzdHlsZTogdGhpcy5fc3R5bGUsXG4gICAgICByZXNvbHV0aW9uOiB0aGlzLl9yZXNvbHV0aW9uXG4gICAgfSwgb3ZlcnJpZGVzKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX2RvbUVsZW1lbnQsIHtcbiAgICAgIGlubmVySFRNTDogdGV4dDIsXG4gICAgICBzdHlsZTogc3R5bGUudG9DU1MocmVzb2x1dGlvbilcbiAgICB9KSwgdGhpcy5fc3R5bGVFbGVtZW50LnRleHRDb250ZW50ID0gc3R5bGUudG9HbG9iYWxDU1MoKSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9zdmdSb290KTtcbiAgICBjb25zdCBjb250ZW50Qm91bmRzID0gdGhpcy5fZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0aGlzLl9zdmdSb290LnJlbW92ZSgpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY29udGVudEJvdW5kcztcbiAgICAod2lkdGggPiB0aGlzLm1heFdpZHRoIHx8IGhlaWdodCA+IHRoaXMubWF4SGVpZ2h0KSAmJiBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRdIExhcmdlIGV4cGFuc2Ugb2YgdGV4dCwgaW5jcmVhc2UgSFRNTFRleHQubWF4V2lkdGggb3IgSFRNTFRleHQubWF4SGVpZ2h0IHByb3BlcnR5LlwiKTtcbiAgICBjb25zdCBjb250ZW50V2lkdGggPSBNYXRoLm1pbih0aGlzLm1heFdpZHRoLCBNYXRoLmNlaWwod2lkdGgpKSwgY29udGVudEhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBNYXRoLmNlaWwoaGVpZ2h0KSk7XG4gICAgcmV0dXJuIHRoaXMuX3N2Z1Jvb3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgY29udGVudFdpZHRoLnRvU3RyaW5nKCkpLCB0aGlzLl9zdmdSb290LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBjb250ZW50SGVpZ2h0LnRvU3RyaW5nKCkpLCB0ZXh0MiAhPT0gdGhpcy5fdGV4dCAmJiAodGhpcy5fZG9tRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl90ZXh0KSwgc3R5bGUgIT09IHRoaXMuX3N0eWxlICYmIChPYmplY3QuYXNzaWduKHRoaXMuX2RvbUVsZW1lbnQsIHsgc3R5bGU6IHRoaXMuX3N0eWxlPy50b0NTUyhyZXNvbHV0aW9uKSB9KSwgdGhpcy5fc3R5bGVFbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5fc3R5bGU/LnRvR2xvYmFsQ1NTKCkpLCB7XG4gICAgICB3aWR0aDogY29udGVudFdpZHRoICsgc3R5bGUucGFkZGluZyAqIDIsXG4gICAgICBoZWlnaHQ6IGNvbnRlbnRIZWlnaHQgKyBzdHlsZS5wYWRkaW5nICogMlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1hbnVhbGx5IHJlZnJlc2ggdGhlIHRleHQuXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtib29sZWFufSByZXNwZWN0RGlydHkgLSBXaGV0aGVyIHRvIGFib3J0IHVwZGF0aW5nIHRoZVxuICAgKiAgICAgICAgdGV4dCBpZiB0aGUgVGV4dCBpc24ndCBkaXJ0eSBhbmQgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVRleHQocmVzcGVjdERpcnR5ID0gITApIHtcbiAgICBjb25zdCB7IHN0eWxlLCBfaW1hZ2U6IGltYWdlLCBfbG9hZEltYWdlOiBsb2FkSW1hZ2UgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMubG9jYWxTdHlsZUlEICE9PSBzdHlsZS5zdHlsZUlEICYmICh0aGlzLmRpcnR5ID0gITAsIHRoaXMubG9jYWxTdHlsZUlEID0gc3R5bGUuc3R5bGVJRCksICF0aGlzLmRpcnR5ICYmIHJlc3BlY3REaXJ0eSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMubWVhc3VyZVRleHQoKTtcbiAgICBpbWFnZS53aWR0aCA9IGxvYWRJbWFnZS53aWR0aCA9IE1hdGguY2VpbChNYXRoLm1heCgxLCB3aWR0aCkpLCBpbWFnZS5oZWlnaHQgPSBsb2FkSW1hZ2UuaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubWF4KDEsIGhlaWdodCkpLCB0aGlzLl91cGRhdGVJRCsrO1xuICAgIGNvbnN0IHVwZGF0ZUlEID0gdGhpcy5fdXBkYXRlSUQ7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxvYWRJbWFnZS5vbmxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICh1cGRhdGVJRCA8IHRoaXMuX3VwZGF0ZUlEKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzdHlsZS5vbkJlZm9yZURyYXcoKSwgaW1hZ2Uuc3JjID0gbG9hZEltYWdlLnNyYywgbG9hZEltYWdlLm9ubG9hZCA9IG51bGwsIGxvYWRJbWFnZS5zcmMgPSBcIlwiLCB0aGlzLnVwZGF0ZVRleHR1cmUoKSwgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHN2Z1VSTCA9IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcodGhpcy5fc3ZnUm9vdCk7XG4gICAgICBsb2FkSW1hZ2Uuc3JjID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0ZjgsJHtlbmNvZGVVUklDb21wb25lbnQoc3ZnVVJMKX1gO1xuICAgIH0pO1xuICB9XG4gIC8qKiBUaGUgcmF3IGltYWdlIGVsZW1lbnQgdGhhdCBpcyByZW5kZXJlZCB1bmRlci10aGUtaG9vZC4gKi9cbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW1hZ2U7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgdGV4dHVyZSByZXNvdXJjZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVRleHR1cmUoKSB7XG4gICAgY29uc3QgeyBzdHlsZSwgdGV4dHVyZSwgX2ltYWdlOiBpbWFnZSwgcmVzb2x1dGlvbiB9ID0gdGhpcywgeyBwYWRkaW5nIH0gPSBzdHlsZSwgeyBiYXNlVGV4dHVyZSB9ID0gdGV4dHVyZTtcbiAgICB0ZXh0dXJlLnRyaW0ud2lkdGggPSB0ZXh0dXJlLl9mcmFtZS53aWR0aCA9IGltYWdlLndpZHRoIC8gcmVzb2x1dGlvbiwgdGV4dHVyZS50cmltLmhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCA9IGltYWdlLmhlaWdodCAvIHJlc29sdXRpb24sIHRleHR1cmUudHJpbS54ID0gLXBhZGRpbmcsIHRleHR1cmUudHJpbS55ID0gLXBhZGRpbmcsIHRleHR1cmUub3JpZy53aWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoIC0gcGFkZGluZyAqIDIsIHRleHR1cmUub3JpZy5oZWlnaHQgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgLSBwYWRkaW5nICogMiwgdGhpcy5fb25UZXh0dXJlVXBkYXRlKCksIGJhc2VUZXh0dXJlLnNldFJlYWxTaXplKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIHJlc29sdXRpb24pLCB0aGlzLmRpcnR5ID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24gJiYgKHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uLCB0aGlzLmRpcnR5ID0gITApLCB0aGlzLnVwZGF0ZVRleHQoITApLCBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgUmVuZGVyZXIuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UElYSS5DYW52YXNSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICovXG4gIF9yZW5kZXJDYW52YXMocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9hdXRvUmVzb2x1dGlvbiAmJiB0aGlzLl9yZXNvbHV0aW9uICE9PSByZW5kZXJlci5yZXNvbHV0aW9uICYmICh0aGlzLl9yZXNvbHV0aW9uID0gcmVuZGVyZXIucmVzb2x1dGlvbiwgdGhpcy5kaXJ0eSA9ICEwKSwgdGhpcy51cGRhdGVUZXh0KCEwKSwgc3VwZXIuX3JlbmRlckNhbnZhcyhyZW5kZXJlcik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9jYWwgYm91bmRzLlxuICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSByZWN0IC0gSW5wdXQgcmVjdGFuZ2xlLlxuICAgKiBAcmV0dXJucyB7UElYSS5SZWN0YW5nbGV9IExvY2FsIGJvdW5kc1xuICAgKi9cbiAgZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVRleHQoITApLCBzdXBlci5nZXRMb2NhbEJvdW5kcyhyZWN0KTtcbiAgfVxuICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgIHRoaXMudXBkYXRlVGV4dCghMCksIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKSwgdGhpcy5fYm91bmRzLmFkZFF1YWQodGhpcy52ZXJ0ZXhEYXRhKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGRpcnR5IHN0eWxlIGNoYW5nZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblN0eWxlQ2hhbmdlKCkge1xuICAgIHRoaXMuZGlydHkgPSAhMDtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveSB0aGlzIFRleHQgb2JqZWN0LiBEb24ndCB1c2UgYWZ0ZXIgY2FsbGluZy5cbiAgICogQHBhcmFtIHtib29sZWFufG9iamVjdH0gb3B0aW9ucyAtIFNhbWUgYXMgU3ByaXRlIGRlc3Ryb3kgb3B0aW9ucy5cbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIHR5cGVvZiBvcHRpb25zID09IFwiYm9vbGVhblwiICYmIChvcHRpb25zID0geyBjaGlsZHJlbjogb3B0aW9ucyB9KSwgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIF9IVE1MVGV4dDIuZGVmYXVsdERlc3Ryb3lPcHRpb25zLCBvcHRpb25zKSwgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICBjb25zdCBmb3JjZUNsZWFyID0gbnVsbDtcbiAgICB0aGlzLm93bnNTdHlsZSAmJiB0aGlzLl9zdHlsZT8uY2xlYW5Gb250cygpLCB0aGlzLl9zdHlsZSA9IGZvcmNlQ2xlYXIsIHRoaXMuX3N2Z1Jvb3Q/LnJlbW92ZSgpLCB0aGlzLl9zdmdSb290ID0gZm9yY2VDbGVhciwgdGhpcy5fZG9tRWxlbWVudD8ucmVtb3ZlKCksIHRoaXMuX2RvbUVsZW1lbnQgPSBmb3JjZUNsZWFyLCB0aGlzLl9mb3JlaWduT2JqZWN0Py5yZW1vdmUoKSwgdGhpcy5fZm9yZWlnbk9iamVjdCA9IGZvcmNlQ2xlYXIsIHRoaXMuX3N0eWxlRWxlbWVudD8ucmVtb3ZlKCksIHRoaXMuX3N0eWxlRWxlbWVudCA9IGZvcmNlQ2xlYXIsIHRoaXMuX2xvYWRJbWFnZS5zcmMgPSBcIlwiLCB0aGlzLl9sb2FkSW1hZ2Uub25sb2FkID0gbnVsbCwgdGhpcy5fbG9hZEltYWdlID0gZm9yY2VDbGVhciwgdGhpcy5faW1hZ2Uuc3JjID0gXCJcIiwgdGhpcy5faW1hZ2UgPSBmb3JjZUNsZWFyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHdpZHRoIGluIHBpeGVscy5cbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVRleHQoITApLCBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy5faW1hZ2Uud2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KCEwKTtcbiAgICBjb25zdCBzID0gY29yZS51dGlscy5zaWduKHRoaXMuc2NhbGUueCkgfHwgMTtcbiAgICB0aGlzLnNjYWxlLnggPSBzICogdmFsdWUgLyB0aGlzLl9pbWFnZS53aWR0aCAvIHRoaXMucmVzb2x1dGlvbiwgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBoZWlnaHQgaW4gcGl4ZWxzLlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVRleHQoITApLCBNYXRoLmFicyh0aGlzLnNjYWxlLnkpICogdGhpcy5faW1hZ2UuaGVpZ2h0IC8gdGhpcy5yZXNvbHV0aW9uO1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLnVwZGF0ZVRleHQoITApO1xuICAgIGNvbnN0IHMgPSBjb3JlLnV0aWxzLnNpZ24odGhpcy5zY2FsZS55KSB8fCAxO1xuICAgIHRoaXMuc2NhbGUueSA9IHMgKiB2YWx1ZSAvIHRoaXMuX2ltYWdlLmhlaWdodCAvIHRoaXMucmVzb2x1dGlvbiwgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gIH1cbiAgLyoqIFRoZSBiYXNlIHN0eWxlIHRvIHJlbmRlciB3aXRoIHRleHQuICovXG4gIGdldCBzdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gIH1cbiAgc2V0IHN0eWxlKHN0eWxlKSB7XG4gICAgdGhpcy5fc3R5bGUgIT09IHN0eWxlICYmIChzdHlsZSA9IHN0eWxlIHx8IHt9LCBzdHlsZSBpbnN0YW5jZW9mIEhUTUxUZXh0U3R5bGUuSFRNTFRleHRTdHlsZSA/ICh0aGlzLm93bnNTdHlsZSA9ICExLCB0aGlzLl9zdHlsZSA9IHN0eWxlKSA6IHN0eWxlIGluc3RhbmNlb2YgdGV4dC5UZXh0U3R5bGUgPyAoY29uc29sZS53YXJuKFwiW0hUTUxUZXh0XSBDbG9uaW5nIFRleHRTdHlsZSwgaWYgdGhpcyBpcyBub3Qgd2hhdCB5b3Ugd2FudCwgdXNlIEhUTUxUZXh0U3R5bGVcIiksIHRoaXMub3duc1N0eWxlID0gITAsIHRoaXMuX3N0eWxlID0gSFRNTFRleHRTdHlsZS5IVE1MVGV4dFN0eWxlLmZyb20oc3R5bGUpKSA6ICh0aGlzLm93bnNTdHlsZSA9ICEwLCB0aGlzLl9zdHlsZSA9IG5ldyBIVE1MVGV4dFN0eWxlLkhUTUxUZXh0U3R5bGUoc3R5bGUpKSwgdGhpcy5sb2NhbFN0eWxlSUQgPSAtMSwgdGhpcy5kaXJ0eSA9ICEwKTtcbiAgfVxuICAvKipcbiAgICogQ29udGVudHMgb2YgdGV4dC4gVGhpcyBjYW4gYmUgSFRNTCB0ZXh0IGFuZCBpbmNsdWRlIHRhZ3MuXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHRleHQgPSBuZXcgSFRNTFRleHQoJ1RoaXMgaXMgYSA8ZW0+c3R5bGVkPC9lbT4gdGV4dCEnKTtcbiAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gIH1cbiAgc2V0IHRleHQodGV4dDIpIHtcbiAgICB0ZXh0MiA9IFN0cmluZyh0ZXh0MiA9PT0gXCJcIiB8fCB0ZXh0MiA9PT0gbnVsbCB8fCB0ZXh0MiA9PT0gdm9pZCAwID8gXCIgXCIgOiB0ZXh0MiksIHRleHQyID0gdGhpcy5zYW5pdGlzZVRleHQodGV4dDIpLCB0aGlzLl90ZXh0ICE9PSB0ZXh0MiAmJiAodGhpcy5fdGV4dCA9IHRleHQyLCB0aGlzLmRpcnR5ID0gITApO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgY2FudmFzLlxuICAgKiBUaGlzIGlzIHNldCB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIHRoZSByZW5kZXJlciByZXNvbHV0aW9uIGJ5IGRlZmF1bHQsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIG1hbnVhbGx5LlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fYXV0b1Jlc29sdXRpb24gPSAhMSwgdGhpcy5fcmVzb2x1dGlvbiAhPT0gdmFsdWUgJiYgKHRoaXMuX3Jlc29sdXRpb24gPSB2YWx1ZSwgdGhpcy5kaXJ0eSA9ICEwKTtcbiAgfVxuICAvKipcbiAgICogU2FuaXRpc2UgdGV4dCAtIHJlcGxhY2UgYDxicj5gIHdpdGggYDxici8+YCwgYCZuYnNwO2Agd2l0aCBgJiMxNjA7YFxuICAgKiBAcGFyYW0gdGV4dFxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnNpdGVwb2ludC5jb20vY29tbXVuaXR5L3QveGh0bWwtMS0wLXRyYW5zaXRpb25hbC14bWwtcGFyc2luZy1lcnJvci1lbnRpdHktbmJzcC1ub3QtZGVmaW5lZC8zMzkyLzNcbiAgICovXG4gIHNhbml0aXNlVGV4dCh0ZXh0Mikge1xuICAgIHJldHVybiB0ZXh0Mi5yZXBsYWNlKC88YnI+L2dpLCBcIjxici8+XCIpLnJlcGxhY2UoLzxocj4vZ2ksIFwiPGhyLz5cIikucmVwbGFjZSgvJm5ic3A7L2dpLCBcIiYjMTYwO1wiKTtcbiAgfVxufTtcbl9IVE1MVGV4dC5kZWZhdWx0RGVzdHJveU9wdGlvbnMgPSB7XG4gIHRleHR1cmU6ICEwLFxuICBjaGlsZHJlbjogITEsXG4gIGJhc2VUZXh0dXJlOiAhMFxufSwgLyoqIERlZmF1bHQgbWF4V2lkdGgsIHNldCBhdCBjb25zdHJ1Y3Rpb24gKi9cbl9IVE1MVGV4dC5kZWZhdWx0TWF4V2lkdGggPSAyMDI0LCAvKiogRGVmYXVsdCBtYXhIZWlnaHQsIHNldCBhdCBjb25zdHJ1Y3Rpb24gKi9cbl9IVE1MVGV4dC5kZWZhdWx0TWF4SGVpZ2h0ID0gMjAyNCwgLyoqIERlZmF1bHQgYXV0b1Jlc29sdXRpb24gZm9yIGFsbCBIVE1MVGV4dCBvYmplY3RzICovXG5fSFRNTFRleHQuZGVmYXVsdEF1dG9SZXNvbHV0aW9uID0gITA7XG5sZXQgSFRNTFRleHQgPSBfSFRNTFRleHQ7XG5leHBvcnRzLkhUTUxUZXh0ID0gSFRNTFRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IVE1MVGV4dC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgdGV4dCA9IHJlcXVpcmUoXCJAcGl4aS90ZXh0XCIpO1xuY29uc3QgX0hUTUxUZXh0U3R5bGUgPSBjbGFzcyBfSFRNTFRleHRTdHlsZTIgZXh0ZW5kcyB0ZXh0LlRleHRTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuX2ZvbnRzID0gW10sIHRoaXMuX292ZXJyaWRlcyA9IFtdLCB0aGlzLl9zdHlsZXNoZWV0ID0gXCJcIiwgdGhpcy5mb250c0RpcnR5ID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBUZXh0U3R5bGUgdG8gSFRNTFRleHRTdHlsZVxuICAgKiBAcGFyYW0gb3JpZ2luYWxTdHlsZVxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQge1RleHRTdHlsZSB9IGZyb20gJ3BpeGkuanMnO1xuICAgKiBpbXBvcnQge0hUTUxUZXh0U3R5bGV9IGZyb20gJ0BwaXhpL3RleHQtaHRtbCc7XG4gICAqIGNvbnN0IHN0eWxlID0gbmV3IFRleHRTdHlsZSgpO1xuICAgKiBjb25zdCBodG1sU3R5bGUgPSBIVE1MVGV4dFN0eWxlLmZyb20oc3R5bGUpO1xuICAgKi9cbiAgc3RhdGljIGZyb20ob3JpZ2luYWxTdHlsZSkge1xuICAgIHJldHVybiBuZXcgX0hUTUxUZXh0U3R5bGUyKFxuICAgICAgT2JqZWN0LmtleXMoX0hUTUxUZXh0U3R5bGUyLmRlZmF1bHRPcHRpb25zKS5yZWR1Y2UoKG9iaiwgcHJvcCkgPT4gKHsgLi4ub2JqLCBbcHJvcF06IG9yaWdpbmFsU3R5bGVbcHJvcF0gfSksIHt9KVxuICAgICk7XG4gIH1cbiAgLyoqIENsZWFyIHRoZSBjdXJyZW50IGZvbnQgKi9cbiAgY2xlYW5Gb250cygpIHtcbiAgICB0aGlzLl9mb250cy5sZW5ndGggPiAwICYmICh0aGlzLl9mb250cy5mb3JFYWNoKChmb250KSA9PiB7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGZvbnQuc3JjKSwgZm9udC5yZWZzLS0sIGZvbnQucmVmcyA9PT0gMCAmJiAoZm9udC5mb250RmFjZSAmJiBkb2N1bWVudC5mb250cy5kZWxldGUoZm9udC5mb250RmFjZSksIGRlbGV0ZSBfSFRNTFRleHRTdHlsZTIuYXZhaWxhYmxlRm9udHNbZm9udC5vcmlnaW5hbFVybF0pO1xuICAgIH0pLCB0aGlzLmZvbnRGYW1pbHkgPSBcIkFyaWFsXCIsIHRoaXMuX2ZvbnRzLmxlbmd0aCA9IDAsIHRoaXMuc3R5bGVJRCsrLCB0aGlzLmZvbnRzRGlydHkgPSAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIEJlY2F1c2Ugb2YgaG93IEhUTUxUZXh0IHJlbmRlcnMsIGZvbnRzIG5lZWQgdG8gYmUgaW1wb3J0ZWRcbiAgICogQHBhcmFtIHVybFxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgbG9hZEZvbnQodXJsLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGF2YWlsYWJsZUZvbnRzIH0gPSBfSFRNTFRleHRTdHlsZTI7XG4gICAgaWYgKGF2YWlsYWJsZUZvbnRzW3VybF0pIHtcbiAgICAgIGNvbnN0IGZvbnQgPSBhdmFpbGFibGVGb250c1t1cmxdO1xuICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRzLnB1c2goZm9udCksIGZvbnQucmVmcysrLCB0aGlzLnN0eWxlSUQrKywgdGhpcy5mb250c0RpcnR5ID0gITAsIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gY29yZS5zZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmJsb2IoKSkudGhlbihhc3luYyAoYmxvYikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSwgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKFtzcmMsIHJlYWRlci5yZXN1bHRdKSwgcmVhZGVyLm9uZXJyb3IgPSByZWplY3QsIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgIH0pKS50aGVuKGFzeW5jIChbc3JjLCBkYXRhU3JjXSkgPT4ge1xuICAgICAgY29uc3QgZm9udCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBmYW1pbHk6IGNvcmUudXRpbHMucGF0aC5iYXNlbmFtZSh1cmwsIGNvcmUudXRpbHMucGF0aC5leHRuYW1lKHVybCkpLFxuICAgICAgICB3ZWlnaHQ6IFwibm9ybWFsXCIsXG4gICAgICAgIHN0eWxlOiBcIm5vcm1hbFwiLFxuICAgICAgICBkaXNwbGF5OiBcImF1dG9cIixcbiAgICAgICAgc3JjLFxuICAgICAgICBkYXRhU3JjLFxuICAgICAgICByZWZzOiAxLFxuICAgICAgICBvcmlnaW5hbFVybDogdXJsLFxuICAgICAgICBmb250RmFjZTogbnVsbFxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICBhdmFpbGFibGVGb250c1t1cmxdID0gZm9udCwgdGhpcy5fZm9udHMucHVzaChmb250KSwgdGhpcy5zdHlsZUlEKys7XG4gICAgICBjb25zdCBmb250RmFjZSA9IG5ldyBGb250RmFjZShmb250LmZhbWlseSwgYHVybCgke2ZvbnQuc3JjfSlgLCB7XG4gICAgICAgIHdlaWdodDogZm9udC53ZWlnaHQsXG4gICAgICAgIHN0eWxlOiBmb250LnN0eWxlLFxuICAgICAgICBkaXNwbGF5OiBmb250LmRpc3BsYXlcbiAgICAgIH0pO1xuICAgICAgZm9udC5mb250RmFjZSA9IGZvbnRGYWNlLCBhd2FpdCBmb250RmFjZS5sb2FkKCksIGRvY3VtZW50LmZvbnRzLmFkZChmb250RmFjZSksIGF3YWl0IGRvY3VtZW50LmZvbnRzLnJlYWR5LCB0aGlzLnN0eWxlSUQrKywgdGhpcy5mb250c0RpcnR5ID0gITA7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIHN0eWxlIG92ZXJyaWRlLCB0aGlzIGNhbiBiZSBhbnkgQ1NTIHByb3BlcnR5XG4gICAqIGl0IHdpbGwgb3ZlcnJpZGUgYW55IGJ1aWx0LWluIHN0eWxlLiBUaGlzIGlzIHRoZVxuICAgKiBwcm9wZXJ0eSBhbmQgdGhlIHZhbHVlIGFzIGEgc3RyaW5nIChlLmcuLCBgY29sb3I6IHJlZGApLlxuICAgKiBUaGlzIHdpbGwgb3ZlcnJpZGUgYW55IG90aGVyIGludGVybmFsIHN0eWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBDU1Mgc3R5bGUocykgdG8gYWRkLlxuICAgKiBAZXhhbXBsZVxuICAgKiBzdHlsZS5hZGRPdmVycmlkZSgnYmFja2dyb3VuZC1jb2xvcjogcmVkJyk7XG4gICAqL1xuICBhZGRPdmVycmlkZSguLi52YWx1ZSkge1xuICAgIGNvbnN0IHRvQWRkID0gdmFsdWUuZmlsdGVyKCh2KSA9PiAhdGhpcy5fb3ZlcnJpZGVzLmluY2x1ZGVzKHYpKTtcbiAgICB0b0FkZC5sZW5ndGggPiAwICYmICh0aGlzLl9vdmVycmlkZXMucHVzaCguLi50b0FkZCksIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGFueSBvdmVycmlkZXMgdGhhdCBtYXRjaCB0aGUgdmFsdWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIENTUyBzdHlsZSB0byByZW1vdmUuXG4gICAqIEBleGFtcGxlXG4gICAqIHN0eWxlLnJlbW92ZU92ZXJyaWRlKCdiYWNrZ3JvdW5kLWNvbG9yOiByZWQnKTtcbiAgICovXG4gIHJlbW92ZU92ZXJyaWRlKC4uLnZhbHVlKSB7XG4gICAgY29uc3QgdG9SZW1vdmUgPSB2YWx1ZS5maWx0ZXIoKHYpID0+IHRoaXMuX292ZXJyaWRlcy5pbmNsdWRlcyh2KSk7XG4gICAgdG9SZW1vdmUubGVuZ3RoID4gMCAmJiAodGhpcy5fb3ZlcnJpZGVzID0gdGhpcy5fb3ZlcnJpZGVzLmZpbHRlcigodikgPT4gIXRvUmVtb3ZlLmluY2x1ZGVzKHYpKSwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm5hbGx5IGNvbnZlcnRzIGFsbCBvZiB0aGUgc3R5bGUgcHJvcGVydGllcyBpbnRvIENTUyBlcXVpdmFsZW50cy5cbiAgICogQHBhcmFtIHNjYWxlXG4gICAqIEByZXR1cm5zIFRoZSBDU1Mgc3R5bGUgc3RyaW5nLCBmb3Igc2V0dGluZyBgc3R5bGVgIHByb3BlcnR5IG9mIHJvb3QgSFRNTEVsZW1lbnQuXG4gICAqL1xuICB0b0NTUyhzY2FsZSkge1xuICAgIHJldHVybiBbXG4gICAgICBgdHJhbnNmb3JtOiBzY2FsZSgke3NjYWxlfSlgLFxuICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgbGVmdFwiLFxuICAgICAgXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2tcIixcbiAgICAgIGBjb2xvcjogJHt0aGlzLm5vcm1hbGl6ZUNvbG9yKHRoaXMuZmlsbCl9YCxcbiAgICAgIGBmb250LXNpemU6ICR7dGhpcy5mb250U2l6ZX1weGAsXG4gICAgICBgZm9udC1mYW1pbHk6ICR7dGhpcy5mb250RmFtaWx5fWAsXG4gICAgICBgZm9udC13ZWlnaHQ6ICR7dGhpcy5mb250V2VpZ2h0fWAsXG4gICAgICBgZm9udC1zdHlsZTogJHt0aGlzLmZvbnRTdHlsZX1gLFxuICAgICAgYGZvbnQtdmFyaWFudDogJHt0aGlzLmZvbnRWYXJpYW50fWAsXG4gICAgICBgbGV0dGVyLXNwYWNpbmc6ICR7dGhpcy5sZXR0ZXJTcGFjaW5nfXB4YCxcbiAgICAgIGB0ZXh0LWFsaWduOiAke3RoaXMuYWxpZ259YCxcbiAgICAgIGBwYWRkaW5nOiAke3RoaXMucGFkZGluZ31weGAsXG4gICAgICBgd2hpdGUtc3BhY2U6ICR7dGhpcy53aGl0ZVNwYWNlfWAsXG4gICAgICAuLi50aGlzLmxpbmVIZWlnaHQgPyBbYGxpbmUtaGVpZ2h0OiAke3RoaXMubGluZUhlaWdodH1weGBdIDogW10sXG4gICAgICAuLi50aGlzLndvcmRXcmFwID8gW1xuICAgICAgICBgd29yZC13cmFwOiAke3RoaXMuYnJlYWtXb3JkcyA/IFwiYnJlYWstYWxsXCIgOiBcImJyZWFrLXdvcmRcIn1gLFxuICAgICAgICBgbWF4LXdpZHRoOiAke3RoaXMud29yZFdyYXBXaWR0aH1weGBcbiAgICAgIF0gOiBbXSxcbiAgICAgIC4uLnRoaXMuc3Ryb2tlVGhpY2tuZXNzID8gW1xuICAgICAgICBgLXdlYmtpdC10ZXh0LXN0cm9rZS13aWR0aDogJHt0aGlzLnN0cm9rZVRoaWNrbmVzc31weGAsXG4gICAgICAgIGAtd2Via2l0LXRleHQtc3Ryb2tlLWNvbG9yOiAke3RoaXMubm9ybWFsaXplQ29sb3IodGhpcy5zdHJva2UpfWAsXG4gICAgICAgIGB0ZXh0LXN0cm9rZS13aWR0aDogJHt0aGlzLnN0cm9rZVRoaWNrbmVzc31weGAsXG4gICAgICAgIGB0ZXh0LXN0cm9rZS1jb2xvcjogJHt0aGlzLm5vcm1hbGl6ZUNvbG9yKHRoaXMuc3Ryb2tlKX1gLFxuICAgICAgICBcInBhaW50LW9yZGVyOiBzdHJva2VcIlxuICAgICAgXSA6IFtdLFxuICAgICAgLi4udGhpcy5kcm9wU2hhZG93ID8gW3RoaXMuZHJvcFNoYWRvd1RvQ1NTKCldIDogW10sXG4gICAgICAuLi50aGlzLl9vdmVycmlkZXNcbiAgICBdLmpvaW4oXCI7XCIpO1xuICB9XG4gIC8qKiBHZXQgdGhlIGZvbnQgQ1NTIHN0eWxlcyBmcm9tIHRoZSBsb2FkZWQgZm9udCwgSWYgYXZhaWxhYmxlLiAqL1xuICB0b0dsb2JhbENTUygpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udHMucmVkdWNlKChyZXN1bHQsIGZvbnQpID0+IGAke3Jlc3VsdH1cbiAgICAgICAgICAgIEBmb250LWZhY2Uge1xuICAgICAgICAgICAgICAgIGZvbnQtZmFtaWx5OiBcIiR7Zm9udC5mYW1pbHl9XCI7XG4gICAgICAgICAgICAgICAgc3JjOiB1cmwoJyR7Zm9udC5kYXRhU3JjfScpO1xuICAgICAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiAke2ZvbnQud2VpZ2h0fTtcbiAgICAgICAgICAgICAgICBmb250LXN0eWxlOiAke2ZvbnQuc3R5bGV9O1xuICAgICAgICAgICAgICAgIGZvbnQtZGlzcGxheTogJHtmb250LmRpc3BsYXl9O1xuICAgICAgICAgICAgfWAsIHRoaXMuX3N0eWxlc2hlZXQpO1xuICB9XG4gIC8qKiBJbnRlcm5hbCBzdHlsZXNoZWV0IGNvbnRlbnRzLCB1c2VmdWwgZm9yIGNyZWF0aW5nIHJ1bGVzIGZvciByZW5kZXJpbmcgKi9cbiAgZ2V0IHN0eWxlc2hlZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlc2hlZXQ7XG4gIH1cbiAgc2V0IHN0eWxlc2hlZXQodmFsdWUpIHtcbiAgICB0aGlzLl9zdHlsZXNoZWV0ICE9PSB2YWx1ZSAmJiAodGhpcy5fc3R5bGVzaGVldCA9IHZhbHVlLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgbnVtZXJpY2FsIGNvbG9ycyBpbnRvIGhleC1zdHJpbmdzXG4gICAqIEBwYXJhbSBjb2xvclxuICAgKi9cbiAgbm9ybWFsaXplQ29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjb2xvcikgJiYgKGNvbG9yID0gY29yZS51dGlscy5yZ2IyaGV4KGNvbG9yKSksIHR5cGVvZiBjb2xvciA9PSBcIm51bWJlclwiID8gY29yZS51dGlscy5oZXgyc3RyaW5nKGNvbG9yKSA6IGNvbG9yO1xuICB9XG4gIC8qKiBDb252ZXJ0IHRoZSBpbnRlcm5hbCBkcm9wLXNoYWRvdyBzZXR0aW5ncyB0byBDU1MgdGV4dC1zaGFkb3cgKi9cbiAgZHJvcFNoYWRvd1RvQ1NTKCkge1xuICAgIGxldCBjb2xvciA9IHRoaXMubm9ybWFsaXplQ29sb3IodGhpcy5kcm9wU2hhZG93Q29sb3IpO1xuICAgIGNvbnN0IGFscGhhID0gdGhpcy5kcm9wU2hhZG93QWxwaGEsIHggPSBNYXRoLnJvdW5kKE1hdGguY29zKHRoaXMuZHJvcFNoYWRvd0FuZ2xlKSAqIHRoaXMuZHJvcFNoYWRvd0Rpc3RhbmNlKSwgeSA9IE1hdGgucm91bmQoTWF0aC5zaW4odGhpcy5kcm9wU2hhZG93QW5nbGUpICogdGhpcy5kcm9wU2hhZG93RGlzdGFuY2UpO1xuICAgIGNvbG9yLnN0YXJ0c1dpdGgoXCIjXCIpICYmIGFscGhhIDwgMSAmJiAoY29sb3IgKz0gKGFscGhhICogMjU1IHwgMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XG4gICAgY29uc3QgcG9zaXRpb24gPSBgJHt4fXB4ICR7eX1weGA7XG4gICAgcmV0dXJuIHRoaXMuZHJvcFNoYWRvd0JsdXIgPiAwID8gYHRleHQtc2hhZG93OiAke3Bvc2l0aW9ufSAke3RoaXMuZHJvcFNoYWRvd0JsdXJ9cHggJHtjb2xvcn1gIDogYHRleHQtc2hhZG93OiAke3Bvc2l0aW9ufSAke2NvbG9yfWA7XG4gIH1cbiAgLyoqIFJlc2V0cyBhbGwgcHJvcGVydGllcyB0byB0aGUgZGVmYXVsdHMgc3BlY2lmaWVkIGluIFRleHRTdHlsZS5wcm90b3R5cGUuX2RlZmF1bHQgKi9cbiAgcmVzZXQoKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBfSFRNTFRleHRTdHlsZTIuZGVmYXVsdE9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgYWZ0ZXIgdGhlIGltYWdlIGlzIGxvYWRlZCBidXQgYmVmb3JlIGRyYXdpbmcgdG8gdGhlIGNhbnZhcy5cbiAgICogTW9zdGx5IHVzZWQgdG8gaGFuZGxlIFNhZmFyaSdzIGZvbnQgbG9hZGluZyBidWcuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uQmVmb3JlRHJhdygpIHtcbiAgICBjb25zdCB7IGZvbnRzRGlydHk6IHByZXZGb250c0RpcnR5IH0gPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLmZvbnRzRGlydHkgPSAhMSwgdGhpcy5pc1NhZmFyaSAmJiB0aGlzLl9mb250cy5sZW5ndGggPiAwICYmIHByZXZGb250c0RpcnR5ID8gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICAvKipcbiAgICogUHJvdmluZyB0aGF0IFNhZmFyaSBpcyB0aGUgbmV3IElFXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGdldCBpc1NhZmFyaSgpIHtcbiAgICBjb25zdCB7IHVzZXJBZ2VudCB9ID0gY29yZS5zZXR0aW5ncy5BREFQVEVSLmdldE5hdmlnYXRvcigpO1xuICAgIHJldHVybiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KHVzZXJBZ2VudCk7XG4gIH1cbiAgc2V0IGZpbGxHcmFkaWVudFN0b3BzKF92YWx1ZSkge1xuICAgIGNvbnNvbGUud2FybihcIltIVE1MVGV4dFN0eWxlXSBmaWxsR3JhZGllbnRTdG9wcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICB9XG4gIGdldCBmaWxsR3JhZGllbnRTdG9wcygpIHtcbiAgICByZXR1cm4gc3VwZXIuZmlsbEdyYWRpZW50U3RvcHM7XG4gIH1cbiAgc2V0IGZpbGxHcmFkaWVudFR5cGUoX3ZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiW0hUTUxUZXh0U3R5bGVdIGZpbGxHcmFkaWVudFR5cGUgaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgfVxuICBnZXQgZmlsbEdyYWRpZW50VHlwZSgpIHtcbiAgICByZXR1cm4gc3VwZXIuZmlsbEdyYWRpZW50VHlwZTtcbiAgfVxuICBzZXQgbWl0ZXJMaW1pdChfdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRTdHlsZV0gbWl0ZXJMaW1pdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICB9XG4gIGdldCBtaXRlckxpbWl0KCkge1xuICAgIHJldHVybiBzdXBlci5taXRlckxpbWl0O1xuICB9XG4gIHNldCB0cmltKF92YWx1ZSkge1xuICAgIGNvbnNvbGUud2FybihcIltIVE1MVGV4dFN0eWxlXSB0cmltIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSFRNTFRleHRcIik7XG4gIH1cbiAgZ2V0IHRyaW0oKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRyaW07XG4gIH1cbiAgc2V0IHRleHRCYXNlbGluZShfdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRTdHlsZV0gdGV4dEJhc2VsaW5lIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSFRNTFRleHRcIik7XG4gIH1cbiAgZ2V0IHRleHRCYXNlbGluZSgpIHtcbiAgICByZXR1cm4gc3VwZXIudGV4dEJhc2VsaW5lO1xuICB9XG4gIHNldCBsZWFkaW5nKF92YWx1ZSkge1xuICAgIGNvbnNvbGUud2FybihcIltIVE1MVGV4dFN0eWxlXSBsZWFkaW5nIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSFRNTFRleHRcIik7XG4gIH1cbiAgZ2V0IGxlYWRpbmcoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmxlYWRpbmc7XG4gIH1cbiAgc2V0IGxpbmVKb2luKF92YWx1ZSkge1xuICAgIGNvbnNvbGUud2FybihcIltIVE1MVGV4dFN0eWxlXSBsaW5lSm9pbiBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICB9XG4gIGdldCBsaW5lSm9pbigpIHtcbiAgICByZXR1cm4gc3VwZXIubGluZUpvaW47XG4gIH1cbn07XG5fSFRNTFRleHRTdHlsZS5hdmFpbGFibGVGb250cyA9IHt9LCAvKipcbiogTGlzdCBvZiBkZWZhdWx0IG9wdGlvbnMsIHRoZXNlIGFyZSBsYXJnZWx5IHRoZSBzYW1lIGFzIFRleHRTdHlsZSxcbiogd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHdoaXRlU3BhY2UsIHdoaWNoIGlzIHNldCB0byAnbm9ybWFsJyBieSBkZWZhdWx0LlxuKi9cbl9IVE1MVGV4dFN0eWxlLmRlZmF1bHRPcHRpb25zID0ge1xuICAvKiogQWxpZ24gKi9cbiAgYWxpZ246IFwibGVmdFwiLFxuICAvKiogQnJlYWsgd29yZHMgKi9cbiAgYnJlYWtXb3JkczogITEsXG4gIC8qKiBEcm9wIHNoYWRvdyAqL1xuICBkcm9wU2hhZG93OiAhMSxcbiAgLyoqIERyb3Agc2hhZG93IGFscGhhICovXG4gIGRyb3BTaGFkb3dBbHBoYTogMSxcbiAgLyoqXG4gICAqIERyb3Agc2hhZG93IGFuZ2xlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IE1hdGguUEkgLyA2XG4gICAqL1xuICBkcm9wU2hhZG93QW5nbGU6IE1hdGguUEkgLyA2LFxuICAvKiogRHJvcCBzaGFkb3cgYmx1ciAqL1xuICBkcm9wU2hhZG93Qmx1cjogMCxcbiAgLyoqIERyb3Agc2hhZG93IGNvbG9yICovXG4gIGRyb3BTaGFkb3dDb2xvcjogXCJibGFja1wiLFxuICAvKiogRHJvcCBzaGFkb3cgZGlzdGFuY2UgKi9cbiAgZHJvcFNoYWRvd0Rpc3RhbmNlOiA1LFxuICAvKiogRmlsbCAqL1xuICBmaWxsOiBcImJsYWNrXCIsXG4gIC8qKiBGb250IGZhbWlseSAqL1xuICBmb250RmFtaWx5OiBcIkFyaWFsXCIsXG4gIC8qKiBGb250IHNpemUgKi9cbiAgZm9udFNpemU6IDI2LFxuICAvKiogRm9udCBzdHlsZSAqL1xuICBmb250U3R5bGU6IFwibm9ybWFsXCIsXG4gIC8qKiBGb250IHZhcmlhbnQgKi9cbiAgZm9udFZhcmlhbnQ6IFwibm9ybWFsXCIsXG4gIC8qKiBGb250IHdlaWdodCAqL1xuICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxuICAvKiogTGV0dGVyIHNwYWNpbmcgKi9cbiAgbGV0dGVyU3BhY2luZzogMCxcbiAgLyoqIExpbmUgaGVpZ2h0ICovXG4gIGxpbmVIZWlnaHQ6IDAsXG4gIC8qKiBQYWRkaW5nICovXG4gIHBhZGRpbmc6IDAsXG4gIC8qKiBTdHJva2UgKi9cbiAgc3Ryb2tlOiBcImJsYWNrXCIsXG4gIC8qKiBTdHJva2UgdGhpY2tuZXNzICovXG4gIHN0cm9rZVRoaWNrbmVzczogMCxcbiAgLyoqIFdoaXRlIHNwYWNlICovXG4gIHdoaXRlU3BhY2U6IFwibm9ybWFsXCIsXG4gIC8qKiBXb3JkIHdyYXAgKi9cbiAgd29yZFdyYXA6ICExLFxuICAvKiogV29yZCB3cmFwIHdpZHRoICovXG4gIHdvcmRXcmFwV2lkdGg6IDEwMFxufTtcbmxldCBIVE1MVGV4dFN0eWxlID0gX0hUTUxUZXh0U3R5bGU7XG5leHBvcnRzLkhUTUxUZXh0U3R5bGUgPSBIVE1MVGV4dFN0eWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SFRNTFRleHRTdHlsZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIEhUTUxUZXh0ID0gcmVxdWlyZShcIi4vSFRNTFRleHQuanNcIiksIEhUTUxUZXh0U3R5bGUgPSByZXF1aXJlKFwiLi9IVE1MVGV4dFN0eWxlLmpzXCIpO1xuZXhwb3J0cy5IVE1MVGV4dCA9IEhUTUxUZXh0LkhUTUxUZXh0O1xuZXhwb3J0cy5IVE1MVGV4dFN0eWxlID0gSFRNTFRleHRTdHlsZS5IVE1MVGV4dFN0eWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIHNwcml0ZSA9IHJlcXVpcmUoXCJAcGl4aS9zcHJpdGVcIiksIF9jb25zdCA9IHJlcXVpcmUoXCIuL2NvbnN0LmpzXCIpLCBUZXh0TWV0cmljcyA9IHJlcXVpcmUoXCIuL1RleHRNZXRyaWNzLmpzXCIpLCBUZXh0U3R5bGUgPSByZXF1aXJlKFwiLi9UZXh0U3R5bGUuanNcIik7XG5jb25zdCBkZWZhdWx0RGVzdHJveU9wdGlvbnMgPSB7XG4gIHRleHR1cmU6ICEwLFxuICBjaGlsZHJlbjogITEsXG4gIGJhc2VUZXh0dXJlOiAhMFxufSwgX1RleHQgPSBjbGFzcyBfVGV4dDIgZXh0ZW5kcyBzcHJpdGUuU3ByaXRlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIHN0cmluZyB0aGF0IHlvdSB3b3VsZCBsaWtlIHRoZSB0ZXh0IHRvIGRpc3BsYXlcbiAgICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIGNhbnZhcyAtIFRoZSBjYW52YXMgZWxlbWVudCBmb3IgZHJhd2luZyB0ZXh0XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0LCBzdHlsZSwgY2FudmFzKSB7XG4gICAgbGV0IG93bkNhbnZhcyA9ICExO1xuICAgIGNhbnZhcyB8fCAoY2FudmFzID0gY29yZS5zZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpLCBvd25DYW52YXMgPSAhMCksIGNhbnZhcy53aWR0aCA9IDMsIGNhbnZhcy5oZWlnaHQgPSAzO1xuICAgIGNvbnN0IHRleHR1cmUgPSBjb3JlLlRleHR1cmUuZnJvbShjYW52YXMpO1xuICAgIHRleHR1cmUub3JpZyA9IG5ldyBjb3JlLlJlY3RhbmdsZSgpLCB0ZXh0dXJlLnRyaW0gPSBuZXcgY29yZS5SZWN0YW5nbGUoKSwgc3VwZXIodGV4dHVyZSksIHRoaXMuX293bkNhbnZhcyA9IG93bkNhbnZhcywgdGhpcy5jYW52YXMgPSBjYW52YXMsIHRoaXMuY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgLy8gcmVxdWlyZWQgZm9yIHRyaW1taW5nIHRvIHdvcmsgd2l0aG91dCB3YXJuaW5nc1xuICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiAhMFxuICAgIH0pLCB0aGlzLl9yZXNvbHV0aW9uID0gX1RleHQyLmRlZmF1bHRSZXNvbHV0aW9uID8/IGNvcmUuc2V0dGluZ3MuUkVTT0xVVElPTiwgdGhpcy5fYXV0b1Jlc29sdXRpb24gPSBfVGV4dDIuZGVmYXVsdEF1dG9SZXNvbHV0aW9uLCB0aGlzLl90ZXh0ID0gbnVsbCwgdGhpcy5fc3R5bGUgPSBudWxsLCB0aGlzLl9zdHlsZUxpc3RlbmVyID0gbnVsbCwgdGhpcy5fZm9udCA9IFwiXCIsIHRoaXMudGV4dCA9IHRleHQsIHRoaXMuc3R5bGUgPSBzdHlsZSwgdGhpcy5sb2NhbFN0eWxlSUQgPSAtMTtcbiAgfVxuICAvKipcbiAgICogQHNlZSBQSVhJLlRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4xLjBcbiAgICovXG4gIHN0YXRpYyBnZXQgZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZygpIHtcbiAgICByZXR1cm4gVGV4dE1ldHJpY3MuVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZztcbiAgfVxuICBzdGF0aWMgc2V0IGV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcodmFsdWUpIHtcbiAgICBjb3JlLnV0aWxzLmRlcHJlY2F0aW9uKFxuICAgICAgXCI3LjEuMFwiLFxuICAgICAgXCJUZXh0LmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgaXMgZGVwcmVjYXRlZCwgdXNlIFRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdcIlxuICAgICksIFRleHRNZXRyaWNzLlRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0ZXh0IHRvIGl0cyBjYW52YXMsIGFuZCB1cGRhdGVzIGl0cyB0ZXh0dXJlLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0IHRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIGVuc3VyZSB0aGUgdGV4dHVyZSBpcyBjb3JyZWN0IGJlZm9yZSByZW5kZXJpbmcsXG4gICAqIGJ1dCBpdCBjYW4gYmUgdXNlZCBjYWxsZWQgZXh0ZXJuYWxseSwgZm9yIGV4YW1wbGUgZnJvbSB0aGlzIGNsYXNzIHRvICdwcmUtZ2VuZXJhdGUnIHRoZSB0ZXh0dXJlIGZyb20gYSBwaWVjZSBvZiB0ZXh0LFxuICAgKiBhbmQgdGhlbiBzaGFyZWQgYWNyb3NzIG11bHRpcGxlIFNwcml0ZXMuXG4gICAqIEBwYXJhbSByZXNwZWN0RGlydHkgLSBXaGV0aGVyIHRvIGFib3J0IHVwZGF0aW5nIHRoZSB0ZXh0IGlmIHRoZSBUZXh0IGlzbid0IGRpcnR5IGFuZCB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKi9cbiAgdXBkYXRlVGV4dChyZXNwZWN0RGlydHkpIHtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuICAgIGlmICh0aGlzLmxvY2FsU3R5bGVJRCAhPT0gc3R5bGUuc3R5bGVJRCAmJiAodGhpcy5kaXJ0eSA9ICEwLCB0aGlzLmxvY2FsU3R5bGVJRCA9IHN0eWxlLnN0eWxlSUQpLCAhdGhpcy5kaXJ0eSAmJiByZXNwZWN0RGlydHkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fZm9udCA9IHRoaXMuX3N0eWxlLnRvRm9udFN0cmluZygpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQsIG1lYXN1cmVkID0gVGV4dE1ldHJpY3MuVGV4dE1ldHJpY3MubWVhc3VyZVRleHQodGhpcy5fdGV4dCB8fCBcIiBcIiwgdGhpcy5fc3R5bGUsIHRoaXMuX3N0eWxlLndvcmRXcmFwLCB0aGlzLmNhbnZhcyksIHdpZHRoID0gbWVhc3VyZWQud2lkdGgsIGhlaWdodCA9IG1lYXN1cmVkLmhlaWdodCwgbGluZXMgPSBtZWFzdXJlZC5saW5lcywgbGluZUhlaWdodCA9IG1lYXN1cmVkLmxpbmVIZWlnaHQsIGxpbmVXaWR0aHMgPSBtZWFzdXJlZC5saW5lV2lkdGhzLCBtYXhMaW5lV2lkdGggPSBtZWFzdXJlZC5tYXhMaW5lV2lkdGgsIGZvbnRQcm9wZXJ0aWVzID0gbWVhc3VyZWQuZm9udFByb3BlcnRpZXM7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIHdpZHRoKSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHRoaXMuX3Jlc29sdXRpb24pLCB0aGlzLmNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIGhlaWdodCkgKyBzdHlsZS5wYWRkaW5nICogMikgKiB0aGlzLl9yZXNvbHV0aW9uKSwgY29udGV4dC5zY2FsZSh0aGlzLl9yZXNvbHV0aW9uLCB0aGlzLl9yZXNvbHV0aW9uKSwgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCksIGNvbnRleHQuZm9udCA9IHRoaXMuX2ZvbnQsIGNvbnRleHQubGluZVdpZHRoID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzLCBjb250ZXh0LnRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZSwgY29udGV4dC5saW5lSm9pbiA9IHN0eWxlLmxpbmVKb2luLCBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHlsZS5taXRlckxpbWl0O1xuICAgIGxldCBsaW5lUG9zaXRpb25YLCBsaW5lUG9zaXRpb25ZO1xuICAgIGNvbnN0IHBhc3Nlc0NvdW50ID0gc3R5bGUuZHJvcFNoYWRvdyA/IDIgOiAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFzc2VzQ291bnQ7ICsraSkge1xuICAgICAgY29uc3QgaXNTaGFkb3dQYXNzID0gc3R5bGUuZHJvcFNoYWRvdyAmJiBpID09PSAwLCBkc09mZnNldFRleHQgPSBpc1NoYWRvd1Bhc3MgPyBNYXRoLmNlaWwoTWF0aC5tYXgoMSwgaGVpZ2h0KSArIHN0eWxlLnBhZGRpbmcgKiAyKSA6IDAsIGRzT2Zmc2V0U2hhZG93ID0gZHNPZmZzZXRUZXh0ICogdGhpcy5fcmVzb2x1dGlvbjtcbiAgICAgIGlmIChpc1NoYWRvd1Bhc3MpIHtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcImJsYWNrXCIsIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIGNvbnN0IGRyb3BTaGFkb3dDb2xvciA9IHN0eWxlLmRyb3BTaGFkb3dDb2xvciwgZHJvcFNoYWRvd0JsdXIgPSBzdHlsZS5kcm9wU2hhZG93Qmx1ciAqIHRoaXMuX3Jlc29sdXRpb24sIGRyb3BTaGFkb3dEaXN0YW5jZSA9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSAqIHRoaXMuX3Jlc29sdXRpb247XG4gICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBjb3JlLkNvbG9yLnNoYXJlZC5zZXRWYWx1ZShkcm9wU2hhZG93Q29sb3IpLnNldEFscGhhKHN0eWxlLmRyb3BTaGFkb3dBbHBoYSkudG9SZ2JhU3RyaW5nKCksIGNvbnRleHQuc2hhZG93Qmx1ciA9IGRyb3BTaGFkb3dCbHVyLCBjb250ZXh0LnNoYWRvd09mZnNldFggPSBNYXRoLmNvcyhzdHlsZS5kcm9wU2hhZG93QW5nbGUpICogZHJvcFNoYWRvd0Rpc3RhbmNlLCBjb250ZXh0LnNoYWRvd09mZnNldFkgPSBNYXRoLnNpbihzdHlsZS5kcm9wU2hhZG93QW5nbGUpICogZHJvcFNoYWRvd0Rpc3RhbmNlICsgZHNPZmZzZXRTaGFkb3c7XG4gICAgICB9IGVsc2VcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLl9nZW5lcmF0ZUZpbGxTdHlsZShzdHlsZSwgbGluZXMsIG1lYXN1cmVkKSwgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0eWxlLnN0cm9rZSwgY29udGV4dC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIiwgY29udGV4dC5zaGFkb3dCbHVyID0gMCwgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMCwgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgIGxldCBsaW5lUG9zaXRpb25ZU2hpZnQgPSAobGluZUhlaWdodCAtIGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplKSAvIDI7XG4gICAgICBsaW5lSGVpZ2h0IC0gZm9udFByb3BlcnRpZXMuZm9udFNpemUgPCAwICYmIChsaW5lUG9zaXRpb25ZU2hpZnQgPSAwKTtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBsaW5lcy5sZW5ndGg7IGkyKyspXG4gICAgICAgIGxpbmVQb3NpdGlvblggPSBzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyLCBsaW5lUG9zaXRpb25ZID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMiArIGkyICogbGluZUhlaWdodCArIGZvbnRQcm9wZXJ0aWVzLmFzY2VudCArIGxpbmVQb3NpdGlvbllTaGlmdCwgc3R5bGUuYWxpZ24gPT09IFwicmlnaHRcIiA/IGxpbmVQb3NpdGlvblggKz0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpMl0gOiBzdHlsZS5hbGlnbiA9PT0gXCJjZW50ZXJcIiAmJiAobGluZVBvc2l0aW9uWCArPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpMl0pIC8gMiksIHN0eWxlLnN0cm9rZSAmJiBzdHlsZS5zdHJva2VUaGlja25lc3MgJiYgdGhpcy5kcmF3TGV0dGVyU3BhY2luZyhcbiAgICAgICAgICBsaW5lc1tpMl0sXG4gICAgICAgICAgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgbGluZVBvc2l0aW9uWSArIHN0eWxlLnBhZGRpbmcgLSBkc09mZnNldFRleHQsXG4gICAgICAgICAgITBcbiAgICAgICAgKSwgc3R5bGUuZmlsbCAmJiB0aGlzLmRyYXdMZXR0ZXJTcGFjaW5nKFxuICAgICAgICAgIGxpbmVzW2kyXSxcbiAgICAgICAgICBsaW5lUG9zaXRpb25YICsgc3R5bGUucGFkZGluZyxcbiAgICAgICAgICBsaW5lUG9zaXRpb25ZICsgc3R5bGUucGFkZGluZyAtIGRzT2Zmc2V0VGV4dFxuICAgICAgICApO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVyIHRoZSB0ZXh0IHdpdGggbGV0dGVyLXNwYWNpbmcuXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIHRleHQgdG8gZHJhd1xuICAgKiBAcGFyYW0geCAtIEhvcml6b250YWwgcG9zaXRpb24gdG8gZHJhdyB0aGUgdGV4dFxuICAgKiBAcGFyYW0geSAtIFZlcnRpY2FsIHBvc2l0aW9uIHRvIGRyYXcgdGhlIHRleHRcbiAgICogQHBhcmFtIGlzU3Ryb2tlIC0gSXMgdGhpcyBkcmF3aW5nIGZvciB0aGUgb3V0c2lkZSBzdHJva2Ugb2YgdGhlXG4gICAqICB0ZXh0PyBJZiBub3QsIGl0J3MgZm9yIHRoZSBpbnNpZGUgZmlsbFxuICAgKi9cbiAgZHJhd0xldHRlclNwYWNpbmcodGV4dCwgeCwgeSwgaXNTdHJva2UgPSAhMSkge1xuICAgIGNvbnN0IGxldHRlclNwYWNpbmcgPSB0aGlzLl9zdHlsZS5sZXR0ZXJTcGFjaW5nO1xuICAgIGxldCB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gITE7XG4gICAgaWYgKFRleHRNZXRyaWNzLlRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQgJiYgKFRleHRNZXRyaWNzLlRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPyAodGhpcy5jb250ZXh0LmxldHRlclNwYWNpbmcgPSBgJHtsZXR0ZXJTcGFjaW5nfXB4YCwgdGhpcy5jb250ZXh0LnRleHRMZXR0ZXJTcGFjaW5nID0gYCR7bGV0dGVyU3BhY2luZ31weGAsIHVzZUV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSAhMCkgOiAodGhpcy5jb250ZXh0LmxldHRlclNwYWNpbmcgPSBcIjBweFwiLCB0aGlzLmNvbnRleHQudGV4dExldHRlclNwYWNpbmcgPSBcIjBweFwiKSksIGxldHRlclNwYWNpbmcgPT09IDAgfHwgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZykge1xuICAgICAgaXNTdHJva2UgPyB0aGlzLmNvbnRleHQuc3Ryb2tlVGV4dCh0ZXh0LCB4LCB5KSA6IHRoaXMuY29udGV4dC5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IHg7XG4gICAgY29uc3Qgc3RyaW5nQXJyYXkgPSBUZXh0TWV0cmljcy5UZXh0TWV0cmljcy5ncmFwaGVtZVNlZ21lbnRlcih0ZXh0KTtcbiAgICBsZXQgcHJldmlvdXNXaWR0aCA9IHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCwgY3VycmVudFdpZHRoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ0FycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBjdXJyZW50Q2hhciA9IHN0cmluZ0FycmF5W2ldO1xuICAgICAgaXNTdHJva2UgPyB0aGlzLmNvbnRleHQuc3Ryb2tlVGV4dChjdXJyZW50Q2hhciwgY3VycmVudFBvc2l0aW9uLCB5KSA6IHRoaXMuY29udGV4dC5maWxsVGV4dChjdXJyZW50Q2hhciwgY3VycmVudFBvc2l0aW9uLCB5KTtcbiAgICAgIGxldCB0ZXh0U3RyID0gXCJcIjtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHN0cmluZ0FycmF5Lmxlbmd0aDsgKytqKVxuICAgICAgICB0ZXh0U3RyICs9IHN0cmluZ0FycmF5W2pdO1xuICAgICAgY3VycmVudFdpZHRoID0gdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHRTdHIpLndpZHRoLCBjdXJyZW50UG9zaXRpb24gKz0gcHJldmlvdXNXaWR0aCAtIGN1cnJlbnRXaWR0aCArIGxldHRlclNwYWNpbmcsIHByZXZpb3VzV2lkdGggPSBjdXJyZW50V2lkdGg7XG4gICAgfVxuICB9XG4gIC8qKiBVcGRhdGVzIHRleHR1cmUgc2l6ZSBiYXNlZCBvbiBjYW52YXMgc2l6ZS4gKi9cbiAgdXBkYXRlVGV4dHVyZSgpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBpZiAodGhpcy5fc3R5bGUudHJpbSkge1xuICAgICAgY29uc3QgdHJpbW1lZCA9IGNvcmUudXRpbHMudHJpbUNhbnZhcyhjYW52YXMpO1xuICAgICAgdHJpbW1lZC5kYXRhICYmIChjYW52YXMud2lkdGggPSB0cmltbWVkLndpZHRoLCBjYW52YXMuaGVpZ2h0ID0gdHJpbW1lZC5oZWlnaHQsIHRoaXMuY29udGV4dC5wdXRJbWFnZURhdGEodHJpbW1lZC5kYXRhLCAwLCAwKSk7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlLCBzdHlsZSA9IHRoaXMuX3N0eWxlLCBwYWRkaW5nID0gc3R5bGUudHJpbSA/IDAgOiBzdHlsZS5wYWRkaW5nLCBiYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgdGV4dHVyZS50cmltLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggPSBjYW52YXMud2lkdGggLyB0aGlzLl9yZXNvbHV0aW9uLCB0ZXh0dXJlLnRyaW0uaGVpZ2h0ID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCAvIHRoaXMuX3Jlc29sdXRpb24sIHRleHR1cmUudHJpbS54ID0gLXBhZGRpbmcsIHRleHR1cmUudHJpbS55ID0gLXBhZGRpbmcsIHRleHR1cmUub3JpZy53aWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoIC0gcGFkZGluZyAqIDIsIHRleHR1cmUub3JpZy5oZWlnaHQgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgLSBwYWRkaW5nICogMiwgdGhpcy5fb25UZXh0dXJlVXBkYXRlKCksIGJhc2VUZXh0dXJlLnNldFJlYWxTaXplKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgdGhpcy5fcmVzb2x1dGlvbiksIHRleHR1cmUudXBkYXRlVXZzKCksIHRoaXMuZGlydHkgPSAhMTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICovXG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9hdXRvUmVzb2x1dGlvbiAmJiB0aGlzLl9yZXNvbHV0aW9uICE9PSByZW5kZXJlci5yZXNvbHV0aW9uICYmICh0aGlzLl9yZXNvbHV0aW9uID0gcmVuZGVyZXIucmVzb2x1dGlvbiwgdGhpcy5kaXJ0eSA9ICEwKSwgdGhpcy51cGRhdGVUZXh0KCEwKSwgc3VwZXIuX3JlbmRlcihyZW5kZXJlcik7XG4gIH1cbiAgLyoqIFVwZGF0ZXMgdGhlIHRyYW5zZm9ybSBvbiBhbGwgY2hpbGRyZW4gb2YgdGhpcyBjb250YWluZXIgZm9yIHJlbmRlcmluZy4gKi9cbiAgdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgIHRoaXMudXBkYXRlVGV4dCghMCksIHN1cGVyLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIGdldEJvdW5kcyhza2lwVXBkYXRlLCByZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVGV4dCghMCksIHRoaXMuX3RleHR1cmVJRCA9PT0gLTEgJiYgKHNraXBVcGRhdGUgPSAhMSksIHN1cGVyLmdldEJvdW5kcyhza2lwVXBkYXRlLCByZWN0KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSB0ZXh0IG9iamVjdC5cbiAgICogQHBhcmFtIHJlY3QgLSBUaGUgb3V0cHV0IHJlY3RhbmdsZS5cbiAgICogQHJldHVybnMgVGhlIGJvdW5kcy5cbiAgICovXG4gIGdldExvY2FsQm91bmRzKHJlY3QpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVUZXh0KCEwKSwgc3VwZXIuZ2V0TG9jYWxCb3VuZHMuY2FsbCh0aGlzLCByZWN0KTtcbiAgfVxuICAvKiogQ2FsY3VsYXRlcyB0aGUgYm91bmRzIG9mIHRoZSBUZXh0IGFzIGEgcmVjdGFuZ2xlLiBUaGUgYm91bmRzIGNhbGN1bGF0aW9uIHRha2VzIHRoZSB3b3JsZFRyYW5zZm9ybSBpbnRvIGFjY291bnQuICovXG4gIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpLCB0aGlzLl9ib3VuZHMuYWRkUXVhZCh0aGlzLnZlcnRleERhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIGZpbGwgc3R5bGUuIENhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIGEgZ3JhZGllbnQgYmFzZWQgb24gdGhlIGZpbGwgc3R5bGUgYmVpbmcgYW4gYXJyYXlcbiAgICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlLlxuICAgKiBAcGFyYW0gbGluZXMgLSBUaGUgbGluZXMgb2YgdGV4dC5cbiAgICogQHBhcmFtIG1ldHJpY3NcbiAgICogQHJldHVybnMgVGhlIGZpbGwgc3R5bGVcbiAgICovXG4gIF9nZW5lcmF0ZUZpbGxTdHlsZShzdHlsZSwgbGluZXMsIG1ldHJpY3MpIHtcbiAgICBjb25zdCBmaWxsU3R5bGUgPSBzdHlsZS5maWxsO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpbGxTdHlsZSkpIHtcbiAgICAgIGlmIChmaWxsU3R5bGUubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gZmlsbFN0eWxlWzBdO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIGZpbGxTdHlsZTtcbiAgICBsZXQgZ3JhZGllbnQ7XG4gICAgY29uc3QgZHJvcFNoYWRvd0NvcnJlY3Rpb24gPSBzdHlsZS5kcm9wU2hhZG93ID8gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlIDogMCwgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcgfHwgMCwgd2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCAvIHRoaXMuX3Jlc29sdXRpb24gLSBkcm9wU2hhZG93Q29ycmVjdGlvbiAtIHBhZGRpbmcgKiAyLCBoZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgLyB0aGlzLl9yZXNvbHV0aW9uIC0gZHJvcFNoYWRvd0NvcnJlY3Rpb24gLSBwYWRkaW5nICogMiwgZmlsbCA9IGZpbGxTdHlsZS5zbGljZSgpLCBmaWxsR3JhZGllbnRTdG9wcyA9IHN0eWxlLmZpbGxHcmFkaWVudFN0b3BzLnNsaWNlKCk7XG4gICAgaWYgKCFmaWxsR3JhZGllbnRTdG9wcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxlbmd0aFBsdXMxID0gZmlsbC5sZW5ndGggKyAxO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGhQbHVzMTsgKytpKVxuICAgICAgICBmaWxsR3JhZGllbnRTdG9wcy5wdXNoKGkgLyBsZW5ndGhQbHVzMSk7XG4gICAgfVxuICAgIGlmIChmaWxsLnVuc2hpZnQoZmlsbFN0eWxlWzBdKSwgZmlsbEdyYWRpZW50U3RvcHMudW5zaGlmdCgwKSwgZmlsbC5wdXNoKGZpbGxTdHlsZVtmaWxsU3R5bGUubGVuZ3RoIC0gMV0pLCBmaWxsR3JhZGllbnRTdG9wcy5wdXNoKDEpLCBzdHlsZS5maWxsR3JhZGllbnRUeXBlID09PSBfY29uc3QuVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwpIHtcbiAgICAgIGdyYWRpZW50ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHdpZHRoIC8gMiwgcGFkZGluZywgd2lkdGggLyAyLCBoZWlnaHQgKyBwYWRkaW5nKTtcbiAgICAgIGNvbnN0IHRleHRIZWlnaHQgPSBtZXRyaWNzLmZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplICsgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsYXN0TGluZUJvdHRvbSA9IG1ldHJpY3MubGluZUhlaWdodCAqIChpIC0gMSkgKyB0ZXh0SGVpZ2h0LCB0aGlzTGluZVRvcCA9IG1ldHJpY3MubGluZUhlaWdodCAqIGk7XG4gICAgICAgIGxldCB0aGlzTGluZUdyYWRpZW50U3RhcnQgPSB0aGlzTGluZVRvcDtcbiAgICAgICAgaSA+IDAgJiYgbGFzdExpbmVCb3R0b20gPiB0aGlzTGluZVRvcCAmJiAodGhpc0xpbmVHcmFkaWVudFN0YXJ0ID0gKHRoaXNMaW5lVG9wICsgbGFzdExpbmVCb3R0b20pIC8gMik7XG4gICAgICAgIGNvbnN0IHRoaXNMaW5lQm90dG9tID0gdGhpc0xpbmVUb3AgKyB0ZXh0SGVpZ2h0LCBuZXh0TGluZVRvcCA9IG1ldHJpY3MubGluZUhlaWdodCAqIChpICsgMSk7XG4gICAgICAgIGxldCB0aGlzTGluZUdyYWRpZW50RW5kID0gdGhpc0xpbmVCb3R0b207XG4gICAgICAgIGkgKyAxIDwgbGluZXMubGVuZ3RoICYmIG5leHRMaW5lVG9wIDwgdGhpc0xpbmVCb3R0b20gJiYgKHRoaXNMaW5lR3JhZGllbnRFbmQgPSAodGhpc0xpbmVCb3R0b20gKyBuZXh0TGluZVRvcCkgLyAyKTtcbiAgICAgICAgY29uc3QgZ3JhZFN0b3BMaW5lSGVpZ2h0ID0gKHRoaXNMaW5lR3JhZGllbnRFbmQgLSB0aGlzTGluZUdyYWRpZW50U3RhcnQpIC8gaGVpZ2h0O1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpbGwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBsZXQgbGluZVN0b3AgPSAwO1xuICAgICAgICAgIHR5cGVvZiBmaWxsR3JhZGllbnRTdG9wc1tqXSA9PSBcIm51bWJlclwiID8gbGluZVN0b3AgPSBmaWxsR3JhZGllbnRTdG9wc1tqXSA6IGxpbmVTdG9wID0gaiAvIGZpbGwubGVuZ3RoO1xuICAgICAgICAgIGxldCBnbG9iYWxTdG9wID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGhpc0xpbmVHcmFkaWVudFN0YXJ0IC8gaGVpZ2h0ICsgbGluZVN0b3AgKiBncmFkU3RvcExpbmVIZWlnaHRcbiAgICAgICAgICApKTtcbiAgICAgICAgICBnbG9iYWxTdG9wID0gTnVtYmVyKGdsb2JhbFN0b3AudG9GaXhlZCg1KSksIGdyYWRpZW50LmFkZENvbG9yU3RvcChnbG9iYWxTdG9wLCBmaWxsW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBncmFkaWVudCA9IHRoaXMuY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChwYWRkaW5nLCBoZWlnaHQgLyAyLCB3aWR0aCArIHBhZGRpbmcsIGhlaWdodCAvIDIpO1xuICAgICAgY29uc3QgdG90YWxJdGVyYXRpb25zID0gZmlsbC5sZW5ndGggKyAxO1xuICAgICAgbGV0IGN1cnJlbnRJdGVyYXRpb24gPSAxO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzdG9wO1xuICAgICAgICB0eXBlb2YgZmlsbEdyYWRpZW50U3RvcHNbaV0gPT0gXCJudW1iZXJcIiA/IHN0b3AgPSBmaWxsR3JhZGllbnRTdG9wc1tpXSA6IHN0b3AgPSBjdXJyZW50SXRlcmF0aW9uIC8gdG90YWxJdGVyYXRpb25zLCBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcCwgZmlsbFtpXSksIGN1cnJlbnRJdGVyYXRpb24rKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyYWRpZW50O1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIHRleHQgb2JqZWN0LlxuICAgKlxuICAgKiBOb3RlKiBVbmxpa2UgYSBTcHJpdGUsIGEgVGV4dCBvYmplY3Qgd2lsbCBhdXRvbWF0aWNhbGx5IGRlc3Ryb3kgaXRzIGJhc2VUZXh0dXJlIGFuZCB0ZXh0dXJlIGFzXG4gICAqIHRoZSBtYWpvcml0eSBvZiB0aGUgdGltZSB0aGUgdGV4dHVyZSB3aWxsIG5vdCBiZSBzaGFyZWQgd2l0aCBhbnkgb3RoZXIgU3ByaXRlcy5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXJcbiAgICogIGRlc3Ryb3kgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT10cnVlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBjdXJyZW50IHRleHR1cmUgb2YgdGhlIHNwcml0ZSBhcyB3ZWxsXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9dHJ1ZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgKi9cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgdHlwZW9mIG9wdGlvbnMgPT0gXCJib29sZWFuXCIgJiYgKG9wdGlvbnMgPSB7IGNoaWxkcmVuOiBvcHRpb25zIH0pLCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdERlc3Ryb3lPcHRpb25zLCBvcHRpb25zKSwgc3VwZXIuZGVzdHJveShvcHRpb25zKSwgdGhpcy5fb3duQ2FudmFzICYmICh0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy53aWR0aCA9IDApLCB0aGlzLmNvbnRleHQgPSBudWxsLCB0aGlzLmNhbnZhcyA9IG51bGwsIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgfVxuICAvKiogVGhlIHdpZHRoIG9mIHRoZSBUZXh0LCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldC4gKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVRleHQoITApLCBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMudXBkYXRlVGV4dCghMCk7XG4gICAgY29uc3QgcyA9IGNvcmUudXRpbHMuc2lnbih0aGlzLnNjYWxlLngpIHx8IDE7XG4gICAgdGhpcy5zY2FsZS54ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoLCB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0LCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldC4gKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVUZXh0KCEwKSwgTWF0aC5hYnModGhpcy5zY2FsZS55KSAqIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMudXBkYXRlVGV4dCghMCk7XG4gICAgY29uc3QgcyA9IGNvcmUudXRpbHMuc2lnbih0aGlzLnNjYWxlLnkpIHx8IDE7XG4gICAgdGhpcy5zY2FsZS55ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodCwgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgc3R5bGUgb2YgdGhlIHRleHQuXG4gICAqXG4gICAqIFNldCB1cCBhbiBldmVudCBsaXN0ZW5lciB0byBsaXN0ZW4gZm9yIGNoYW5nZXMgb24gdGhlIHN0eWxlIG9iamVjdCBhbmQgbWFyayB0aGUgdGV4dCBhcyBkaXJ0eS5cbiAgICpcbiAgICogSWYgc2V0dGluZyB0aGUgYHN0eWxlYCBjYW4gYWxzbyBiZSBwYXJ0aWFsIHtAbGluayBQSVhJLklUZXh0U3R5bGV9LlxuICAgKi9cbiAgZ2V0IHN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgfVxuICBzZXQgc3R5bGUoc3R5bGUpIHtcbiAgICBzdHlsZSA9IHN0eWxlIHx8IHt9LCBzdHlsZSBpbnN0YW5jZW9mIFRleHRTdHlsZS5UZXh0U3R5bGUgPyB0aGlzLl9zdHlsZSA9IHN0eWxlIDogdGhpcy5fc3R5bGUgPSBuZXcgVGV4dFN0eWxlLlRleHRTdHlsZShzdHlsZSksIHRoaXMubG9jYWxTdHlsZUlEID0gLTEsIHRoaXMuZGlydHkgPSAhMDtcbiAgfVxuICAvKiogU2V0IHRoZSBjb3B5IGZvciB0aGUgdGV4dCBvYmplY3QuIFRvIHNwbGl0IGEgbGluZSB5b3UgY2FuIHVzZSAnXFxuJy4gKi9cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gIH1cbiAgc2V0IHRleHQodGV4dCkge1xuICAgIHRleHQgPSBTdHJpbmcodGV4dCA/PyBcIlwiKSwgdGhpcy5fdGV4dCAhPT0gdGV4dCAmJiAodGhpcy5fdGV4dCA9IHRleHQsIHRoaXMuZGlydHkgPSAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSBjYW52YXMuXG4gICAqXG4gICAqIFRoaXMgaXMgc2V0IHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggdGhlIHJlbmRlcmVyIHJlc29sdXRpb24gYnkgZGVmYXVsdCwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgbWFudWFsbHkuXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fYXV0b1Jlc29sdXRpb24gPSAhMSwgdGhpcy5fcmVzb2x1dGlvbiAhPT0gdmFsdWUgJiYgKHRoaXMuX3Jlc29sdXRpb24gPSB2YWx1ZSwgdGhpcy5kaXJ0eSA9ICEwKTtcbiAgfVxufTtcbl9UZXh0LmRlZmF1bHRBdXRvUmVzb2x1dGlvbiA9ICEwO1xubGV0IFRleHQgPSBfVGV4dDtcbmV4cG9ydHMuVGV4dCA9IFRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZSA9IHJlcXVpcmUoXCJAcGl4aS9jb3JlXCIpO1xuY29uc3QgY29udGV4dFNldHRpbmdzID0ge1xuICAvLyBUZXh0TWV0cmljcyByZXF1aXJlcyBnZXRJbWFnZURhdGEgcmVhZGJhY2sgZm9yIG1lYXN1cmluZyBmb250cy5cbiAgd2lsbFJlYWRGcmVxdWVudGx5OiAhMFxufSwgX1RleHRNZXRyaWNzID0gY2xhc3MgX1RleHRNZXRyaWNzMiB7XG4gIC8qKlxuICAgKiBDaGVja2luZyB0aGF0IHdlIGNhbiB1c2UgbW9kZXJuIGNhbnZhcyAyRCBBUEkuXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgaXMgYW4gdW5zdGFibGUgQVBJLCBDaHJvbWUgPCA5NCB1c2UgYHRleHRMZXR0ZXJTcGFjaW5nYCwgbGF0ZXIgdmVyc2lvbnMgdXNlIGBsZXR0ZXJTcGFjaW5nYC5cbiAgICogQHNlZSBQSVhJLlRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2xldHRlclNwYWNpbmdcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL29yaWdpbnRyaWFscy8jL3ZpZXdfdHJpYWwvMzU4NTk5MTIwMzI5Mzc1NzQ0MVxuICAgKi9cbiAgc3RhdGljIGdldCBleHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkKCkge1xuICAgIGxldCByZXN1bHQgPSBfVGV4dE1ldHJpY3MyLl9leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkO1xuICAgIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgcHJvdG8gPSBjb3JlLnNldHRpbmdzLkFEQVBURVIuZ2V0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKCkucHJvdG90eXBlO1xuICAgICAgcmVzdWx0ID0gX1RleHRNZXRyaWNzMi5fZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1N1cHBvcnRlZCA9IFwibGV0dGVyU3BhY2luZ1wiIGluIHByb3RvIHx8IFwidGV4dExldHRlclNwYWNpbmdcIiBpbiBwcm90bztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHRleHQgLSB0aGUgdGV4dCB0aGF0IHdhcyBtZWFzdXJlZFxuICAgKiBAcGFyYW0gc3R5bGUgLSB0aGUgc3R5bGUgdGhhdCB3YXMgbWVhc3VyZWRcbiAgICogQHBhcmFtIHdpZHRoIC0gdGhlIG1lYXN1cmVkIHdpZHRoIG9mIHRoZSB0ZXh0XG4gICAqIEBwYXJhbSBoZWlnaHQgLSB0aGUgbWVhc3VyZWQgaGVpZ2h0IG9mIHRoZSB0ZXh0XG4gICAqIEBwYXJhbSBsaW5lcyAtIGFuIGFycmF5IG9mIHRoZSBsaW5lcyBvZiB0ZXh0IGJyb2tlbiBieSBuZXcgbGluZXMgYW5kIHdyYXBwaW5nIGlmIHNwZWNpZmllZCBpbiBzdHlsZVxuICAgKiBAcGFyYW0gbGluZVdpZHRocyAtIGFuIGFycmF5IG9mIHRoZSBsaW5lIHdpZHRocyBmb3IgZWFjaCBsaW5lIG1hdGNoZWQgdG8gYGxpbmVzYFxuICAgKiBAcGFyYW0gbGluZUhlaWdodCAtIHRoZSBtZWFzdXJlZCBsaW5lIGhlaWdodCBmb3IgdGhpcyBzdHlsZVxuICAgKiBAcGFyYW0gbWF4TGluZVdpZHRoIC0gdGhlIG1heGltdW0gbGluZSB3aWR0aCBmb3IgYWxsIG1lYXN1cmVkIGxpbmVzXG4gICAqIEBwYXJhbSB7UElYSS5JRm9udE1ldHJpY3N9IGZvbnRQcm9wZXJ0aWVzIC0gdGhlIGZvbnQgcHJvcGVydGllcyBvYmplY3QgZnJvbSBUZXh0TWV0cmljcy5tZWFzdXJlRm9udFxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4dCwgc3R5bGUsIHdpZHRoLCBoZWlnaHQsIGxpbmVzLCBsaW5lV2lkdGhzLCBsaW5lSGVpZ2h0LCBtYXhMaW5lV2lkdGgsIGZvbnRQcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dCwgdGhpcy5zdHlsZSA9IHN0eWxlLCB0aGlzLndpZHRoID0gd2lkdGgsIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0LCB0aGlzLmxpbmVzID0gbGluZXMsIHRoaXMubGluZVdpZHRocyA9IGxpbmVXaWR0aHMsIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQsIHRoaXMubWF4TGluZVdpZHRoID0gbWF4TGluZVdpZHRoLCB0aGlzLmZvbnRQcm9wZXJ0aWVzID0gZm9udFByb3BlcnRpZXM7XG4gIH1cbiAgLyoqXG4gICAqIE1lYXN1cmVzIHRoZSBzdXBwbGllZCBzdHJpbmcgb2YgdGV4dCBhbmQgcmV0dXJucyBhIFJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dCB0byBtZWFzdXJlLlxuICAgKiBAcGFyYW0gc3R5bGUgLSBUaGUgdGV4dCBzdHlsZSB0byB1c2UgZm9yIG1lYXN1cmluZ1xuICAgKiBAcGFyYW0gd29yZFdyYXAgLSBPdmVycmlkZSBmb3IgaWYgd29yZC13cmFwIHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSB0ZXh0LlxuICAgKiBAcGFyYW0gY2FudmFzIC0gb3B0aW9uYWwgc3BlY2lmaWNhdGlvbiBvZiB0aGUgY2FudmFzIHRvIHVzZSBmb3IgbWVhc3VyaW5nLlxuICAgKiBAcmV0dXJucyBNZWFzdXJlZCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB0ZXh0LlxuICAgKi9cbiAgc3RhdGljIG1lYXN1cmVUZXh0KHRleHQsIHN0eWxlLCB3b3JkV3JhcCwgY2FudmFzID0gX1RleHRNZXRyaWNzMi5fY2FudmFzKSB7XG4gICAgd29yZFdyYXAgPSB3b3JkV3JhcCA/PyBzdHlsZS53b3JkV3JhcDtcbiAgICBjb25zdCBmb250ID0gc3R5bGUudG9Gb250U3RyaW5nKCksIGZvbnRQcm9wZXJ0aWVzID0gX1RleHRNZXRyaWNzMi5tZWFzdXJlRm9udChmb250KTtcbiAgICBmb250UHJvcGVydGllcy5mb250U2l6ZSA9PT0gMCAmJiAoZm9udFByb3BlcnRpZXMuZm9udFNpemUgPSBzdHlsZS5mb250U2l6ZSwgZm9udFByb3BlcnRpZXMuYXNjZW50ID0gc3R5bGUuZm9udFNpemUpO1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRTZXR0aW5ncyk7XG4gICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICBjb25zdCBsaW5lcyA9ICh3b3JkV3JhcCA/IF9UZXh0TWV0cmljczIud29yZFdyYXAodGV4dCwgc3R5bGUsIGNhbnZhcykgOiB0ZXh0KS5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyksIGxpbmVXaWR0aHMgPSBuZXcgQXJyYXkobGluZXMubGVuZ3RoKTtcbiAgICBsZXQgbWF4TGluZVdpZHRoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSBfVGV4dE1ldHJpY3MyLl9tZWFzdXJlVGV4dChsaW5lc1tpXSwgc3R5bGUubGV0dGVyU3BhY2luZywgY29udGV4dCk7XG4gICAgICBsaW5lV2lkdGhzW2ldID0gbGluZVdpZHRoLCBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgfVxuICAgIGxldCB3aWR0aCA9IG1heExpbmVXaWR0aCArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICBzdHlsZS5kcm9wU2hhZG93ICYmICh3aWR0aCArPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UpO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBzdHlsZS5saW5lSGVpZ2h0IHx8IGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplICsgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuICAgIGxldCBoZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCBmb250UHJvcGVydGllcy5mb250U2l6ZSArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAqIDIpICsgc3R5bGUubGVhZGluZyArIChsaW5lcy5sZW5ndGggLSAxKSAqIChsaW5lSGVpZ2h0ICsgc3R5bGUubGVhZGluZyk7XG4gICAgcmV0dXJuIHN0eWxlLmRyb3BTaGFkb3cgJiYgKGhlaWdodCArPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UpLCBuZXcgX1RleHRNZXRyaWNzMihcbiAgICAgIHRleHQsXG4gICAgICBzdHlsZSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbGluZXMsXG4gICAgICBsaW5lV2lkdGhzLFxuICAgICAgbGluZUhlaWdodCArIHN0eWxlLmxlYWRpbmcsXG4gICAgICBtYXhMaW5lV2lkdGgsXG4gICAgICBmb250UHJvcGVydGllc1xuICAgICk7XG4gIH1cbiAgc3RhdGljIF9tZWFzdXJlVGV4dCh0ZXh0LCBsZXR0ZXJTcGFjaW5nLCBjb250ZXh0KSB7XG4gICAgbGV0IHVzZUV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSAhMTtcbiAgICBfVGV4dE1ldHJpY3MyLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQgJiYgKF9UZXh0TWV0cmljczIuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA/IChjb250ZXh0LmxldHRlclNwYWNpbmcgPSBgJHtsZXR0ZXJTcGFjaW5nfXB4YCwgY29udGV4dC50ZXh0TGV0dGVyU3BhY2luZyA9IGAke2xldHRlclNwYWNpbmd9cHhgLCB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gITApIDogKGNvbnRleHQubGV0dGVyU3BhY2luZyA9IFwiMHB4XCIsIGNvbnRleHQudGV4dExldHRlclNwYWNpbmcgPSBcIjBweFwiKSk7XG4gICAgbGV0IHdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICByZXR1cm4gd2lkdGggPiAwICYmICh1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID8gd2lkdGggLT0gbGV0dGVyU3BhY2luZyA6IHdpZHRoICs9IChfVGV4dE1ldHJpY3MyLmdyYXBoZW1lU2VnbWVudGVyKHRleHQpLmxlbmd0aCAtIDEpICogbGV0dGVyU3BhY2luZyksIHdpZHRoO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIG5ld2xpbmVzIHRvIGEgc3RyaW5nIHRvIGhhdmUgaXQgb3B0aW1hbGx5IGZpdCBpbnRvIHRoZSBob3Jpem9udGFsXG4gICAqIGJvdW5kcyBzZXQgYnkgdGhlIFRleHQgb2JqZWN0J3Mgd29yZFdyYXBXaWR0aCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHRleHQgLSBTdHJpbmcgdG8gYXBwbHkgd29yZCB3cmFwcGluZyB0b1xuICAgKiBAcGFyYW0gc3R5bGUgLSB0aGUgc3R5bGUgdG8gdXNlIHdoZW4gd3JhcHBpbmdcbiAgICogQHBhcmFtIGNhbnZhcyAtIG9wdGlvbmFsIHNwZWNpZmljYXRpb24gb2YgdGhlIGNhbnZhcyB0byB1c2UgZm9yIG1lYXN1cmluZy5cbiAgICogQHJldHVybnMgTmV3IHN0cmluZyB3aXRoIG5ldyBsaW5lcyBhcHBsaWVkIHdoZXJlIHJlcXVpcmVkXG4gICAqL1xuICBzdGF0aWMgd29yZFdyYXAodGV4dCwgc3R5bGUsIGNhbnZhcyA9IF9UZXh0TWV0cmljczIuX2NhbnZhcykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRTZXR0aW5ncyk7XG4gICAgbGV0IHdpZHRoID0gMCwgbGluZSA9IFwiXCIsIGxpbmVzID0gXCJcIjtcbiAgICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB7IGxldHRlclNwYWNpbmcsIHdoaXRlU3BhY2UgfSA9IHN0eWxlLCBjb2xsYXBzZVNwYWNlcyA9IF9UZXh0TWV0cmljczIuY29sbGFwc2VTcGFjZXMod2hpdGVTcGFjZSksIGNvbGxhcHNlTmV3bGluZXMgPSBfVGV4dE1ldHJpY3MyLmNvbGxhcHNlTmV3bGluZXMod2hpdGVTcGFjZSk7XG4gICAgbGV0IGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XG4gICAgY29uc3Qgd29yZFdyYXBXaWR0aCA9IHN0eWxlLndvcmRXcmFwV2lkdGggKyBsZXR0ZXJTcGFjaW5nLCB0b2tlbnMgPSBfVGV4dE1ldHJpY3MyLnRva2VuaXplKHRleHQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICBpZiAoX1RleHRNZXRyaWNzMi5pc05ld2xpbmUodG9rZW4pKSB7XG4gICAgICAgIGlmICghY29sbGFwc2VOZXdsaW5lcykge1xuICAgICAgICAgIGxpbmVzICs9IF9UZXh0TWV0cmljczIuYWRkTGluZShsaW5lKSwgY2FuUHJlcGVuZFNwYWNlcyA9ICFjb2xsYXBzZVNwYWNlcywgbGluZSA9IFwiXCIsIHdpZHRoID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IFwiIFwiO1xuICAgICAgfVxuICAgICAgaWYgKGNvbGxhcHNlU3BhY2VzKSB7XG4gICAgICAgIGNvbnN0IGN1cnJJc0JyZWFraW5nU3BhY2UgPSBfVGV4dE1ldHJpY3MyLmlzQnJlYWtpbmdTcGFjZSh0b2tlbiksIGxhc3RJc0JyZWFraW5nU3BhY2UgPSBfVGV4dE1ldHJpY3MyLmlzQnJlYWtpbmdTcGFjZShsaW5lW2xpbmUubGVuZ3RoIC0gMV0pO1xuICAgICAgICBpZiAoY3VycklzQnJlYWtpbmdTcGFjZSAmJiBsYXN0SXNCcmVha2luZ1NwYWNlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW5XaWR0aCA9IF9UZXh0TWV0cmljczIuZ2V0RnJvbUNhY2hlKHRva2VuLCBsZXR0ZXJTcGFjaW5nLCBjYWNoZSwgY29udGV4dCk7XG4gICAgICBpZiAodG9rZW5XaWR0aCA+IHdvcmRXcmFwV2lkdGgpXG4gICAgICAgIGlmIChsaW5lICE9PSBcIlwiICYmIChsaW5lcyArPSBfVGV4dE1ldHJpY3MyLmFkZExpbmUobGluZSksIGxpbmUgPSBcIlwiLCB3aWR0aCA9IDApLCBfVGV4dE1ldHJpY3MyLmNhbkJyZWFrV29yZHModG9rZW4sIHN0eWxlLmJyZWFrV29yZHMpKSB7XG4gICAgICAgICAgY29uc3QgY2hhcmFjdGVycyA9IF9UZXh0TWV0cmljczIud29yZFdyYXBTcGxpdCh0b2tlbik7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGFyYWN0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgY2hhciA9IGNoYXJhY3RlcnNbal0sIGxhc3RDaGFyID0gY2hhciwgayA9IDE7XG4gICAgICAgICAgICBmb3IgKDsgY2hhcmFjdGVyc1tqICsga107ICkge1xuICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhciA9IGNoYXJhY3RlcnNbaiArIGtdO1xuICAgICAgICAgICAgICBpZiAoIV9UZXh0TWV0cmljczIuY2FuQnJlYWtDaGFycyhsYXN0Q2hhciwgbmV4dENoYXIsIHRva2VuLCBqLCBzdHlsZS5icmVha1dvcmRzKSlcbiAgICAgICAgICAgICAgICBjaGFyICs9IG5leHRDaGFyO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGxhc3RDaGFyID0gbmV4dENoYXIsIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGogKz0gayAtIDE7XG4gICAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJXaWR0aCA9IF9UZXh0TWV0cmljczIuZ2V0RnJvbUNhY2hlKGNoYXIsIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNoYXJhY3RlcldpZHRoICsgd2lkdGggPiB3b3JkV3JhcFdpZHRoICYmIChsaW5lcyArPSBfVGV4dE1ldHJpY3MyLmFkZExpbmUobGluZSksIGNhblByZXBlbmRTcGFjZXMgPSAhMSwgbGluZSA9IFwiXCIsIHdpZHRoID0gMCksIGxpbmUgKz0gY2hhciwgd2lkdGggKz0gY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmUubGVuZ3RoID4gMCAmJiAobGluZXMgKz0gX1RleHRNZXRyaWNzMi5hZGRMaW5lKGxpbmUpLCBsaW5lID0gXCJcIiwgd2lkdGggPSAwKTtcbiAgICAgICAgICBjb25zdCBpc0xhc3RUb2tlbiA9IGkgPT09IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgIGxpbmVzICs9IF9UZXh0TWV0cmljczIuYWRkTGluZSh0b2tlbiwgIWlzTGFzdFRva2VuKSwgY2FuUHJlcGVuZFNwYWNlcyA9ICExLCBsaW5lID0gXCJcIiwgd2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHRva2VuV2lkdGggKyB3aWR0aCA+IHdvcmRXcmFwV2lkdGggJiYgKGNhblByZXBlbmRTcGFjZXMgPSAhMSwgbGluZXMgKz0gX1RleHRNZXRyaWNzMi5hZGRMaW5lKGxpbmUpLCBsaW5lID0gXCJcIiwgd2lkdGggPSAwKSwgKGxpbmUubGVuZ3RoID4gMCB8fCAhX1RleHRNZXRyaWNzMi5pc0JyZWFraW5nU3BhY2UodG9rZW4pIHx8IGNhblByZXBlbmRTcGFjZXMpICYmIChsaW5lICs9IHRva2VuLCB3aWR0aCArPSB0b2tlbldpZHRoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzICs9IF9UZXh0TWV0cmljczIuYWRkTGluZShsaW5lLCAhMSksIGxpbmVzO1xuICB9XG4gIC8qKlxuICAgKiBDb252aWVuaWVuY2UgZnVuY3Rpb24gZm9yIGxvZ2dpbmcgZWFjaCBsaW5lIGFkZGVkIGR1cmluZyB0aGUgd29yZFdyYXAgbWV0aG9kLlxuICAgKiBAcGFyYW0gbGluZSAgICAtIFRoZSBsaW5lIG9mIHRleHQgdG8gYWRkXG4gICAqIEBwYXJhbSBuZXdMaW5lIC0gQWRkIG5ldyBsaW5lIGNoYXJhY3RlciB0byBlbmRcbiAgICogQHJldHVybnMgQSBmb3JtYXR0ZWQgbGluZVxuICAgKi9cbiAgc3RhdGljIGFkZExpbmUobGluZSwgbmV3TGluZSA9ICEwKSB7XG4gICAgcmV0dXJuIGxpbmUgPSBfVGV4dE1ldHJpY3MyLnRyaW1SaWdodChsaW5lKSwgbGluZSA9IG5ld0xpbmUgPyBgJHtsaW5lfVxuYCA6IGxpbmUsIGxpbmU7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgJiBzZXRzIHRoZSB3aWR0aHMgb2YgY2FsY3VsYXRlZCBjaGFyYWN0ZXJzIGluIGEgY2FjaGUgb2JqZWN0XG4gICAqIEBwYXJhbSBrZXkgICAgICAgICAgICAtIFRoZSBrZXlcbiAgICogQHBhcmFtIGxldHRlclNwYWNpbmcgIC0gVGhlIGxldHRlciBzcGFjaW5nXG4gICAqIEBwYXJhbSBjYWNoZSAgICAgICAgICAtIFRoZSBjYWNoZVxuICAgKiBAcGFyYW0gY29udGV4dCAgICAgICAgLSBUaGUgY2FudmFzIGNvbnRleHRcbiAgICogQHJldHVybnMgVGhlIGZyb20gY2FjaGUuXG4gICAqL1xuICBzdGF0aWMgZ2V0RnJvbUNhY2hlKGtleSwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpIHtcbiAgICBsZXQgd2lkdGggPSBjYWNoZVtrZXldO1xuICAgIHJldHVybiB0eXBlb2Ygd2lkdGggIT0gXCJudW1iZXJcIiAmJiAod2lkdGggPSBfVGV4dE1ldHJpY3MyLl9tZWFzdXJlVGV4dChrZXksIGxldHRlclNwYWNpbmcsIGNvbnRleHQpICsgbGV0dGVyU3BhY2luZywgY2FjaGVba2V5XSA9IHdpZHRoKSwgd2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB3ZSBzaG91bGQgY29sbGFwc2UgYnJlYWtpbmcgc3BhY2VzLlxuICAgKiBAcGFyYW0gd2hpdGVTcGFjZSAtIFRoZSBUZXh0U3R5bGUgcHJvcGVydHkgd2hpdGVTcGFjZVxuICAgKiBAcmV0dXJucyBTaG91bGQgY29sbGFwc2VcbiAgICovXG4gIHN0YXRpYyBjb2xsYXBzZVNwYWNlcyh3aGl0ZVNwYWNlKSB7XG4gICAgcmV0dXJuIHdoaXRlU3BhY2UgPT09IFwibm9ybWFsXCIgfHwgd2hpdGVTcGFjZSA9PT0gXCJwcmUtbGluZVwiO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIGNvbGxhcHNlIG5ld0xpbmUgY2hhcnMuXG4gICAqIEBwYXJhbSB3aGl0ZVNwYWNlIC0gVGhlIHdoaXRlIHNwYWNlXG4gICAqIEByZXR1cm5zIHNob3VsZCBjb2xsYXBzZVxuICAgKi9cbiAgc3RhdGljIGNvbGxhcHNlTmV3bGluZXMod2hpdGVTcGFjZSkge1xuICAgIHJldHVybiB3aGl0ZVNwYWNlID09PSBcIm5vcm1hbFwiO1xuICB9XG4gIC8qKlxuICAgKiBUcmltcyBicmVha2luZyB3aGl0ZXNwYWNlcyBmcm9tIHN0cmluZy5cbiAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dFxuICAgKiBAcmV0dXJucyBUcmltbWVkIHN0cmluZ1xuICAgKi9cbiAgc3RhdGljIHRyaW1SaWdodCh0ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiB0ZXh0ICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgY2hhciA9IHRleHRbaV07XG4gICAgICBpZiAoIV9UZXh0TWV0cmljczIuaXNCcmVha2luZ1NwYWNlKGNoYXIpKVxuICAgICAgICBicmVhaztcbiAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgY2hhciBpcyBhIG5ld2xpbmUuXG4gICAqIEBwYXJhbSBjaGFyIC0gVGhlIGNoYXJhY3RlclxuICAgKiBAcmV0dXJucyBUcnVlIGlmIG5ld2xpbmUsIEZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBpc05ld2xpbmUoY2hhcikge1xuICAgIHJldHVybiB0eXBlb2YgY2hhciAhPSBcInN0cmluZ1wiID8gITEgOiBfVGV4dE1ldHJpY3MyLl9uZXdsaW5lcy5pbmNsdWRlcyhjaGFyLmNoYXJDb2RlQXQoMCkpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGNoYXIgaXMgYSBicmVha2luZyB3aGl0ZXNwYWNlLlxuICAgKlxuICAgKiBJdCBhbGxvd3Mgb25lIHRvIGRldGVybWluZSB3aGV0aGVyIGNoYXIgc2hvdWxkIGJlIGEgYnJlYWtpbmcgd2hpdGVzcGFjZVxuICAgKiBGb3IgZXhhbXBsZSBjZXJ0YWluIGNoYXJhY3RlcnMgaW4gQ0pLIGxhbmdzIG9yIG51bWJlcnMuXG4gICAqIEl0IG11c3QgcmV0dXJuIGEgYm9vbGVhbi5cbiAgICogQHBhcmFtIGNoYXIgLSBUaGUgY2hhcmFjdGVyXG4gICAqIEBwYXJhbSBbX25leHRDaGFyXSAtIFRoZSBuZXh0IGNoYXJhY3RlclxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHdoaXRlc3BhY2UsIEZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBpc0JyZWFraW5nU3BhY2UoY2hhciwgX25leHRDaGFyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjaGFyICE9IFwic3RyaW5nXCIgPyAhMSA6IF9UZXh0TWV0cmljczIuX2JyZWFraW5nU3BhY2VzLmluY2x1ZGVzKGNoYXIuY2hhckNvZGVBdCgwKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIHdvcmRzLCBicmVha2luZy1zcGFjZXMgYW5kIG5ld0xpbmUgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0gdGV4dCAtIFRoZSB0ZXh0XG4gICAqIEByZXR1cm5zIEEgdG9rZW5pemVkIGFycmF5XG4gICAqL1xuICBzdGF0aWMgdG9rZW5pemUodGV4dCkge1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGxldCB0b2tlbiA9IFwiXCI7XG4gICAgaWYgKHR5cGVvZiB0ZXh0ICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IHRleHRbaV0sIG5leHRDaGFyID0gdGV4dFtpICsgMV07XG4gICAgICBpZiAoX1RleHRNZXRyaWNzMi5pc0JyZWFraW5nU3BhY2UoY2hhciwgbmV4dENoYXIpIHx8IF9UZXh0TWV0cmljczIuaXNOZXdsaW5lKGNoYXIpKSB7XG4gICAgICAgIHRva2VuICE9PSBcIlwiICYmICh0b2tlbnMucHVzaCh0b2tlbiksIHRva2VuID0gXCJcIiksIHRva2Vucy5wdXNoKGNoYXIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRva2VuICs9IGNoYXI7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbiAhPT0gXCJcIiAmJiB0b2tlbnMucHVzaCh0b2tlbiksIHRva2VucztcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgaGVscGVyIG1ldGhvZCB1c2VkIGludGVybmFsbHkgYnkgVGV4dE1ldHJpY3MsIGV4cG9zZWQgdG8gYWxsb3cgY3VzdG9taXppbmcgdGhlIGNsYXNzJ3MgYmVoYXZpb3IuXG4gICAqXG4gICAqIEl0IGFsbG93cyBvbmUgdG8gY3VzdG9taXNlIHdoaWNoIHdvcmRzIHNob3VsZCBicmVha1xuICAgKiBFeGFtcGxlcyBhcmUgaWYgdGhlIHRva2VuIGlzIENKSyBvciBudW1iZXJzLlxuICAgKiBJdCBtdXN0IHJldHVybiBhIGJvb2xlYW4uXG4gICAqIEBwYXJhbSBfdG9rZW4gLSBUaGUgdG9rZW5cbiAgICogQHBhcmFtIGJyZWFrV29yZHMgLSBUaGUgc3R5bGUgYXR0ciBicmVhayB3b3Jkc1xuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRvIGJyZWFrIHdvcmQgb3Igbm90XG4gICAqL1xuICBzdGF0aWMgY2FuQnJlYWtXb3JkcyhfdG9rZW4sIGJyZWFrV29yZHMpIHtcbiAgICByZXR1cm4gYnJlYWtXb3JkcztcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgaGVscGVyIG1ldGhvZCB1c2VkIGludGVybmFsbHkgYnkgVGV4dE1ldHJpY3MsIGV4cG9zZWQgdG8gYWxsb3cgY3VzdG9taXppbmcgdGhlIGNsYXNzJ3MgYmVoYXZpb3IuXG4gICAqXG4gICAqIEl0IGFsbG93cyBvbmUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBwYWlyIG9mIGNoYXJhY3RlcnNcbiAgICogc2hvdWxkIGJlIGJyb2tlbiBieSBuZXdsaW5lc1xuICAgKiBGb3IgZXhhbXBsZSBjZXJ0YWluIGNoYXJhY3RlcnMgaW4gQ0pLIGxhbmdzIG9yIG51bWJlcnMuXG4gICAqIEl0IG11c3QgcmV0dXJuIGEgYm9vbGVhbi5cbiAgICogQHBhcmFtIF9jaGFyIC0gVGhlIGNoYXJhY3RlclxuICAgKiBAcGFyYW0gX25leHRDaGFyIC0gVGhlIG5leHQgY2hhcmFjdGVyXG4gICAqIEBwYXJhbSBfdG9rZW4gLSBUaGUgdG9rZW4vd29yZCB0aGUgY2hhcmFjdGVycyBhcmUgZnJvbVxuICAgKiBAcGFyYW0gX2luZGV4IC0gVGhlIGluZGV4IGluIHRoZSB0b2tlbiBvZiB0aGUgY2hhclxuICAgKiBAcGFyYW0gX2JyZWFrV29yZHMgLSBUaGUgc3R5bGUgYXR0ciBicmVhayB3b3Jkc1xuICAgKiBAcmV0dXJucyB3aGV0aGVyIHRvIGJyZWFrIHdvcmQgb3Igbm90XG4gICAqL1xuICBzdGF0aWMgY2FuQnJlYWtDaGFycyhfY2hhciwgX25leHRDaGFyLCBfdG9rZW4sIF9pbmRleCwgX2JyZWFrV29yZHMpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRhYmxlIGhlbHBlciBtZXRob2QgdXNlZCBpbnRlcm5hbGx5IGJ5IFRleHRNZXRyaWNzLCBleHBvc2VkIHRvIGFsbG93IGN1c3RvbWl6aW5nIHRoZSBjbGFzcydzIGJlaGF2aW9yLlxuICAgKlxuICAgKiBJdCBpcyBjYWxsZWQgd2hlbiBhIHRva2VuICh1c3VhbGx5IGEgd29yZCkgaGFzIHRvIGJlIHNwbGl0IGludG8gc2VwYXJhdGUgcGllY2VzXG4gICAqIGluIG9yZGVyIHRvIGRldGVybWluZSB0aGUgcG9pbnQgdG8gYnJlYWsgYSB3b3JkLlxuICAgKiBJdCBtdXN0IHJldHVybiBhbiBhcnJheSBvZiBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gdG9rZW4gLSBUaGUgdG9rZW4gdG8gc3BsaXRcbiAgICogQHJldHVybnMgVGhlIGNoYXJhY3RlcnMgb2YgdGhlIHRva2VuXG4gICAqIEBzZWUgVGV4dE1ldHJpY3MuZ3JhcGhlbWVTZWdtZW50ZXJcbiAgICovXG4gIHN0YXRpYyB3b3JkV3JhcFNwbGl0KHRva2VuKSB7XG4gICAgcmV0dXJuIF9UZXh0TWV0cmljczIuZ3JhcGhlbWVTZWdtZW50ZXIodG9rZW4pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBhc2NlbnQsIGRlc2NlbnQgYW5kIGZvbnRTaXplIG9mIGEgZ2l2ZW4gZm9udC1zdHlsZVxuICAgKiBAcGFyYW0gZm9udCAtIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIHN0eWxlIG9mIHRoZSBmb250XG4gICAqIEByZXR1cm5zIEZvbnQgcHJvcGVydGllcyBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBtZWFzdXJlRm9udChmb250KSB7XG4gICAgaWYgKF9UZXh0TWV0cmljczIuX2ZvbnRzW2ZvbnRdKVxuICAgICAgcmV0dXJuIF9UZXh0TWV0cmljczIuX2ZvbnRzW2ZvbnRdO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICBhc2NlbnQ6IDAsXG4gICAgICBkZXNjZW50OiAwLFxuICAgICAgZm9udFNpemU6IDBcbiAgICB9LCBjYW52YXMgPSBfVGV4dE1ldHJpY3MyLl9jYW52YXMsIGNvbnRleHQgPSBfVGV4dE1ldHJpY3MyLl9jb250ZXh0O1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgY29uc3QgbWV0cmljc1N0cmluZyA9IF9UZXh0TWV0cmljczIuTUVUUklDU19TVFJJTkcgKyBfVGV4dE1ldHJpY3MyLkJBU0VMSU5FX1NZTUJPTCwgd2lkdGggPSBNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dChtZXRyaWNzU3RyaW5nKS53aWR0aCk7XG4gICAgbGV0IGJhc2VsaW5lID0gTWF0aC5jZWlsKGNvbnRleHQubWVhc3VyZVRleHQoX1RleHRNZXRyaWNzMi5CQVNFTElORV9TWU1CT0wpLndpZHRoKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwoX1RleHRNZXRyaWNzMi5IRUlHSFRfTVVMVElQTElFUiAqIGJhc2VsaW5lKTtcbiAgICBpZiAoYmFzZWxpbmUgPSBiYXNlbGluZSAqIF9UZXh0TWV0cmljczIuQkFTRUxJTkVfTVVMVElQTElFUiB8IDAsIHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMClcbiAgICAgIHJldHVybiBfVGV4dE1ldHJpY3MyLl9mb250c1tmb250XSA9IHByb3BlcnRpZXMsIHByb3BlcnRpZXM7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGgsIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQsIGNvbnRleHQuZmlsbFN0eWxlID0gXCIjZjAwXCIsIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCksIGNvbnRleHQuZm9udCA9IGZvbnQsIGNvbnRleHQudGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCIsIGNvbnRleHQuZmlsbFN0eWxlID0gXCIjMDAwXCIsIGNvbnRleHQuZmlsbFRleHQobWV0cmljc1N0cmluZywgMCwgYmFzZWxpbmUpO1xuICAgIGNvbnN0IGltYWdlZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGEsIHBpeGVscyA9IGltYWdlZGF0YS5sZW5ndGgsIGxpbmUgPSB3aWR0aCAqIDQ7XG4gICAgbGV0IGkgPSAwLCBpZHggPSAwLCBzdG9wID0gITE7XG4gICAgZm9yIChpID0gMDsgaSA8IGJhc2VsaW5lOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZTsgaiArPSA0KVxuICAgICAgICBpZiAoaW1hZ2VkYXRhW2lkeCArIGpdICE9PSAyNTUpIHtcbiAgICAgICAgICBzdG9wID0gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGlmICghc3RvcClcbiAgICAgICAgaWR4ICs9IGxpbmU7XG4gICAgICBlbHNlXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKHByb3BlcnRpZXMuYXNjZW50ID0gYmFzZWxpbmUgLSBpLCBpZHggPSBwaXhlbHMgLSBsaW5lLCBzdG9wID0gITEsIGkgPSBoZWlnaHQ7IGkgPiBiYXNlbGluZTsgLS1pKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmU7IGogKz0gNClcbiAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBqXSAhPT0gMjU1KSB7XG4gICAgICAgICAgc3RvcCA9ICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBpZiAoIXN0b3ApXG4gICAgICAgIGlkeCAtPSBsaW5lO1xuICAgICAgZWxzZVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BlcnRpZXMuZGVzY2VudCA9IGkgLSBiYXNlbGluZSwgcHJvcGVydGllcy5mb250U2l6ZSA9IHByb3BlcnRpZXMuYXNjZW50ICsgcHJvcGVydGllcy5kZXNjZW50LCBfVGV4dE1ldHJpY3MyLl9mb250c1tmb250XSA9IHByb3BlcnRpZXMsIHByb3BlcnRpZXM7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIGZvbnQgbWV0cmljcyBpbiBtZXRyaWNzIGNhY2hlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZvbnRdIC0gZm9udCBuYW1lLiBJZiBmb250IG5hbWUgbm90IHNldCB0aGVuIGNsZWFyIGNhY2hlIGZvciBhbGwgZm9udHMuXG4gICAqL1xuICBzdGF0aWMgY2xlYXJNZXRyaWNzKGZvbnQgPSBcIlwiKSB7XG4gICAgZm9udCA/IGRlbGV0ZSBfVGV4dE1ldHJpY3MyLl9mb250c1tmb250XSA6IF9UZXh0TWV0cmljczIuX2ZvbnRzID0ge307XG4gIH1cbiAgLyoqXG4gICAqIENhY2hlZCBjYW52YXMgZWxlbWVudCBmb3IgbWVhc3VyaW5nIHRleHRcbiAgICogVE9ETzogdGhpcyBzaG91bGQgYmUgcHJpdmF0ZSwgYnV0IGlzbid0IGJlY2F1c2Ugb2YgYmFja3dhcmQgY29tcGF0LCB3aWxsIGZpeCBsYXRlci5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIGdldCBfY2FudmFzKCkge1xuICAgIGlmICghX1RleHRNZXRyaWNzMi5fX2NhbnZhcykge1xuICAgICAgbGV0IGNhbnZhcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuICAgICAgICBpZiAoYy5nZXRDb250ZXh0KFwiMmRcIiwgY29udGV4dFNldHRpbmdzKT8ubWVhc3VyZVRleHQpXG4gICAgICAgICAgcmV0dXJuIF9UZXh0TWV0cmljczIuX19jYW52YXMgPSBjLCBjO1xuICAgICAgICBjYW52YXMgPSBjb3JlLnNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgY2FudmFzID0gY29yZS5zZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgfVxuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDEwLCBfVGV4dE1ldHJpY3MyLl9fY2FudmFzID0gY2FudmFzO1xuICAgIH1cbiAgICByZXR1cm4gX1RleHRNZXRyaWNzMi5fX2NhbnZhcztcbiAgfVxuICAvKipcbiAgICogVE9ETzogdGhpcyBzaG91bGQgYmUgcHJpdmF0ZSwgYnV0IGlzbid0IGJlY2F1c2Ugb2YgYmFja3dhcmQgY29tcGF0LCB3aWxsIGZpeCBsYXRlci5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIGdldCBfY29udGV4dCgpIHtcbiAgICByZXR1cm4gX1RleHRNZXRyaWNzMi5fX2NvbnRleHQgfHwgKF9UZXh0TWV0cmljczIuX19jb250ZXh0ID0gX1RleHRNZXRyaWNzMi5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCBjb250ZXh0U2V0dGluZ3MpKSwgX1RleHRNZXRyaWNzMi5fX2NvbnRleHQ7XG4gIH1cbn07XG5fVGV4dE1ldHJpY3MuTUVUUklDU19TVFJJTkcgPSBcInxcXHhDOXFcXHhDNVwiLCAvKiogQmFzZWxpbmUgc3ltYm9sIGZvciBjYWxjdWxhdGUgZm9udCBtZXRyaWNzLiAqL1xuX1RleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTCA9IFwiTVwiLCAvKiogQmFzZWxpbmUgbXVsdGlwbGllciBmb3IgY2FsY3VsYXRlIGZvbnQgbWV0cmljcy4gKi9cbl9UZXh0TWV0cmljcy5CQVNFTElORV9NVUxUSVBMSUVSID0gMS40LCAvKiogSGVpZ2h0IG11bHRpcGxpZXIgZm9yIHNldHRpbmcgaGVpZ2h0IG9mIGNhbnZhcyB0byBjYWxjdWxhdGUgZm9udCBtZXRyaWNzLiAqL1xuX1RleHRNZXRyaWNzLkhFSUdIVF9NVUxUSVBMSUVSID0gMiwgLyoqXG4qIEEgVW5pY29kZSBcImNoYXJhY3RlclwiLCBvciBcImdyYXBoZW1lIGNsdXN0ZXJcIiwgY2FuIGJlIGNvbXBvc2VkIG9mIG11bHRpcGxlIFVuaWNvZGUgY29kZSBwb2ludHMsXG4qIHN1Y2ggYXMgbGV0dGVycyB3aXRoIGRpYWNyaXRpY2FsIG1hcmtzIChlLmcuIGAnXFx1MDA2NVxcdTAzMDEnYCwgbGV0dGVyIGUgd2l0aCBhY3V0ZSlcbiogb3IgZW1vamlzIHdpdGggbW9kaWZpZXJzIChlLmcuIGAnXFx1RDgzRVxcdURERDFcXHUyMDBEXFx1RDgzRFxcdURDQkInYCwgdGVjaG5vbG9naXN0KS5cbiogVGhlIG5ldyBgSW50bC5TZWdtZW50ZXJgIEFQSSBpbiBFUzIwMjIgY2FuIHNwbGl0IHRoZSBzdHJpbmcgaW50byBncmFwaGVtZSBjbHVzdGVycyBjb3JyZWN0bHkuIElmIGl0IGlzIG5vdCBhdmFpbGFibGUsXG4qIFBpeGlKUyB3aWxsIGZhbGxiYWNrIHRvIHVzZSB0aGUgaXRlcmF0b3Igb2YgU3RyaW5nLCB3aGljaCBjYW4gb25seSBzcGlsdCB0aGUgc3RyaW5nIGludG8gY29kZSBwb2ludHMuXG4qIElmIHlvdSB3YW50IHRvIGdldCBmdWxsIGZ1bmN0aW9uYWxpdHkgaW4gZW52aXJvbm1lbnRzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBgSW50bC5TZWdtZW50ZXJgIChzdWNoIGFzIEZpcmVmb3gpLFxuKiB5b3UgY2FuIHVzZSBvdGhlciBsaWJyYXJpZXMgc3VjaCBhcyBbZ3JhcGhlbWUtc3BsaXR0ZXJde0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2dyYXBoZW1lLXNwbGl0dGVyfVxuKiBvciBbZ3JhcGhlbWVyXXtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9ncmFwaGVtZXJ9IHRvIGNyZWF0ZSBhIHBvbHlmaWxsLiBTaW5jZSB0aGVzZSBsaWJyYXJpZXMgY2FuIGJlXG4qIHJlbGF0aXZlbHkgbGFyZ2UgaW4gc2l6ZSB0byBoYW5kbGUgdmFyaW91cyBVbmljb2RlIGdyYXBoZW1lIGNsdXN0ZXJzIHByb3Blcmx5LCBQaXhpSlMgd29uJ3QgdXNlIHRoZW0gZGlyZWN0bHkuXG4qL1xuX1RleHRNZXRyaWNzLmdyYXBoZW1lU2VnbWVudGVyID0gKCgpID0+IHtcbiAgaWYgKHR5cGVvZiBJbnRsPy5TZWdtZW50ZXIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3Qgc2VnbWVudGVyID0gbmV3IEludGwuU2VnbWVudGVyKCk7XG4gICAgcmV0dXJuIChzKSA9PiBbLi4uc2VnbWVudGVyLnNlZ21lbnQocyldLm1hcCgoeCkgPT4geC5zZWdtZW50KTtcbiAgfVxuICByZXR1cm4gKHMpID0+IFsuLi5zXTtcbn0pKCksIC8qKlxuKiBOZXcgcmVuZGVyaW5nIGJlaGF2aW9yIGZvciBsZXR0ZXItc3BhY2luZyB3aGljaCB1c2VzIENocm9tZSdzIG5ldyBuYXRpdmUgQVBJLiBUaGlzIHdpbGxcbiogbGVhZCB0byBtb3JlIGFjY3VyYXRlIGxldHRlci1zcGFjaW5nIHJlc3VsdHMgYmVjYXVzZSBpdCBkb2VzIG5vdCB0cnkgdG8gbWFudWFsbHkgZHJhd1xuKiBlYWNoIGNoYXJhY3Rlci4gSG93ZXZlciwgdGhpcyBDaHJvbWUgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IG5vdCBzZXJ2ZSBhbGwgY2FzZXMgeWV0LlxuKiBAc2VlIFBJWEkuVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1N1cHBvcnRlZFxuKi9cbl9UZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gITEsIC8qKiBDYWNoZSBvZiB7QHNlZSBQSVhJLlRleHRNZXRyaWNzLkZvbnRNZXRyaWNzfSBvYmplY3RzLiAqL1xuX1RleHRNZXRyaWNzLl9mb250cyA9IHt9LCAvKiogQ2FjaGUgb2YgbmV3IGxpbmUgY2hhcnMuICovXG5fVGV4dE1ldHJpY3MuX25ld2xpbmVzID0gW1xuICAxMCxcbiAgLy8gbGluZSBmZWVkXG4gIDEzXG4gIC8vIGNhcnJpYWdlIHJldHVyblxuXSwgLyoqIENhY2hlIG9mIGJyZWFraW5nIHNwYWNlcy4gKi9cbl9UZXh0TWV0cmljcy5fYnJlYWtpbmdTcGFjZXMgPSBbXG4gIDksXG4gIC8vIGNoYXJhY3RlciB0YWJ1bGF0aW9uXG4gIDMyLFxuICAvLyBzcGFjZVxuICA4MTkyLFxuICAvLyBlbiBxdWFkXG4gIDgxOTMsXG4gIC8vIGVtIHF1YWRcbiAgODE5NCxcbiAgLy8gZW4gc3BhY2VcbiAgODE5NSxcbiAgLy8gZW0gc3BhY2VcbiAgODE5NixcbiAgLy8gdGhyZWUtcGVyLWVtIHNwYWNlXG4gIDgxOTcsXG4gIC8vIGZvdXItcGVyLWVtIHNwYWNlXG4gIDgxOTgsXG4gIC8vIHNpeC1wZXItZW0gc3BhY2VcbiAgODIwMCxcbiAgLy8gcHVuY3R1YXRpb24gc3BhY2VcbiAgODIwMSxcbiAgLy8gdGhpbiBzcGFjZVxuICA4MjAyLFxuICAvLyBoYWlyIHNwYWNlXG4gIDgyODcsXG4gIC8vIG1lZGl1bSBtYXRoZW1hdGljYWwgc3BhY2VcbiAgMTIyODhcbiAgLy8gaWRlb2dyYXBoaWMgc3BhY2Vcbl07XG5sZXQgVGV4dE1ldHJpY3MgPSBfVGV4dE1ldHJpY3M7XG5leHBvcnRzLlRleHRNZXRyaWNzID0gVGV4dE1ldHJpY3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0TWV0cmljcy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9jb25zdCA9IHJlcXVpcmUoXCIuL2NvbnN0LmpzXCIpLCBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIik7XG5jb25zdCBnZW5lcmljRm9udEZhbWlsaWVzID0gW1xuICBcInNlcmlmXCIsXG4gIFwic2Fucy1zZXJpZlwiLFxuICBcIm1vbm9zcGFjZVwiLFxuICBcImN1cnNpdmVcIixcbiAgXCJmYW50YXN5XCIsXG4gIFwic3lzdGVtLXVpXCJcbl0sIF9UZXh0U3R5bGUgPSBjbGFzcyBfVGV4dFN0eWxlMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0gc3R5bGUgLSBUZXh0U3R5bGUgcHJvcGVydGllcyB0byBiZSBzZXQgb24gdGhlIHRleHQuIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUuZGVmYXVsdFN0eWxlfVxuICAgKiAgICAgICBmb3IgdGhlIGRlZmF1bHQgdmFsdWVzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3R5bGUpIHtcbiAgICB0aGlzLnN0eWxlSUQgPSAwLCB0aGlzLnJlc2V0KCksIGRlZXBDb3B5UHJvcGVydGllcyh0aGlzLCBzdHlsZSwgc3R5bGUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFRleHRTdHlsZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAqIE5vdGUgdGhhdCB0aGUgb25seSB0aGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IGFyZSBjbG9uZWQuXG4gICAqXG4gICAqIEByZXR1cm4gTmV3IGNsb25lZCBUZXh0U3R5bGUgb2JqZWN0XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZWRQcm9wZXJ0aWVzID0ge307XG4gICAgcmV0dXJuIGRlZXBDb3B5UHJvcGVydGllcyhjbG9uZWRQcm9wZXJ0aWVzLCB0aGlzLCBfVGV4dFN0eWxlMi5kZWZhdWx0U3R5bGUpLCBuZXcgX1RleHRTdHlsZTIoY2xvbmVkUHJvcGVydGllcyk7XG4gIH1cbiAgLyoqIFJlc2V0cyBhbGwgcHJvcGVydGllcyB0byB0aGUgZGVmYXVsdHMgc3BlY2lmaWVkIGluIFRleHRTdHlsZS5wcm90b3R5cGUuX2RlZmF1bHQgKi9cbiAgcmVzZXQoKSB7XG4gICAgZGVlcENvcHlQcm9wZXJ0aWVzKHRoaXMsIF9UZXh0U3R5bGUyLmRlZmF1bHRTdHlsZSwgX1RleHRTdHlsZTIuZGVmYXVsdFN0eWxlKTtcbiAgfVxuICAvKipcbiAgICogQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCwgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHQuXG4gICAqXG4gICAqIEBtZW1iZXIgeydsZWZ0J3wnY2VudGVyJ3wncmlnaHQnfCdqdXN0aWZ5J31cbiAgICovXG4gIGdldCBhbGlnbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYWxpZ247XG4gIH1cbiAgc2V0IGFsaWduKGFsaWduKSB7XG4gICAgdGhpcy5fYWxpZ24gIT09IGFsaWduICYmICh0aGlzLl9hbGlnbiA9IGFsaWduLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqIEluZGljYXRlcyBpZiBsaW5lcyBjYW4gYmUgd3JhcHBlZCB3aXRoaW4gd29yZHMsIGl0IG5lZWRzIHdvcmRXcmFwIHRvIGJlIHNldCB0byB0cnVlLiAqL1xuICBnZXQgYnJlYWtXb3JkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fYnJlYWtXb3JkcztcbiAgfVxuICBzZXQgYnJlYWtXb3JkcyhicmVha1dvcmRzKSB7XG4gICAgdGhpcy5fYnJlYWtXb3JkcyAhPT0gYnJlYWtXb3JkcyAmJiAodGhpcy5fYnJlYWtXb3JkcyA9IGJyZWFrV29yZHMsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKiogU2V0IGEgZHJvcCBzaGFkb3cgZm9yIHRoZSB0ZXh0LiAqL1xuICBnZXQgZHJvcFNoYWRvdygpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvdztcbiAgfVxuICBzZXQgZHJvcFNoYWRvdyhkcm9wU2hhZG93KSB7XG4gICAgdGhpcy5fZHJvcFNoYWRvdyAhPT0gZHJvcFNoYWRvdyAmJiAodGhpcy5fZHJvcFNoYWRvdyA9IGRyb3BTaGFkb3csIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKiogU2V0IGFscGhhIGZvciB0aGUgZHJvcCBzaGFkb3cuICovXG4gIGdldCBkcm9wU2hhZG93QWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3dBbHBoYTtcbiAgfVxuICBzZXQgZHJvcFNoYWRvd0FscGhhKGRyb3BTaGFkb3dBbHBoYSkge1xuICAgIHRoaXMuX2Ryb3BTaGFkb3dBbHBoYSAhPT0gZHJvcFNoYWRvd0FscGhhICYmICh0aGlzLl9kcm9wU2hhZG93QWxwaGEgPSBkcm9wU2hhZG93QWxwaGEsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKiogU2V0IGEgYW5nbGUgb2YgdGhlIGRyb3Agc2hhZG93LiAqL1xuICBnZXQgZHJvcFNoYWRvd0FuZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93QW5nbGU7XG4gIH1cbiAgc2V0IGRyb3BTaGFkb3dBbmdsZShkcm9wU2hhZG93QW5nbGUpIHtcbiAgICB0aGlzLl9kcm9wU2hhZG93QW5nbGUgIT09IGRyb3BTaGFkb3dBbmdsZSAmJiAodGhpcy5fZHJvcFNoYWRvd0FuZ2xlID0gZHJvcFNoYWRvd0FuZ2xlLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqIFNldCBhIHNoYWRvdyBibHVyIHJhZGl1cy4gKi9cbiAgZ2V0IGRyb3BTaGFkb3dCbHVyKCkge1xuICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93Qmx1cjtcbiAgfVxuICBzZXQgZHJvcFNoYWRvd0JsdXIoZHJvcFNoYWRvd0JsdXIpIHtcbiAgICB0aGlzLl9kcm9wU2hhZG93Qmx1ciAhPT0gZHJvcFNoYWRvd0JsdXIgJiYgKHRoaXMuX2Ryb3BTaGFkb3dCbHVyID0gZHJvcFNoYWRvd0JsdXIsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKiogQSBmaWxsIHN0eWxlIHRvIGJlIHVzZWQgb24gdGhlIGRyb3BzaGFkb3cgZS5nLiwgJ3JlZCcsICcjMDBGRjAwJy4gKi9cbiAgZ2V0IGRyb3BTaGFkb3dDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0NvbG9yO1xuICB9XG4gIHNldCBkcm9wU2hhZG93Q29sb3IoZHJvcFNoYWRvd0NvbG9yKSB7XG4gICAgY29uc3Qgb3V0cHV0Q29sb3IgPSBnZXRDb2xvcihkcm9wU2hhZG93Q29sb3IpO1xuICAgIHRoaXMuX2Ryb3BTaGFkb3dDb2xvciAhPT0gb3V0cHV0Q29sb3IgJiYgKHRoaXMuX2Ryb3BTaGFkb3dDb2xvciA9IG91dHB1dENvbG9yLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqIFNldCBhIGRpc3RhbmNlIG9mIHRoZSBkcm9wIHNoYWRvdy4gKi9cbiAgZ2V0IGRyb3BTaGFkb3dEaXN0YW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICB9XG4gIHNldCBkcm9wU2hhZG93RGlzdGFuY2UoZHJvcFNoYWRvd0Rpc3RhbmNlKSB7XG4gICAgdGhpcy5fZHJvcFNoYWRvd0Rpc3RhbmNlICE9PSBkcm9wU2hhZG93RGlzdGFuY2UgJiYgKHRoaXMuX2Ryb3BTaGFkb3dEaXN0YW5jZSA9IGRyb3BTaGFkb3dEaXN0YW5jZSwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKlxuICAgKiBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgZS5nLiwgJ3JlZCcsICcjMDBGRjAwJy5cbiAgICpcbiAgICogQ2FuIGJlIGFuIGFycmF5IHRvIGNyZWF0ZSBhIGdyYWRpZW50IGUuZy4sIGBbJyMwMDAwMDAnLCcjRkZGRkZGJ11gXG4gICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2ZpbGxTdHlsZXxNRE59XG4gICAqXG4gICAqIEBtZW1iZXIge3N0cmluZ3xzdHJpbmdbXXxudW1iZXJ8bnVtYmVyW118Q2FudmFzR3JhZGllbnR8Q2FudmFzUGF0dGVybn1cbiAgICovXG4gIGdldCBmaWxsKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxsO1xuICB9XG4gIHNldCBmaWxsKGZpbGwpIHtcbiAgICBjb25zdCBvdXRwdXRDb2xvciA9IGdldENvbG9yKGZpbGwpO1xuICAgIHRoaXMuX2ZpbGwgIT09IG91dHB1dENvbG9yICYmICh0aGlzLl9maWxsID0gb3V0cHV0Q29sb3IsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKipcbiAgICogSWYgZmlsbCBpcyBhbiBhcnJheSBvZiBjb2xvdXJzIHRvIGNyZWF0ZSBhIGdyYWRpZW50LCB0aGlzIGNhbiBjaGFuZ2UgdGhlIHR5cGUvZGlyZWN0aW9uIG9mIHRoZSBncmFkaWVudC5cbiAgICpcbiAgICogQHR5cGUge1BJWEkuVEVYVF9HUkFESUVOVH1cbiAgICovXG4gIGdldCBmaWxsR3JhZGllbnRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxsR3JhZGllbnRUeXBlO1xuICB9XG4gIHNldCBmaWxsR3JhZGllbnRUeXBlKGZpbGxHcmFkaWVudFR5cGUpIHtcbiAgICB0aGlzLl9maWxsR3JhZGllbnRUeXBlICE9PSBmaWxsR3JhZGllbnRUeXBlICYmICh0aGlzLl9maWxsR3JhZGllbnRUeXBlID0gZmlsbEdyYWRpZW50VHlwZSwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKlxuICAgKiBJZiBmaWxsIGlzIGFuIGFycmF5IG9mIGNvbG91cnMgdG8gY3JlYXRlIGEgZ3JhZGllbnQsIHRoaXMgYXJyYXkgY2FuIHNldCB0aGUgc3RvcCBwb2ludHNcbiAgICogKG51bWJlcnMgYmV0d2VlbiAwIGFuZCAxKSBmb3IgdGhlIGNvbG9yLCBvdmVycmlkaW5nIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiBldmVubHkgc3BhY2luZyB0aGVtLlxuICAgKi9cbiAgZ2V0IGZpbGxHcmFkaWVudFN0b3BzKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxsR3JhZGllbnRTdG9wcztcbiAgfVxuICBzZXQgZmlsbEdyYWRpZW50U3RvcHMoZmlsbEdyYWRpZW50U3RvcHMpIHtcbiAgICBhcmVBcnJheXNFcXVhbCh0aGlzLl9maWxsR3JhZGllbnRTdG9wcywgZmlsbEdyYWRpZW50U3RvcHMpIHx8ICh0aGlzLl9maWxsR3JhZGllbnRTdG9wcyA9IGZpbGxHcmFkaWVudFN0b3BzLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb250IGZhbWlseSwgY2FuIGJlIGEgc2luZ2xlIGZvbnQgbmFtZSwgb3IgYSBsaXN0IG9mIG5hbWVzIHdoZXJlIHRoZSBmaXJzdFxuICAgKiBpcyB0aGUgcHJlZmVycmVkIGZvbnQuXG4gICAqL1xuICBnZXQgZm9udEZhbWlseSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udEZhbWlseTtcbiAgfVxuICBzZXQgZm9udEZhbWlseShmb250RmFtaWx5KSB7XG4gICAgdGhpcy5mb250RmFtaWx5ICE9PSBmb250RmFtaWx5ICYmICh0aGlzLl9mb250RmFtaWx5ID0gZm9udEZhbWlseSwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZm9udCBzaXplXG4gICAqIChhcyBhIG51bWJlciBpdCBjb252ZXJ0cyB0byBweCwgYnV0IGFzIGEgc3RyaW5nLCBlcXVpdmFsZW50cyBhcmUgJzI2cHgnLCcyMHB0JywnMTYwJScgb3IgJzEuNmVtJylcbiAgICovXG4gIGdldCBmb250U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFNpemU7XG4gIH1cbiAgc2V0IGZvbnRTaXplKGZvbnRTaXplKSB7XG4gICAgdGhpcy5fZm9udFNpemUgIT09IGZvbnRTaXplICYmICh0aGlzLl9mb250U2l6ZSA9IGZvbnRTaXplLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb250IHN0eWxlLlxuICAgKlxuICAgKiBAbWVtYmVyIHsnbm9ybWFsJ3wnaXRhbGljJ3wnb2JsaXF1ZSd9XG4gICAqL1xuICBnZXQgZm9udFN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9mb250U3R5bGU7XG4gIH1cbiAgc2V0IGZvbnRTdHlsZShmb250U3R5bGUpIHtcbiAgICB0aGlzLl9mb250U3R5bGUgIT09IGZvbnRTdHlsZSAmJiAodGhpcy5fZm9udFN0eWxlID0gZm9udFN0eWxlLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb250IHZhcmlhbnQuXG4gICAqXG4gICAqIEBtZW1iZXIgeydub3JtYWwnfCdzbWFsbC1jYXBzJ31cbiAgICovXG4gIGdldCBmb250VmFyaWFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFZhcmlhbnQ7XG4gIH1cbiAgc2V0IGZvbnRWYXJpYW50KGZvbnRWYXJpYW50KSB7XG4gICAgdGhpcy5fZm9udFZhcmlhbnQgIT09IGZvbnRWYXJpYW50ICYmICh0aGlzLl9mb250VmFyaWFudCA9IGZvbnRWYXJpYW50LCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb250IHdlaWdodC5cbiAgICpcbiAgICogQG1lbWJlciB7J25vcm1hbCd8J2JvbGQnfCdib2xkZXInfCdsaWdodGVyJ3wnMTAwJ3wnMjAwJ3wnMzAwJ3wnNDAwJ3wnNTAwJ3wnNjAwJ3wnNzAwJ3wnODAwJ3wnOTAwJ31cbiAgICovXG4gIGdldCBmb250V2VpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9mb250V2VpZ2h0O1xuICB9XG4gIHNldCBmb250V2VpZ2h0KGZvbnRXZWlnaHQpIHtcbiAgICB0aGlzLl9mb250V2VpZ2h0ICE9PSBmb250V2VpZ2h0ICYmICh0aGlzLl9mb250V2VpZ2h0ID0gZm9udFdlaWdodCwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKiBUaGUgYW1vdW50IG9mIHNwYWNpbmcgYmV0d2VlbiBsZXR0ZXJzLCBkZWZhdWx0IGlzIDAuICovXG4gIGdldCBsZXR0ZXJTcGFjaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9sZXR0ZXJTcGFjaW5nO1xuICB9XG4gIHNldCBsZXR0ZXJTcGFjaW5nKGxldHRlclNwYWNpbmcpIHtcbiAgICB0aGlzLl9sZXR0ZXJTcGFjaW5nICE9PSBsZXR0ZXJTcGFjaW5nICYmICh0aGlzLl9sZXR0ZXJTcGFjaW5nID0gbGV0dGVyU3BhY2luZywgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKiBUaGUgbGluZSBoZWlnaHQsIGEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgdmVydGljYWwgc3BhY2UgdGhhdCBhIGxldHRlciB1c2VzLiAqL1xuICBnZXQgbGluZUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGluZUhlaWdodDtcbiAgfVxuICBzZXQgbGluZUhlaWdodChsaW5lSGVpZ2h0KSB7XG4gICAgdGhpcy5fbGluZUhlaWdodCAhPT0gbGluZUhlaWdodCAmJiAodGhpcy5fbGluZUhlaWdodCA9IGxpbmVIZWlnaHQsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKiogVGhlIHNwYWNlIGJldHdlZW4gbGluZXMuICovXG4gIGdldCBsZWFkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9sZWFkaW5nO1xuICB9XG4gIHNldCBsZWFkaW5nKGxlYWRpbmcpIHtcbiAgICB0aGlzLl9sZWFkaW5nICE9PSBsZWFkaW5nICYmICh0aGlzLl9sZWFkaW5nID0gbGVhZGluZywgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbGluZUpvaW4gcHJvcGVydHkgc2V0cyB0aGUgdHlwZSBvZiBjb3JuZXIgY3JlYXRlZCwgaXQgY2FuIHJlc29sdmUgc3Bpa2VkIHRleHQgaXNzdWVzLlxuICAgKiBEZWZhdWx0IGlzICdtaXRlcicgKGNyZWF0ZXMgYSBzaGFycCBjb3JuZXIpLlxuICAgKlxuICAgKiBAbWVtYmVyIHsnbWl0ZXInfCdyb3VuZCd8J2JldmVsJ31cbiAgICovXG4gIGdldCBsaW5lSm9pbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGluZUpvaW47XG4gIH1cbiAgc2V0IGxpbmVKb2luKGxpbmVKb2luKSB7XG4gICAgdGhpcy5fbGluZUpvaW4gIT09IGxpbmVKb2luICYmICh0aGlzLl9saW5lSm9pbiA9IGxpbmVKb2luLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtaXRlciBsaW1pdCB0byB1c2Ugd2hlbiB1c2luZyB0aGUgJ21pdGVyJyBsaW5lSm9pbiBtb2RlLlxuICAgKlxuICAgKiBUaGlzIGNhbiByZWR1Y2Ugb3IgaW5jcmVhc2UgdGhlIHNwaWtpbmVzcyBvZiByZW5kZXJlZCB0ZXh0LlxuICAgKi9cbiAgZ2V0IG1pdGVyTGltaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pdGVyTGltaXQ7XG4gIH1cbiAgc2V0IG1pdGVyTGltaXQobWl0ZXJMaW1pdCkge1xuICAgIHRoaXMuX21pdGVyTGltaXQgIT09IG1pdGVyTGltaXQgJiYgKHRoaXMuX21pdGVyTGltaXQgPSBtaXRlckxpbWl0LCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqXG4gICAqIE9jY2FzaW9uYWxseSBzb21lIGZvbnRzIGFyZSBjcm9wcGVkLiBBZGRpbmcgc29tZSBwYWRkaW5nIHdpbGwgcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nXG4gICAqIGJ5IGFkZGluZyBwYWRkaW5nIHRvIGFsbCBzaWRlcyBvZiB0aGUgdGV4dC5cbiAgICovXG4gIGdldCBwYWRkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICB9XG4gIHNldCBwYWRkaW5nKHBhZGRpbmcpIHtcbiAgICB0aGlzLl9wYWRkaW5nICE9PSBwYWRkaW5nICYmICh0aGlzLl9wYWRkaW5nID0gcGFkZGluZywgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKlxuICAgKiBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgc3Ryb2tlLCBlLmcuLCAnYmx1ZScsICcjRkNGRjAwJ1xuICAgKi9cbiAgZ2V0IHN0cm9rZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Ryb2tlO1xuICB9XG4gIHNldCBzdHJva2Uoc3Ryb2tlKSB7XG4gICAgY29uc3Qgb3V0cHV0Q29sb3IgPSBnZXRDb2xvcihzdHJva2UpO1xuICAgIHRoaXMuX3N0cm9rZSAhPT0gb3V0cHV0Q29sb3IgJiYgKHRoaXMuX3N0cm9rZSA9IG91dHB1dENvbG9yLCB0aGlzLnN0eWxlSUQrKyk7XG4gIH1cbiAgLyoqXG4gICAqIEEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgdGhpY2tuZXNzIG9mIHRoZSBzdHJva2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCBzdHJva2VUaGlja25lc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cm9rZVRoaWNrbmVzcztcbiAgfVxuICBzZXQgc3Ryb2tlVGhpY2tuZXNzKHN0cm9rZVRoaWNrbmVzcykge1xuICAgIHRoaXMuX3N0cm9rZVRoaWNrbmVzcyAhPT0gc3Ryb2tlVGhpY2tuZXNzICYmICh0aGlzLl9zdHJva2VUaGlja25lc3MgPSBzdHJva2VUaGlja25lc3MsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2VsaW5lIG9mIHRoZSB0ZXh0IHRoYXQgaXMgcmVuZGVyZWQuXG4gICAqXG4gICAqIEBtZW1iZXIgeydhbHBoYWJldGljJ3wndG9wJ3wnaGFuZ2luZyd8J21pZGRsZSd8J2lkZW9ncmFwaGljJ3wnYm90dG9tJ31cbiAgICovXG4gIGdldCB0ZXh0QmFzZWxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHRCYXNlbGluZTtcbiAgfVxuICBzZXQgdGV4dEJhc2VsaW5lKHRleHRCYXNlbGluZSkge1xuICAgIHRoaXMuX3RleHRCYXNlbGluZSAhPT0gdGV4dEJhc2VsaW5lICYmICh0aGlzLl90ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmUsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKiogVHJpbSB0cmFuc3BhcmVudCBib3JkZXJzLiAqL1xuICBnZXQgdHJpbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJpbTtcbiAgfVxuICBzZXQgdHJpbSh0cmltKSB7XG4gICAgdGhpcy5fdHJpbSAhPT0gdHJpbSAmJiAodGhpcy5fdHJpbSA9IHRyaW0sIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKipcbiAgICogSG93IG5ld2xpbmVzIGFuZCBzcGFjZXMgc2hvdWxkIGJlIGhhbmRsZWQuXG4gICAqIERlZmF1bHQgaXMgJ3ByZScgKHByZXNlcnZlLCBwcmVzZXJ2ZSkuXG4gICAqXG4gICAqICB2YWx1ZSAgICAgICB8IE5ldyBsaW5lcyAgICAgfCAgIFNwYWNlc1xuICAgKiAgLS0tICAgICAgICAgfCAtLS0gICAgICAgICAgIHwgICAtLS1cbiAgICogJ25vcm1hbCcgICAgIHwgQ29sbGFwc2UgICAgICB8ICAgQ29sbGFwc2VcbiAgICogJ3ByZScgICAgICAgIHwgUHJlc2VydmUgICAgICB8ICAgUHJlc2VydmVcbiAgICogJ3ByZS1saW5lJyAgIHwgUHJlc2VydmUgICAgICB8ICAgQ29sbGFwc2VcbiAgICpcbiAgICogQG1lbWJlciB7J25vcm1hbCd8J3ByZSd8J3ByZS1saW5lJ31cbiAgICovXG4gIGdldCB3aGl0ZVNwYWNlKCkge1xuICAgIHJldHVybiB0aGlzLl93aGl0ZVNwYWNlO1xuICB9XG4gIHNldCB3aGl0ZVNwYWNlKHdoaXRlU3BhY2UpIHtcbiAgICB0aGlzLl93aGl0ZVNwYWNlICE9PSB3aGl0ZVNwYWNlICYmICh0aGlzLl93aGl0ZVNwYWNlID0gd2hpdGVTcGFjZSwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKiBJbmRpY2F0ZXMgaWYgd29yZCB3cmFwIHNob3VsZCBiZSB1c2VkLiAqL1xuICBnZXQgd29yZFdyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dvcmRXcmFwO1xuICB9XG4gIHNldCB3b3JkV3JhcCh3b3JkV3JhcCkge1xuICAgIHRoaXMuX3dvcmRXcmFwICE9PSB3b3JkV3JhcCAmJiAodGhpcy5fd29yZFdyYXAgPSB3b3JkV3JhcCwgdGhpcy5zdHlsZUlEKyspO1xuICB9XG4gIC8qKiBUaGUgd2lkdGggYXQgd2hpY2ggdGV4dCB3aWxsIHdyYXAsIGl0IG5lZWRzIHdvcmRXcmFwIHRvIGJlIHNldCB0byB0cnVlLiAqL1xuICBnZXQgd29yZFdyYXBXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd29yZFdyYXBXaWR0aDtcbiAgfVxuICBzZXQgd29yZFdyYXBXaWR0aCh3b3JkV3JhcFdpZHRoKSB7XG4gICAgdGhpcy5fd29yZFdyYXBXaWR0aCAhPT0gd29yZFdyYXBXaWR0aCAmJiAodGhpcy5fd29yZFdyYXBXaWR0aCA9IHdvcmRXcmFwV2lkdGgsIHRoaXMuc3R5bGVJRCsrKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgZm9udCBzdHlsZSBzdHJpbmcgdG8gdXNlIGZvciBgVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQoKWAuXG4gICAqXG4gICAqIEByZXR1cm4gRm9udCBzdHlsZSBzdHJpbmcsIGZvciBwYXNzaW5nIHRvIGBUZXh0TWV0cmljcy5tZWFzdXJlRm9udCgpYFxuICAgKi9cbiAgdG9Gb250U3RyaW5nKCkge1xuICAgIGNvbnN0IGZvbnRTaXplU3RyaW5nID0gdHlwZW9mIHRoaXMuZm9udFNpemUgPT0gXCJudW1iZXJcIiA/IGAke3RoaXMuZm9udFNpemV9cHhgIDogdGhpcy5mb250U2l6ZTtcbiAgICBsZXQgZm9udEZhbWlsaWVzID0gdGhpcy5mb250RmFtaWx5O1xuICAgIEFycmF5LmlzQXJyYXkodGhpcy5mb250RmFtaWx5KSB8fCAoZm9udEZhbWlsaWVzID0gdGhpcy5mb250RmFtaWx5LnNwbGl0KFwiLFwiKSk7XG4gICAgZm9yIChsZXQgaSA9IGZvbnRGYW1pbGllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvbnRGYW1pbHkgPSBmb250RmFtaWxpZXNbaV0udHJpbSgpO1xuICAgICAgIS8oW1xcXCJcXCddKVteXFwnXFxcIl0rXFwxLy50ZXN0KGZvbnRGYW1pbHkpICYmICFnZW5lcmljRm9udEZhbWlsaWVzLmluY2x1ZGVzKGZvbnRGYW1pbHkpICYmIChmb250RmFtaWx5ID0gYFwiJHtmb250RmFtaWx5fVwiYCksIGZvbnRGYW1pbGllc1tpXSA9IGZvbnRGYW1pbHk7XG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLmZvbnRTdHlsZX0gJHt0aGlzLmZvbnRWYXJpYW50fSAke3RoaXMuZm9udFdlaWdodH0gJHtmb250U2l6ZVN0cmluZ30gJHtmb250RmFtaWxpZXMuam9pbihcIixcIil9YDtcbiAgfVxufTtcbl9UZXh0U3R5bGUuZGVmYXVsdFN0eWxlID0ge1xuICAvKipcbiAgICogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS5hbGlnbn1cbiAgICogQHR5cGUgeydsZWZ0J3wnY2VudGVyJ3wncmlnaHQnfCdqdXN0aWZ5J31cbiAgICovXG4gIGFsaWduOiBcImxlZnRcIixcbiAgLyoqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUuYnJlYWtXb3Jkc30gKi9cbiAgYnJlYWtXb3JkczogITEsXG4gIC8qKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLmRyb3BTaGFkb3d9ICovXG4gIGRyb3BTaGFkb3c6ICExLFxuICAvKiogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS5kcm9wU2hhZG93QWxwaGF9ICovXG4gIGRyb3BTaGFkb3dBbHBoYTogMSxcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUuZHJvcFNoYWRvd0FuZ2xlfVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCBNYXRoLlBJIC8gNlxuICAgKi9cbiAgZHJvcFNoYWRvd0FuZ2xlOiBNYXRoLlBJIC8gNixcbiAgLyoqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUuZHJvcFNoYWRvd0JsdXJ9ICovXG4gIGRyb3BTaGFkb3dCbHVyOiAwLFxuICAvKipcbiAgICogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS5kcm9wU2hhZG93Q29sb3J9XG4gICAqIEB0eXBlIHtzdHJpbmd8bnVtYmVyfVxuICAgKi9cbiAgZHJvcFNoYWRvd0NvbG9yOiBcImJsYWNrXCIsXG4gIC8qKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZX0gKi9cbiAgZHJvcFNoYWRvd0Rpc3RhbmNlOiA1LFxuICAvKipcbiAgICogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS5maWxsfVxuICAgKiBAdHlwZSB7c3RyaW5nfHN0cmluZ1tdfG51bWJlcnxudW1iZXJbXXxDYW52YXNHcmFkaWVudHxDYW52YXNQYXR0ZXJufVxuICAgKi9cbiAgZmlsbDogXCJibGFja1wiLFxuICAvKipcbiAgICogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS5maWxsR3JhZGllbnRUeXBlfVxuICAgKiBAdHlwZSB7UElYSS5URVhUX0dSQURJRU5UfVxuICAgKiBAZGVmYXVsdCBQSVhJLlRFWFRfR1JBRElFTlQuTElORUFSX1ZFUlRJQ0FMXG4gICAqL1xuICBmaWxsR3JhZGllbnRUeXBlOiBfY29uc3QuVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLmZpbGxHcmFkaWVudFN0b3BzfVxuICAgKiBAdHlwZSB7bnVtYmVyW119XG4gICAqIEBkZWZhdWx0IFtdXG4gICAqL1xuICBmaWxsR3JhZGllbnRTdG9wczogW10sXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLmZvbnRGYW1pbHl9XG4gICAqIEB0eXBlIHtzdHJpbmd8c3RyaW5nW119XG4gICAqL1xuICBmb250RmFtaWx5OiBcIkFyaWFsXCIsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLmZvbnRTaXplfVxuICAgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ30gXG4gICAqL1xuICBmb250U2l6ZTogMjYsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLmZvbnRTdHlsZX1cbiAgICogQHR5cGUgeydub3JtYWwnfCdpdGFsaWMnfCdvYmxpcXVlJ31cbiAgICovXG4gIGZvbnRTdHlsZTogXCJub3JtYWxcIixcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUuZm9udFZhcmlhbnR9XG4gICAqIEB0eXBlIHsnbm9ybWFsJ3wnc21hbGwtY2Fwcyd9XG4gICAqL1xuICBmb250VmFyaWFudDogXCJub3JtYWxcIixcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUuZm9udFdlaWdodH1cbiAgICogQHR5cGUgeydub3JtYWwnfCdib2xkJ3wnYm9sZGVyJ3wnbGlnaHRlcid8JzEwMCd8JzIwMCd8JzMwMCd8JzQwMCd8JzUwMCd8JzYwMCd8JzcwMCd8JzgwMCd8JzkwMCd9XG4gICAqL1xuICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxuICAvKiogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS5sZWFkaW5nfSAqL1xuICBsZWFkaW5nOiAwLFxuICAvKiogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS5sZXR0ZXJTcGFjaW5nfSAqL1xuICBsZXR0ZXJTcGFjaW5nOiAwLFxuICAvKiogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS5saW5lSGVpZ2h0fSAqL1xuICBsaW5lSGVpZ2h0OiAwLFxuICAvKipcbiAgICogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS5saW5lSm9pbn1cbiAgICogQHR5cGUgeydtaXRlcid8J3JvdW5kJ3wnYmV2ZWwnfVxuICAgKi9cbiAgbGluZUpvaW46IFwibWl0ZXJcIixcbiAgLyoqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUubWl0ZXJMaW1pdH0gKi9cbiAgbWl0ZXJMaW1pdDogMTAsXG4gIC8qKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLnBhZGRpbmd9ICovXG4gIHBhZGRpbmc6IDAsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLnN0cm9rZX1cbiAgICogQHR5cGUge3N0cmluZ3xudW1iZXJ9XG4gICAqL1xuICBzdHJva2U6IFwiYmxhY2tcIixcbiAgLyoqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUuc3Ryb2tlVGhpY2tuZXNzfSAqL1xuICBzdHJva2VUaGlja25lc3M6IDAsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFBJWEkuVGV4dFN0eWxlLnRleHRCYXNlbGluZX0gXG4gICAqIEB0eXBlIHsnYWxwaGFiZXRpYyd8J3RvcCd8J2hhbmdpbmcnfCdtaWRkbGUnfCdpZGVvZ3JhcGhpYyd8J2JvdHRvbSd9XG4gICAqL1xuICB0ZXh0QmFzZWxpbmU6IFwiYWxwaGFiZXRpY1wiLFxuICAvKiogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS50cmltfSAqL1xuICB0cmltOiAhMSxcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgUElYSS5UZXh0U3R5bGUud2hpdGVTcGFjZX1cbiAgICogQHR5cGUgeydub3JtYWwnfCdwcmUnfCdwcmUtbGluZSd9XG4gICAqL1xuICB3aGl0ZVNwYWNlOiBcInByZVwiLFxuICAvKiogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS53b3JkV3JhcH0gKi9cbiAgd29yZFdyYXA6ICExLFxuICAvKiogU2VlIHtAbGluayBQSVhJLlRleHRTdHlsZS53b3JkV3JhcFdpZHRofSAqL1xuICB3b3JkV3JhcFdpZHRoOiAxMDBcbn07XG5sZXQgVGV4dFN0eWxlID0gX1RleHRTdHlsZTtcbmZ1bmN0aW9uIGdldENvbG9yKGNvbG9yKSB7XG4gIGNvbnN0IHRlbXAgPSBjb3JlLkNvbG9yLnNoYXJlZCwgZm9ybWF0ID0gKGNvbG9yMikgPT4ge1xuICAgIGNvbnN0IHJlcyA9IHRlbXAuc2V0VmFsdWUoY29sb3IyKTtcbiAgICByZXR1cm4gcmVzLmFscGhhID09PSAxID8gcmVzLnRvSGV4KCkgOiByZXMudG9SZ2JhU3RyaW5nKCk7XG4gIH07XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGNvbG9yKSA/IGNvbG9yLm1hcChmb3JtYXQpIDogZm9ybWF0KGNvbG9yKTtcbn1cbmZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGFycmF5MSwgYXJyYXkyKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheTEpIHx8ICFBcnJheS5pc0FycmF5KGFycmF5MikgfHwgYXJyYXkxLmxlbmd0aCAhPT0gYXJyYXkyLmxlbmd0aClcbiAgICByZXR1cm4gITE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgKytpKVxuICAgIGlmIChhcnJheTFbaV0gIT09IGFycmF5MltpXSlcbiAgICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gZGVlcENvcHlQcm9wZXJ0aWVzKHRhcmdldCwgc291cmNlLCBwcm9wZXJ0eU9iaikge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcGVydHlPYmopXG4gICAgQXJyYXkuaXNBcnJheShzb3VyY2VbcHJvcF0pID8gdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdLnNsaWNlKCkgOiB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG59XG5leHBvcnRzLlRleHRTdHlsZSA9IFRleHRTdHlsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHRTdHlsZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIFRFWFRfR1JBRElFTlQgPSAvKiBAX19QVVJFX18gKi8gKChURVhUX0dSQURJRU5UMikgPT4gKFRFWFRfR1JBRElFTlQyW1RFWFRfR1JBRElFTlQyLkxJTkVBUl9WRVJUSUNBTCA9IDBdID0gXCJMSU5FQVJfVkVSVElDQUxcIiwgVEVYVF9HUkFESUVOVDJbVEVYVF9HUkFESUVOVDIuTElORUFSX0hPUklaT05UQUwgPSAxXSA9IFwiTElORUFSX0hPUklaT05UQUxcIiwgVEVYVF9HUkFESUVOVDIpKShURVhUX0dSQURJRU5UIHx8IHt9KTtcbmV4cG9ydHMuVEVYVF9HUkFESUVOVCA9IFRFWFRfR1JBRElFTlQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9jb25zdCA9IHJlcXVpcmUoXCIuL2NvbnN0LmpzXCIpLCBUZXh0ID0gcmVxdWlyZShcIi4vVGV4dC5qc1wiKSwgVGV4dE1ldHJpY3MgPSByZXF1aXJlKFwiLi9UZXh0TWV0cmljcy5qc1wiKSwgVGV4dFN0eWxlID0gcmVxdWlyZShcIi4vVGV4dFN0eWxlLmpzXCIpO1xuZXhwb3J0cy5URVhUX0dSQURJRU5UID0gX2NvbnN0LlRFWFRfR1JBRElFTlQ7XG5leHBvcnRzLlRleHQgPSBUZXh0LlRleHQ7XG5leHBvcnRzLlRleHRNZXRyaWNzID0gVGV4dE1ldHJpY3MuVGV4dE1ldHJpY3M7XG5leHBvcnRzLlRleHRTdHlsZSA9IFRleHRTdHlsZS5UZXh0U3R5bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9jb25zdCA9IHJlcXVpcmUoXCIuL2NvbnN0LmpzXCIpLCBUaWNrZXJMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL1RpY2tlckxpc3RlbmVyLmpzXCIpO1xuY29uc3QgX1RpY2tlciA9IGNsYXNzIF9UaWNrZXIyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hdXRvU3RhcnQgPSAhMSwgdGhpcy5kZWx0YVRpbWUgPSAxLCB0aGlzLmxhc3RUaW1lID0gLTEsIHRoaXMuc3BlZWQgPSAxLCB0aGlzLnN0YXJ0ZWQgPSAhMSwgdGhpcy5fcmVxdWVzdElkID0gbnVsbCwgdGhpcy5fbWF4RWxhcHNlZE1TID0gMTAwLCB0aGlzLl9taW5FbGFwc2VkTVMgPSAwLCB0aGlzLl9wcm90ZWN0ZWQgPSAhMSwgdGhpcy5fbGFzdEZyYW1lID0gLTEsIHRoaXMuX2hlYWQgPSBuZXcgVGlja2VyTGlzdGVuZXIuVGlja2VyTGlzdGVuZXIobnVsbCwgbnVsbCwgMSAvIDApLCB0aGlzLmRlbHRhTVMgPSAxIC8gX1RpY2tlcjIudGFyZ2V0RlBNUywgdGhpcy5lbGFwc2VkTVMgPSAxIC8gX1RpY2tlcjIudGFyZ2V0RlBNUywgdGhpcy5fdGljayA9ICh0aW1lKSA9PiB7XG4gICAgICB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsLCB0aGlzLnN0YXJ0ZWQgJiYgKHRoaXMudXBkYXRlKHRpbWUpLCB0aGlzLnN0YXJ0ZWQgJiYgdGhpcy5fcmVxdWVzdElkID09PSBudWxsICYmIHRoaXMuX2hlYWQubmV4dCAmJiAodGhpcy5fcmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spKSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ29uZGl0aW9uYWxseSByZXF1ZXN0cyBhIG5ldyBhbmltYXRpb24gZnJhbWUuXG4gICAqIElmIGEgZnJhbWUgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkLCBhbmQgaWYgdGhlIGludGVybmFsXG4gICAqIGVtaXR0ZXIgaGFzIGxpc3RlbmVycywgYSBuZXcgZnJhbWUgaXMgcmVxdWVzdGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlcXVlc3RJZk5lZWRlZCgpIHtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgPT09IG51bGwgJiYgdGhpcy5faGVhZC5uZXh0ICYmICh0aGlzLmxhc3RUaW1lID0gcGVyZm9ybWFuY2Uubm93KCksIHRoaXMuX2xhc3RGcmFtZSA9IHRoaXMubGFzdFRpbWUsIHRoaXMuX3JlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbmRpdGlvbmFsbHkgY2FuY2VscyBhIHBlbmRpbmcgYW5pbWF0aW9uIGZyYW1lLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NhbmNlbElmTmVlZGVkKCkge1xuICAgIHRoaXMuX3JlcXVlc3RJZCAhPT0gbnVsbCAmJiAoY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVxdWVzdElkKSwgdGhpcy5fcmVxdWVzdElkID0gbnVsbCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbmRpdGlvbmFsbHkgcmVxdWVzdHMgYSBuZXcgYW5pbWF0aW9uIGZyYW1lLlxuICAgKiBJZiB0aGUgdGlja2VyIGhhcyBiZWVuIHN0YXJ0ZWQgaXQgY2hlY2tzIGlmIGEgZnJhbWUgaGFzIG5vdCBhbHJlYWR5XG4gICAqIGJlZW4gcmVxdWVzdGVkLCBhbmQgaWYgdGhlIGludGVybmFsIGVtaXR0ZXIgaGFzIGxpc3RlbmVycy4gSWYgdGhlc2VcbiAgICogY29uZGl0aW9ucyBhcmUgbWV0LCBhIG5ldyBmcmFtZSBpcyByZXF1ZXN0ZWQuIElmIHRoZSB0aWNrZXIgaGFzIG5vdFxuICAgKiBiZWVuIHN0YXJ0ZWQsIGJ1dCBhdXRvU3RhcnQgaXMgYHRydWVgLCB0aGVuIHRoZSB0aWNrZXIgc3RhcnRzIG5vdyxcbiAgICogYW5kIGNvbnRpbnVlcyB3aXRoIHRoZSBwcmV2aW91cyBjb25kaXRpb25zIHRvIHJlcXVlc3QgYSBuZXcgZnJhbWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc3RhcnRJZlBvc3NpYmxlKCkge1xuICAgIHRoaXMuc3RhcnRlZCA/IHRoaXMuX3JlcXVlc3RJZk5lZWRlZCgpIDogdGhpcy5hdXRvU3RhcnQgJiYgdGhpcy5zdGFydCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGhhbmRsZXIgZm9yIHRpY2sgZXZlbnRzLiBDYWxscyBjb250aW51b3VzbHkgdW5sZXNzXG4gICAqIGl0IGlzIHJlbW92ZWQgb3IgdGhlIHRpY2tlciBpcyBzdG9wcGVkLlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIHVwZGF0ZXNcbiAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgbGlzdGVuZXIgY29udGV4dFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PVBJWEkuVVBEQVRFX1BSSU9SSVRZLk5PUk1BTF0gLSBUaGUgcHJpb3JpdHkgZm9yIGVtaXR0aW5nXG4gICAqIEByZXR1cm5zIFRoaXMgaW5zdGFuY2Ugb2YgYSB0aWNrZXJcbiAgICovXG4gIGFkZChmbiwgY29udGV4dCwgcHJpb3JpdHkgPSBfY29uc3QuVVBEQVRFX1BSSU9SSVRZLk5PUk1BTCkge1xuICAgIHJldHVybiB0aGlzLl9hZGRMaXN0ZW5lcihuZXcgVGlja2VyTGlzdGVuZXIuVGlja2VyTGlzdGVuZXIoZm4sIGNvbnRleHQsIHByaW9yaXR5KSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGhhbmRsZXIgZm9yIHRoZSB0aWNrIGV2ZW50IHdoaWNoIGlzIG9ubHkgZXhlY3V0ZSBvbmNlLlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIG9uZSB1cGRhdGVcbiAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgbGlzdGVuZXIgY29udGV4dFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PVBJWEkuVVBEQVRFX1BSSU9SSVRZLk5PUk1BTF0gLSBUaGUgcHJpb3JpdHkgZm9yIGVtaXR0aW5nXG4gICAqIEByZXR1cm5zIFRoaXMgaW5zdGFuY2Ugb2YgYSB0aWNrZXJcbiAgICovXG4gIGFkZE9uY2UoZm4sIGNvbnRleHQsIHByaW9yaXR5ID0gX2NvbnN0LlVQREFURV9QUklPUklUWS5OT1JNQUwpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkTGlzdGVuZXIobmV3IFRpY2tlckxpc3RlbmVyLlRpY2tlckxpc3RlbmVyKGZuLCBjb250ZXh0LCBwcmlvcml0eSwgITApKTtcbiAgfVxuICAvKipcbiAgICogSW50ZXJuYWxseSBhZGRzIHRoZSBldmVudCBoYW5kbGVyIHNvIHRoYXQgaXQgY2FuIGJlIHNvcnRlZCBieSBwcmlvcml0eS5cbiAgICogUHJpb3JpdHkgYWxsb3dzIGNlcnRhaW4gaGFuZGxlciAodXNlciwgQW5pbWF0ZWRTcHJpdGUsIEludGVyYWN0aW9uKSB0byBiZSBydW5cbiAgICogYmVmb3JlIHRoZSByZW5kZXJpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIEN1cnJlbnQgbGlzdGVuZXIgYmVpbmcgYWRkZWQuXG4gICAqIEByZXR1cm5zIFRoaXMgaW5zdGFuY2Ugb2YgYSB0aWNrZXJcbiAgICovXG4gIF9hZGRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZC5uZXh0LCBwcmV2aW91cyA9IHRoaXMuX2hlYWQ7XG4gICAgaWYgKCFjdXJyZW50KVxuICAgICAgbGlzdGVuZXIuY29ubmVjdChwcmV2aW91cyk7XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKDsgY3VycmVudDsgKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lci5wcmlvcml0eSA+IGN1cnJlbnQucHJpb3JpdHkpIHtcbiAgICAgICAgICBsaXN0ZW5lci5jb25uZWN0KHByZXZpb3VzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQsIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lci5wcmV2aW91cyB8fCBsaXN0ZW5lci5jb25uZWN0KHByZXZpb3VzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0SWZQb3NzaWJsZSgpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFueSBoYW5kbGVycyBtYXRjaGluZyB0aGUgZnVuY3Rpb24gYW5kIGNvbnRleHQgcGFyYW1ldGVycy5cbiAgICogSWYgbm8gaGFuZGxlcnMgYXJlIGxlZnQgYWZ0ZXIgcmVtb3ZpbmcsIHRoZW4gaXQgY2FuY2VscyB0aGUgYW5pbWF0aW9uIGZyYW1lLlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBsaXN0ZW5lciBjb250ZXh0IHRvIGJlIHJlbW92ZWRcbiAgICogQHJldHVybnMgVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgKi9cbiAgcmVtb3ZlKGZuLCBjb250ZXh0KSB7XG4gICAgbGV0IGxpc3RlbmVyID0gdGhpcy5faGVhZC5uZXh0O1xuICAgIGZvciAoOyBsaXN0ZW5lcjsgKVxuICAgICAgbGlzdGVuZXIubWF0Y2goZm4sIGNvbnRleHQpID8gbGlzdGVuZXIgPSBsaXN0ZW5lci5kZXN0cm95KCkgOiBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWQubmV4dCB8fCB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycyBvbiB0aGlzIHRpY2tlciwgY2FsY3VsYXRlZCBieSB3YWxraW5nIHRocm91Z2ggbGlua2VkIGxpc3RcbiAgICogQHJlYWRvbmx5XG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICovXG4gIGdldCBjb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX2hlYWQpXG4gICAgICByZXR1cm4gMDtcbiAgICBsZXQgY291bnQgPSAwLCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICBmb3IgKDsgY3VycmVudCA9IGN1cnJlbnQubmV4dDsgKVxuICAgICAgY291bnQrKztcbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgLyoqIFN0YXJ0cyB0aGUgdGlja2VyLiBJZiB0aGUgdGlja2VyIGhhcyBsaXN0ZW5lcnMgYSBuZXcgYW5pbWF0aW9uIGZyYW1lIGlzIHJlcXVlc3RlZCBhdCB0aGlzIHBvaW50LiAqL1xuICBzdGFydCgpIHtcbiAgICB0aGlzLnN0YXJ0ZWQgfHwgKHRoaXMuc3RhcnRlZCA9ICEwLCB0aGlzLl9yZXF1ZXN0SWZOZWVkZWQoKSk7XG4gIH1cbiAgLyoqIFN0b3BzIHRoZSB0aWNrZXIuIElmIHRoZSB0aWNrZXIgaGFzIHJlcXVlc3RlZCBhbiBhbmltYXRpb24gZnJhbWUgaXQgaXMgY2FuY2VsZWQgYXQgdGhpcyBwb2ludC4gKi9cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnN0YXJ0ZWQgJiYgKHRoaXMuc3RhcnRlZCA9ICExLCB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpKTtcbiAgfVxuICAvKiogRGVzdHJveSB0aGUgdGlja2VyIGFuZCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy4gQ2FsbGluZyB0aGlzIG1ldGhvZCByZW1vdmVzIGFsbCByZWZlcmVuY2VzIHRvIGludGVybmFsIGV2ZW50cy4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAoIXRoaXMuX3Byb3RlY3RlZCkge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB0aGlzLl9oZWFkLm5leHQ7XG4gICAgICBmb3IgKDsgbGlzdGVuZXI7IClcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5kZXN0cm95KCEwKTtcbiAgICAgIHRoaXMuX2hlYWQuZGVzdHJveSgpLCB0aGlzLl9oZWFkID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGFuIHVwZGF0ZS4gQW4gdXBkYXRlIGVudGFpbHMgc2V0dGluZyB0aGVcbiAgICogY3VycmVudCB7QGxpbmsgUElYSS5UaWNrZXIjZWxhcHNlZE1TfSxcbiAgICogdGhlIGN1cnJlbnQge0BsaW5rIFBJWEkuVGlja2VyI2RlbHRhVGltZX0sXG4gICAqIGludm9raW5nIGFsbCBsaXN0ZW5lcnMgd2l0aCBjdXJyZW50IGRlbHRhVGltZSxcbiAgICogYW5kIHRoZW4gZmluYWxseSBzZXR0aW5nIHtAbGluayBQSVhJLlRpY2tlciNsYXN0VGltZX1cbiAgICogd2l0aCB0aGUgdmFsdWUgb2YgY3VycmVudFRpbWUgdGhhdCB3YXMgcHJvdmlkZWQuXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgYW5pbWF0aW9uXG4gICAqIGZyYW1lIGNhbGxiYWNrcyBpZiB0aGUgdGlja2VyIGluc3RhbmNlIGhhcyBiZWVuIHN0YXJ0ZWRcbiAgICogYW5kIGxpc3RlbmVycyBhcmUgYWRkZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY3VycmVudFRpbWU9cGVyZm9ybWFuY2Uubm93KCldIC0gdGhlIGN1cnJlbnQgdGltZSBvZiBleGVjdXRpb25cbiAgICovXG4gIHVwZGF0ZShjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpKSB7XG4gICAgbGV0IGVsYXBzZWRNUztcbiAgICBpZiAoY3VycmVudFRpbWUgPiB0aGlzLmxhc3RUaW1lKSB7XG4gICAgICBpZiAoZWxhcHNlZE1TID0gdGhpcy5lbGFwc2VkTVMgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWUsIGVsYXBzZWRNUyA+IHRoaXMuX21heEVsYXBzZWRNUyAmJiAoZWxhcHNlZE1TID0gdGhpcy5fbWF4RWxhcHNlZE1TKSwgZWxhcHNlZE1TICo9IHRoaXMuc3BlZWQsIHRoaXMuX21pbkVsYXBzZWRNUykge1xuICAgICAgICBjb25zdCBkZWx0YSA9IGN1cnJlbnRUaW1lIC0gdGhpcy5fbGFzdEZyYW1lIHwgMDtcbiAgICAgICAgaWYgKGRlbHRhIDwgdGhpcy5fbWluRWxhcHNlZE1TKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gY3VycmVudFRpbWUgLSBkZWx0YSAlIHRoaXMuX21pbkVsYXBzZWRNUztcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVsdGFNUyA9IGVsYXBzZWRNUywgdGhpcy5kZWx0YVRpbWUgPSB0aGlzLmRlbHRhTVMgKiBfVGlja2VyMi50YXJnZXRGUE1TO1xuICAgICAgY29uc3QgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBsZXQgbGlzdGVuZXIgPSBoZWFkLm5leHQ7XG4gICAgICBmb3IgKDsgbGlzdGVuZXI7IClcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5lbWl0KHRoaXMuZGVsdGFUaW1lKTtcbiAgICAgIGhlYWQubmV4dCB8fCB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5kZWx0YVRpbWUgPSB0aGlzLmRlbHRhTVMgPSB0aGlzLmVsYXBzZWRNUyA9IDA7XG4gICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZnJhbWVzIHBlciBzZWNvbmQgYXQgd2hpY2ggdGhpcyB0aWNrZXIgaXMgcnVubmluZy5cbiAgICogVGhlIGRlZmF1bHQgaXMgYXBwcm94aW1hdGVseSA2MCBpbiBtb3N0IG1vZGVybiBicm93c2Vycy5cbiAgICogKipOb3RlOioqIFRoaXMgZG9lcyBub3QgZmFjdG9yIGluIHRoZSB2YWx1ZSBvZlxuICAgKiB7QGxpbmsgUElYSS5UaWNrZXIjc3BlZWR9LCB3aGljaCBpcyBzcGVjaWZpY1xuICAgKiB0byBzY2FsaW5nIHtAbGluayBQSVhJLlRpY2tlciNkZWx0YVRpbWV9LlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IEZQUygpIHtcbiAgICByZXR1cm4gMWUzIC8gdGhpcy5lbGFwc2VkTVM7XG4gIH1cbiAgLyoqXG4gICAqIE1hbmFnZXMgdGhlIG1heGltdW0gYW1vdW50IG9mIG1pbGxpc2Vjb25kcyBhbGxvd2VkIHRvXG4gICAqIGVsYXBzZSBiZXR3ZWVuIGludm9raW5nIHtAbGluayBQSVhJLlRpY2tlciN1cGRhdGV9LlxuICAgKiBUaGlzIHZhbHVlIGlzIHVzZWQgdG8gY2FwIHtAbGluayBQSVhJLlRpY2tlciNkZWx0YVRpbWV9LFxuICAgKiBidXQgZG9lcyBub3QgZWZmZWN0IHRoZSBtZWFzdXJlZCB2YWx1ZSBvZiB7QGxpbmsgUElYSS5UaWNrZXIjRlBTfS5cbiAgICogV2hlbiBzZXR0aW5nIHRoaXMgcHJvcGVydHkgaXQgaXMgY2xhbXBlZCB0byBhIHZhbHVlIGJldHdlZW5cbiAgICogYDBgIGFuZCBgVGlja2VyLnRhcmdldEZQTVMgKiAxMDAwYC5cbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxMFxuICAgKi9cbiAgZ2V0IG1pbkZQUygpIHtcbiAgICByZXR1cm4gMWUzIC8gdGhpcy5fbWF4RWxhcHNlZE1TO1xuICB9XG4gIHNldCBtaW5GUFMoZnBzKSB7XG4gICAgY29uc3QgbWluRlBTID0gTWF0aC5taW4odGhpcy5tYXhGUFMsIGZwcyksIG1pbkZQTVMgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBtaW5GUFMpIC8gMWUzLCBfVGlja2VyMi50YXJnZXRGUE1TKTtcbiAgICB0aGlzLl9tYXhFbGFwc2VkTVMgPSAxIC8gbWluRlBNUztcbiAgfVxuICAvKipcbiAgICogTWFuYWdlcyB0aGUgbWluaW11bSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHJlcXVpcmVkIHRvXG4gICAqIGVsYXBzZSBiZXR3ZWVuIGludm9raW5nIHtAbGluayBQSVhJLlRpY2tlciN1cGRhdGV9LlxuICAgKiBUaGlzIHdpbGwgZWZmZWN0IHRoZSBtZWFzdXJlZCB2YWx1ZSBvZiB7QGxpbmsgUElYSS5UaWNrZXIjRlBTfS5cbiAgICogSWYgaXQgaXMgc2V0IHRvIGAwYCwgdGhlbiB0aGVyZSBpcyBubyBsaW1pdDsgUGl4aUpTIHdpbGwgcmVuZGVyIGFzIG1hbnkgZnJhbWVzIGFzIGl0IGNhbi5cbiAgICogT3RoZXJ3aXNlIGl0IHdpbGwgYmUgYXQgbGVhc3QgYG1pbkZQU2BcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgbWF4RlBTKCkge1xuICAgIHJldHVybiB0aGlzLl9taW5FbGFwc2VkTVMgPyBNYXRoLnJvdW5kKDFlMyAvIHRoaXMuX21pbkVsYXBzZWRNUykgOiAwO1xuICB9XG4gIHNldCBtYXhGUFMoZnBzKSB7XG4gICAgaWYgKGZwcyA9PT0gMClcbiAgICAgIHRoaXMuX21pbkVsYXBzZWRNUyA9IDA7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBtYXhGUFMgPSBNYXRoLm1heCh0aGlzLm1pbkZQUywgZnBzKTtcbiAgICAgIHRoaXMuX21pbkVsYXBzZWRNUyA9IDEgLyAobWF4RlBTIC8gMWUzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzaGFyZWQgdGlja2VyIGluc3RhbmNlIHVzZWQgYnkge0BsaW5rIFBJWEkuQW5pbWF0ZWRTcHJpdGV9IGFuZCBieVxuICAgKiB7QGxpbmsgUElYSS5WaWRlb1Jlc291cmNlfSB0byB1cGRhdGUgYW5pbWF0aW9uIGZyYW1lcyAvIHZpZGVvIHRleHR1cmVzLlxuICAgKlxuICAgKiBJdCBtYXkgYWxzbyBiZSB1c2VkIGJ5IHtAbGluayBQSVhJLkFwcGxpY2F0aW9ufSBpZiBjcmVhdGVkIHdpdGggdGhlIGBzaGFyZWRUaWNrZXJgIG9wdGlvbiBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICogVGhlIHByb3BlcnR5IHtAbGluayBQSVhJLlRpY2tlciNhdXRvU3RhcnR9IGlzIHNldCB0byBgdHJ1ZWAgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqIFBsZWFzZSBmb2xsb3cgdGhlIGV4YW1wbGVzIGZvciB1c2FnZSwgaW5jbHVkaW5nIGhvdyB0byBvcHQtb3V0IG9mIGF1dG8tc3RhcnRpbmcgdGhlIHNoYXJlZCB0aWNrZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IFRpY2tlciB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBjb25zdCB0aWNrZXIgPSBUaWNrZXIuc2hhcmVkO1xuICAgKiAvLyBTZXQgdGhpcyB0byBwcmV2ZW50IHN0YXJ0aW5nIHRoaXMgdGlja2VyIHdoZW4gbGlzdGVuZXJzIGFyZSBhZGRlZC5cbiAgICogLy8gQnkgZGVmYXVsdCB0aGlzIGlzIHRydWUgb25seSBmb3IgdGhlIFBJWEkuVGlja2VyLnNoYXJlZCBpbnN0YW5jZS5cbiAgICogdGlja2VyLmF1dG9TdGFydCA9IGZhbHNlO1xuICAgKlxuICAgKiAvLyBGWUksIGNhbGwgdGhpcyB0byBlbnN1cmUgdGhlIHRpY2tlciBpcyBzdG9wcGVkLiBJdCBzaG91bGQgYmUgc3RvcHBlZFxuICAgKiAvLyBpZiB5b3UgaGF2ZSBub3QgYXR0ZW1wdGVkIHRvIHJlbmRlciBhbnl0aGluZyB5ZXQuXG4gICAqIHRpY2tlci5zdG9wKCk7XG4gICAqXG4gICAqIC8vIENhbGwgdGhpcyB3aGVuIHlvdSBhcmUgcmVhZHkgZm9yIGEgcnVubmluZyBzaGFyZWQgdGlja2VyLlxuICAgKiB0aWNrZXIuc3RhcnQoKTtcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgYXV0b0RldGVjdFJlbmRlcmVyLCBDb250YWluZXIgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogLy8gWW91IG1heSB1c2UgdGhlIHNoYXJlZCB0aWNrZXIgdG8gcmVuZGVyLi4uXG4gICAqIGNvbnN0IHJlbmRlcmVyID0gYXV0b0RldGVjdFJlbmRlcmVyKCk7XG4gICAqIGNvbnN0IHN0YWdlID0gbmV3IENvbnRhaW5lcigpO1xuICAgKiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHJlbmRlcmVyLnZpZXcpO1xuICAgKiB0aWNrZXIuYWRkKCh0aW1lKSA9PiByZW5kZXJlci5yZW5kZXIoc3RhZ2UpKTtcbiAgICpcbiAgICogLy8gT3IgeW91IGNhbiBqdXN0IHVwZGF0ZSBpdCBtYW51YWxseS5cbiAgICogdGlja2VyLmF1dG9TdGFydCA9IGZhbHNlO1xuICAgKiB0aWNrZXIuc3RvcCgpO1xuICAgKiBjb25zdCBhbmltYXRlID0gKHRpbWUpID0+IHtcbiAgICogICAgIHRpY2tlci51cGRhdGUodGltZSk7XG4gICAqICAgICByZW5kZXJlci5yZW5kZXIoc3RhZ2UpO1xuICAgKiAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgKiB9O1xuICAgKiBhbmltYXRlKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICogQG1lbWJlciB7UElYSS5UaWNrZXJ9XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBnZXQgc2hhcmVkKCkge1xuICAgIGlmICghX1RpY2tlcjIuX3NoYXJlZCkge1xuICAgICAgY29uc3Qgc2hhcmVkID0gX1RpY2tlcjIuX3NoYXJlZCA9IG5ldyBfVGlja2VyMigpO1xuICAgICAgc2hhcmVkLmF1dG9TdGFydCA9ICEwLCBzaGFyZWQuX3Byb3RlY3RlZCA9ICEwO1xuICAgIH1cbiAgICByZXR1cm4gX1RpY2tlcjIuX3NoYXJlZDtcbiAgfVxuICAvKipcbiAgICogVGhlIHN5c3RlbSB0aWNrZXIgaW5zdGFuY2UgdXNlZCBieSB7QGxpbmsgUElYSS5CYXNlUHJlcGFyZX0gZm9yIGNvcmUgdGltaW5nXG4gICAqIGZ1bmN0aW9uYWxpdHkgdGhhdCBzaG91bGRuJ3QgdXN1YWxseSBuZWVkIHRvIGJlIHBhdXNlZCwgdW5saWtlIHRoZSBgc2hhcmVkYFxuICAgKiB0aWNrZXIgd2hpY2ggZHJpdmVzIHZpc3VhbCBhbmltYXRpb25zIGFuZCByZW5kZXJpbmcgd2hpY2ggbWF5IHdhbnQgdG8gYmUgcGF1c2VkLlxuICAgKlxuICAgKiBUaGUgcHJvcGVydHkge0BsaW5rIFBJWEkuVGlja2VyI2F1dG9TdGFydH0gaXMgc2V0IHRvIGB0cnVlYCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICogQG1lbWJlciB7UElYSS5UaWNrZXJ9XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBnZXQgc3lzdGVtKCkge1xuICAgIGlmICghX1RpY2tlcjIuX3N5c3RlbSkge1xuICAgICAgY29uc3Qgc3lzdGVtID0gX1RpY2tlcjIuX3N5c3RlbSA9IG5ldyBfVGlja2VyMigpO1xuICAgICAgc3lzdGVtLmF1dG9TdGFydCA9ICEwLCBzeXN0ZW0uX3Byb3RlY3RlZCA9ICEwO1xuICAgIH1cbiAgICByZXR1cm4gX1RpY2tlcjIuX3N5c3RlbTtcbiAgfVxufTtcbl9UaWNrZXIudGFyZ2V0RlBNUyA9IDAuMDY7XG5sZXQgVGlja2VyID0gX1RpY2tlcjtcbmV4cG9ydHMuVGlja2VyID0gVGlja2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlja2VyLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBUaWNrZXJMaXN0ZW5lciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIG9uZSB1cGRhdGVcbiAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgbGlzdGVuZXIgY29udGV4dFxuICAgKiBAcGFyYW0gcHJpb3JpdHkgLSBUaGUgcHJpb3JpdHkgZm9yIGVtaXR0aW5nXG4gICAqIEBwYXJhbSBvbmNlIC0gSWYgdGhlIGhhbmRsZXIgc2hvdWxkIGZpcmUgb25jZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZm4sIGNvbnRleHQgPSBudWxsLCBwcmlvcml0eSA9IDAsIG9uY2UgPSAhMSkge1xuICAgIHRoaXMubmV4dCA9IG51bGwsIHRoaXMucHJldmlvdXMgPSBudWxsLCB0aGlzLl9kZXN0cm95ZWQgPSAhMSwgdGhpcy5mbiA9IGZuLCB0aGlzLmNvbnRleHQgPSBjb250ZXh0LCB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHksIHRoaXMub25jZSA9IG9uY2U7XG4gIH1cbiAgLyoqXG4gICAqIFNpbXBsZSBjb21wYXJlIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgaWYgYSBmdW5jdGlvbiBhbmQgY29udGV4dCBtYXRjaC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciBvbmUgdXBkYXRlXG4gICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBsaXN0ZW5lciBtYXRjaCB0aGUgYXJndW1lbnRzXG4gICAqL1xuICBtYXRjaChmbiwgY29udGV4dCA9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5mbiA9PT0gZm4gJiYgdGhpcy5jb250ZXh0ID09PSBjb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBFbWl0IGJ5IGNhbGxpbmcgdGhlIGN1cnJlbnQgZnVuY3Rpb24uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBkZWx0YVRpbWUgLSB0aW1lIHNpbmNlIHRoZSBsYXN0IGVtaXQuXG4gICAqIEByZXR1cm5zIE5leHQgdGlja2VyXG4gICAqL1xuICBlbWl0KGRlbHRhVGltZSkge1xuICAgIHRoaXMuZm4gJiYgKHRoaXMuY29udGV4dCA/IHRoaXMuZm4uY2FsbCh0aGlzLmNvbnRleHQsIGRlbHRhVGltZSkgOiB0aGlzLmZuKGRlbHRhVGltZSkpO1xuICAgIGNvbnN0IHJlZGlyZWN0ID0gdGhpcy5uZXh0O1xuICAgIHJldHVybiB0aGlzLm9uY2UgJiYgdGhpcy5kZXN0cm95KCEwKSwgdGhpcy5fZGVzdHJveWVkICYmICh0aGlzLm5leHQgPSBudWxsKSwgcmVkaXJlY3Q7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gdGhlIGxpc3QuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBwcmV2aW91cyAtIElucHV0IG5vZGUsIHByZXZpb3VzIGxpc3RlbmVyXG4gICAqL1xuICBjb25uZWN0KHByZXZpb3VzKSB7XG4gICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzLCBwcmV2aW91cy5uZXh0ICYmIChwcmV2aW91cy5uZXh0LnByZXZpb3VzID0gdGhpcyksIHRoaXMubmV4dCA9IHByZXZpb3VzLm5leHQsIHByZXZpb3VzLm5leHQgPSB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95IGFuZCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGhhcmQgLSBgdHJ1ZWAgdG8gcmVtb3ZlIHRoZSBgbmV4dGAgcmVmZXJlbmNlLCB0aGlzXG4gICAqICAgICAgICBpcyBjb25zaWRlcmVkIGEgaGFyZCBkZXN0cm95LiBTb2Z0IGRlc3Ryb3kgbWFpbnRhaW5zIHRoZSBuZXh0IHJlZmVyZW5jZS5cbiAgICogQHJldHVybnMgVGhlIGxpc3RlbmVyIHRvIHJlZGlyZWN0IHdoaWxlIGVtaXR0aW5nIG9yIHJlbW92aW5nLlxuICAgKi9cbiAgZGVzdHJveShoYXJkID0gITEpIHtcbiAgICB0aGlzLl9kZXN0cm95ZWQgPSAhMCwgdGhpcy5mbiA9IG51bGwsIHRoaXMuY29udGV4dCA9IG51bGwsIHRoaXMucHJldmlvdXMgJiYgKHRoaXMucHJldmlvdXMubmV4dCA9IHRoaXMubmV4dCksIHRoaXMubmV4dCAmJiAodGhpcy5uZXh0LnByZXZpb3VzID0gdGhpcy5wcmV2aW91cyk7XG4gICAgY29uc3QgcmVkaXJlY3QgPSB0aGlzLm5leHQ7XG4gICAgcmV0dXJuIHRoaXMubmV4dCA9IGhhcmQgPyBudWxsIDogcmVkaXJlY3QsIHRoaXMucHJldmlvdXMgPSBudWxsLCByZWRpcmVjdDtcbiAgfVxufVxuZXhwb3J0cy5UaWNrZXJMaXN0ZW5lciA9IFRpY2tlckxpc3RlbmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlja2VyTGlzdGVuZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBleHRlbnNpb25zID0gcmVxdWlyZShcIkBwaXhpL2V4dGVuc2lvbnNcIiksIF9jb25zdCA9IHJlcXVpcmUoXCIuL2NvbnN0LmpzXCIpLCBUaWNrZXIgPSByZXF1aXJlKFwiLi9UaWNrZXIuanNcIik7XG5jbGFzcyBUaWNrZXJQbHVnaW4ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgcGx1Z2luIHdpdGggc2NvcGUgb2YgYXBwbGljYXRpb24gaW5zdGFuY2VcbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gU2VlIGFwcGxpY2F0aW9uIG9wdGlvbnNcbiAgICovXG4gIHN0YXRpYyBpbml0KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBhdXRvU3RhcnQ6ICEwLFxuICAgICAgc2hhcmVkVGlja2VyOiAhMVxuICAgIH0sIG9wdGlvbnMpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgXCJ0aWNrZXJcIixcbiAgICAgIHtcbiAgICAgICAgc2V0KHRpY2tlcikge1xuICAgICAgICAgIHRoaXMuX3RpY2tlciAmJiB0aGlzLl90aWNrZXIucmVtb3ZlKHRoaXMucmVuZGVyLCB0aGlzKSwgdGhpcy5fdGlja2VyID0gdGlja2VyLCB0aWNrZXIgJiYgdGlja2VyLmFkZCh0aGlzLnJlbmRlciwgdGhpcywgX2NvbnN0LlVQREFURV9QUklPUklUWS5MT1cpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RpY2tlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICksIHRoaXMuc3RvcCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3RpY2tlci5zdG9wKCk7XG4gICAgfSwgdGhpcy5zdGFydCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3RpY2tlci5zdGFydCgpO1xuICAgIH0sIHRoaXMuX3RpY2tlciA9IG51bGwsIHRoaXMudGlja2VyID0gb3B0aW9ucy5zaGFyZWRUaWNrZXIgPyBUaWNrZXIuVGlja2VyLnNoYXJlZCA6IG5ldyBUaWNrZXIuVGlja2VyKCksIG9wdGlvbnMuYXV0b1N0YXJ0ICYmIHRoaXMuc3RhcnQoKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYW4gdXAgdGhlIHRpY2tlciwgc2NvcGVkIHRvIGFwcGxpY2F0aW9uLlxuICAgKiBAc3RhdGljXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fdGlja2VyKSB7XG4gICAgICBjb25zdCBvbGRUaWNrZXIgPSB0aGlzLl90aWNrZXI7XG4gICAgICB0aGlzLnRpY2tlciA9IG51bGwsIG9sZFRpY2tlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5UaWNrZXJQbHVnaW4uZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5FeHRlbnNpb25UeXBlLkFwcGxpY2F0aW9uO1xuZXh0ZW5zaW9ucy5leHRlbnNpb25zLmFkZChUaWNrZXJQbHVnaW4pO1xuZXhwb3J0cy5UaWNrZXJQbHVnaW4gPSBUaWNrZXJQbHVnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWNrZXJQbHVnaW4uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBVUERBVEVfUFJJT1JJVFkgPSAvKiBAX19QVVJFX18gKi8gKChVUERBVEVfUFJJT1JJVFkyKSA9PiAoVVBEQVRFX1BSSU9SSVRZMltVUERBVEVfUFJJT1JJVFkyLklOVEVSQUNUSU9OID0gNTBdID0gXCJJTlRFUkFDVElPTlwiLCBVUERBVEVfUFJJT1JJVFkyW1VQREFURV9QUklPUklUWTIuSElHSCA9IDI1XSA9IFwiSElHSFwiLCBVUERBVEVfUFJJT1JJVFkyW1VQREFURV9QUklPUklUWTIuTk9STUFMID0gMF0gPSBcIk5PUk1BTFwiLCBVUERBVEVfUFJJT1JJVFkyW1VQREFURV9QUklPUklUWTIuTE9XID0gLTI1XSA9IFwiTE9XXCIsIFVQREFURV9QUklPUklUWTJbVVBEQVRFX1BSSU9SSVRZMi5VVElMSVRZID0gLTUwXSA9IFwiVVRJTElUWVwiLCBVUERBVEVfUFJJT1JJVFkyKSkoVVBEQVRFX1BSSU9SSVRZIHx8IHt9KTtcbmV4cG9ydHMuVVBEQVRFX1BSSU9SSVRZID0gVVBEQVRFX1BSSU9SSVRZO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnJlcXVpcmUoXCIuL3NldHRpbmdzLmpzXCIpO1xudmFyIF9jb25zdCA9IHJlcXVpcmUoXCIuL2NvbnN0LmpzXCIpLCBUaWNrZXIgPSByZXF1aXJlKFwiLi9UaWNrZXIuanNcIiksIFRpY2tlclBsdWdpbiA9IHJlcXVpcmUoXCIuL1RpY2tlclBsdWdpbi5qc1wiKTtcbmV4cG9ydHMuVVBEQVRFX1BSSU9SSVRZID0gX2NvbnN0LlVQREFURV9QUklPUklUWTtcbmV4cG9ydHMuVGlja2VyID0gVGlja2VyLlRpY2tlcjtcbmV4cG9ydHMuVGlja2VyUGx1Z2luID0gVGlja2VyUGx1Z2luLlRpY2tlclBsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgc2V0dGluZ3MgPSByZXF1aXJlKFwiQHBpeGkvc2V0dGluZ3NcIiksIHV0aWxzID0gcmVxdWlyZShcIkBwaXhpL3V0aWxzXCIpLCBUaWNrZXIgPSByZXF1aXJlKFwiLi9UaWNrZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhzZXR0aW5ncy5zZXR0aW5ncywge1xuICAvKipcbiAgICogVGFyZ2V0IGZyYW1lcyBwZXIgbWlsbGlzZWNvbmQuXG4gICAqIEBzdGF0aWNcbiAgICogQG5hbWUgVEFSR0VUX0ZQTVNcbiAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4xLjBcbiAgICogQHNlZSBQSVhJLlRpY2tlci50YXJnZXRGUE1TXG4gICAqL1xuICBUQVJHRVRfRlBNUzoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBUaWNrZXIuVGlja2VyLnRhcmdldEZQTVM7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5UQVJHRVRfRlBNUyBpcyBkZXByZWNhdGVkLCB1c2UgVGlja2VyLnRhcmdldEZQTVNcIiksIFRpY2tlci5UaWNrZXIudGFyZ2V0RlBNUyA9IHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZXR0aW5nc1wiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZXR0aW5ncy5zZXR0aW5ncztcbiAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXR0aW5ncy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCJAcGl4aS9jb25zdGFudHNcIik7XG5sZXQgcHJvbWlzZTtcbmFzeW5jIGZ1bmN0aW9uIGRldGVjdFZpZGVvQWxwaGFNb2RlKCkge1xuICByZXR1cm4gcHJvbWlzZSA/PyAocHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgZ2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCJ3ZWJnbFwiKTtcbiAgICBpZiAoIWdsKVxuICAgICAgcmV0dXJuIGNvbnN0YW50cy5BTFBIQV9NT0RFUy5VTlBBQ0s7XG4gICAgY29uc3QgdmlkZW8gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgdmlkZW8yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuICAgICAgdmlkZW8yLm9ubG9hZGVkZGF0YSA9ICgpID0+IHJlc29sdmUodmlkZW8yKSwgdmlkZW8yLm9uZXJyb3IgPSAoKSA9PiByZXNvbHZlKG51bGwpLCB2aWRlbzIuYXV0b3BsYXkgPSAhMSwgdmlkZW8yLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIiwgdmlkZW8yLnByZWxvYWQgPSBcImF1dG9cIiwgdmlkZW8yLnNyYyA9IFwiZGF0YTp2aWRlby93ZWJtO2Jhc2U2NCxHa1hmbzU5Q2hvRUJRdmVCQVVMeWdRUkM4NEVJUW9LRWQyVmliVUtIZ1FKQ2hZRUNHRk9BWndFQUFBQUFBQUhURVUyYmRMcE51NHRUcTRRVlNhbG1VNnlCb1UyN2kxT3JoQlpVcm10VHJJSEdUYnVNVTZ1RUVsVERaMU9zZ2dFWFRidU1VNnVFSEZPN2ExT3NnZ0c5N0FFQUFBQUFBQUJaQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFWU2FsbW9DclhzWU1QUWtCTmdJUk1ZWFptVjBHRVRHRjJaa1NKaUVCRUFBQUFBQUFBRmxTdWE4eXVBUUFBQUFBQUFFUFhnUUZ6eFlnQUFBQUFBQUFBQVp5QkFDSzFuSU4xYm1TSWdRQ0doVlpmVmxBNWc0RUJJK09EaEFKaVdnRGdsTENCQXJxQkFwcUJBbFBBZ1FGVnNJUlZ1WUVCRWxURFo5VnpjOUpqd0l0anhZZ0FBQUFBQUFBQUFXZkluRVdqaDBWT1EwOUVSVkpFaDQ5TVlYWmpJR3hwWW5ad2VDMTJjRGxueUtKRm80aEVWVkpCVkVsUFRrU0hsREF3T2pBd09qQXdMakEwTURBd01EQXdNQUFBSDBPMmRjZm5nUUNnd3FHZ2dRQUFBSUpKZzBJQUFCQUFGZ0E0SkJ3WVNnQUFJQ0FBRWIvLy80citBQUIxb1oybW0rNkJBYVdXZ2ttRFFnQUFFQUFXQURna0hCaEtBQUFnSUFCSVFCeFR1MnVSdTQremdRQzNpdmVCQWZHQ0FYSHdnUU09XCIsIHZpZGVvMi5sb2FkKCk7XG4gICAgfSk7XG4gICAgaWYgKCF2aWRlbylcbiAgICAgIHJldHVybiBjb25zdGFudHMuQUxQSEFfTU9ERVMuVU5QQUNLO1xuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgY29uc3QgZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpLCBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgICAgZ2wuQ09MT1JfQVRUQUNITUVOVDAsXG4gICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgdGV4dHVyZSxcbiAgICAgIDBcbiAgICApLCBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsICExKSwgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCwgZ2wuTk9ORSksIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdmlkZW8pO1xuICAgIGNvbnN0IHBpeGVsID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgcmV0dXJuIGdsLnJlYWRQaXhlbHMoMCwgMCwgMSwgMSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWwpLCBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlciksIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSksIGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKT8ubG9zZUNvbnRleHQoKSwgcGl4ZWxbMF0gPD0gcGl4ZWxbM10gPyBjb25zdGFudHMuQUxQSEFfTU9ERVMuUE1BIDogY29uc3RhbnRzLkFMUEhBX01PREVTLlVOUEFDSztcbiAgfSkoKSksIHByb21pc2U7XG59XG5leHBvcnRzLmRldGVjdFZpZGVvQWxwaGFNb2RlID0gZGV0ZWN0VmlkZW9BbHBoYU1vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3RWaWRlb0FscGhhTW9kZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGRlcHJlY2F0aW9uID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvZGVwcmVjYXRpb24uanNcIik7XG5mdW5jdGlvbiBza2lwSGVsbG8oKSB7XG4gIGRlcHJlY2F0aW9uLmRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJza2lwSGVsbG8gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBzZXR0aW5ncy5SRU5ERVJfT1BUSU9OUy5oZWxsb1wiKTtcbn1cbmZ1bmN0aW9uIHNheUhlbGxvKCkge1xuICBkZXByZWNhdGlvbi5kZXByZWNhdGlvbihcIjcuMC4wXCIsIGBzYXlIZWxsbyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFJlbmRlcmVyJ3MgXCJoZWxsb1wiIG9wdGlvbmApO1xufVxuZXhwb3J0cy5zYXlIZWxsbyA9IHNheUhlbGxvO1xuZXhwb3J0cy5za2lwSGVsbG8gPSBza2lwSGVsbG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxsby5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xucmVxdWlyZShcIi4uL3NldHRpbmdzLmpzXCIpO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZShcIkBwaXhpL3NldHRpbmdzXCIpO1xubGV0IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIGlzV2ViR0xTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiB0eXBlb2Ygc3VwcG9ydGVkID4gXCJ1XCIgJiYgKHN1cHBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGNvbnRleHRPcHRpb25zID0ge1xuICAgICAgc3RlbmNpbDogITAsXG4gICAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBzZXR0aW5ncy5zZXR0aW5ncy5GQUlMX0lGX01BSk9SX1BFUkZPUk1BTkNFX0NBVkVBVFxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc2V0dGluZ3Muc2V0dGluZ3MuQURBUFRFUi5nZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQoKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgY2FudmFzID0gc2V0dGluZ3Muc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoKTtcbiAgICAgIGxldCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwgY29udGV4dE9wdGlvbnMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIGNvbnRleHRPcHRpb25zKTtcbiAgICAgIGNvbnN0IHN1Y2Nlc3MgPSAhIWdsPy5nZXRDb250ZXh0QXR0cmlidXRlcygpPy5zdGVuY2lsO1xuICAgICAgaWYgKGdsKSB7XG4gICAgICAgIGNvbnN0IGxvc2VDb250ZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpO1xuICAgICAgICBsb3NlQ29udGV4dCAmJiBsb3NlQ29udGV4dC5sb3NlQ29udGV4dCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdsID0gbnVsbCwgc3VjY2VzcztcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gIH0oKSksIHN1cHBvcnRlZDtcbn1cbmV4cG9ydHMuaXNXZWJHTFN1cHBvcnRlZCA9IGlzV2ViR0xTdXBwb3J0ZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1dlYkdMU3VwcG9ydGVkLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29sb3IgPSByZXF1aXJlKFwiQHBpeGkvY29sb3JcIiksIGRlcHJlY2F0aW9uID0gcmVxdWlyZShcIi4uL2xvZ2dpbmcvZGVwcmVjYXRpb24uanNcIik7XG5mdW5jdGlvbiBoZXgycmdiKGhleCwgb3V0ID0gW10pIHtcbiAgcmV0dXJuIGRlcHJlY2F0aW9uLmRlcHJlY2F0aW9uKFwiNy4yLjBcIiwgXCJ1dGlscy5oZXgycmdiIGlzIGRlcHJlY2F0ZWQsIHVzZSBDb2xvciN0b1JnYkFycmF5IGluc3RlYWRcIiksIGNvbG9yLkNvbG9yLnNoYXJlZC5zZXRWYWx1ZShoZXgpLnRvUmdiQXJyYXkob3V0KTtcbn1cbmZ1bmN0aW9uIGhleDJzdHJpbmcoaGV4KSB7XG4gIHJldHVybiBkZXByZWNhdGlvbi5kZXByZWNhdGlvbihcIjcuMi4wXCIsIFwidXRpbHMuaGV4MnN0cmluZyBpcyBkZXByZWNhdGVkLCB1c2UgQ29sb3IjdG9IZXggaW5zdGVhZFwiKSwgY29sb3IuQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGhleCkudG9IZXgoKTtcbn1cbmZ1bmN0aW9uIHN0cmluZzJoZXgoc3RyaW5nKSB7XG4gIHJldHVybiBkZXByZWNhdGlvbi5kZXByZWNhdGlvbihcIjcuMi4wXCIsIFwidXRpbHMuc3RyaW5nMmhleCBpcyBkZXByZWNhdGVkLCB1c2UgQ29sb3IjdG9OdW1iZXIgaW5zdGVhZFwiKSwgY29sb3IuQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHN0cmluZykudG9OdW1iZXIoKTtcbn1cbmZ1bmN0aW9uIHJnYjJoZXgocmdiKSB7XG4gIHJldHVybiBkZXByZWNhdGlvbi5kZXByZWNhdGlvbihcIjcuMi4wXCIsIFwidXRpbHMucmdiMmhleCBpcyBkZXByZWNhdGVkLCB1c2UgQ29sb3IjdG9OdW1iZXIgaW5zdGVhZFwiKSwgY29sb3IuQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHJnYikudG9OdW1iZXIoKTtcbn1cbmV4cG9ydHMuaGV4MnJnYiA9IGhleDJyZ2I7XG5leHBvcnRzLmhleDJzdHJpbmcgPSBoZXgyc3RyaW5nO1xuZXhwb3J0cy5yZ2IyaGV4ID0gcmdiMmhleDtcbmV4cG9ydHMuc3RyaW5nMmhleCA9IHN0cmluZzJoZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb2xvciA9IHJlcXVpcmUoXCJAcGl4aS9jb2xvclwiKSwgY29uc3RhbnRzID0gcmVxdWlyZShcIkBwaXhpL2NvbnN0YW50c1wiKSwgZGVwcmVjYXRpb24gPSByZXF1aXJlKFwiLi4vbG9nZ2luZy9kZXByZWNhdGlvbi5qc1wiKTtcbmZ1bmN0aW9uIG1hcFByZW11bHRpcGxpZWRCbGVuZE1vZGVzKCkge1xuICBjb25zdCBwbSA9IFtdLCBucG0gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKVxuICAgIHBtW2ldID0gaSwgbnBtW2ldID0gaTtcbiAgcG1bY29uc3RhbnRzLkJMRU5EX01PREVTLk5PUk1BTF9OUE1dID0gY29uc3RhbnRzLkJMRU5EX01PREVTLk5PUk1BTCwgcG1bY29uc3RhbnRzLkJMRU5EX01PREVTLkFERF9OUE1dID0gY29uc3RhbnRzLkJMRU5EX01PREVTLkFERCwgcG1bY29uc3RhbnRzLkJMRU5EX01PREVTLlNDUkVFTl9OUE1dID0gY29uc3RhbnRzLkJMRU5EX01PREVTLlNDUkVFTiwgbnBtW2NvbnN0YW50cy5CTEVORF9NT0RFUy5OT1JNQUxdID0gY29uc3RhbnRzLkJMRU5EX01PREVTLk5PUk1BTF9OUE0sIG5wbVtjb25zdGFudHMuQkxFTkRfTU9ERVMuQUREXSA9IGNvbnN0YW50cy5CTEVORF9NT0RFUy5BRERfTlBNLCBucG1bY29uc3RhbnRzLkJMRU5EX01PREVTLlNDUkVFTl0gPSBjb25zdGFudHMuQkxFTkRfTU9ERVMuU0NSRUVOX05QTTtcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgcmV0dXJuIGFycmF5LnB1c2gobnBtKSwgYXJyYXkucHVzaChwbSksIGFycmF5O1xufVxuY29uc3QgcHJlbXVsdGlwbHlCbGVuZE1vZGUgPSBtYXBQcmVtdWx0aXBsaWVkQmxlbmRNb2RlcygpO1xuZnVuY3Rpb24gY29ycmVjdEJsZW5kTW9kZShibGVuZE1vZGUsIHByZW11bHRpcGxpZWQpIHtcbiAgcmV0dXJuIHByZW11bHRpcGx5QmxlbmRNb2RlW3ByZW11bHRpcGxpZWQgPyAxIDogMF1bYmxlbmRNb2RlXTtcbn1cbmZ1bmN0aW9uIHByZW11bHRpcGx5UmdiYShyZ2IsIGFscGhhLCBvdXQsIHByZW11bHRpcGx5ID0gITApIHtcbiAgcmV0dXJuIGRlcHJlY2F0aW9uLmRlcHJlY2F0aW9uKFwiNy4yLjBcIiwgXCJ1dGlscy5wcmVtdWx0aXBseVJnYmEgaGFzIG1vdmVkIHRvIENvbG9yLnByZW11bHRpcGx5XCIpLCBjb2xvci5Db2xvci5zaGFyZWQuc2V0VmFsdWUocmdiKS5wcmVtdWx0aXBseShhbHBoYSwgcHJlbXVsdGlwbHkpLnRvQXJyYXkob3V0ID8/IG5ldyBGbG9hdDMyQXJyYXkoNCkpO1xufVxuZnVuY3Rpb24gcHJlbXVsdGlwbHlUaW50KHRpbnQsIGFscGhhKSB7XG4gIHJldHVybiBkZXByZWNhdGlvbi5kZXByZWNhdGlvbihcIjcuMi4wXCIsIFwidXRpbHMucHJlbXVsdGlwbHlUaW50IGhhcyBtb3ZlZCB0byBDb2xvci50b1ByZW11bHRpcGxpZWRcIiksIGNvbG9yLkNvbG9yLnNoYXJlZC5zZXRWYWx1ZSh0aW50KS50b1ByZW11bHRpcGxpZWQoYWxwaGEpO1xufVxuZnVuY3Rpb24gcHJlbXVsdGlwbHlUaW50VG9SZ2JhKHRpbnQsIGFscGhhLCBvdXQsIHByZW11bHRpcGx5ID0gITApIHtcbiAgcmV0dXJuIGRlcHJlY2F0aW9uLmRlcHJlY2F0aW9uKFwiNy4yLjBcIiwgXCJ1dGlscy5wcmVtdWx0aXBseVRpbnRUb1JnYmEgaGFzIG1vdmVkIHRvIENvbG9yLnByZW11bHRpcGx5XCIpLCBjb2xvci5Db2xvci5zaGFyZWQuc2V0VmFsdWUodGludCkucHJlbXVsdGlwbHkoYWxwaGEsIHByZW11bHRpcGx5KS50b0FycmF5KG91dCA/PyBuZXcgRmxvYXQzMkFycmF5KDQpKTtcbn1cbmV4cG9ydHMuY29ycmVjdEJsZW5kTW9kZSA9IGNvcnJlY3RCbGVuZE1vZGU7XG5leHBvcnRzLnByZW11bHRpcGx5QmxlbmRNb2RlID0gcHJlbXVsdGlwbHlCbGVuZE1vZGU7XG5leHBvcnRzLnByZW11bHRpcGx5UmdiYSA9IHByZW11bHRpcGx5UmdiYTtcbmV4cG9ydHMucHJlbXVsdGlwbHlUaW50ID0gcHJlbXVsdGlwbHlUaW50O1xuZXhwb3J0cy5wcmVtdWx0aXBseVRpbnRUb1JnYmEgPSBwcmVtdWx0aXBseVRpbnRUb1JnYmE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVtdWx0aXBseS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgREFUQV9VUkkgPSAvXlxccypkYXRhOig/OihbXFx3LV0rKVxcLyhbXFx3Ky4tXSspKT8oPzo7Y2hhcnNldD0oW1xcdy1dKykpPyg/OjsoYmFzZTY0KSk/LCguKikvaTtcbmV4cG9ydHMuREFUQV9VUkkgPSBEQVRBX1VSSTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBjcmVhdGVJbmRpY2VzRm9yUXVhZHMoc2l6ZSwgb3V0QnVmZmVyID0gbnVsbCkge1xuICBjb25zdCB0b3RhbEluZGljZXMgPSBzaXplICogNjtcbiAgaWYgKG91dEJ1ZmZlciA9IG91dEJ1ZmZlciB8fCBuZXcgVWludDE2QXJyYXkodG90YWxJbmRpY2VzKSwgb3V0QnVmZmVyLmxlbmd0aCAhPT0gdG90YWxJbmRpY2VzKVxuICAgIHRocm93IG5ldyBFcnJvcihgT3V0IGJ1ZmZlciBsZW5ndGggaXMgaW5jb3JyZWN0LCBnb3QgJHtvdXRCdWZmZXIubGVuZ3RofSBhbmQgZXhwZWN0ZWQgJHt0b3RhbEluZGljZXN9YCk7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvdGFsSW5kaWNlczsgaSArPSA2LCBqICs9IDQpXG4gICAgb3V0QnVmZmVyW2kgKyAwXSA9IGogKyAwLCBvdXRCdWZmZXJbaSArIDFdID0gaiArIDEsIG91dEJ1ZmZlcltpICsgMl0gPSBqICsgMiwgb3V0QnVmZmVyW2kgKyAzXSA9IGogKyAwLCBvdXRCdWZmZXJbaSArIDRdID0gaiArIDIsIG91dEJ1ZmZlcltpICsgNV0gPSBqICsgMztcbiAgcmV0dXJuIG91dEJ1ZmZlcjtcbn1cbmV4cG9ydHMuY3JlYXRlSW5kaWNlc0ZvclF1YWRzID0gY3JlYXRlSW5kaWNlc0ZvclF1YWRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlSW5kaWNlc0ZvclF1YWRzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRCdWZmZXJUeXBlKGFycmF5KSB7XG4gIGlmIChhcnJheS5CWVRFU19QRVJfRUxFTUVOVCA9PT0gNClcbiAgICByZXR1cm4gYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgPyBcIkZsb2F0MzJBcnJheVwiIDogYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSA/IFwiVWludDMyQXJyYXlcIiA6IFwiSW50MzJBcnJheVwiO1xuICBpZiAoYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgPT09IDIpIHtcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSlcbiAgICAgIHJldHVybiBcIlVpbnQxNkFycmF5XCI7XG4gIH0gZWxzZSBpZiAoYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgPT09IDEgJiYgYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgIHJldHVybiBcIlVpbnQ4QXJyYXlcIjtcbiAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmdldEJ1ZmZlclR5cGUgPSBnZXRCdWZmZXJUeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0QnVmZmVyVHlwZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGdldEJ1ZmZlclR5cGUgPSByZXF1aXJlKFwiLi9nZXRCdWZmZXJUeXBlLmpzXCIpO1xuY29uc3QgbWFwID0geyBGbG9hdDMyQXJyYXksIFVpbnQzMkFycmF5LCBJbnQzMkFycmF5LCBVaW50OEFycmF5IH07XG5mdW5jdGlvbiBpbnRlcmxlYXZlVHlwZWRBcnJheXMoYXJyYXlzLCBzaXplcykge1xuICBsZXQgb3V0U2l6ZSA9IDAsIHN0cmlkZSA9IDA7XG4gIGNvbnN0IHZpZXdzID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKVxuICAgIHN0cmlkZSArPSBzaXplc1tpXSwgb3V0U2l6ZSArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIob3V0U2l6ZSAqIDQpO1xuICBsZXQgb3V0ID0gbnVsbCwgbGl0dGxlT2Zmc2V0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzaXplID0gc2l6ZXNbaV0sIGFycmF5ID0gYXJyYXlzW2ldLCB0eXBlID0gZ2V0QnVmZmVyVHlwZS5nZXRCdWZmZXJUeXBlKGFycmF5KTtcbiAgICB2aWV3c1t0eXBlXSB8fCAodmlld3NbdHlwZV0gPSBuZXcgbWFwW3R5cGVdKGJ1ZmZlcikpLCBvdXQgPSB2aWV3c1t0eXBlXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBpbmRleFN0YXJ0ID0gKGogLyBzaXplIHwgMCkgKiBzdHJpZGUgKyBsaXR0bGVPZmZzZXQsIGluZGV4ID0gaiAlIHNpemU7XG4gICAgICBvdXRbaW5kZXhTdGFydCArIGluZGV4XSA9IGFycmF5W2pdO1xuICAgIH1cbiAgICBsaXR0bGVPZmZzZXQgKz0gc2l6ZTtcbiAgfVxuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xufVxuZXhwb3J0cy5pbnRlcmxlYXZlVHlwZWRBcnJheXMgPSBpbnRlcmxlYXZlVHlwZWRBcnJheXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmxlYXZlVHlwZWRBcnJheXMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIG5leHRQb3cyKHYpIHtcbiAgcmV0dXJuIHYgKz0gdiA9PT0gMCA/IDEgOiAwLCAtLXYsIHYgfD0gdiA+Pj4gMSwgdiB8PSB2ID4+PiAyLCB2IHw9IHYgPj4+IDQsIHYgfD0gdiA+Pj4gOCwgdiB8PSB2ID4+PiAxNiwgdiArIDE7XG59XG5mdW5jdGlvbiBpc1BvdzIodikge1xuICByZXR1cm4gISh2ICYgdiAtIDEpICYmICEhdjtcbn1cbmZ1bmN0aW9uIGxvZzIodikge1xuICBsZXQgciA9ICh2ID4gNjU1MzUgPyAxIDogMCkgPDwgNDtcbiAgdiA+Pj49IHI7XG4gIGxldCBzaGlmdCA9ICh2ID4gMjU1ID8gMSA6IDApIDw8IDM7XG4gIHJldHVybiB2ID4+Pj0gc2hpZnQsIHIgfD0gc2hpZnQsIHNoaWZ0ID0gKHYgPiAxNSA/IDEgOiAwKSA8PCAyLCB2ID4+Pj0gc2hpZnQsIHIgfD0gc2hpZnQsIHNoaWZ0ID0gKHYgPiAzID8gMSA6IDApIDw8IDEsIHYgPj4+PSBzaGlmdCwgciB8PSBzaGlmdCwgciB8IHYgPj4gMTtcbn1cbmV4cG9ydHMuaXNQb3cyID0gaXNQb3cyO1xuZXhwb3J0cy5sb2cyID0gbG9nMjtcbmV4cG9ydHMubmV4dFBvdzIgPSBuZXh0UG93Mjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvdzIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHJlbW92ZUl0ZW1zKGFyciwgc3RhcnRJZHgsIHJlbW92ZUNvdW50KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIGxldCBpO1xuICBpZiAoc3RhcnRJZHggPj0gbGVuZ3RoIHx8IHJlbW92ZUNvdW50ID09PSAwKVxuICAgIHJldHVybjtcbiAgcmVtb3ZlQ291bnQgPSBzdGFydElkeCArIHJlbW92ZUNvdW50ID4gbGVuZ3RoID8gbGVuZ3RoIC0gc3RhcnRJZHggOiByZW1vdmVDb3VudDtcbiAgY29uc3QgbGVuID0gbGVuZ3RoIC0gcmVtb3ZlQ291bnQ7XG4gIGZvciAoaSA9IHN0YXJ0SWR4OyBpIDwgbGVuOyArK2kpXG4gICAgYXJyW2ldID0gYXJyW2kgKyByZW1vdmVDb3VudF07XG4gIGFyci5sZW5ndGggPSBsZW47XG59XG5leHBvcnRzLnJlbW92ZUl0ZW1zID0gcmVtb3ZlSXRlbXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmVJdGVtcy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gc2lnbihuKSB7XG4gIHJldHVybiBuID09PSAwID8gMCA6IG4gPCAwID8gLTEgOiAxO1xufVxuZXhwb3J0cy5zaWduID0gc2lnbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ24uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmxldCBuZXh0VWlkID0gMDtcbmZ1bmN0aW9uIHVpZCgpIHtcbiAgcmV0dXJuICsrbmV4dFVpZDtcbn1cbmV4cG9ydHMudWlkID0gdWlkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWlkLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5yZXF1aXJlKFwiLi9zZXR0aW5ncy5qc1wiKTtcbnZhciBzZXR0aW5ncyA9IHJlcXVpcmUoXCJAcGl4aS9zZXR0aW5nc1wiKSwgZXZlbnRlbWl0dGVyMyA9IHJlcXVpcmUoXCJldmVudGVtaXR0ZXIzXCIpLCBlYXJjdXQgPSByZXF1aXJlKFwiZWFyY3V0XCIpLCB1cmwgPSByZXF1aXJlKFwiLi91cmwuanNcIiksIHBhdGggPSByZXF1aXJlKFwiLi9wYXRoLmpzXCIpLCBkZXRlY3RWaWRlb0FscGhhTW9kZSA9IHJlcXVpcmUoXCIuL2Jyb3dzZXIvZGV0ZWN0VmlkZW9BbHBoYU1vZGUuanNcIiksIGhlbGxvID0gcmVxdWlyZShcIi4vYnJvd3Nlci9oZWxsby5qc1wiKSwgaXNXZWJHTFN1cHBvcnRlZCA9IHJlcXVpcmUoXCIuL2Jyb3dzZXIvaXNXZWJHTFN1cHBvcnRlZC5qc1wiKSwgaGV4ID0gcmVxdWlyZShcIi4vY29sb3IvaGV4LmpzXCIpLCBwcmVtdWx0aXBseSA9IHJlcXVpcmUoXCIuL2NvbG9yL3ByZW11bHRpcGx5LmpzXCIpLCBfY29uc3QgPSByZXF1aXJlKFwiLi9jb25zdC5qc1wiKSwgY3JlYXRlSW5kaWNlc0ZvclF1YWRzID0gcmVxdWlyZShcIi4vZGF0YS9jcmVhdGVJbmRpY2VzRm9yUXVhZHMuanNcIiksIGdldEJ1ZmZlclR5cGUgPSByZXF1aXJlKFwiLi9kYXRhL2dldEJ1ZmZlclR5cGUuanNcIiksIGludGVybGVhdmVUeXBlZEFycmF5cyA9IHJlcXVpcmUoXCIuL2RhdGEvaW50ZXJsZWF2ZVR5cGVkQXJyYXlzLmpzXCIpLCBwb3cyID0gcmVxdWlyZShcIi4vZGF0YS9wb3cyLmpzXCIpLCByZW1vdmVJdGVtcyA9IHJlcXVpcmUoXCIuL2RhdGEvcmVtb3ZlSXRlbXMuanNcIiksIHNpZ24gPSByZXF1aXJlKFwiLi9kYXRhL3NpZ24uanNcIiksIHVpZCA9IHJlcXVpcmUoXCIuL2RhdGEvdWlkLmpzXCIpLCBkZXByZWNhdGlvbiA9IHJlcXVpcmUoXCIuL2xvZ2dpbmcvZGVwcmVjYXRpb24uanNcIiksIEJvdW5kaW5nQm94ID0gcmVxdWlyZShcIi4vbWVkaWEvQm91bmRpbmdCb3guanNcIiksIGNhY2hlcyA9IHJlcXVpcmUoXCIuL21lZGlhL2NhY2hlcy5qc1wiKSwgQ2FudmFzUmVuZGVyVGFyZ2V0ID0gcmVxdWlyZShcIi4vbWVkaWEvQ2FudmFzUmVuZGVyVGFyZ2V0LmpzXCIpLCBnZXRDYW52YXNCb3VuZGluZ0JveCA9IHJlcXVpcmUoXCIuL21lZGlhL2dldENhbnZhc0JvdW5kaW5nQm94LmpzXCIpLCB0cmltQ2FudmFzID0gcmVxdWlyZShcIi4vbWVkaWEvdHJpbUNhbnZhcy5qc1wiKSwgZGVjb21wb3NlRGF0YVVyaSA9IHJlcXVpcmUoXCIuL25ldHdvcmsvZGVjb21wb3NlRGF0YVVyaS5qc1wiKSwgZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4gPSByZXF1aXJlKFwiLi9uZXR3b3JrL2RldGVybWluZUNyb3NzT3JpZ2luLmpzXCIpLCBnZXRSZXNvbHV0aW9uT2ZVcmwgPSByZXF1aXJlKFwiLi9uZXR3b3JrL2dldFJlc29sdXRpb25PZlVybC5qc1wiKTtcbnJlcXVpcmUoXCIuL3R5cGVzL2luZGV4LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNNb2JpbGVcIiwge1xuICBlbnVtZXJhYmxlOiAhMCxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2V0dGluZ3MuaXNNb2JpbGU7XG4gIH1cbn0pO1xuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBldmVudGVtaXR0ZXIzO1xuZXhwb3J0cy5lYXJjdXQgPSBlYXJjdXQ7XG5leHBvcnRzLnVybCA9IHVybC51cmw7XG5leHBvcnRzLnBhdGggPSBwYXRoLnBhdGg7XG5leHBvcnRzLmRldGVjdFZpZGVvQWxwaGFNb2RlID0gZGV0ZWN0VmlkZW9BbHBoYU1vZGUuZGV0ZWN0VmlkZW9BbHBoYU1vZGU7XG5leHBvcnRzLnNheUhlbGxvID0gaGVsbG8uc2F5SGVsbG87XG5leHBvcnRzLnNraXBIZWxsbyA9IGhlbGxvLnNraXBIZWxsbztcbmV4cG9ydHMuaXNXZWJHTFN1cHBvcnRlZCA9IGlzV2ViR0xTdXBwb3J0ZWQuaXNXZWJHTFN1cHBvcnRlZDtcbmV4cG9ydHMuaGV4MnJnYiA9IGhleC5oZXgycmdiO1xuZXhwb3J0cy5oZXgyc3RyaW5nID0gaGV4LmhleDJzdHJpbmc7XG5leHBvcnRzLnJnYjJoZXggPSBoZXgucmdiMmhleDtcbmV4cG9ydHMuc3RyaW5nMmhleCA9IGhleC5zdHJpbmcyaGV4O1xuZXhwb3J0cy5jb3JyZWN0QmxlbmRNb2RlID0gcHJlbXVsdGlwbHkuY29ycmVjdEJsZW5kTW9kZTtcbmV4cG9ydHMucHJlbXVsdGlwbHlCbGVuZE1vZGUgPSBwcmVtdWx0aXBseS5wcmVtdWx0aXBseUJsZW5kTW9kZTtcbmV4cG9ydHMucHJlbXVsdGlwbHlSZ2JhID0gcHJlbXVsdGlwbHkucHJlbXVsdGlwbHlSZ2JhO1xuZXhwb3J0cy5wcmVtdWx0aXBseVRpbnQgPSBwcmVtdWx0aXBseS5wcmVtdWx0aXBseVRpbnQ7XG5leHBvcnRzLnByZW11bHRpcGx5VGludFRvUmdiYSA9IHByZW11bHRpcGx5LnByZW11bHRpcGx5VGludFRvUmdiYTtcbmV4cG9ydHMuREFUQV9VUkkgPSBfY29uc3QuREFUQV9VUkk7XG5leHBvcnRzLmNyZWF0ZUluZGljZXNGb3JRdWFkcyA9IGNyZWF0ZUluZGljZXNGb3JRdWFkcy5jcmVhdGVJbmRpY2VzRm9yUXVhZHM7XG5leHBvcnRzLmdldEJ1ZmZlclR5cGUgPSBnZXRCdWZmZXJUeXBlLmdldEJ1ZmZlclR5cGU7XG5leHBvcnRzLmludGVybGVhdmVUeXBlZEFycmF5cyA9IGludGVybGVhdmVUeXBlZEFycmF5cy5pbnRlcmxlYXZlVHlwZWRBcnJheXM7XG5leHBvcnRzLmlzUG93MiA9IHBvdzIuaXNQb3cyO1xuZXhwb3J0cy5sb2cyID0gcG93Mi5sb2cyO1xuZXhwb3J0cy5uZXh0UG93MiA9IHBvdzIubmV4dFBvdzI7XG5leHBvcnRzLnJlbW92ZUl0ZW1zID0gcmVtb3ZlSXRlbXMucmVtb3ZlSXRlbXM7XG5leHBvcnRzLnNpZ24gPSBzaWduLnNpZ247XG5leHBvcnRzLnVpZCA9IHVpZC51aWQ7XG5leHBvcnRzLmRlcHJlY2F0aW9uID0gZGVwcmVjYXRpb24uZGVwcmVjYXRpb247XG5leHBvcnRzLkJvdW5kaW5nQm94ID0gQm91bmRpbmdCb3guQm91bmRpbmdCb3g7XG5leHBvcnRzLkJhc2VUZXh0dXJlQ2FjaGUgPSBjYWNoZXMuQmFzZVRleHR1cmVDYWNoZTtcbmV4cG9ydHMuUHJvZ3JhbUNhY2hlID0gY2FjaGVzLlByb2dyYW1DYWNoZTtcbmV4cG9ydHMuVGV4dHVyZUNhY2hlID0gY2FjaGVzLlRleHR1cmVDYWNoZTtcbmV4cG9ydHMuY2xlYXJUZXh0dXJlQ2FjaGUgPSBjYWNoZXMuY2xlYXJUZXh0dXJlQ2FjaGU7XG5leHBvcnRzLmRlc3Ryb3lUZXh0dXJlQ2FjaGUgPSBjYWNoZXMuZGVzdHJveVRleHR1cmVDYWNoZTtcbmV4cG9ydHMuQ2FudmFzUmVuZGVyVGFyZ2V0ID0gQ2FudmFzUmVuZGVyVGFyZ2V0LkNhbnZhc1JlbmRlclRhcmdldDtcbmV4cG9ydHMuZ2V0Q2FudmFzQm91bmRpbmdCb3ggPSBnZXRDYW52YXNCb3VuZGluZ0JveC5nZXRDYW52YXNCb3VuZGluZ0JveDtcbmV4cG9ydHMudHJpbUNhbnZhcyA9IHRyaW1DYW52YXMudHJpbUNhbnZhcztcbmV4cG9ydHMuZGVjb21wb3NlRGF0YVVyaSA9IGRlY29tcG9zZURhdGFVcmkuZGVjb21wb3NlRGF0YVVyaTtcbmV4cG9ydHMuZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4gPSBkZXRlcm1pbmVDcm9zc09yaWdpbi5kZXRlcm1pbmVDcm9zc09yaWdpbjtcbmV4cG9ydHMuZ2V0UmVzb2x1dGlvbk9mVXJsID0gZ2V0UmVzb2x1dGlvbk9mVXJsLmdldFJlc29sdXRpb25PZlVybDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB3YXJuaW5ncyA9IHt9O1xuZnVuY3Rpb24gZGVwcmVjYXRpb24odmVyc2lvbiwgbWVzc2FnZSwgaWdub3JlRGVwdGggPSAzKSB7XG4gIGlmICh3YXJuaW5nc1ttZXNzYWdlXSlcbiAgICByZXR1cm47XG4gIGxldCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICB0eXBlb2Ygc3RhY2sgPiBcInVcIiA/IGNvbnNvbGUud2FybihcIlBpeGlKUyBEZXByZWNhdGlvbiBXYXJuaW5nOiBcIiwgYCR7bWVzc2FnZX1cbkRlcHJlY2F0ZWQgc2luY2UgdiR7dmVyc2lvbn1gKSA6IChzdGFjayA9IHN0YWNrLnNwbGl0KGBcbmApLnNwbGljZShpZ25vcmVEZXB0aCkuam9pbihgXG5gKSwgY29uc29sZS5ncm91cENvbGxhcHNlZCA/IChjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFxuICAgIFwiJWNQaXhpSlMgRGVwcmVjYXRpb24gV2FybmluZzogJWMlc1wiLFxuICAgIFwiY29sb3I6IzYxNDEwODtiYWNrZ3JvdW5kOiNmZmZiZTZcIixcbiAgICBcImZvbnQtd2VpZ2h0Om5vcm1hbDtjb2xvcjojNjE0MTA4O2JhY2tncm91bmQ6I2ZmZmJlNlwiLFxuICAgIGAke21lc3NhZ2V9XG5EZXByZWNhdGVkIHNpbmNlIHYke3ZlcnNpb259YFxuICApLCBjb25zb2xlLndhcm4oc3RhY2spLCBjb25zb2xlLmdyb3VwRW5kKCkpIDogKGNvbnNvbGUud2FybihcIlBpeGlKUyBEZXByZWNhdGlvbiBXYXJuaW5nOiBcIiwgYCR7bWVzc2FnZX1cbkRlcHJlY2F0ZWQgc2luY2UgdiR7dmVyc2lvbn1gKSwgY29uc29sZS53YXJuKHN0YWNrKSkpLCB3YXJuaW5nc1ttZXNzYWdlXSA9ICEwO1xufVxuZXhwb3J0cy5kZXByZWNhdGlvbiA9IGRlcHJlY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwcmVjYXRpb24uanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9Cb3VuZGluZ0JveCA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBsZWZ0IC0gVGhlIGxlZnQgY29vcmRpbmF0ZSB2YWx1ZSBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgKiBAcGFyYW0gdG9wIC0gVGhlIHRvcCBjb29yZGluYXRlIHZhbHVlIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAqIEBwYXJhbSByaWdodCAtIFRoZSByaWdodCBjb29yZGluYXRlIHZhbHVlIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAqIEBwYXJhbSBib3R0b20gLSBUaGUgYm90dG9tIGNvb3JkaW5hdGUgdmFsdWUgb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xuICAgIHRoaXMubGVmdCA9IGxlZnQsIHRoaXMudG9wID0gdG9wLCB0aGlzLnJpZ2h0ID0gcmlnaHQsIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICB9XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIGJvdW5kaW5nIGJveC4gKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0O1xuICB9XG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyBib3guICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tIC0gdGhpcy50b3A7XG4gIH1cbiAgLyoqIERldGVybWluZXMgd2hldGhlciB0aGUgQm91bmRpbmdCb3ggaXMgZW1wdHkuICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVmdCA9PT0gdGhpcy5yaWdodCB8fCB0aGlzLnRvcCA9PT0gdGhpcy5ib3R0b207XG4gIH1cbn07XG5fQm91bmRpbmdCb3guRU1QVFkgPSBuZXcgX0JvdW5kaW5nQm94KDAsIDAsIDAsIDApO1xubGV0IEJvdW5kaW5nQm94ID0gX0JvdW5kaW5nQm94O1xuZXhwb3J0cy5Cb3VuZGluZ0JveCA9IEJvdW5kaW5nQm94O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm91bmRpbmdCb3guanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBzZXR0aW5ncyA9IHJlcXVpcmUoXCJAcGl4aS9zZXR0aW5nc1wiKTtcbmNsYXNzIENhbnZhc1JlbmRlclRhcmdldCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gd2lkdGggLSB0aGUgd2lkdGggZm9yIHRoZSBuZXdseSBjcmVhdGVkIGNhbnZhc1xuICAgKiBAcGFyYW0gaGVpZ2h0IC0gdGhlIGhlaWdodCBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgY2FudmFzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzb2x1dGlvbj1QSVhJLnNldHRpbmdzLlJFU09MVVRJT05dIC0gVGhlIHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIGNhbnZhc1xuICAgKi9cbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbikge1xuICAgIHRoaXMuX2NhbnZhcyA9IHNldHRpbmdzLnNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCksIHRoaXMuX2NvbnRleHQgPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLCB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IHNldHRpbmdzLnNldHRpbmdzLlJFU09MVVRJT04sIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGNhbnZhcyB0aGF0IHdhcyBjcmVhdGVkIGJ5IHRoZSBDYW52YXNSZW5kZXJUYXJnZXQgY2xhc3MuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLl9jaGVja0Rlc3Ryb3llZCgpLCB0aGlzLl9jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKSwgdGhpcy5fY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplcyB0aGUgY2FudmFzIHRvIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodC5cbiAgICogQHBhcmFtIGRlc2lyZWRXaWR0aCAtIHRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBjYW52YXNcbiAgICogQHBhcmFtIGRlc2lyZWRIZWlnaHQgLSB0aGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIGNhbnZhc1xuICAgKi9cbiAgcmVzaXplKGRlc2lyZWRXaWR0aCwgZGVzaXJlZEhlaWdodCkge1xuICAgIHRoaXMuX2NoZWNrRGVzdHJveWVkKCksIHRoaXMuX2NhbnZhcy53aWR0aCA9IE1hdGgucm91bmQoZGVzaXJlZFdpZHRoICogdGhpcy5yZXNvbHV0aW9uKSwgdGhpcy5fY2FudmFzLmhlaWdodCA9IE1hdGgucm91bmQoZGVzaXJlZEhlaWdodCAqIHRoaXMucmVzb2x1dGlvbik7XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoaXMgY2FudmFzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsLCB0aGlzLl9jYW52YXMgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGhlIGNhbnZhcyBidWZmZXIgaW4gcGl4ZWxzLlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrRGVzdHJveWVkKCksIHRoaXMuX2NhbnZhcy53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsKSB7XG4gICAgdGhpcy5fY2hlY2tEZXN0cm95ZWQoKSwgdGhpcy5fY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZCh2YWwpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgYnVmZmVyIGluIHBpeGVscy5cbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tEZXN0cm95ZWQoKSwgdGhpcy5fY2FudmFzLmhlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbCkge1xuICAgIHRoaXMuX2NoZWNrRGVzdHJveWVkKCksIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBNYXRoLnJvdW5kKHZhbCk7XG4gIH1cbiAgLyoqIFRoZSBDYW52YXMgb2JqZWN0IHRoYXQgYmVsb25ncyB0byB0aGlzIENhbnZhc1JlbmRlclRhcmdldC4gKi9cbiAgZ2V0IGNhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tEZXN0cm95ZWQoKSwgdGhpcy5fY2FudmFzO1xuICB9XG4gIC8qKiBBIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBvYmplY3QgcmVwcmVzZW50aW5nIGEgdHdvLWRpbWVuc2lvbmFsIHJlbmRlcmluZyBjb250ZXh0LiAqL1xuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tEZXN0cm95ZWQoKSwgdGhpcy5fY29udGV4dDtcbiAgfVxuICBfY2hlY2tEZXN0cm95ZWQoKSB7XG4gICAgaWYgKHRoaXMuX2NhbnZhcyA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgQ2FudmFzUmVuZGVyVGFyZ2V0IGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkXCIpO1xuICB9XG59XG5leHBvcnRzLkNhbnZhc1JlbmRlclRhcmdldCA9IENhbnZhc1JlbmRlclRhcmdldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc1JlbmRlclRhcmdldC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgUHJvZ3JhbUNhY2hlID0ge30sIFRleHR1cmVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCBCYXNlVGV4dHVyZUNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBkZXN0cm95VGV4dHVyZUNhY2hlKCkge1xuICBsZXQga2V5O1xuICBmb3IgKGtleSBpbiBUZXh0dXJlQ2FjaGUpXG4gICAgVGV4dHVyZUNhY2hlW2tleV0uZGVzdHJveSgpO1xuICBmb3IgKGtleSBpbiBCYXNlVGV4dHVyZUNhY2hlKVxuICAgIEJhc2VUZXh0dXJlQ2FjaGVba2V5XS5kZXN0cm95KCk7XG59XG5mdW5jdGlvbiBjbGVhclRleHR1cmVDYWNoZSgpIHtcbiAgbGV0IGtleTtcbiAgZm9yIChrZXkgaW4gVGV4dHVyZUNhY2hlKVxuICAgIGRlbGV0ZSBUZXh0dXJlQ2FjaGVba2V5XTtcbiAgZm9yIChrZXkgaW4gQmFzZVRleHR1cmVDYWNoZSlcbiAgICBkZWxldGUgQmFzZVRleHR1cmVDYWNoZVtrZXldO1xufVxuZXhwb3J0cy5CYXNlVGV4dHVyZUNhY2hlID0gQmFzZVRleHR1cmVDYWNoZTtcbmV4cG9ydHMuUHJvZ3JhbUNhY2hlID0gUHJvZ3JhbUNhY2hlO1xuZXhwb3J0cy5UZXh0dXJlQ2FjaGUgPSBUZXh0dXJlQ2FjaGU7XG5leHBvcnRzLmNsZWFyVGV4dHVyZUNhY2hlID0gY2xlYXJUZXh0dXJlQ2FjaGU7XG5leHBvcnRzLmRlc3Ryb3lUZXh0dXJlQ2FjaGUgPSBkZXN0cm95VGV4dHVyZUNhY2hlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FjaGVzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQm91bmRpbmdCb3ggPSByZXF1aXJlKFwiLi9Cb3VuZGluZ0JveC5qc1wiKTtcbmZ1bmN0aW9uIGNoZWNrUm93KGRhdGEsIHdpZHRoLCB5KSB7XG4gIGZvciAobGV0IHggPSAwLCBpbmRleCA9IDQgKiB5ICogd2lkdGg7IHggPCB3aWR0aDsgKyt4LCBpbmRleCArPSA0KVxuICAgIGlmIChkYXRhW2luZGV4ICsgM10gIT09IDApXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGNoZWNrQ29sdW1uKGRhdGEsIHdpZHRoLCB4LCB0b3AsIGJvdHRvbSkge1xuICBjb25zdCBzdHJpZGUgPSA0ICogd2lkdGg7XG4gIGZvciAobGV0IHkgPSB0b3AsIGluZGV4ID0gdG9wICogc3RyaWRlICsgNCAqIHg7IHkgPD0gYm90dG9tOyArK3ksIGluZGV4ICs9IHN0cmlkZSlcbiAgICBpZiAoZGF0YVtpbmRleCArIDNdICE9PSAwKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBnZXRDYW52YXNCb3VuZGluZ0JveChjYW52YXMpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjYW52YXMsIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICEwXG4gIH0pO1xuICBpZiAoY29udGV4dCA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGdldCBjYW52YXMgMkQgY29udGV4dFwiKTtcbiAgY29uc3QgZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gIGxldCBsZWZ0ID0gMCwgdG9wID0gMCwgcmlnaHQgPSB3aWR0aCAtIDEsIGJvdHRvbSA9IGhlaWdodCAtIDE7XG4gIGZvciAoOyB0b3AgPCBoZWlnaHQgJiYgY2hlY2tSb3coZGF0YSwgd2lkdGgsIHRvcCk7IClcbiAgICArK3RvcDtcbiAgaWYgKHRvcCA9PT0gaGVpZ2h0KVxuICAgIHJldHVybiBCb3VuZGluZ0JveC5Cb3VuZGluZ0JveC5FTVBUWTtcbiAgZm9yICg7IGNoZWNrUm93KGRhdGEsIHdpZHRoLCBib3R0b20pOyApXG4gICAgLS1ib3R0b207XG4gIGZvciAoOyBjaGVja0NvbHVtbihkYXRhLCB3aWR0aCwgbGVmdCwgdG9wLCBib3R0b20pOyApXG4gICAgKytsZWZ0O1xuICBmb3IgKDsgY2hlY2tDb2x1bW4oZGF0YSwgd2lkdGgsIHJpZ2h0LCB0b3AsIGJvdHRvbSk7IClcbiAgICAtLXJpZ2h0O1xuICByZXR1cm4gKytyaWdodCwgKytib3R0b20sIG5ldyBCb3VuZGluZ0JveC5Cb3VuZGluZ0JveChsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pO1xufVxuZXhwb3J0cy5nZXRDYW52YXNCb3VuZGluZ0JveCA9IGdldENhbnZhc0JvdW5kaW5nQm94O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0Q2FudmFzQm91bmRpbmdCb3guanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBnZXRDYW52YXNCb3VuZGluZ0JveCA9IHJlcXVpcmUoXCIuL2dldENhbnZhc0JvdW5kaW5nQm94LmpzXCIpO1xuZnVuY3Rpb24gdHJpbUNhbnZhcyhjYW52YXMpIHtcbiAgY29uc3QgYm91bmRpbmdCb3ggPSBnZXRDYW52YXNCb3VuZGluZ0JveC5nZXRDYW52YXNCb3VuZGluZ0JveChjYW52YXMpLCB7IHdpZHRoLCBoZWlnaHQgfSA9IGJvdW5kaW5nQm94O1xuICBsZXQgZGF0YSA9IG51bGw7XG4gIGlmICghYm91bmRpbmdCb3guaXNFbXB0eSgpKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGdldCBjYW52YXMgMkQgY29udGV4dFwiKTtcbiAgICBkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoXG4gICAgICBib3VuZGluZ0JveC5sZWZ0LFxuICAgICAgYm91bmRpbmdCb3gudG9wLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICApO1xuICB9XG4gIHJldHVybiB7IHdpZHRoLCBoZWlnaHQsIGRhdGEgfTtcbn1cbmV4cG9ydHMudHJpbUNhbnZhcyA9IHRyaW1DYW52YXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmltQ2FudmFzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2NvbnN0ID0gcmVxdWlyZShcIi4uL2NvbnN0LmpzXCIpO1xuZnVuY3Rpb24gZGVjb21wb3NlRGF0YVVyaShkYXRhVXJpKSB7XG4gIGNvbnN0IGRhdGFVcmlNYXRjaCA9IF9jb25zdC5EQVRBX1VSSS5leGVjKGRhdGFVcmkpO1xuICBpZiAoZGF0YVVyaU1hdGNoKVxuICAgIHJldHVybiB7XG4gICAgICBtZWRpYVR5cGU6IGRhdGFVcmlNYXRjaFsxXSA/IGRhdGFVcmlNYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogdm9pZCAwLFxuICAgICAgc3ViVHlwZTogZGF0YVVyaU1hdGNoWzJdID8gZGF0YVVyaU1hdGNoWzJdLnRvTG93ZXJDYXNlKCkgOiB2b2lkIDAsXG4gICAgICBjaGFyc2V0OiBkYXRhVXJpTWF0Y2hbM10gPyBkYXRhVXJpTWF0Y2hbM10udG9Mb3dlckNhc2UoKSA6IHZvaWQgMCxcbiAgICAgIGVuY29kaW5nOiBkYXRhVXJpTWF0Y2hbNF0gPyBkYXRhVXJpTWF0Y2hbNF0udG9Mb3dlckNhc2UoKSA6IHZvaWQgMCxcbiAgICAgIGRhdGE6IGRhdGFVcmlNYXRjaFs1XVxuICAgIH07XG59XG5leHBvcnRzLmRlY29tcG9zZURhdGFVcmkgPSBkZWNvbXBvc2VEYXRhVXJpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb21wb3NlRGF0YVVyaS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4odXJsLCBsb2MgPSBnbG9iYWxUaGlzLmxvY2F0aW9uKSB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aChcImRhdGE6XCIpKVxuICAgIHJldHVybiBcIlwiO1xuICBsb2MgPSBsb2MgfHwgZ2xvYmFsVGhpcy5sb2NhdGlvbjtcbiAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwsIGRvY3VtZW50LmJhc2VVUkkpO1xuICByZXR1cm4gcGFyc2VkVXJsLmhvc3RuYW1lICE9PSBsb2MuaG9zdG5hbWUgfHwgcGFyc2VkVXJsLnBvcnQgIT09IGxvYy5wb3J0IHx8IHBhcnNlZFVybC5wcm90b2NvbCAhPT0gbG9jLnByb3RvY29sID8gXCJhbm9ueW1vdXNcIiA6IFwiXCI7XG59XG5leHBvcnRzLmRldGVybWluZUNyb3NzT3JpZ2luID0gZGV0ZXJtaW5lQ3Jvc3NPcmlnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlcm1pbmVDcm9zc09yaWdpbi5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xucmVxdWlyZShcIi4uL3NldHRpbmdzLmpzXCIpO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZShcIkBwaXhpL3NldHRpbmdzXCIpO1xuZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbk9mVXJsKHVybCwgZGVmYXVsdFZhbHVlID0gMSkge1xuICBjb25zdCByZXNvbHV0aW9uID0gc2V0dGluZ3Muc2V0dGluZ3MuUkVUSU5BX1BSRUZJWD8uZXhlYyh1cmwpO1xuICByZXR1cm4gcmVzb2x1dGlvbiA/IHBhcnNlRmxvYXQocmVzb2x1dGlvblsxXSkgOiBkZWZhdWx0VmFsdWU7XG59XG5leHBvcnRzLmdldFJlc29sdXRpb25PZlVybCA9IGdldFJlc29sdXRpb25PZlVybDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFJlc29sdXRpb25PZlVybC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZShcIkBwaXhpL3NldHRpbmdzXCIpO1xuZnVuY3Rpb24gYXNzZXJ0UGF0aChwYXRoMikge1xuICBpZiAodHlwZW9mIHBhdGgyICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHBhdGgyKX1gKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVVybFBhcmFtcyh1cmwpIHtcbiAgcmV0dXJuIHVybC5zcGxpdChcIj9cIilbMF0uc3BsaXQoXCIjXCIpWzBdO1xufVxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VBbGwoc3RyLCBmaW5kLCByZXBsYWNlKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChmaW5kKSwgXCJnXCIpLCByZXBsYWNlKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgyLCBhbGxvd0Fib3ZlUm9vdCkge1xuICBsZXQgcmVzID0gXCJcIiwgbGFzdFNlZ21lbnRMZW5ndGggPSAwLCBsYXN0U2xhc2ggPSAtMSwgZG90cyA9IDAsIGNvZGUgPSAtMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcGF0aDIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaSA8IHBhdGgyLmxlbmd0aClcbiAgICAgIGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KGkpO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKGNvZGUgPT09IDQ3KVxuICAgICAgICBicmVhaztcbiAgICAgIGNvZGUgPSA0NztcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICBpZiAoIShsYXN0U2xhc2ggPT09IGkgLSAxIHx8IGRvdHMgPT09IDEpKVxuICAgICAgICBpZiAobGFzdFNsYXNoICE9PSBpIC0gMSAmJiBkb3RzID09PSAyKSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPCAyIHx8IGxhc3RTZWdtZW50TGVuZ3RoICE9PSAyIHx8IHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAxKSAhPT0gNDYgfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDIpICE9PSA0Nikge1xuICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RTbGFzaEluZGV4ID0gcmVzLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ICE9PSByZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGxhc3RTbGFzaEluZGV4ID09PSAtMSA/IChyZXMgPSBcIlwiLCBsYXN0U2VnbWVudExlbmd0aCA9IDApIDogKHJlcyA9IHJlcy5zbGljZSgwLCBsYXN0U2xhc2hJbmRleCksIGxhc3RTZWdtZW50TGVuZ3RoID0gcmVzLmxlbmd0aCAtIDEgLSByZXMubGFzdEluZGV4T2YoXCIvXCIpKSwgbGFzdFNsYXNoID0gaSwgZG90cyA9IDA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzLmxlbmd0aCA9PT0gMiB8fCByZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIHJlcyA9IFwiXCIsIGxhc3RTZWdtZW50TGVuZ3RoID0gMCwgbGFzdFNsYXNoID0gaSwgZG90cyA9IDA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhbGxvd0Fib3ZlUm9vdCAmJiAocmVzLmxlbmd0aCA+IDAgPyByZXMgKz0gXCIvLi5cIiA6IHJlcyA9IFwiLi5cIiwgbGFzdFNlZ21lbnRMZW5ndGggPSAyKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgcmVzLmxlbmd0aCA+IDAgPyByZXMgKz0gYC8ke3BhdGgyLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpfWAgOiByZXMgPSBwYXRoMi5zbGljZShsYXN0U2xhc2ggKyAxLCBpKSwgbGFzdFNlZ21lbnRMZW5ndGggPSBpIC0gbGFzdFNsYXNoIC0gMTtcbiAgICAgIGxhc3RTbGFzaCA9IGksIGRvdHMgPSAwO1xuICAgIH0gZWxzZVxuICAgICAgY29kZSA9PT0gNDYgJiYgZG90cyAhPT0gLTEgPyArK2RvdHMgOiBkb3RzID0gLTE7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmNvbnN0IHBhdGggPSB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHBhdGggdG8gcG9zaXggZm9ybWF0LlxuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIGNvbnZlcnQgdG8gcG9zaXhcbiAgICovXG4gIHRvUG9zaXgocGF0aDIpIHtcbiAgICByZXR1cm4gcmVwbGFjZUFsbChwYXRoMiwgXCJcXFxcXCIsIFwiL1wiKTtcbiAgfSxcbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcGF0aCBpcyBhIFVSTCBlLmcuIGh0dHA6Ly8sIGh0dHBzOi8vXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gY2hlY2tcbiAgICovXG4gIGlzVXJsKHBhdGgyKSB7XG4gICAgcmV0dXJuIC9eaHR0cHM/Oi8udGVzdCh0aGlzLnRvUG9zaXgocGF0aDIpKTtcbiAgfSxcbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcGF0aCBpcyBhIGRhdGEgVVJMXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gY2hlY2tcbiAgICovXG4gIGlzRGF0YVVybChwYXRoMikge1xuICAgIHJldHVybiAvXmRhdGE6KFthLXpdK1xcL1thLXowLTktKy5dKyg7W2EtejAtOS0uISMkJSorLnt9fH5gXSs9W2EtejAtOS0uISMkJSorLnt9KClffH5gXSspKik/KDtiYXNlNjQpPywoW2EtejAtOSEkJicsKCkqKzs9XFwtLl9+OkBcXC8/JVxcczw+XSo/KSQvaS50ZXN0KHBhdGgyKTtcbiAgfSxcbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcGF0aCBpcyBhIGJsb2IgVVJMXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gY2hlY2tcbiAgICovXG4gIGlzQmxvYlVybChwYXRoMikge1xuICAgIHJldHVybiBwYXRoMi5zdGFydHNXaXRoKFwiYmxvYjpcIik7XG4gIH0sXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHBhdGggaGFzIGEgcHJvdG9jb2wgZS5nLiBodHRwOi8vLCBodHRwczovLywgZmlsZTovLy8sIGRhdGE6LCBibG9iOiwgQzovXG4gICAqIFRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBmb3Igd2luZG93cyBmaWxlIHBhdGhzXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gY2hlY2tcbiAgICovXG4gIGhhc1Byb3RvY29sKHBhdGgyKSB7XG4gICAgcmV0dXJuIC9eW14vOl0rOi8udGVzdCh0aGlzLnRvUG9zaXgocGF0aDIpKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb3RvY29sIG9mIHRoZSBwYXRoIGUuZy4gaHR0cDovLywgaHR0cHM6Ly8sIGZpbGU6Ly8vLCBkYXRhOiwgYmxvYjosIEM6L1xuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIGdldCB0aGUgcHJvdG9jb2wgZnJvbVxuICAgKi9cbiAgZ2V0UHJvdG9jb2wocGF0aDIpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKSwgcGF0aDIgPSB0aGlzLnRvUG9zaXgocGF0aDIpO1xuICAgIGNvbnN0IG1hdGNoRmlsZSA9IC9eZmlsZTpcXC9cXC9cXC8vLmV4ZWMocGF0aDIpO1xuICAgIGlmIChtYXRjaEZpbGUpXG4gICAgICByZXR1cm4gbWF0Y2hGaWxlWzBdO1xuICAgIGNvbnN0IG1hdGNoUHJvdG9jb2wgPSAvXlteLzpdKzpcXC97MCwyfS8uZXhlYyhwYXRoMik7XG4gICAgcmV0dXJuIG1hdGNoUHJvdG9jb2wgPyBtYXRjaFByb3RvY29sWzBdIDogXCJcIjtcbiAgfSxcbiAgLyoqXG4gICAqIENvbnZlcnRzIFVSTCB0byBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgKiBXaGVuIGxvYWRpbmcgZnJvbSBhIFdlYiBXb3JrZXIsIHdlIG11c3QgdXNlIGFic29sdXRlIHBhdGhzLlxuICAgKiBJZiB0aGUgVVJMIGlzIGFscmVhZHkgYWJzb2x1dGUgd2UgcmV0dXJuIGl0IGFzIGlzXG4gICAqIElmIGl0J3Mgbm90LCB3ZSBjb252ZXJ0IGl0XG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIHRlc3RcbiAgICogQHBhcmFtIGN1c3RvbUJhc2VVcmwgLSBUaGUgYmFzZSBVUkwgdG8gdXNlXG4gICAqIEBwYXJhbSBjdXN0b21Sb290VXJsIC0gVGhlIHJvb3QgVVJMIHRvIHVzZVxuICAgKi9cbiAgdG9BYnNvbHV0ZSh1cmwsIGN1c3RvbUJhc2VVcmwsIGN1c3RvbVJvb3RVcmwpIHtcbiAgICBpZiAoYXNzZXJ0UGF0aCh1cmwpLCB0aGlzLmlzRGF0YVVybCh1cmwpIHx8IHRoaXMuaXNCbG9iVXJsKHVybCkpXG4gICAgICByZXR1cm4gdXJsO1xuICAgIGNvbnN0IGJhc2VVcmwgPSByZW1vdmVVcmxQYXJhbXModGhpcy50b1Bvc2l4KGN1c3RvbUJhc2VVcmwgPz8gc2V0dGluZ3Muc2V0dGluZ3MuQURBUFRFUi5nZXRCYXNlVXJsKCkpKSwgcm9vdFVybCA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgoY3VzdG9tUm9vdFVybCA/PyB0aGlzLnJvb3RuYW1lKGJhc2VVcmwpKSk7XG4gICAgcmV0dXJuIHVybCA9IHRoaXMudG9Qb3NpeCh1cmwpLCB1cmwuc3RhcnRzV2l0aChcIi9cIikgPyBwYXRoLmpvaW4ocm9vdFVybCwgdXJsLnNsaWNlKDEpKSA6IHRoaXMuaXNBYnNvbHV0ZSh1cmwpID8gdXJsIDogdGhpcy5qb2luKGJhc2VVcmwsIHVybCk7XG4gIH0sXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIHRoZSBnaXZlbiBwYXRoLCByZXNvbHZpbmcgJy4uJyBhbmQgJy4nIHNlZ21lbnRzXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gbm9ybWFsaXplXG4gICAqL1xuICBub3JtYWxpemUocGF0aDIpIHtcbiAgICBpZiAoYXNzZXJ0UGF0aChwYXRoMiksIHBhdGgyLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBcIi5cIjtcbiAgICBpZiAodGhpcy5pc0RhdGFVcmwocGF0aDIpIHx8IHRoaXMuaXNCbG9iVXJsKHBhdGgyKSlcbiAgICAgIHJldHVybiBwYXRoMjtcbiAgICBwYXRoMiA9IHRoaXMudG9Qb3NpeChwYXRoMik7XG4gICAgbGV0IHByb3RvY29sID0gXCJcIjtcbiAgICBjb25zdCBpc0Fic29sdXRlID0gcGF0aDIuc3RhcnRzV2l0aChcIi9cIik7XG4gICAgdGhpcy5oYXNQcm90b2NvbChwYXRoMikgJiYgKHByb3RvY29sID0gdGhpcy5yb290bmFtZShwYXRoMiksIHBhdGgyID0gcGF0aDIuc2xpY2UocHJvdG9jb2wubGVuZ3RoKSk7XG4gICAgY29uc3QgdHJhaWxpbmdTZXBhcmF0b3IgPSBwYXRoMi5lbmRzV2l0aChcIi9cIik7XG4gICAgcmV0dXJuIHBhdGgyID0gbm9ybWFsaXplU3RyaW5nUG9zaXgocGF0aDIsICExKSwgcGF0aDIubGVuZ3RoID4gMCAmJiB0cmFpbGluZ1NlcGFyYXRvciAmJiAocGF0aDIgKz0gXCIvXCIpLCBpc0Fic29sdXRlID8gYC8ke3BhdGgyfWAgOiBwcm90b2NvbCArIHBhdGgyO1xuICB9LFxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBwYXRoIGlzIGFuIGFic29sdXRlIHBhdGguXG4gICAqIEFic29sdXRlIHBhdGhzIGNhbiBiZSB1cmxzLCBkYXRhIHVybHMsIG9yIHBhdGhzIG9uIGRpc2tcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byB0ZXN0XG4gICAqL1xuICBpc0Fic29sdXRlKHBhdGgyKSB7XG4gICAgcmV0dXJuIGFzc2VydFBhdGgocGF0aDIpLCBwYXRoMiA9IHRoaXMudG9Qb3NpeChwYXRoMiksIHRoaXMuaGFzUHJvdG9jb2wocGF0aDIpID8gITAgOiBwYXRoMi5zdGFydHNXaXRoKFwiL1wiKTtcbiAgfSxcbiAgLyoqXG4gICAqIEpvaW5zIGFsbCBnaXZlbiBwYXRoIHNlZ21lbnRzIHRvZ2V0aGVyIHVzaW5nIHRoZSBwbGF0Zm9ybS1zcGVjaWZpYyBzZXBhcmF0b3IgYXMgYSBkZWxpbWl0ZXIsXG4gICAqIHRoZW4gbm9ybWFsaXplcyB0aGUgcmVzdWx0aW5nIHBhdGhcbiAgICogQHBhcmFtIHNlZ21lbnRzIC0gVGhlIHNlZ21lbnRzIG9mIHRoZSBwYXRoIHRvIGpvaW5cbiAgICovXG4gIGpvaW4oLi4uc2VnbWVudHMpIHtcbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFwiLlwiO1xuICAgIGxldCBqb2luZWQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgYXJnID0gc2VnbWVudHNbaV07XG4gICAgICBpZiAoYXNzZXJ0UGF0aChhcmcpLCBhcmcubGVuZ3RoID4gMClcbiAgICAgICAgaWYgKGpvaW5lZCA9PT0gdm9pZCAwKVxuICAgICAgICAgIGpvaW5lZCA9IGFyZztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgcHJldkFyZyA9IHNlZ21lbnRzW2kgLSAxXSA/PyBcIlwiO1xuICAgICAgICAgIHRoaXMuZXh0bmFtZShwcmV2QXJnKSA/IGpvaW5lZCArPSBgLy4uLyR7YXJnfWAgOiBqb2luZWQgKz0gYC8ke2FyZ31gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqb2luZWQgPT09IHZvaWQgMCA/IFwiLlwiIDogdGhpcy5ub3JtYWxpemUoam9pbmVkKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpcmVjdG9yeSBuYW1lIG9mIGEgcGF0aFxuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHBhcnNlXG4gICAqL1xuICBkaXJuYW1lKHBhdGgyKSB7XG4gICAgaWYgKGFzc2VydFBhdGgocGF0aDIpLCBwYXRoMi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gXCIuXCI7XG4gICAgcGF0aDIgPSB0aGlzLnRvUG9zaXgocGF0aDIpO1xuICAgIGxldCBjb2RlID0gcGF0aDIuY2hhckNvZGVBdCgwKTtcbiAgICBjb25zdCBoYXNSb290ID0gY29kZSA9PT0gNDc7XG4gICAgbGV0IGVuZCA9IC0xLCBtYXRjaGVkU2xhc2ggPSAhMDtcbiAgICBjb25zdCBwcm90byA9IHRoaXMuZ2V0UHJvdG9jb2wocGF0aDIpLCBvcmlncGF0aCA9IHBhdGgyO1xuICAgIHBhdGgyID0gcGF0aDIuc2xpY2UocHJvdG8ubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gcGF0aDIubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpXG4gICAgICBpZiAoY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSksIGNvZGUgPT09IDQ3KSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9ICExO1xuICAgIHJldHVybiBlbmQgPT09IC0xID8gaGFzUm9vdCA/IFwiL1wiIDogdGhpcy5pc1VybChvcmlncGF0aCkgPyBwcm90byArIHBhdGgyIDogcHJvdG8gOiBoYXNSb290ICYmIGVuZCA9PT0gMSA/IFwiLy9cIiA6IHByb3RvICsgcGF0aDIuc2xpY2UoMCwgZW5kKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb3Qgb2YgdGhlIHBhdGggZS5nLiAvLCBDOi8sIGZpbGU6Ly8vLCBodHRwOi8vZG9tYWluLmNvbS9cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBwYXJzZVxuICAgKi9cbiAgcm9vdG5hbWUocGF0aDIpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKSwgcGF0aDIgPSB0aGlzLnRvUG9zaXgocGF0aDIpO1xuICAgIGxldCByb290ID0gXCJcIjtcbiAgICBpZiAocGF0aDIuc3RhcnRzV2l0aChcIi9cIikgPyByb290ID0gXCIvXCIgOiByb290ID0gdGhpcy5nZXRQcm90b2NvbChwYXRoMiksIHRoaXMuaXNVcmwocGF0aDIpKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHBhdGgyLmluZGV4T2YoXCIvXCIsIHJvb3QubGVuZ3RoKTtcbiAgICAgIGluZGV4ICE9PSAtMSA/IHJvb3QgPSBwYXRoMi5zbGljZSgwLCBpbmRleCkgOiByb290ID0gcGF0aDIsIHJvb3QuZW5kc1dpdGgoXCIvXCIpIHx8IChyb290ICs9IFwiL1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IHBvcnRpb24gb2YgYSBwYXRoXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gdGVzdFxuICAgKiBAcGFyYW0gZXh0IC0gT3B0aW9uYWwgZXh0ZW5zaW9uIHRvIHJlbW92ZVxuICAgKi9cbiAgYmFzZW5hbWUocGF0aDIsIGV4dCkge1xuICAgIGFzc2VydFBhdGgocGF0aDIpLCBleHQgJiYgYXNzZXJ0UGF0aChleHQpLCBwYXRoMiA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgocGF0aDIpKTtcbiAgICBsZXQgc3RhcnQgPSAwLCBlbmQgPSAtMSwgbWF0Y2hlZFNsYXNoID0gITAsIGk7XG4gICAgaWYgKGV4dCAhPT0gdm9pZCAwICYmIGV4dC5sZW5ndGggPiAwICYmIGV4dC5sZW5ndGggPD0gcGF0aDIubGVuZ3RoKSB7XG4gICAgICBpZiAoZXh0Lmxlbmd0aCA9PT0gcGF0aDIubGVuZ3RoICYmIGV4dCA9PT0gcGF0aDIpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgbGV0IGV4dElkeCA9IGV4dC5sZW5ndGggLSAxLCBmaXJzdE5vblNsYXNoRW5kID0gLTE7XG4gICAgICBmb3IgKGkgPSBwYXRoMi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBjb25zdCBjb2RlID0gcGF0aDIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGZpcnN0Tm9uU2xhc2hFbmQgPT09IC0xICYmIChtYXRjaGVkU2xhc2ggPSAhMSwgZmlyc3ROb25TbGFzaEVuZCA9IGkgKyAxKSwgZXh0SWR4ID49IDAgJiYgKGNvZGUgPT09IGV4dC5jaGFyQ29kZUF0KGV4dElkeCkgPyAtLWV4dElkeCA9PT0gLTEgJiYgKGVuZCA9IGkpIDogKGV4dElkeCA9IC0xLCBlbmQgPSBmaXJzdE5vblNsYXNoRW5kKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnQgPT09IGVuZCA/IGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQgOiBlbmQgPT09IC0xICYmIChlbmQgPSBwYXRoMi5sZW5ndGgpLCBwYXRoMi5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgZm9yIChpID0gcGF0aDIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXG4gICAgICBpZiAocGF0aDIuY2hhckNvZGVBdChpKSA9PT0gNDcpIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgZW5kID09PSAtMSAmJiAobWF0Y2hlZFNsYXNoID0gITEsIGVuZCA9IGkgKyAxKTtcbiAgICByZXR1cm4gZW5kID09PSAtMSA/IFwiXCIgOiBwYXRoMi5zbGljZShzdGFydCwgZW5kKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBvZiB0aGUgcGF0aCwgZnJvbSB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIHRoZSAuIChwZXJpb2QpIGNoYXJhY3RlciB0byBlbmQgb2Ygc3RyaW5nIGluIHRoZSBsYXN0XG4gICAqIHBvcnRpb24gb2YgdGhlIHBhdGguIElmIHRoZXJlIGlzIG5vIC4gaW4gdGhlIGxhc3QgcG9ydGlvbiBvZiB0aGUgcGF0aCwgb3IgaWYgdGhlcmUgYXJlIG5vIC4gY2hhcmFjdGVycyBvdGhlciB0aGFuXG4gICAqIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIGJhc2VuYW1lIG9mIHBhdGgsIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBwYXJzZVxuICAgKi9cbiAgZXh0bmFtZShwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpLCBwYXRoMiA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgocGF0aDIpKTtcbiAgICBsZXQgc3RhcnREb3QgPSAtMSwgc3RhcnRQYXJ0ID0gMCwgZW5kID0gLTEsIG1hdGNoZWRTbGFzaCA9ICEwLCBwcmVEb3RTdGF0ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHBhdGgyLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBjb2RlID0gcGF0aDIuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZW5kID09PSAtMSAmJiAobWF0Y2hlZFNsYXNoID0gITEsIGVuZCA9IGkgKyAxKSwgY29kZSA9PT0gNDYgPyBzdGFydERvdCA9PT0gLTEgPyBzdGFydERvdCA9IGkgOiBwcmVEb3RTdGF0ZSAhPT0gMSAmJiAocHJlRG90U3RhdGUgPSAxKSA6IHN0YXJ0RG90ICE9PSAtMSAmJiAocHJlRG90U3RhdGUgPSAtMSk7XG4gICAgfVxuICAgIHJldHVybiBzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fCBwcmVEb3RTdGF0ZSA9PT0gMCB8fCBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSA/IFwiXCIgOiBwYXRoMi5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgfSxcbiAgLyoqXG4gICAqIFBhcnNlcyBhIHBhdGggaW50byBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgJ3Jvb3QnLCBgZGlyYCwgYGJhc2VgLCBgZXh0YCwgYW5kIGBuYW1lYCBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHBhcnNlXG4gICAqL1xuICBwYXJzZShwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIGNvbnN0IHJldCA9IHsgcm9vdDogXCJcIiwgZGlyOiBcIlwiLCBiYXNlOiBcIlwiLCBleHQ6IFwiXCIsIG5hbWU6IFwiXCIgfTtcbiAgICBpZiAocGF0aDIubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHJldDtcbiAgICBwYXRoMiA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgocGF0aDIpKTtcbiAgICBsZXQgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoMCk7XG4gICAgY29uc3QgaXNBYnNvbHV0ZSA9IHRoaXMuaXNBYnNvbHV0ZShwYXRoMik7XG4gICAgbGV0IHN0YXJ0O1xuICAgIGNvbnN0IHByb3RvY29sID0gXCJcIjtcbiAgICByZXQucm9vdCA9IHRoaXMucm9vdG5hbWUocGF0aDIpLCBpc0Fic29sdXRlIHx8IHRoaXMuaGFzUHJvdG9jb2wocGF0aDIpID8gc3RhcnQgPSAxIDogc3RhcnQgPSAwO1xuICAgIGxldCBzdGFydERvdCA9IC0xLCBzdGFydFBhcnQgPSAwLCBlbmQgPSAtMSwgbWF0Y2hlZFNsYXNoID0gITAsIGkgPSBwYXRoMi5sZW5ndGggLSAxLCBwcmVEb3RTdGF0ZSA9IDA7XG4gICAgZm9yICg7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgaWYgKGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KGkpLCBjb2RlID09PSA0Nykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZW5kID09PSAtMSAmJiAobWF0Y2hlZFNsYXNoID0gITEsIGVuZCA9IGkgKyAxKSwgY29kZSA9PT0gNDYgPyBzdGFydERvdCA9PT0gLTEgPyBzdGFydERvdCA9IGkgOiBwcmVEb3RTdGF0ZSAhPT0gMSAmJiAocHJlRG90U3RhdGUgPSAxKSA6IHN0YXJ0RG90ICE9PSAtMSAmJiAocHJlRG90U3RhdGUgPSAtMSk7XG4gICAgfVxuICAgIHJldHVybiBzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fCBwcmVEb3RTdGF0ZSA9PT0gMCB8fCBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSA/IGVuZCAhPT0gLTEgJiYgKHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlID8gcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGgyLnNsaWNlKDEsIGVuZCkgOiByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aDIuc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpKSA6IChzdGFydFBhcnQgPT09IDAgJiYgaXNBYnNvbHV0ZSA/IChyZXQubmFtZSA9IHBhdGgyLnNsaWNlKDEsIHN0YXJ0RG90KSwgcmV0LmJhc2UgPSBwYXRoMi5zbGljZSgxLCBlbmQpKSA6IChyZXQubmFtZSA9IHBhdGgyLnNsaWNlKHN0YXJ0UGFydCwgc3RhcnREb3QpLCByZXQuYmFzZSA9IHBhdGgyLnNsaWNlKHN0YXJ0UGFydCwgZW5kKSksIHJldC5leHQgPSBwYXRoMi5zbGljZShzdGFydERvdCwgZW5kKSksIHJldC5kaXIgPSB0aGlzLmRpcm5hbWUocGF0aDIpLCBwcm90b2NvbCAmJiAocmV0LmRpciA9IHByb3RvY29sICsgcmV0LmRpciksIHJldDtcbiAgfSxcbiAgc2VwOiBcIi9cIixcbiAgZGVsaW1pdGVyOiBcIjpcIlxufTtcbmV4cG9ydHMucGF0aCA9IHBhdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgc2V0dGluZ3MgPSByZXF1aXJlKFwiQHBpeGkvc2V0dGluZ3NcIik7XG5zZXR0aW5ncy5zZXR0aW5ncy5SRVRJTkFfUFJFRklYID0gL0AoWzAtOVxcLl0rKXgvO1xuc2V0dGluZ3Muc2V0dGluZ3MuRkFJTF9JRl9NQUpPUl9QRVJGT1JNQU5DRV9DQVZFQVQgPSAhMTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNldHRpbmdzXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNldHRpbmdzLnNldHRpbmdzO1xuICB9XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldHRpbmdzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHVybCQxID0gcmVxdWlyZShcInVybFwiKSwgZGVwcmVjYXRpb24gPSByZXF1aXJlKFwiLi9sb2dnaW5nL2RlcHJlY2F0aW9uLmpzXCIpO1xuY29uc3QgdXJsID0ge1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4zLjBcbiAgICovXG4gIGdldCBwYXJzZSgpIHtcbiAgICByZXR1cm4gZGVwcmVjYXRpb24uZGVwcmVjYXRpb24oXCI3LjMuMFwiLCBcInV0aWxzLnVybC5wYXJzZSBpcyBkZXByZWNhdGVkLCB1c2UgbmF0aXZlIFVSTCBBUEkgaW5zdGVhZC5cIiksIHVybCQxLnBhcnNlO1xuICB9LFxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4zLjBcbiAgICovXG4gIGdldCBmb3JtYXQoKSB7XG4gICAgcmV0dXJuIGRlcHJlY2F0aW9uLmRlcHJlY2F0aW9uKFwiNy4zLjBcIiwgXCJ1dGlscy51cmwuZm9ybWF0IGlzIGRlcHJlY2F0ZWQsIHVzZSBuYXRpdmUgVVJMIEFQSSBpbnN0ZWFkLlwiKSwgdXJsJDEuZm9ybWF0O1xuICB9LFxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4zLjBcbiAgICovXG4gIGdldCByZXNvbHZlKCkge1xuICAgIHJldHVybiBkZXByZWNhdGlvbi5kZXByZWNhdGlvbihcIjcuMy4wXCIsIFwidXRpbHMudXJsLnJlc29sdmUgaXMgZGVwcmVjYXRlZCwgdXNlIG5hdGl2ZSBVUkwgQVBJIGluc3RlYWQuXCIpLCB1cmwkMS5yZXNvbHZlO1xuICB9XG59O1xuZXhwb3J0cy51cmwgPSB1cmw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmwuanMubWFwXG4iLCIvKipcbiAqIFRoZSBFYXNlIGNsYXNzIHByb3ZpZGVzIGEgY29sbGVjdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zIGZvciB1c2Ugd2l0aCB0d2Vlbi5qcy5cbiAqL1xudmFyIEVhc2luZyA9IHtcbiAgICBMaW5lYXI6IHtcbiAgICAgICAgTm9uZTogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudDtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFF1YWRyYXRpYzoge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogKDIgLSBhbW91bnQpO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKC0tYW1vdW50ICogKGFtb3VudCAtIDIpIC0gMSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBDdWJpYzoge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gLS1hbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKyAxO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGFtb3VudCAtPSAyKSAqIGFtb3VudCAqIGFtb3VudCArIDIpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgUXVhcnRpYzoge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIC0tYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKChhbW91bnQgLT0gMikgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgLSAyKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFF1aW50aWM6IHtcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIC0tYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmICgoYW1vdW50ICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChhbW91bnQgLT0gMikgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKyAyKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFNpbnVzb2lkYWw6IHtcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5jb3MoKGFtb3VudCAqIE1hdGguUEkpIC8gMik7XG4gICAgICAgIH0sXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc2luKChhbW91bnQgKiBNYXRoLlBJKSAvIDIpO1xuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGFtb3VudCkpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgRXhwb25lbnRpYWw6IHtcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgYW1vdW50IC0gMSk7XG4gICAgICAgIH0sXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogYW1vdW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoYW1vdW50ICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBhbW91bnQgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChhbW91bnQgLSAxKSkgKyAyKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIENpcmN1bGFyOiB7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gYW1vdW50ICogYW1vdW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLWFtb3VudCAqIGFtb3VudCk7XG4gICAgICAgIH0sXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGFtb3VudCAqIGFtb3VudCkgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoYW1vdW50IC09IDIpICogYW1vdW50KSArIDEpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgRWxhc3RpYzoge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAxMCAqIChhbW91bnQgLSAxKSkgKiBNYXRoLnNpbigoYW1vdW50IC0gMS4xKSAqIDUgKiBNYXRoLlBJKTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwICogYW1vdW50KSAqIE1hdGguc2luKChhbW91bnQgLSAwLjEpICogNSAqIE1hdGguUEkpICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFtb3VudCAqPSAyO1xuICAgICAgICAgICAgaWYgKGFtb3VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIE1hdGgucG93KDIsIDEwICogKGFtb3VudCAtIDEpKSAqIE1hdGguc2luKChhbW91bnQgLSAxLjEpICogNSAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDIsIC0xMCAqIChhbW91bnQgLSAxKSkgKiBNYXRoLnNpbigoYW1vdW50IC0gMS4xKSAqIDUgKiBNYXRoLlBJKSArIDE7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBCYWNrOiB7XG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50ICogKChzICsgMSkgKiBhbW91bnQgLSBzKTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gLS1hbW91bnQgKiBhbW91bnQgKiAoKHMgKyAxKSAqIGFtb3VudCArIHMpICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1OCAqIDEuNTI1O1xuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChhbW91bnQgKiBhbW91bnQgKiAoKHMgKyAxKSAqIGFtb3VudCAtIHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGFtb3VudCAtPSAyKSAqIGFtb3VudCAqICgocyArIDEpICogYW1vdW50ICsgcykgKyAyKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIEJvdW5jZToge1xuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBFYXNpbmcuQm91bmNlLk91dCgxIC0gYW1vdW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICBpZiAoYW1vdW50IDwgMSAvIDIuNzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogYW1vdW50ICogYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYW1vdW50IDwgMiAvIDIuNzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGFtb3VudCAtPSAxLjUgLyAyLjc1KSAqIGFtb3VudCArIDAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhbW91bnQgPCAyLjUgLyAyLjc1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChhbW91bnQgLT0gMi4yNSAvIDIuNzUpICogYW1vdW50ICsgMC45Mzc1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChhbW91bnQgLT0gMi42MjUgLyAyLjc1KSAqIGFtb3VudCArIDAuOTg0Mzc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICAgICAgaWYgKGFtb3VudCA8IDAuNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFYXNpbmcuQm91bmNlLkluKGFtb3VudCAqIDIpICogMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEVhc2luZy5Cb3VuY2UuT3V0KGFtb3VudCAqIDIgLSAxKSAqIDAuNSArIDAuNTtcbiAgICAgICAgfSxcbiAgICB9LFxufTtcblxudmFyIG5vdztcbi8vIEluY2x1ZGUgYSBwZXJmb3JtYW5jZS5ub3cgcG9seWZpbGwuXG4vLyBJbiBub2RlLmpzLCB1c2UgcHJvY2Vzcy5ocnRpbWUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbi8vIEB0cy1pZ25vcmVcbmlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuaHJ0aW1lKSB7XG4gICAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB2YXIgdGltZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgICAgIC8vIENvbnZlcnQgW3NlY29uZHMsIG5hbm9zZWNvbmRzXSB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgIHJldHVybiB0aW1lWzBdICogMTAwMCArIHRpbWVbMV0gLyAxMDAwMDAwO1xuICAgIH07XG59XG4vLyBJbiBhIGJyb3dzZXIsIHVzZSBzZWxmLnBlcmZvcm1hbmNlLm5vdyBpZiBpdCBpcyBhdmFpbGFibGUuXG5lbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5wZXJmb3JtYW5jZSAhPT0gdW5kZWZpbmVkICYmIHNlbGYucGVyZm9ybWFuY2Uubm93ICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUaGlzIG11c3QgYmUgYm91bmQsIGJlY2F1c2UgZGlyZWN0bHkgYXNzaWduaW5nIHRoaXMgZnVuY3Rpb25cbiAgICAvLyBsZWFkcyB0byBhbiBpbnZvY2F0aW9uIGV4Y2VwdGlvbiBpbiBDaHJvbWUuXG4gICAgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3cuYmluZChzZWxmLnBlcmZvcm1hbmNlKTtcbn1cbi8vIFVzZSBEYXRlLm5vdyBpZiBpdCBpcyBhdmFpbGFibGUuXG5lbHNlIGlmIChEYXRlLm5vdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbm93ID0gRGF0ZS5ub3c7XG59XG4vLyBPdGhlcndpc2UsIHVzZSAnbmV3IERhdGUoKS5nZXRUaW1lKCknLlxuZWxzZSB7XG4gICAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcbn1cbnZhciBub3ckMSA9IG5vdztcblxuLyoqXG4gKiBDb250cm9sbGluZyBncm91cHMgb2YgdHdlZW5zXG4gKlxuICogVXNpbmcgdGhlIFRXRUVOIHNpbmdsZXRvbiB0byBtYW5hZ2UgeW91ciB0d2VlbnMgY2FuIGNhdXNlIGlzc3VlcyBpbiBsYXJnZSBhcHBzIHdpdGggbWFueSBjb21wb25lbnRzLlxuICogSW4gdGhlc2UgY2FzZXMsIHlvdSBtYXkgd2FudCB0byBjcmVhdGUgeW91ciBvd24gc21hbGxlciBncm91cHMgb2YgdHdlZW5cbiAqL1xudmFyIEdyb3VwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyb3VwKCkge1xuICAgICAgICB0aGlzLl90d2VlbnMgPSB7fTtcbiAgICAgICAgdGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGUgPSB7fTtcbiAgICB9XG4gICAgR3JvdXAucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3R3ZWVucykubWFwKGZ1bmN0aW9uICh0d2VlbklkKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3R3ZWVuc1t0d2VlbklkXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHcm91cC5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90d2VlbnMgPSB7fTtcbiAgICB9O1xuICAgIEdyb3VwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgdGhpcy5fdHdlZW5zW3R3ZWVuLmdldElkKCldID0gdHdlZW47XG4gICAgICAgIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlW3R3ZWVuLmdldElkKCldID0gdHdlZW47XG4gICAgfTtcbiAgICBHcm91cC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHR3ZWVuKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl90d2VlbnNbdHdlZW4uZ2V0SWQoKV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl90d2VlbnNBZGRlZER1cmluZ1VwZGF0ZVt0d2Vlbi5nZXRJZCgpXTtcbiAgICB9O1xuICAgIEdyb3VwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodGltZSwgcHJlc2VydmUpIHtcbiAgICAgICAgaWYgKHRpbWUgPT09IHZvaWQgMCkgeyB0aW1lID0gbm93JDEoKTsgfVxuICAgICAgICBpZiAocHJlc2VydmUgPT09IHZvaWQgMCkgeyBwcmVzZXJ2ZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciB0d2VlbklkcyA9IE9iamVjdC5rZXlzKHRoaXMuX3R3ZWVucyk7XG4gICAgICAgIGlmICh0d2Vlbklkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUd2VlbnMgYXJlIHVwZGF0ZWQgaW4gXCJiYXRjaGVzXCIuIElmIHlvdSBhZGQgYSBuZXcgdHdlZW4gZHVyaW5nIGFuXG4gICAgICAgIC8vIHVwZGF0ZSwgdGhlbiB0aGUgbmV3IHR3ZWVuIHdpbGwgYmUgdXBkYXRlZCBpbiB0aGUgbmV4dCBiYXRjaC5cbiAgICAgICAgLy8gSWYgeW91IHJlbW92ZSBhIHR3ZWVuIGR1cmluZyBhbiB1cGRhdGUsIGl0IG1heSBvciBtYXkgbm90IGJlIHVwZGF0ZWQuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGlmIHRoZSByZW1vdmVkIHR3ZWVuIHdhcyBhZGRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgYmF0Y2gsXG4gICAgICAgIC8vIHRoZW4gaXQgd2lsbCBub3QgYmUgdXBkYXRlZC5cbiAgICAgICAgd2hpbGUgKHR3ZWVuSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR3ZWVuSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR3ZWVuID0gdGhpcy5fdHdlZW5zW3R3ZWVuSWRzW2ldXTtcbiAgICAgICAgICAgICAgICB2YXIgYXV0b1N0YXJ0ID0gIXByZXNlcnZlO1xuICAgICAgICAgICAgICAgIGlmICh0d2VlbiAmJiB0d2Vlbi51cGRhdGUodGltZSwgYXV0b1N0YXJ0KSA9PT0gZmFsc2UgJiYgIXByZXNlcnZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90d2VlbnNbdHdlZW5JZHNbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR3ZWVuSWRzID0gT2JqZWN0LmtleXModGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwO1xufSgpKTtcblxuLyoqXG4gKlxuICovXG52YXIgSW50ZXJwb2xhdGlvbiA9IHtcbiAgICBMaW5lYXI6IGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIHZhciBtID0gdi5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgZiA9IG0gKiBrO1xuICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoZik7XG4gICAgICAgIHZhciBmbiA9IEludGVycG9sYXRpb24uVXRpbHMuTGluZWFyO1xuICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmbih2WzBdLCB2WzFdLCBmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoayA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmbih2W21dLCB2W20gLSAxXSwgbSAtIGYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbih2W2ldLCB2W2kgKyAxID4gbSA/IG0gOiBpICsgMV0sIGYgLSBpKTtcbiAgICB9LFxuICAgIEJlemllcjogZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgdmFyIGIgPSAwO1xuICAgICAgICB2YXIgbiA9IHYubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHB3ID0gTWF0aC5wb3c7XG4gICAgICAgIHZhciBibiA9IEludGVycG9sYXRpb24uVXRpbHMuQmVybnN0ZWluO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgICAgIGIgKz0gcHcoMSAtIGssIG4gLSBpKSAqIHB3KGssIGkpICogdltpXSAqIGJuKG4sIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiO1xuICAgIH0sXG4gICAgQ2F0bXVsbFJvbTogZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgdmFyIG0gPSB2Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBmID0gbSAqIGs7XG4gICAgICAgIHZhciBpID0gTWF0aC5mbG9vcihmKTtcbiAgICAgICAgdmFyIGZuID0gSW50ZXJwb2xhdGlvbi5VdGlscy5DYXRtdWxsUm9tO1xuICAgICAgICBpZiAodlswXSA9PT0gdlttXSkge1xuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgaSA9IE1hdGguZmxvb3IoKGYgPSBtICogKDEgKyBrKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuKHZbKGkgLSAxICsgbSkgJSBtXSwgdltpXSwgdlsoaSArIDEpICUgbV0sIHZbKGkgKyAyKSAlIG1dLCBmIC0gaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdlswXSAtIChmbih2WzBdLCB2WzBdLCB2WzFdLCB2WzFdLCAtZikgLSB2WzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2W21dIC0gKGZuKHZbbV0sIHZbbV0sIHZbbSAtIDFdLCB2W20gLSAxXSwgZiAtIG0pIC0gdlttXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4odltpID8gaSAtIDEgOiAwXSwgdltpXSwgdlttIDwgaSArIDEgPyBtIDogaSArIDFdLCB2W20gPCBpICsgMiA/IG0gOiBpICsgMl0sIGYgLSBpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgVXRpbHM6IHtcbiAgICAgICAgTGluZWFyOiBmdW5jdGlvbiAocDAsIHAxLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB9LFxuICAgICAgICBCZXJuc3RlaW46IGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICAgICAgICB2YXIgZmMgPSBJbnRlcnBvbGF0aW9uLlV0aWxzLkZhY3RvcmlhbDtcbiAgICAgICAgICAgIHJldHVybiBmYyhuKSAvIGZjKGkpIC8gZmMobiAtIGkpO1xuICAgICAgICB9LFxuICAgICAgICBGYWN0b3JpYWw6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYSA9IFsxXTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHZhciBzID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoYVtuXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVtuXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG47IGkgPiAxOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgcyAqPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhW25dID0gcztcbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCksXG4gICAgICAgIENhdG11bGxSb206IGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMywgdCkge1xuICAgICAgICAgICAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICAgICAgICAgICAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICAgICAgICAgICAgdmFyIHQyID0gdCAqIHQ7XG4gICAgICAgICAgICB2YXIgdDMgPSB0ICogdDI7XG4gICAgICAgICAgICByZXR1cm4gKDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEpICogdDMgKyAoLTMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5cbi8qKlxuICogVXRpbHNcbiAqL1xudmFyIFNlcXVlbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcXVlbmNlKCkge1xuICAgIH1cbiAgICBTZXF1ZW5jZS5uZXh0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBTZXF1ZW5jZS5fbmV4dElkKys7XG4gICAgfTtcbiAgICBTZXF1ZW5jZS5fbmV4dElkID0gMDtcbiAgICByZXR1cm4gU2VxdWVuY2U7XG59KCkpO1xuXG52YXIgbWFpbkdyb3VwID0gbmV3IEdyb3VwKCk7XG5cbi8qKlxuICogVHdlZW4uanMgLSBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90d2VlbmpzL3R3ZWVuLmpzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2VlbmpzL3R3ZWVuLmpzL2dyYXBocy9jb250cmlidXRvcnMgZm9yIHRoZSBmdWxsIGxpc3Qgb2YgY29udHJpYnV0b3JzLlxuICogVGhhbmsgeW91IGFsbCwgeW91J3JlIGF3ZXNvbWUhXG4gKi9cbnZhciBUd2VlbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUd2Vlbihfb2JqZWN0LCBfZ3JvdXApIHtcbiAgICAgICAgaWYgKF9ncm91cCA9PT0gdm9pZCAwKSB7IF9ncm91cCA9IG1haW5Hcm91cDsgfVxuICAgICAgICB0aGlzLl9vYmplY3QgPSBfb2JqZWN0O1xuICAgICAgICB0aGlzLl9ncm91cCA9IF9ncm91cDtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IDA7XG4gICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0ID0ge307XG4gICAgICAgIHRoaXMuX3ZhbHVlc0VuZCA9IHt9O1xuICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCA9IHt9O1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IDEwMDA7XG4gICAgICAgIHRoaXMuX2luaXRpYWxSZXBlYXQgPSAwO1xuICAgICAgICB0aGlzLl9yZXBlYXQgPSAwO1xuICAgICAgICB0aGlzLl95b3lvID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXZlcnNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kZWxheVRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9lYXNpbmdGdW5jdGlvbiA9IEVhc2luZy5MaW5lYXIuTm9uZTtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkZ1bmN0aW9uID0gSW50ZXJwb2xhdGlvbi5MaW5lYXI7XG4gICAgICAgIHRoaXMuX2NoYWluZWRUd2VlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faWQgPSBTZXF1ZW5jZS5uZXh0SWQoKTtcbiAgICAgICAgdGhpcy5faXNDaGFpblN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZ29Ub0VuZCA9IGZhbHNlO1xuICAgIH1cbiAgICBUd2Vlbi5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5pc1BsYXlpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1BsYXlpbmc7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1BhdXNlZDtcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzLCBkdXJhdGlvbikge1xuICAgICAgICAvLyBUT0RPPyByZXN0b3JlIHRoaXMsIHRoZW4gdXBkYXRlIHRoZSAwN19keW5hbWljX3RvIGV4YW1wbGUgdG8gc2V0IGZveFxuICAgICAgICAvLyB0d2VlbidzIHRvIG9uIGVhY2ggdXBkYXRlLiBUaGF0IHdheSB0aGUgYmVoYXZpb3IgaXMgb3B0LWluICh0aGVyZSdzXG4gICAgICAgIC8vIGN1cnJlbnRseSBubyBvcHQtb3V0KS5cbiAgICAgICAgLy8gZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnRpZXMpIHRoaXMuX3ZhbHVlc0VuZFtwcm9wXSA9IHByb3BlcnRpZXNbcHJvcF1cbiAgICAgICAgdGhpcy5fdmFsdWVzRW5kID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzKTtcbiAgICAgICAgaWYgKGR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IGQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUGxheWluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuX2dyb3VwICYmIHRoaXMuX2dyb3VwLmFkZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVwZWF0ID0gdGhpcy5faW5pdGlhbFJlcGVhdDtcbiAgICAgICAgaWYgKHRoaXMuX3JldmVyc2VkKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIHJldmVyc2VkIChmLmUuIHVzaW5nIHRoZSB5b3lvIGZlYXR1cmUpIHRoZW4gd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gZmxpcCB0aGUgdHdlZW4gZGlyZWN0aW9uIGJhY2sgdG8gZm9yd2FyZC5cbiAgICAgICAgICAgIHRoaXMuX3JldmVyc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N3YXBFbmRTdGFydFJlcGVhdFZhbHVlcyhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFja0ZpcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQ2hhaW5TdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRpbWUgIT09IHVuZGVmaW5lZCA/ICh0eXBlb2YgdGltZSA9PT0gJ3N0cmluZycgPyBub3ckMSgpICsgcGFyc2VGbG9hdCh0aW1lKSA6IHRpbWUpIDogbm93JDEoKTtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lICs9IHRoaXMuX2RlbGF5VGltZTtcbiAgICAgICAgdGhpcy5fc2V0dXBQcm9wZXJ0aWVzKHRoaXMuX29iamVjdCwgdGhpcy5fdmFsdWVzU3RhcnQsIHRoaXMuX3ZhbHVlc0VuZCwgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5fc2V0dXBQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKF9vYmplY3QsIF92YWx1ZXNTdGFydCwgX3ZhbHVlc0VuZCwgX3ZhbHVlc1N0YXJ0UmVwZWF0KSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIF92YWx1ZXNFbmQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFZhbHVlID0gX29iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB2YXIgc3RhcnRWYWx1ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgdmFyIHByb3BUeXBlID0gc3RhcnRWYWx1ZUlzQXJyYXkgPyAnYXJyYXknIDogdHlwZW9mIHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICB2YXIgaXNJbnRlcnBvbGF0aW9uTGlzdCA9ICFzdGFydFZhbHVlSXNBcnJheSAmJiBBcnJheS5pc0FycmF5KF92YWx1ZXNFbmRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIC8vIElmIGB0bygpYCBzcGVjaWZpZXMgYSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNvdXJjZSBvYmplY3QsXG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgbm90IHNldCB0aGF0IHByb3BlcnR5IGluIHRoZSBvYmplY3RcbiAgICAgICAgICAgIGlmIChwcm9wVHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGFuIEFycmF5IHdhcyBwcm92aWRlZCBhcyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICAgICAgaWYgKGlzSW50ZXJwb2xhdGlvbkxpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kVmFsdWVzID0gX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKGVuZFZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBhbiBhcnJheSBvZiByZWxhdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICBlbmRWYWx1ZXMgPSBlbmRWYWx1ZXMubWFwKHRoaXMuX2hhbmRsZVJlbGF0aXZlVmFsdWUuYmluZCh0aGlzLCBzdGFydFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbG9jYWwgY29weSBvZiB0aGUgQXJyYXkgd2l0aCB0aGUgc3RhcnQgdmFsdWUgYXQgdGhlIGZyb250XG4gICAgICAgICAgICAgICAgX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPSBbc3RhcnRWYWx1ZV0uY29uY2F0KGVuZFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgdGhlIGRlZXBuZXNzIG9mIHRoZSB2YWx1ZXNcbiAgICAgICAgICAgIGlmICgocHJvcFR5cGUgPT09ICdvYmplY3QnIHx8IHN0YXJ0VmFsdWVJc0FycmF5KSAmJiBzdGFydFZhbHVlICYmICFpc0ludGVycG9sYXRpb25MaXN0KSB7XG4gICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9IHN0YXJ0VmFsdWVJc0FycmF5ID8gW10gOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHN0YXJ0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV1bcHJvcF0gPSBzdGFydFZhbHVlW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gc3RhcnRWYWx1ZUlzQXJyYXkgPyBbXSA6IHt9OyAvLyBUT0RPPyByZXBlYXQgbmVzdGVkIHZhbHVlcz8gQW5kIHlveW8/IEFuZCBhcnJheSB2YWx1ZXM/XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXR1cFByb3BlcnRpZXMoc3RhcnRWYWx1ZSwgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSwgX3ZhbHVlc0VuZFtwcm9wZXJ0eV0sIF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgc3RhcnRpbmcgdmFsdWUsIGJ1dCBvbmx5IG9uY2UuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfdmFsdWVzU3RhcnRbcHJvcGVydHldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRbcHJvcGVydHldID0gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydFZhbHVlSXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSAqPSAxLjA7IC8vIEVuc3VyZXMgd2UncmUgdXNpbmcgbnVtYmVycywgbm90IHN0cmluZ3NcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzSW50ZXJwb2xhdGlvbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSBfdmFsdWVzRW5kW3Byb3BlcnR5XS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSBfdmFsdWVzU3RhcnRbcHJvcGVydHldIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NoYWluU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNDaGFpblN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdG9wQ2hhaW5lZFR3ZWVucygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5fZ3JvdXAgJiYgdGhpcy5fZ3JvdXAucmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX29uU3RvcENhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9vblN0b3BDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZ29Ub0VuZCA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlKEluZmluaXR5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3ckMSgpOyB9XG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCB8fCAhdGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhdXNlU3RhcnQgPSB0aW1lO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5fZ3JvdXAgJiYgdGhpcy5fZ3JvdXAucmVtb3ZlKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3ckMSgpOyB9XG4gICAgICAgIGlmICghdGhpcy5faXNQYXVzZWQgfHwgIXRoaXMuX2lzUGxheWluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lICs9IHRpbWUgLSB0aGlzLl9wYXVzZVN0YXJ0O1xuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gMDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuX2dyb3VwICYmIHRoaXMuX2dyb3VwLmFkZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuc3RvcENoYWluZWRUd2VlbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBudW1DaGFpbmVkVHdlZW5zID0gdGhpcy5fY2hhaW5lZFR3ZWVucy5sZW5ndGg7IGkgPCBudW1DaGFpbmVkVHdlZW5zOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYWluZWRUd2VlbnNbaV0uc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmdyb3VwID0gZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwID0gZ3JvdXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICB0aGlzLl9kZWxheVRpbWUgPSBhbW91bnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uICh0aW1lcykge1xuICAgICAgICB0aGlzLl9pbml0aWFsUmVwZWF0ID0gdGltZXM7XG4gICAgICAgIHRoaXMuX3JlcGVhdCA9IHRpbWVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5yZXBlYXREZWxheSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgdGhpcy5fcmVwZWF0RGVsYXlUaW1lID0gYW1vdW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS55b3lvID0gZnVuY3Rpb24gKHlveW8pIHtcbiAgICAgICAgdGhpcy5feW95byA9IHlveW87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmVhc2luZyA9IGZ1bmN0aW9uIChlYXNpbmdGdW5jdGlvbikge1xuICAgICAgICB0aGlzLl9lYXNpbmdGdW5jdGlvbiA9IGVhc2luZ0Z1bmN0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5pbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGludGVycG9sYXRpb25GdW5jdGlvbikge1xuICAgICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBpbnRlcnBvbGF0aW9uRnVuY3Rpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHdlZW5zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB0d2VlbnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFpbmVkVHdlZW5zID0gdHdlZW5zO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5vblVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vblVwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLm9uUmVwZWF0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uUmVwZWF0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUub25Db21wbGV0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vbkNvbXBsZXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUub25TdG9wID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uU3RvcENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdHdlZW4gaXMgc3RpbGwgcGxheWluZyBhZnRlciB0aGUgdXBkYXRlLCBmYWxzZVxuICAgICAqIG90aGVyd2lzZSAoY2FsbGluZyB1cGRhdGUgb24gYSBwYXVzZWQgdHdlZW4gc3RpbGwgcmV0dXJucyB0cnVlIGJlY2F1c2VcbiAgICAgKiBpdCBpcyBzdGlsbCBwbGF5aW5nLCBqdXN0IHBhdXNlZCkuXG4gICAgICovXG4gICAgVHdlZW4ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0aW1lLCBhdXRvU3RhcnQpIHtcbiAgICAgICAgaWYgKHRpbWUgPT09IHZvaWQgMCkgeyB0aW1lID0gbm93JDEoKTsgfVxuICAgICAgICBpZiAoYXV0b1N0YXJ0ID09PSB2b2lkIDApIHsgYXV0b1N0YXJ0ID0gdHJ1ZTsgfVxuICAgICAgICBpZiAodGhpcy5faXNQYXVzZWQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIHByb3BlcnR5O1xuICAgICAgICB2YXIgZWxhcHNlZDtcbiAgICAgICAgdmFyIGVuZFRpbWUgPSB0aGlzLl9zdGFydFRpbWUgKyB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgaWYgKCF0aGlzLl9nb1RvRW5kICYmICF0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aW1lID4gZW5kVGltZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYXV0b1N0YXJ0KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQodGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ29Ub0VuZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGltZSA8IHRoaXMuX3N0YXJ0VGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29uU3RhcnRDYWxsYmFja0ZpcmVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29uU3RhcnRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsYXBzZWQgPSAodGltZSAtIHRoaXMuX3N0YXJ0VGltZSkgLyB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgZWxhcHNlZCA9IHRoaXMuX2R1cmF0aW9uID09PSAwIHx8IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2Vhc2luZ0Z1bmN0aW9uKGVsYXBzZWQpO1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICB0aGlzLl91cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX29iamVjdCwgdGhpcy5fdmFsdWVzU3RhcnQsIHRoaXMuX3ZhbHVlc0VuZCwgdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5fb25VcGRhdGVDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fb25VcGRhdGVDYWxsYmFjayh0aGlzLl9vYmplY3QsIGVsYXBzZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGFwc2VkID09PSAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVwZWF0ID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZSh0aGlzLl9yZXBlYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcGVhdC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWFzc2lnbiBzdGFydGluZyB2YWx1ZXMsIHJlc3RhcnQgYnkgbWFraW5nIHN0YXJ0VGltZSA9IG5vd1xuICAgICAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl95b3lvICYmIHR5cGVvZiB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSArIHBhcnNlRmxvYXQodGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3lveW8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N3YXBFbmRTdGFydFJlcGVhdFZhbHVlcyhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5feW95bykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXZlcnNlZCA9ICF0aGlzLl9yZXZlcnNlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlcGVhdERlbGF5VGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRpbWUgKyB0aGlzLl9yZXBlYXREZWxheVRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aW1lICsgdGhpcy5fZGVsYXlUaW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25SZXBlYXRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblJlcGVhdENhbGxiYWNrKHRoaXMuX29iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uQ29tcGxldGVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNvbXBsZXRlQ2FsbGJhY2sodGhpcy5fb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG51bUNoYWluZWRUd2VlbnMgPSB0aGlzLl9jaGFpbmVkVHdlZW5zLmxlbmd0aDsgaSA8IG51bUNoYWluZWRUd2VlbnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSBjaGFpbmVkIHR3ZWVucyBzdGFydCBleGFjdGx5IGF0IHRoZSB0aW1lIHRoZXkgc2hvdWxkLFxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHRoZSBgdXBkYXRlKClgIG1ldGhvZCB3YXMgY2FsbGVkIHdheSBwYXN0IHRoZSBkdXJhdGlvbiBvZiB0aGUgdHdlZW5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhaW5lZFR3ZWVuc1tpXS5zdGFydCh0aGlzLl9zdGFydFRpbWUgKyB0aGlzLl9kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFR3ZWVuLnByb3RvdHlwZS5fdXBkYXRlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChfb2JqZWN0LCBfdmFsdWVzU3RhcnQsIF92YWx1ZXNFbmQsIHZhbHVlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIF92YWx1ZXNFbmQpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHVwZGF0ZSBwcm9wZXJ0aWVzIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBzb3VyY2Ugb2JqZWN0XG4gICAgICAgICAgICBpZiAoX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBfdmFsdWVzU3RhcnRbcHJvcGVydHldIHx8IDA7XG4gICAgICAgICAgICB2YXIgZW5kID0gX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB2YXIgc3RhcnRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShfb2JqZWN0W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB2YXIgZW5kSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoZW5kKTtcbiAgICAgICAgICAgIHZhciBpc0ludGVycG9sYXRpb25MaXN0ID0gIXN0YXJ0SXNBcnJheSAmJiBlbmRJc0FycmF5O1xuICAgICAgICAgICAgaWYgKGlzSW50ZXJwb2xhdGlvbkxpc3QpIHtcbiAgICAgICAgICAgICAgICBfb2JqZWN0W3Byb3BlcnR5XSA9IHRoaXMuX2ludGVycG9sYXRpb25GdW5jdGlvbihlbmQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdvYmplY3QnICYmIGVuZCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJvcGVydGllcyhfb2JqZWN0W3Byb3BlcnR5XSwgc3RhcnQsIGVuZCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2VzIHJlbGF0aXZlIGVuZCB2YWx1ZXMgd2l0aCBzdGFydCBhcyBiYXNlIChlLmcuOiArMTAsIC0zKVxuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuX2hhbmRsZVJlbGF0aXZlVmFsdWUoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IG5vbiBudW1lcmljIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xuICAgICAgICAgICAgICAgICAgICBfb2JqZWN0W3Byb3BlcnR5XSA9IHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVHdlZW4ucHJvdG90eXBlLl9oYW5kbGVSZWxhdGl2ZVZhbHVlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQuY2hhckF0KDApID09PSAnKycgfHwgZW5kLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnQgKyBwYXJzZUZsb2F0KGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChlbmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUd2Vlbi5wcm90b3R5cGUuX3N3YXBFbmRTdGFydFJlcGVhdFZhbHVlcyA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICB2YXIgdG1wID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldO1xuICAgICAgICB2YXIgZW5kVmFsdWUgPSB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldO1xuICAgICAgICBpZiAodHlwZW9mIGVuZFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldICsgcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPSB0bXA7XG4gICAgfTtcbiAgICByZXR1cm4gVHdlZW47XG59KCkpO1xuXG52YXIgVkVSU0lPTiA9ICcxOC42LjQnO1xuXG4vKipcbiAqIFR3ZWVuLmpzIC0gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qc1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qcy9ncmFwaHMvY29udHJpYnV0b3JzIGZvciB0aGUgZnVsbCBsaXN0IG9mIGNvbnRyaWJ1dG9ycy5cbiAqIFRoYW5rIHlvdSBhbGwsIHlvdSdyZSBhd2Vzb21lIVxuICovXG52YXIgbmV4dElkID0gU2VxdWVuY2UubmV4dElkO1xuLyoqXG4gKiBDb250cm9sbGluZyBncm91cHMgb2YgdHdlZW5zXG4gKlxuICogVXNpbmcgdGhlIFRXRUVOIHNpbmdsZXRvbiB0byBtYW5hZ2UgeW91ciB0d2VlbnMgY2FuIGNhdXNlIGlzc3VlcyBpbiBsYXJnZSBhcHBzIHdpdGggbWFueSBjb21wb25lbnRzLlxuICogSW4gdGhlc2UgY2FzZXMsIHlvdSBtYXkgd2FudCB0byBjcmVhdGUgeW91ciBvd24gc21hbGxlciBncm91cHMgb2YgdHdlZW5zLlxuICovXG52YXIgVFdFRU4gPSBtYWluR3JvdXA7XG4vLyBUaGlzIGlzIHRoZSBiZXN0IHdheSB0byBleHBvcnQgdGhpbmdzIGluIGEgd2F5IHRoYXQncyBjb21wYXRpYmxlIHdpdGggYm90aCBFU1xuLy8gTW9kdWxlcyBhbmQgQ29tbW9uSlMsIHdpdGhvdXQgYnVpbGQgaGFja3MsIGFuZCBzbyBhcyBub3QgdG8gYnJlYWsgdGhlXG4vLyBleGlzdGluZyBBUEkuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvMTk2MSNpc3N1ZWNvbW1lbnQtNDIzMDM3ODgxXG52YXIgZ2V0QWxsID0gVFdFRU4uZ2V0QWxsLmJpbmQoVFdFRU4pO1xudmFyIHJlbW92ZUFsbCA9IFRXRUVOLnJlbW92ZUFsbC5iaW5kKFRXRUVOKTtcbnZhciBhZGQgPSBUV0VFTi5hZGQuYmluZChUV0VFTik7XG52YXIgcmVtb3ZlID0gVFdFRU4ucmVtb3ZlLmJpbmQoVFdFRU4pO1xudmFyIHVwZGF0ZSA9IFRXRUVOLnVwZGF0ZS5iaW5kKFRXRUVOKTtcbnZhciBleHBvcnRzID0ge1xuICAgIEVhc2luZzogRWFzaW5nLFxuICAgIEdyb3VwOiBHcm91cCxcbiAgICBJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0aW9uLFxuICAgIG5vdzogbm93JDEsXG4gICAgU2VxdWVuY2U6IFNlcXVlbmNlLFxuICAgIG5leHRJZDogbmV4dElkLFxuICAgIFR3ZWVuOiBUd2VlbixcbiAgICBWRVJTSU9OOiBWRVJTSU9OLFxuICAgIGdldEFsbDogZ2V0QWxsLFxuICAgIHJlbW92ZUFsbDogcmVtb3ZlQWxsLFxuICAgIGFkZDogYWRkLFxuICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgIHVwZGF0ZTogdXBkYXRlLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZXhwb3J0cztcbmV4cG9ydCB7IEVhc2luZywgR3JvdXAsIEludGVycG9sYXRpb24sIFNlcXVlbmNlLCBUd2VlbiwgVkVSU0lPTiwgYWRkLCBnZXRBbGwsIG5leHRJZCwgbm93JDEgYXMgbm93LCByZW1vdmUsIHJlbW92ZUFsbCwgdXBkYXRlIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJy4vJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYygnU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpYyA9IEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZyk7XG5cdGlmICh0eXBlb2YgaW50cmluc2ljID09PSAnZnVuY3Rpb24nICYmICRpbmRleE9mKG5hbWUsICcucHJvdG90eXBlLicpID4gLTEpIHtcblx0XHRyZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKTtcblx0fVxuXHRyZXR1cm4gaW50cmluc2ljO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIHNldEZ1bmN0aW9uTGVuZ3RoID0gcmVxdWlyZSgnc2V0LWZ1bmN0aW9uLWxlbmd0aCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcbnZhciAkYXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklJyk7XG52YXIgJGNhbGwgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCUnKTtcbnZhciAkcmVmbGVjdEFwcGx5ID0gR2V0SW50cmluc2ljKCclUmVmbGVjdC5hcHBseSUnLCB0cnVlKSB8fCBiaW5kLmNhbGwoJGNhbGwsICRhcHBseSk7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG52YXIgJG1heCA9IEdldEludHJpbnNpYygnJU1hdGgubWF4JScpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ2luYWxGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdhIGZ1bmN0aW9uIGlzIHJlcXVpcmVkJyk7XG5cdH1cblx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xuXHRyZXR1cm4gc2V0RnVuY3Rpb25MZW5ndGgoXG5cdFx0ZnVuYyxcblx0XHQxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpLFxuXHRcdHRydWVcblx0KTtcbn07XG5cbnZhciBhcHBseUJpbmQgPSBmdW5jdGlvbiBhcHBseUJpbmQoKSB7XG5cdHJldHVybiAkcmVmbGVjdEFwcGx5KGJpbmQsICRhcHBseSwgYXJndW1lbnRzKTtcbn07XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0JGRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAnYXBwbHknLCB7IHZhbHVlOiBhcHBseUJpbmQgfSk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cy5hcHBseSA9IGFwcGx5QmluZDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMgPSByZXF1aXJlKCdoYXMtcHJvcGVydHktZGVzY3JpcHRvcnMnKSgpO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gaGFzUHJvcGVydHlEZXNjcmlwdG9ycyAmJiBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuXHR9XG59XG5cbnZhciAkU3ludGF4RXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVTeW50YXhFcnJvciUnKTtcbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG52YXIgZ29wZCA9IHJlcXVpcmUoJ2dvcGQnKTtcblxuLyoqIEB0eXBlIHsob2JqOiBSZWNvcmQ8UHJvcGVydHlLZXksIHVua25vd24+LCBwcm9wZXJ0eTogUHJvcGVydHlLZXksIHZhbHVlOiB1bmtub3duLCBub25FbnVtZXJhYmxlPzogYm9vbGVhbiB8IG51bGwsIG5vbldyaXRhYmxlPzogYm9vbGVhbiB8IG51bGwsIG5vbkNvbmZpZ3VyYWJsZT86IGJvb2xlYW4gfCBudWxsLCBsb29zZT86IGJvb2xlYW4pID0+IHZvaWR9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZURhdGFQcm9wZXJ0eShcblx0b2JqLFxuXHRwcm9wZXJ0eSxcblx0dmFsdWVcbikge1xuXHRpZiAoIW9iaiB8fCAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJykpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG9iamAgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbmAnKTtcblx0fVxuXHRpZiAodHlwZW9mIHByb3BlcnR5ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcGVydHkgIT09ICdzeW1ib2wnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bwcm9wZXJ0eWAgbXVzdCBiZSBhIHN0cmluZyBvciBhIHN5bWJvbGAnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGFyZ3VtZW50c1szXSAhPT0gJ2Jvb2xlYW4nICYmIGFyZ3VtZW50c1szXSAhPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbm9uRW51bWVyYWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIHR5cGVvZiBhcmd1bWVudHNbNF0gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbNF0gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbldyaXRhYmxlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuIG9yIG51bGwnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgdHlwZW9mIGFyZ3VtZW50c1s1XSAhPT0gJ2Jvb2xlYW4nICYmIGFyZ3VtZW50c1s1XSAhPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbm9uQ29uZmlndXJhYmxlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuIG9yIG51bGwnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgdHlwZW9mIGFyZ3VtZW50c1s2XSAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bsb29zZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0dmFyIG5vbkVudW1lcmFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cdHZhciBub25Xcml0YWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogbnVsbDtcblx0dmFyIG5vbkNvbmZpZ3VyYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ID8gYXJndW1lbnRzWzVdIDogbnVsbDtcblx0dmFyIGxvb3NlID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgPyBhcmd1bWVudHNbNl0gOiBmYWxzZTtcblxuXHQvKiBAdHlwZSB7ZmFsc2UgfCBUeXBlZFByb3BlcnR5RGVzY3JpcHRvcjx1bmtub3duPn0gKi9cblx0dmFyIGRlc2MgPSAhIWdvcGQgJiYgZ29wZChvYmosIHByb3BlcnR5KTtcblxuXHRpZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHksIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogbm9uQ29uZmlndXJhYmxlID09PSBudWxsICYmIGRlc2MgPyBkZXNjLmNvbmZpZ3VyYWJsZSA6ICFub25Db25maWd1cmFibGUsXG5cdFx0XHRlbnVtZXJhYmxlOiBub25FbnVtZXJhYmxlID09PSBudWxsICYmIGRlc2MgPyBkZXNjLmVudW1lcmFibGUgOiAhbm9uRW51bWVyYWJsZSxcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdHdyaXRhYmxlOiBub25Xcml0YWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy53cml0YWJsZSA6ICFub25Xcml0YWJsZVxuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGxvb3NlIHx8ICghbm9uRW51bWVyYWJsZSAmJiAhbm9uV3JpdGFibGUgJiYgIW5vbkNvbmZpZ3VyYWJsZSkpIHtcblx0XHQvLyBtdXN0IGZhbGwgYmFjayB0byBbW1NldF1dLCBhbmQgd2FzIG5vdCBleHBsaWNpdGx5IGFza2VkIHRvIG1ha2Ugbm9uLWVudW1lcmFibGUsIG5vbi13cml0YWJsZSwgb3Igbm9uLWNvbmZpZ3VyYWJsZVxuXHRcdG9ialtwcm9wZXJ0eV0gPSB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBkZWZpbmluZyBhIHByb3BlcnR5IGFzIG5vbi1jb25maWd1cmFibGUsIG5vbi13cml0YWJsZSwgb3Igbm9uLWVudW1lcmFibGUuJyk7XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGVhcmN1dDtcblxuZnVuY3Rpb24gZWFyY3V0KGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0pIHtcblxuICAgIGRpbSA9IGRpbSB8fCAyO1xuXG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoLFxuICAgICAgICBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJOb2RlID0gbGlua2VkTGlzdChkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlKSxcbiAgICAgICAgdHJpYW5nbGVzID0gW107XG5cbiAgICBpZiAoIW91dGVyTm9kZSB8fCBvdXRlck5vZGUubmV4dCA9PT0gb3V0ZXJOb2RlLnByZXYpIHJldHVybiB0cmlhbmdsZXM7XG5cbiAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgaW52U2l6ZTtcblxuICAgIGlmIChoYXNIb2xlcykgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKTtcblxuICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDgwICogZGltKSB7XG4gICAgICAgIG1pblggPSBtYXhYID0gZGF0YVswXTtcbiAgICAgICAgbWluWSA9IG1heFkgPSBkYXRhWzFdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0pIHtcbiAgICAgICAgICAgIHggPSBkYXRhW2ldO1xuICAgICAgICAgICAgeSA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1pblgsIG1pblkgYW5kIGludlNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG4gICAgICAgIGludlNpemUgPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgICAgICBpbnZTaXplID0gaW52U2l6ZSAhPT0gMCA/IDMyNzY3IC8gaW52U2l6ZSA6IDA7XG4gICAgfVxuXG4gICAgZWFyY3V0TGlua2VkKG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDApO1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcbn1cblxuLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlKSB7XG4gICAgdmFyIGksIGxhc3Q7XG5cbiAgICBpZiAoY2xvY2t3aXNlID09PSAoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pID4gMCkpIHtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH1cblxuICAgIGlmIChsYXN0ICYmIGVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XG4gICAgICAgIHJlbW92ZU5vZGUobGFzdCk7XG4gICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbi8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCkge1xuICAgIGlmICghc3RhcnQpIHJldHVybiBzdGFydDtcbiAgICBpZiAoIWVuZCkgZW5kID0gc3RhcnQ7XG5cbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBhZ2FpbjtcbiAgICBkbyB7XG4gICAgICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHAgPSBlbmQgPSBwLnByZXY7XG4gICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSBicmVhaztcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XG5cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzKSB7XG4gICAgaWYgKCFlYXIpIHJldHVybjtcblxuICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbiAgICBpZiAoIXBhc3MgJiYgaW52U2l6ZSkgaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgdmFyIHN0b3AgPSBlYXIsXG4gICAgICAgIHByZXYsIG5leHQ7XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcbiAgICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG4gICAgICAgIHByZXYgPSBlYXIucHJldjtcbiAgICAgICAgbmV4dCA9IGVhci5uZXh0O1xuXG4gICAgICAgIGlmIChpbnZTaXplID8gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSA6IGlzRWFyKGVhcikpIHtcbiAgICAgICAgICAgIC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwcmV2LmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChuZXh0LmkgLyBkaW0gfCAwKTtcblxuICAgICAgICAgICAgcmVtb3ZlTm9kZShlYXIpO1xuXG4gICAgICAgICAgICAvLyBza2lwcGluZyB0aGUgbmV4dCB2ZXJ0ZXggbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXG4gICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XG4gICAgICAgICAgICBzdG9wID0gbmV4dC5uZXh0O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhciA9IG5leHQ7XG5cbiAgICAgICAgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcbiAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xuICAgICAgICAgICAgLy8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cbiAgICAgICAgICAgIGlmICghcGFzcykge1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0pO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAyKTtcblxuICAgICAgICAgICAgLy8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMikge1xuICAgICAgICAgICAgICAgIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5mdW5jdGlvbiBpc0VhcihlYXIpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxuICAgIHZhciBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgeDAgPSBheCA8IGJ4ID8gKGF4IDwgY3ggPyBheCA6IGN4KSA6IChieCA8IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkwID0gYXkgPCBieSA/IChheSA8IGN5ID8gYXkgOiBjeSkgOiAoYnkgPCBjeSA/IGJ5IDogY3kpLFxuICAgICAgICB4MSA9IGF4ID4gYnggPyAoYXggPiBjeCA/IGF4IDogY3gpIDogKGJ4ID4gY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTEgPSBheSA+IGJ5ID8gKGF5ID4gY3kgPyBheSA6IGN5KSA6IChieSA+IGN5ID8gYnkgOiBjeSk7XG5cbiAgICB2YXIgcCA9IGMubmV4dDtcbiAgICB3aGlsZSAocCAhPT0gYSkge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIHZhciBhID0gZWFyLnByZXYsXG4gICAgICAgIGIgPSBlYXIsXG4gICAgICAgIGMgPSBlYXIubmV4dDtcblxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIHZhciBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgeDAgPSBheCA8IGJ4ID8gKGF4IDwgY3ggPyBheCA6IGN4KSA6IChieCA8IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkwID0gYXkgPCBieSA/IChheSA8IGN5ID8gYXkgOiBjeSkgOiAoYnkgPCBjeSA/IGJ5IDogY3kpLFxuICAgICAgICB4MSA9IGF4ID4gYnggPyAoYXggPiBjeCA/IGF4IDogY3gpIDogKGJ4ID4gY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTEgPSBheSA+IGJ5ID8gKGF5ID4gY3kgPyBheSA6IGN5KSA6IChieSA+IGN5ID8gYnkgOiBjeSk7XG5cbiAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgIHZhciBtaW5aID0gek9yZGVyKHgwLCB5MCwgbWluWCwgbWluWSwgaW52U2l6ZSksXG4gICAgICAgIG1heFogPSB6T3JkZXIoeDEsIHkxLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblxuICAgIHZhciBwID0gZWFyLnByZXZaLFxuICAgICAgICBuID0gZWFyLm5leHRaO1xuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgaW4gYm90aCBkaXJlY3Rpb25zXG4gICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblogJiYgbiAmJiBuLnogPD0gbWF4Wikge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55KSAmJiBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuXG4gICAgICAgIGlmIChuLnggPj0geDAgJiYgbi54IDw9IHgxICYmIG4ueSA+PSB5MCAmJiBuLnkgPD0geTEgJiYgbiAhPT0gYSAmJiBuICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55KSAmJiBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuICAgIH1cblxuICAgIC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gaW5jcmVhc2luZyB6LW9yZGVyXG4gICAgd2hpbGUgKG4gJiYgbi56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKG4ueCA+PSB4MCAmJiBuLnggPD0geDEgJiYgbi55ID49IHkwICYmIG4ueSA8PSB5MSAmJiBuICE9PSBhICYmIG4gIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBuLngsIG4ueSkgJiYgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBuID0gbi5uZXh0WjtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gZ28gdGhyb3VnaCBhbGwgcG9seWdvbiBub2RlcyBhbmQgY3VyZSBzbWFsbCBsb2NhbCBzZWxmLWludGVyc2VjdGlvbnNcbmZ1bmN0aW9uIGN1cmVMb2NhbEludGVyc2VjdGlvbnMoc3RhcnQsIHRyaWFuZ2xlcywgZGltKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBhID0gcC5wcmV2LFxuICAgICAgICAgICAgYiA9IHAubmV4dC5uZXh0O1xuXG4gICAgICAgIGlmICghZXF1YWxzKGEsIGIpICYmIGludGVyc2VjdHMoYSwgcCwgcC5uZXh0LCBiKSAmJiBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkpIHtcblxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYS5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwLmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGIuaSAvIGRpbSB8IDApO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwLm5leHQpO1xuXG4gICAgICAgICAgICBwID0gc3RhcnQgPSBiO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGZpbHRlclBvaW50cyhwKTtcbn1cblxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG4gICAgdmFyIGEgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XG4gICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBzcGxpdFBvbHlnb24oYSwgYik7XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgICAgICAgICAgICAgIGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcbiAgICAgICAgICAgICAgICBjID0gZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcbiAgICB2YXIgcXVldWUgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGlzdCA9IGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSk7XG4gICAgICAgIGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XG4gICAgICAgIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xuICAgIH1cblxuICAgIHF1ZXVlLnNvcnQoY29tcGFyZVgpO1xuXG4gICAgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0ZXJOb2RlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlWChhLCBiKSB7XG4gICAgcmV0dXJuIGEueCAtIGIueDtcbn1cblxuLy8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGFuZCBsaW5rIGl0XG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBicmlkZ2UgPSBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpO1xuICAgIGlmICghYnJpZGdlKSB7XG4gICAgICAgIHJldHVybiBvdXRlck5vZGU7XG4gICAgfVxuXG4gICAgdmFyIGJyaWRnZVJldmVyc2UgPSBzcGxpdFBvbHlnb24oYnJpZGdlLCBob2xlKTtcblxuICAgIC8vIGZpbHRlciBjb2xsaW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgIGZpbHRlclBvaW50cyhicmlkZ2VSZXZlcnNlLCBicmlkZ2VSZXZlcnNlLm5leHQpO1xuICAgIHJldHVybiBmaWx0ZXJQb2ludHMoYnJpZGdlLCBicmlkZ2UubmV4dCk7XG59XG5cbi8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBwID0gb3V0ZXJOb2RlLFxuICAgICAgICBoeCA9IGhvbGUueCxcbiAgICAgICAgaHkgPSBob2xlLnksXG4gICAgICAgIHF4ID0gLUluZmluaXR5LFxuICAgICAgICBtO1xuXG4gICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuICAgIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcbiAgICBkbyB7XG4gICAgICAgIGlmIChoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSkge1xuICAgICAgICAgICAgdmFyIHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG4gICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcbiAgICAgICAgICAgICAgICBxeCA9IHg7XG4gICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gaHgpIHJldHVybiBtOyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsZWZ0bW9zdCBlbmRwb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcblxuICAgIGlmICghbSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuICAgIHZhciBzdG9wID0gbSxcbiAgICAgICAgbXggPSBtLngsXG4gICAgICAgIG15ID0gbS55LFxuICAgICAgICB0YW5NaW4gPSBJbmZpbml0eSxcbiAgICAgICAgdGFuO1xuXG4gICAgcCA9IG07XG5cbiAgICBkbyB7XG4gICAgICAgIGlmIChoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcbiAgICAgICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XG5cbiAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcblxuICAgICAgICAgICAgaWYgKGxvY2FsbHlJbnNpZGUocCwgaG9sZSkgJiZcbiAgICAgICAgICAgICAgICAodGFuIDwgdGFuTWluIHx8ICh0YW4gPT09IHRhbk1pbiAmJiAocC54ID4gbS54IHx8IChwLnggPT09IG0ueCAmJiBzZWN0b3JDb250YWluc1NlY3RvcihtLCBwKSkpKSkpIHtcbiAgICAgICAgICAgICAgICBtID0gcDtcbiAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0b3ApO1xuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIHdoZXRoZXIgc2VjdG9yIGluIHZlcnRleCBtIGNvbnRhaW5zIHNlY3RvciBpbiB2ZXJ0ZXggcCBpbiB0aGUgc2FtZSBjb29yZGluYXRlc1xuZnVuY3Rpb24gc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkge1xuICAgIHJldHVybiBhcmVhKG0ucHJldiwgbSwgcC5wcmV2KSA8IDAgJiYgYXJlYShwLm5leHQsIG0sIG0ubmV4dCkgPCAwO1xufVxuXG4vLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnogPT09IDApIHAueiA9IHpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgIHAucHJldlogPSBwLnByZXY7XG4gICAgICAgIHAubmV4dFogPSBwLm5leHQ7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcC5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgcC5wcmV2WiA9IG51bGw7XG5cbiAgICBzb3J0TGlua2VkKHApO1xufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcbiAgICAgICAgaW5TaXplID0gMTtcblxuICAgIGRvIHtcbiAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgIGxpc3QgPSBudWxsO1xuICAgICAgICB0YWlsID0gbnVsbDtcbiAgICAgICAgbnVtTWVyZ2VzID0gMDtcblxuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgbnVtTWVyZ2VzKys7XG4gICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgIHBTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHBTaXplKys7XG4gICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgaWYgKCFxKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xuXG4gICAgICAgICAgICB3aGlsZSAocFNpemUgPiAwIHx8IChxU2l6ZSA+IDAgJiYgcSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwU2l6ZSAhPT0gMCAmJiAocVNpemUgPT09IDAgfHwgIXEgfHwgcC56IDw9IHEueikpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcblxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgICAgICBpblNpemUgKj0gMjtcblxuICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xuXG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGludmVyc2Ugb2YgdGhlIGxvbmdlciBzaWRlIG9mIGRhdGEgYmJveFxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXG4gICAgeCA9ICh4IC0gbWluWCkgKiBpbnZTaXplIHwgMDtcbiAgICB5ID0gKHkgLSBtaW5ZKSAqIGludlNpemUgfCAwO1xuXG4gICAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vLyBmaW5kIHRoZSBsZWZ0bW9zdCBub2RlIG9mIGEgcG9seWdvbiByaW5nXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC54IDwgbGVmdG1vc3QueCB8fCAocC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkpKSBsZWZ0bW9zdCA9IHA7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGxlZnRtb3N0O1xufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gICAgcmV0dXJuIChjeCAtIHB4KSAqIChheSAtIHB5KSA+PSAoYXggLSBweCkgKiAoY3kgLSBweSkgJiZcbiAgICAgICAgICAgKGF4IC0gcHgpICogKGJ5IC0gcHkpID49IChieCAtIHB4KSAqIChheSAtIHB5KSAmJlxuICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgPj0gKGN4IC0gcHgpICogKGJ5IC0gcHkpO1xufVxuXG4vLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XG4gICAgcmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhaW50ZXJzZWN0c1BvbHlnb24oYSwgYikgJiYgLy8gZG9uZXMndCBpbnRlcnNlY3Qgb3RoZXIgZWRnZXNcbiAgICAgICAgICAgKGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSAmJiBtaWRkbGVJbnNpZGUoYSwgYikgJiYgLy8gbG9jYWxseSB2aXNpYmxlXG4gICAgICAgICAgICAoYXJlYShhLnByZXYsIGEsIGIucHJldikgfHwgYXJlYShhLCBiLnByZXYsIGIpKSB8fCAvLyBkb2VzIG5vdCBjcmVhdGUgb3Bwb3NpdGUtZmFjaW5nIHNlY3RvcnNcbiAgICAgICAgICAgIGVxdWFscyhhLCBiKSAmJiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA+IDAgJiYgYXJlYShiLnByZXYsIGIsIGIubmV4dCkgPiAwKTsgLy8gc3BlY2lhbCB6ZXJvLWxlbmd0aCBjYXNlXG59XG5cbi8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcbmZ1bmN0aW9uIGFyZWEocCwgcSwgcikge1xuICAgIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcbmZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xufVxuXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgdmFyIG8xID0gc2lnbihhcmVhKHAxLCBxMSwgcDIpKTtcbiAgICB2YXIgbzIgPSBzaWduKGFyZWEocDEsIHExLCBxMikpO1xuICAgIHZhciBvMyA9IHNpZ24oYXJlYShwMiwgcTIsIHAxKSk7XG4gICAgdmFyIG80ID0gc2lnbihhcmVhKHAyLCBxMiwgcTEpKTtcblxuICAgIGlmIChvMSAhPT0gbzIgJiYgbzMgIT09IG80KSByZXR1cm4gdHJ1ZTsgLy8gZ2VuZXJhbCBjYXNlXG5cbiAgICBpZiAobzEgPT09IDAgJiYgb25TZWdtZW50KHAxLCBwMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBwMiBhcmUgY29sbGluZWFyIGFuZCBwMiBsaWVzIG9uIHAxcTFcbiAgICBpZiAobzIgPT09IDAgJiYgb25TZWdtZW50KHAxLCBxMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBxMiBhcmUgY29sbGluZWFyIGFuZCBxMiBsaWVzIG9uIHAxcTFcbiAgICBpZiAobzMgPT09IDAgJiYgb25TZWdtZW50KHAyLCBwMSwgcTIpKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBwMSBhcmUgY29sbGluZWFyIGFuZCBwMSBsaWVzIG9uIHAycTJcbiAgICBpZiAobzQgPT09IDAgJiYgb25TZWdtZW50KHAyLCBxMSwgcTIpKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBxMSBhcmUgY29sbGluZWFyIGFuZCBxMSBsaWVzIG9uIHAycTJcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gZm9yIGNvbGxpbmVhciBwb2ludHMgcCwgcSwgciwgY2hlY2sgaWYgcG9pbnQgcSBsaWVzIG9uIHNlZ21lbnQgcHJcbmZ1bmN0aW9uIG9uU2VnbWVudChwLCBxLCByKSB7XG4gICAgcmV0dXJuIHEueCA8PSBNYXRoLm1heChwLngsIHIueCkgJiYgcS54ID49IE1hdGgubWluKHAueCwgci54KSAmJiBxLnkgPD0gTWF0aC5tYXgocC55LCByLnkpICYmIHEueSA+PSBNYXRoLm1pbihwLnksIHIueSk7XG59XG5cbmZ1bmN0aW9uIHNpZ24obnVtKSB7XG4gICAgcmV0dXJuIG51bSA+IDAgPyAxIDogbnVtIDwgMCA/IC0xIDogMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgcCA9IGE7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cyhwLCBwLm5leHQsIGEsIGIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPCAwID9cbiAgICAgICAgYXJlYShhLCBiLCBhLm5leHQpID49IDAgJiYgYXJlYShhLCBhLnByZXYsIGIpID49IDAgOlxuICAgICAgICBhcmVhKGEsIGIsIGEucHJldikgPCAwIHx8IGFyZWEoYSwgYS5uZXh0LCBiKSA8IDA7XG59XG5cbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKGEsIGIpIHtcbiAgICB2YXIgcCA9IGEsXG4gICAgICAgIGluc2lkZSA9IGZhbHNlLFxuICAgICAgICBweCA9IChhLnggKyBiLngpIC8gMixcbiAgICAgICAgcHkgPSAoYS55ICsgYi55KSAvIDI7XG4gICAgZG8ge1xuICAgICAgICBpZiAoKChwLnkgPiBweSkgIT09IChwLm5leHQueSA+IHB5KSkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxuICAgICAgICAgICAgICAgIChweCA8IChwLm5leHQueCAtIHAueCkgKiAocHkgLSBwLnkpIC8gKHAubmV4dC55IC0gcC55KSArIHAueCkpXG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGluc2lkZTtcbn1cblxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xuLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oYSwgYikge1xuICAgIHZhciBhMiA9IG5ldyBOb2RlKGEuaSwgYS54LCBhLnkpLFxuICAgICAgICBiMiA9IG5ldyBOb2RlKGIuaSwgYi54LCBiLnkpLFxuICAgICAgICBhbiA9IGEubmV4dCxcbiAgICAgICAgYnAgPSBiLnByZXY7XG5cbiAgICBhLm5leHQgPSBiO1xuICAgIGIucHJldiA9IGE7XG5cbiAgICBhMi5uZXh0ID0gYW47XG4gICAgYW4ucHJldiA9IGEyO1xuXG4gICAgYjIubmV4dCA9IGEyO1xuICAgIGEyLnByZXYgPSBiMjtcblxuICAgIGJwLm5leHQgPSBiMjtcbiAgICBiMi5wcmV2ID0gYnA7XG5cbiAgICByZXR1cm4gYjI7XG59XG5cbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcbiAgICB2YXIgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xuXG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIHAucHJldiA9IHA7XG4gICAgICAgIHAubmV4dCA9IHA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgICAgIHAucHJldiA9IGxhc3Q7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcbiAgICAgICAgbGFzdC5uZXh0ID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUocCkge1xuICAgIHAubmV4dC5wcmV2ID0gcC5wcmV2O1xuICAgIHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXG4gICAgaWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuICAgIGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcbn1cblxuZnVuY3Rpb24gTm9kZShpLCB4LCB5KSB7XG4gICAgLy8gdmVydGV4IGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XG4gICAgdGhpcy5pID0gaTtcblxuICAgIC8vIHZlcnRleCBjb29yZGluYXRlc1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRleCBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcblxuICAgIC8vIHotb3JkZXIgY3VydmUgdmFsdWVcbiAgICB0aGlzLnogPSAwO1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuICAgIHRoaXMucHJldlogPSBudWxsO1xuICAgIHRoaXMubmV4dFogPSBudWxsO1xuXG4gICAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcbiAgICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcbn1cblxuLy8gcmV0dXJuIGEgcGVyY2VudGFnZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHBvbHlnb24gYXJlYSBhbmQgaXRzIHRyaWFuZ3VsYXRpb24gYXJlYTtcbi8vIHVzZWQgdG8gdmVyaWZ5IGNvcnJlY3RuZXNzIG9mIHRyaWFuZ3VsYXRpb25cbmVhcmN1dC5kZXZpYXRpb24gPSBmdW5jdGlvbiAoZGF0YSwgaG9sZUluZGljZXMsIGRpbSwgdHJpYW5nbGVzKSB7XG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoO1xuICAgIHZhciBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblxuICAgIHZhciBwb2x5Z29uQXJlYSA9IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSkpO1xuICAgIGlmIChoYXNIb2xlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBwb2x5Z29uQXJlYSAtPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyaWFuZ2xlc0FyZWEgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIGEgPSB0cmlhbmdsZXNbaV0gKiBkaW07XG4gICAgICAgIHZhciBiID0gdHJpYW5nbGVzW2kgKyAxXSAqIGRpbTtcbiAgICAgICAgdmFyIGMgPSB0cmlhbmdsZXNbaSArIDJdICogZGltO1xuICAgICAgICB0cmlhbmdsZXNBcmVhICs9IE1hdGguYWJzKFxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2NdKSAqIChkYXRhW2IgKyAxXSAtIGRhdGFbYSArIDFdKSAtXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbYl0pICogKGRhdGFbYyArIDFdIC0gZGF0YVthICsgMV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9seWdvbkFyZWEgPT09IDAgJiYgdHJpYW5nbGVzQXJlYSA9PT0gMCA/IDAgOlxuICAgICAgICBNYXRoLmFicygodHJpYW5nbGVzQXJlYSAtIHBvbHlnb25BcmVhKSAvIHBvbHlnb25BcmVhKTtcbn07XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSkge1xuICAgICAgICBzdW0gKz0gKGRhdGFbal0gLSBkYXRhW2ldKSAqIChkYXRhW2kgKyAxXSArIGRhdGFbaiArIDFdKTtcbiAgICAgICAgaiA9IGk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5cbi8vIHR1cm4gYSBwb2x5Z29uIGluIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgZm9ybSAoZS5nLiBhcyBpbiBHZW9KU09OKSBpbnRvIGEgZm9ybSBFYXJjdXQgYWNjZXB0c1xuZWFyY3V0LmZsYXR0ZW4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBkaW0gPSBkYXRhWzBdWzBdLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0ge3ZlcnRpY2VzOiBbXSwgaG9sZXM6IFtdLCBkaW1lbnNpb25zOiBkaW19LFxuICAgICAgICBob2xlSW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykgcmVzdWx0LnZlcnRpY2VzLnB1c2goZGF0YVtpXVtqXVtkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBob2xlSW5kZXggKz0gZGF0YVtpIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0LmhvbGVzLnB1c2goaG9sZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xuXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxudmFyIGNvbmNhdHR5ID0gZnVuY3Rpb24gY29uY2F0dHkoYSwgYikge1xuICAgIHZhciBhcnIgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhcnJbaV0gPSBhW2ldO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgYXJyW2ogKyBhLmxlbmd0aF0gPSBiW2pdO1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG59O1xuXG52YXIgc2xpY3kgPSBmdW5jdGlvbiBzbGljeShhcnJMaWtlLCBvZmZzZXQpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IG9mZnNldCB8fCAwLCBqID0gMDsgaSA8IGFyckxpa2UubGVuZ3RoOyBpICs9IDEsIGogKz0gMSkge1xuICAgICAgICBhcnJbal0gPSBhcnJMaWtlW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcblxudmFyIGpvaW55ID0gZnVuY3Rpb24gKGFyciwgam9pbmVyKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBhcnJbaV07XG4gICAgICAgIGlmIChpICsgMSA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0ciArPSBqb2luZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuYXBwbHkodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljeShhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBjb25jYXR0eShhcmdzLCBhcmd1bWVudHMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICBjb25jYXR0eShhcmdzLCBhcmd1bWVudHMpXG4gICAgICAgICk7XG5cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gbWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3NbaV0gPSAnJCcgKyBpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBqb2lueShib3VuZEFyZ3MsICcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoe30sICcnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHR9XG59XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcbnZhciBoYXNQcm90byA9IHJlcXVpcmUoJ2hhcy1wcm90bycpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCAoXG5cdGhhc1Byb3RvXG5cdFx0PyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXHRcdDogbnVsbFxuKTtcblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQmlnSW50NjRBcnJheSUnOiB0eXBlb2YgQmlnSW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQ2NEFycmF5LFxuXHQnJUJpZ1VpbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdVaW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdVaW50NjRBcnJheSxcblx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVkZWNvZGVVUkklJzogZGVjb2RlVVJJLFxuXHQnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyVlbmNvZGVVUklDb21wb25lbnQlJzogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHQnJUVycm9yJSc6IEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6IEV2YWxFcnJvcixcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6IFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiBVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldFxufTtcblxuaWYgKGdldFByb3RvKSB7XG5cdHRyeSB7XG5cdFx0bnVsbC5lcnJvcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXNoYWRvd3JlYWxtL3B1bGwvMzg0I2lzc3VlY29tbWVudC0xMzY0MjY0MjI5XG5cdFx0dmFyIGVycm9yUHJvdG8gPSBnZXRQcm90byhnZXRQcm90byhlKSk7XG5cdFx0SU5UUklOU0lDU1snJUVycm9yLnByb3RvdHlwZSUnXSA9IGVycm9yUHJvdG87XG5cdH1cbn1cblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbiAmJiBnZXRQcm90bykge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhc293bicpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcbnZhciAkZXhlYyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBSZWdFeHAucHJvdG90eXBlLmV4ZWMpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xuXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0aWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xuXHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWNOYW1lID0gbmFtZTtcblx0dmFyIGFsaWFzO1xuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XG5cdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHR9XG5cblx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcblx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpYXM6IGFsaWFzLFxuXHRcdFx0bmFtZTogaW50cmluc2ljTmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cblxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFsbG93TWlzc2luZyAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdGlmICgkZXhlYygvXiU/W14lXSolPyQvLCBuYW1lKSA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2AlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWUnKTtcblx0fVxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcblxuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcblxudmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMgPSBmdW5jdGlvbiBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzKCkge1xuXHRpZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0dHJ5IHtcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IHZhbHVlOiAxIH0pO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZGVmaW5lUHJvcGVydHlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuaGFzUHJvcGVydHlEZXNjcmlwdG9ycy5oYXNBcnJheUxlbmd0aERlZmluZUJ1ZyA9IGZ1bmN0aW9uIGhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnKCkge1xuXHQvLyBub2RlIHYwLjYgaGFzIGEgYnVnIHdoZXJlIGFycmF5IGxlbmd0aHMgY2FuIGJlIFNldCBidXQgbm90IERlZmluZWRcblx0aWYgKCFoYXNQcm9wZXJ0eURlc2NyaXB0b3JzKCkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiAkZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHZhbHVlOiAxIH0pLmxlbmd0aCAhPT0gMTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIEluIEZpcmVmb3ggNC0yMiwgZGVmaW5pbmcgbGVuZ3RoIG9uIGFuIGFycmF5IHRocm93cyBhbiBleGNlcHRpb24uXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUHJvcGVydHlEZXNjcmlwdG9ycztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRlc3QgPSB7XG5cdGZvbzoge31cbn07XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1Byb3RvKCkge1xuXHRyZXR1cm4geyBfX3Byb3RvX186IHRlc3QgfS5mb28gPT09IHRlc3QuZm9vICYmICEoeyBfX3Byb3RvX186IG51bGwgfSBpbnN0YW5jZW9mICRPYmplY3QpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmUoJy4vc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xudmFyICRoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG5cbi8qKiBAdHlwZSB7KG86IHt9LCBwOiBQcm9wZXJ0eUtleSkgPT4gcCBpcyBrZXlvZiBvfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoY2FsbCwgJGhhc093bik7XG4iLCJleHBvcnQgKiBmcm9tICcuL2lzTW9iaWxlJztcbmV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL2lzTW9iaWxlJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsInZhciBhcHBsZUlwaG9uZSA9IC9pUGhvbmUvaTtcbnZhciBhcHBsZUlwb2QgPSAvaVBvZC9pO1xudmFyIGFwcGxlVGFibGV0ID0gL2lQYWQvaTtcbnZhciBhcHBsZVVuaXZlcnNhbCA9IC9cXGJpT1MtdW5pdmVyc2FsKD86LispTWFjXFxiL2k7XG52YXIgYW5kcm9pZFBob25lID0gL1xcYkFuZHJvaWQoPzouKylNb2JpbGVcXGIvaTtcbnZhciBhbmRyb2lkVGFibGV0ID0gL0FuZHJvaWQvaTtcbnZhciBhbWF6b25QaG9uZSA9IC8oPzpTRDQ5MzBVUnxcXGJTaWxrKD86LispTW9iaWxlXFxiKS9pO1xudmFyIGFtYXpvblRhYmxldCA9IC9TaWxrL2k7XG52YXIgd2luZG93c1Bob25lID0gL1dpbmRvd3MgUGhvbmUvaTtcbnZhciB3aW5kb3dzVGFibGV0ID0gL1xcYldpbmRvd3MoPzouKylBUk1cXGIvaTtcbnZhciBvdGhlckJsYWNrQmVycnkgPSAvQmxhY2tCZXJyeS9pO1xudmFyIG90aGVyQmxhY2tCZXJyeTEwID0gL0JCMTAvaTtcbnZhciBvdGhlck9wZXJhID0gL09wZXJhIE1pbmkvaTtcbnZhciBvdGhlckNocm9tZSA9IC9cXGIoQ3JpT1N8Q2hyb21lKSg/Oi4rKU1vYmlsZS9pO1xudmFyIG90aGVyRmlyZWZveCA9IC9Nb2JpbGUoPzouKylGaXJlZm94XFxiL2k7XG52YXIgaXNBcHBsZVRhYmxldE9uSW9zMTMgPSBmdW5jdGlvbiAobmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdNYWNJbnRlbCcgJiZcbiAgICAgICAgdHlwZW9mIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMSAmJlxuICAgICAgICB0eXBlb2YgTVNTdHJlYW0gPT09ICd1bmRlZmluZWQnKTtcbn07XG5mdW5jdGlvbiBjcmVhdGVNYXRjaCh1c2VyQWdlbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZ2V4KSB7IHJldHVybiByZWdleC50ZXN0KHVzZXJBZ2VudCk7IH07XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc01vYmlsZShwYXJhbSkge1xuICAgIHZhciBuYXYgPSB7XG4gICAgICAgIHVzZXJBZ2VudDogJycsXG4gICAgICAgIHBsYXRmb3JtOiAnJyxcbiAgICAgICAgbWF4VG91Y2hQb2ludHM6IDBcbiAgICB9O1xuICAgIGlmICghcGFyYW0gJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbmF2ID0ge1xuICAgICAgICAgICAgdXNlckFnZW50OiBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICAgICAgcGxhdGZvcm06IG5hdmlnYXRvci5wbGF0Zm9ybSxcbiAgICAgICAgICAgIG1heFRvdWNoUG9pbnRzOiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgMFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hdi51c2VyQWdlbnQgPSBwYXJhbTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyYW0gJiYgcGFyYW0udXNlckFnZW50KSB7XG4gICAgICAgIG5hdiA9IHtcbiAgICAgICAgICAgIHVzZXJBZ2VudDogcGFyYW0udXNlckFnZW50LFxuICAgICAgICAgICAgcGxhdGZvcm06IHBhcmFtLnBsYXRmb3JtLFxuICAgICAgICAgICAgbWF4VG91Y2hQb2ludHM6IHBhcmFtLm1heFRvdWNoUG9pbnRzIHx8IDBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHVzZXJBZ2VudCA9IG5hdi51c2VyQWdlbnQ7XG4gICAgdmFyIHRtcCA9IHVzZXJBZ2VudC5zcGxpdCgnW0ZCQU4nKTtcbiAgICBpZiAodHlwZW9mIHRtcFsxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdXNlckFnZW50ID0gdG1wWzBdO1xuICAgIH1cbiAgICB0bXAgPSB1c2VyQWdlbnQuc3BsaXQoJ1R3aXR0ZXInKTtcbiAgICBpZiAodHlwZW9mIHRtcFsxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdXNlckFnZW50ID0gdG1wWzBdO1xuICAgIH1cbiAgICB2YXIgbWF0Y2ggPSBjcmVhdGVNYXRjaCh1c2VyQWdlbnQpO1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIGFwcGxlOiB7XG4gICAgICAgICAgICBwaG9uZTogbWF0Y2goYXBwbGVJcGhvbmUpICYmICFtYXRjaCh3aW5kb3dzUGhvbmUpLFxuICAgICAgICAgICAgaXBvZDogbWF0Y2goYXBwbGVJcG9kKSxcbiAgICAgICAgICAgIHRhYmxldDogIW1hdGNoKGFwcGxlSXBob25lKSAmJlxuICAgICAgICAgICAgICAgIChtYXRjaChhcHBsZVRhYmxldCkgfHwgaXNBcHBsZVRhYmxldE9uSW9zMTMobmF2KSkgJiZcbiAgICAgICAgICAgICAgICAhbWF0Y2god2luZG93c1Bob25lKSxcbiAgICAgICAgICAgIHVuaXZlcnNhbDogbWF0Y2goYXBwbGVVbml2ZXJzYWwpLFxuICAgICAgICAgICAgZGV2aWNlOiAobWF0Y2goYXBwbGVJcGhvbmUpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2goYXBwbGVJcG9kKSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoKGFwcGxlVGFibGV0KSB8fFxuICAgICAgICAgICAgICAgIG1hdGNoKGFwcGxlVW5pdmVyc2FsKSB8fFxuICAgICAgICAgICAgICAgIGlzQXBwbGVUYWJsZXRPbklvczEzKG5hdikpICYmXG4gICAgICAgICAgICAgICAgIW1hdGNoKHdpbmRvd3NQaG9uZSlcbiAgICAgICAgfSxcbiAgICAgICAgYW1hem9uOiB7XG4gICAgICAgICAgICBwaG9uZTogbWF0Y2goYW1hem9uUGhvbmUpLFxuICAgICAgICAgICAgdGFibGV0OiAhbWF0Y2goYW1hem9uUGhvbmUpICYmIG1hdGNoKGFtYXpvblRhYmxldCksXG4gICAgICAgICAgICBkZXZpY2U6IG1hdGNoKGFtYXpvblBob25lKSB8fCBtYXRjaChhbWF6b25UYWJsZXQpXG4gICAgICAgIH0sXG4gICAgICAgIGFuZHJvaWQ6IHtcbiAgICAgICAgICAgIHBob25lOiAoIW1hdGNoKHdpbmRvd3NQaG9uZSkgJiYgbWF0Y2goYW1hem9uUGhvbmUpKSB8fFxuICAgICAgICAgICAgICAgICghbWF0Y2god2luZG93c1Bob25lKSAmJiBtYXRjaChhbmRyb2lkUGhvbmUpKSxcbiAgICAgICAgICAgIHRhYmxldDogIW1hdGNoKHdpbmRvd3NQaG9uZSkgJiZcbiAgICAgICAgICAgICAgICAhbWF0Y2goYW1hem9uUGhvbmUpICYmXG4gICAgICAgICAgICAgICAgIW1hdGNoKGFuZHJvaWRQaG9uZSkgJiZcbiAgICAgICAgICAgICAgICAobWF0Y2goYW1hem9uVGFibGV0KSB8fCBtYXRjaChhbmRyb2lkVGFibGV0KSksXG4gICAgICAgICAgICBkZXZpY2U6ICghbWF0Y2god2luZG93c1Bob25lKSAmJlxuICAgICAgICAgICAgICAgIChtYXRjaChhbWF6b25QaG9uZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2goYW1hem9uVGFibGV0KSB8fFxuICAgICAgICAgICAgICAgICAgICBtYXRjaChhbmRyb2lkUGhvbmUpIHx8XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoKGFuZHJvaWRUYWJsZXQpKSkgfHxcbiAgICAgICAgICAgICAgICBtYXRjaCgvXFxib2todHRwXFxiL2kpXG4gICAgICAgIH0sXG4gICAgICAgIHdpbmRvd3M6IHtcbiAgICAgICAgICAgIHBob25lOiBtYXRjaCh3aW5kb3dzUGhvbmUpLFxuICAgICAgICAgICAgdGFibGV0OiBtYXRjaCh3aW5kb3dzVGFibGV0KSxcbiAgICAgICAgICAgIGRldmljZTogbWF0Y2god2luZG93c1Bob25lKSB8fCBtYXRjaCh3aW5kb3dzVGFibGV0KVxuICAgICAgICB9LFxuICAgICAgICBvdGhlcjoge1xuICAgICAgICAgICAgYmxhY2tiZXJyeTogbWF0Y2gob3RoZXJCbGFja0JlcnJ5KSxcbiAgICAgICAgICAgIGJsYWNrYmVycnkxMDogbWF0Y2gob3RoZXJCbGFja0JlcnJ5MTApLFxuICAgICAgICAgICAgb3BlcmE6IG1hdGNoKG90aGVyT3BlcmEpLFxuICAgICAgICAgICAgZmlyZWZveDogbWF0Y2gob3RoZXJGaXJlZm94KSxcbiAgICAgICAgICAgIGNocm9tZTogbWF0Y2gob3RoZXJDaHJvbWUpLFxuICAgICAgICAgICAgZGV2aWNlOiBtYXRjaChvdGhlckJsYWNrQmVycnkpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2gob3RoZXJCbGFja0JlcnJ5MTApIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2gob3RoZXJPcGVyYSkgfHxcbiAgICAgICAgICAgICAgICBtYXRjaChvdGhlckZpcmVmb3gpIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2gob3RoZXJDaHJvbWUpXG4gICAgICAgIH0sXG4gICAgICAgIGFueTogZmFsc2UsXG4gICAgICAgIHBob25lOiBmYWxzZSxcbiAgICAgICAgdGFibGV0OiBmYWxzZVxuICAgIH07XG4gICAgcmVzdWx0LmFueSA9XG4gICAgICAgIHJlc3VsdC5hcHBsZS5kZXZpY2UgfHxcbiAgICAgICAgICAgIHJlc3VsdC5hbmRyb2lkLmRldmljZSB8fFxuICAgICAgICAgICAgcmVzdWx0LndpbmRvd3MuZGV2aWNlIHx8XG4gICAgICAgICAgICByZXN1bHQub3RoZXIuZGV2aWNlO1xuICAgIHJlc3VsdC5waG9uZSA9XG4gICAgICAgIHJlc3VsdC5hcHBsZS5waG9uZSB8fCByZXN1bHQuYW5kcm9pZC5waG9uZSB8fCByZXN1bHQud2luZG93cy5waG9uZTtcbiAgICByZXN1bHQudGFibGV0ID1cbiAgICAgICAgcmVzdWx0LmFwcGxlLnRhYmxldCB8fCByZXN1bHQuYW5kcm9pZC50YWJsZXQgfHwgcmVzdWx0LndpbmRvd3MudGFibGV0O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc01vYmlsZS5qcy5tYXAiLCJ2YXIgaGFzTWFwID0gdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXAucHJvdG90eXBlO1xudmFyIG1hcFNpemVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBoYXNNYXAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1hcC5wcm90b3R5cGUsICdzaXplJykgOiBudWxsO1xudmFyIG1hcFNpemUgPSBoYXNNYXAgJiYgbWFwU2l6ZURlc2NyaXB0b3IgJiYgdHlwZW9mIG1hcFNpemVEZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyA/IG1hcFNpemVEZXNjcmlwdG9yLmdldCA6IG51bGw7XG52YXIgbWFwRm9yRWFjaCA9IGhhc01hcCAmJiBNYXAucHJvdG90eXBlLmZvckVhY2g7XG52YXIgaGFzU2V0ID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBTZXQucHJvdG90eXBlO1xudmFyIHNldFNpemVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBoYXNTZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFNldC5wcm90b3R5cGUsICdzaXplJykgOiBudWxsO1xudmFyIHNldFNpemUgPSBoYXNTZXQgJiYgc2V0U2l6ZURlc2NyaXB0b3IgJiYgdHlwZW9mIHNldFNpemVEZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyA/IHNldFNpemVEZXNjcmlwdG9yLmdldCA6IG51bGw7XG52YXIgc2V0Rm9yRWFjaCA9IGhhc1NldCAmJiBTZXQucHJvdG90eXBlLmZvckVhY2g7XG52YXIgaGFzV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIFdlYWtNYXAucHJvdG90eXBlO1xudmFyIHdlYWtNYXBIYXMgPSBoYXNXZWFrTWFwID8gV2Vha01hcC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbnZhciBoYXNXZWFrU2V0ID0gdHlwZW9mIFdlYWtTZXQgPT09ICdmdW5jdGlvbicgJiYgV2Vha1NldC5wcm90b3R5cGU7XG52YXIgd2Vha1NldEhhcyA9IGhhc1dlYWtTZXQgPyBXZWFrU2V0LnByb3RvdHlwZS5oYXMgOiBudWxsO1xudmFyIGhhc1dlYWtSZWYgPSB0eXBlb2YgV2Vha1JlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWFrUmVmLnByb3RvdHlwZTtcbnZhciB3ZWFrUmVmRGVyZWYgPSBoYXNXZWFrUmVmID8gV2Vha1JlZi5wcm90b3R5cGUuZGVyZWYgOiBudWxsO1xudmFyIGJvb2xlYW5WYWx1ZU9mID0gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZjtcbnZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciAkbWF0Y2ggPSBTdHJpbmcucHJvdG90eXBlLm1hdGNoO1xudmFyICRzbGljZSA9IFN0cmluZy5wcm90b3R5cGUuc2xpY2U7XG52YXIgJHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG52YXIgJHRvVXBwZXJDYXNlID0gU3RyaW5nLnByb3RvdHlwZS50b1VwcGVyQ2FzZTtcbnZhciAkdG9Mb3dlckNhc2UgPSBTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlO1xudmFyICR0ZXN0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0O1xudmFyICRjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xudmFyICRqb2luID0gQXJyYXkucHJvdG90eXBlLmpvaW47XG52YXIgJGFyclNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyICRmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgYmlnSW50VmFsdWVPZiA9IHR5cGVvZiBCaWdJbnQgPT09ICdmdW5jdGlvbicgPyBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YgOiBudWxsO1xudmFyIGdPUFMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIHN5bVRvU3RyaW5nID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJyA/IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgOiBudWxsO1xudmFyIGhhc1NoYW1tZWRTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnb2JqZWN0Jztcbi8vIGllLCBgaGFzLXRvc3RyaW5ndGFnL3NoYW1zXG52YXIgdG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gaGFzU2hhbW1lZFN5bWJvbHMgPyAnb2JqZWN0JyA6ICdzeW1ib2wnKVxuICAgID8gU3ltYm9sLnRvU3RyaW5nVGFnXG4gICAgOiBudWxsO1xudmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbnZhciBnUE8gPSAodHlwZW9mIFJlZmxlY3QgPT09ICdmdW5jdGlvbicgPyBSZWZsZWN0LmdldFByb3RvdHlwZU9mIDogT2JqZWN0LmdldFByb3RvdHlwZU9mKSB8fCAoXG4gICAgW10uX19wcm90b19fID09PSBBcnJheS5wcm90b3R5cGUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuICAgICAgICA/IGZ1bmN0aW9uIChPKSB7XG4gICAgICAgICAgICByZXR1cm4gTy5fX3Byb3RvX187IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cbiAgICAgICAgfVxuICAgICAgICA6IG51bGxcbik7XG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNTZXBhcmF0b3IobnVtLCBzdHIpIHtcbiAgICBpZiAoXG4gICAgICAgIG51bSA9PT0gSW5maW5pdHlcbiAgICAgICAgfHwgbnVtID09PSAtSW5maW5pdHlcbiAgICAgICAgfHwgbnVtICE9PSBudW1cbiAgICAgICAgfHwgKG51bSAmJiBudW0gPiAtMTAwMCAmJiBudW0gPCAxMDAwKVxuICAgICAgICB8fCAkdGVzdC5jYWxsKC9lLywgc3RyKVxuICAgICkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICB2YXIgc2VwUmVnZXggPSAvWzAtOV0oPz0oPzpbMC05XXszfSkrKD8hWzAtOV0pKS9nO1xuICAgIGlmICh0eXBlb2YgbnVtID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgaW50ID0gbnVtIDwgMCA/IC0kZmxvb3IoLW51bSkgOiAkZmxvb3IobnVtKTsgLy8gdHJ1bmMobnVtKVxuICAgICAgICBpZiAoaW50ICE9PSBudW0pIHtcbiAgICAgICAgICAgIHZhciBpbnRTdHIgPSBTdHJpbmcoaW50KTtcbiAgICAgICAgICAgIHZhciBkZWMgPSAkc2xpY2UuY2FsbChzdHIsIGludFN0ci5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKGludFN0ciwgc2VwUmVnZXgsICckJl8nKSArICcuJyArICRyZXBsYWNlLmNhbGwoJHJlcGxhY2UuY2FsbChkZWMsIC8oWzAtOV17M30pL2csICckJl8nKSwgL18kLywgJycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKHN0ciwgc2VwUmVnZXgsICckJl8nKTtcbn1cblxudmFyIHV0aWxJbnNwZWN0ID0gcmVxdWlyZSgnLi91dGlsLmluc3BlY3QnKTtcbnZhciBpbnNwZWN0Q3VzdG9tID0gdXRpbEluc3BlY3QuY3VzdG9tO1xudmFyIGluc3BlY3RTeW1ib2wgPSBpc1N5bWJvbChpbnNwZWN0Q3VzdG9tKSA/IGluc3BlY3RDdXN0b20gOiBudWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluc3BlY3RfKG9iaiwgb3B0aW9ucywgZGVwdGgsIHNlZW4pIHtcbiAgICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoaGFzKG9wdHMsICdxdW90ZVN0eWxlJykgJiYgKG9wdHMucXVvdGVTdHlsZSAhPT0gJ3NpbmdsZScgJiYgb3B0cy5xdW90ZVN0eWxlICE9PSAnZG91YmxlJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwicXVvdGVTdHlsZVwiIG11c3QgYmUgXCJzaW5nbGVcIiBvciBcImRvdWJsZVwiJyk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICAgaGFzKG9wdHMsICdtYXhTdHJpbmdMZW5ndGgnKSAmJiAodHlwZW9mIG9wdHMubWF4U3RyaW5nTGVuZ3RoID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyBvcHRzLm1heFN0cmluZ0xlbmd0aCA8IDAgJiYgb3B0cy5tYXhTdHJpbmdMZW5ndGggIT09IEluZmluaXR5XG4gICAgICAgICAgICA6IG9wdHMubWF4U3RyaW5nTGVuZ3RoICE9PSBudWxsXG4gICAgICAgIClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwibWF4U3RyaW5nTGVuZ3RoXCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgSW5maW5pdHksIG9yIGBudWxsYCcpO1xuICAgIH1cbiAgICB2YXIgY3VzdG9tSW5zcGVjdCA9IGhhcyhvcHRzLCAnY3VzdG9tSW5zcGVjdCcpID8gb3B0cy5jdXN0b21JbnNwZWN0IDogdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGN1c3RvbUluc3BlY3QgIT09ICdib29sZWFuJyAmJiBjdXN0b21JbnNwZWN0ICE9PSAnc3ltYm9sJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJjdXN0b21JbnNwZWN0XCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGB0cnVlYCwgYGZhbHNlYCwgb3IgYFxcJ3N5bWJvbFxcJ2AnKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgIGhhcyhvcHRzLCAnaW5kZW50JylcbiAgICAgICAgJiYgb3B0cy5pbmRlbnQgIT09IG51bGxcbiAgICAgICAgJiYgb3B0cy5pbmRlbnQgIT09ICdcXHQnXG4gICAgICAgICYmICEocGFyc2VJbnQob3B0cy5pbmRlbnQsIDEwKSA9PT0gb3B0cy5pbmRlbnQgJiYgb3B0cy5pbmRlbnQgPiAwKVxuICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJpbmRlbnRcIiBtdXN0IGJlIFwiXFxcXHRcIiwgYW4gaW50ZWdlciA+IDAsIG9yIGBudWxsYCcpO1xuICAgIH1cbiAgICBpZiAoaGFzKG9wdHMsICdudW1lcmljU2VwYXJhdG9yJykgJiYgdHlwZW9mIG9wdHMubnVtZXJpY1NlcGFyYXRvciAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcIm51bWVyaWNTZXBhcmF0b3JcIiwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYHRydWVgIG9yIGBmYWxzZWAnKTtcbiAgICB9XG4gICAgdmFyIG51bWVyaWNTZXBhcmF0b3IgPSBvcHRzLm51bWVyaWNTZXBhcmF0b3I7XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIG9iaiA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbnNwZWN0U3RyaW5nKG9iaiwgb3B0cyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAob2JqID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHkgLyBvYmogPiAwID8gJzAnIDogJy0wJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyID0gU3RyaW5nKG9iaik7XG4gICAgICAgIHJldHVybiBudW1lcmljU2VwYXJhdG9yID8gYWRkTnVtZXJpY1NlcGFyYXRvcihvYmosIHN0cikgOiBzdHI7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnYmlnaW50Jykge1xuICAgICAgICB2YXIgYmlnSW50U3RyID0gU3RyaW5nKG9iaikgKyAnbic7XG4gICAgICAgIHJldHVybiBudW1lcmljU2VwYXJhdG9yID8gYWRkTnVtZXJpY1NlcGFyYXRvcihvYmosIGJpZ0ludFN0cikgOiBiaWdJbnRTdHI7XG4gICAgfVxuXG4gICAgdmFyIG1heERlcHRoID0gdHlwZW9mIG9wdHMuZGVwdGggPT09ICd1bmRlZmluZWQnID8gNSA6IG9wdHMuZGVwdGg7XG4gICAgaWYgKHR5cGVvZiBkZXB0aCA9PT0gJ3VuZGVmaW5lZCcpIHsgZGVwdGggPSAwOyB9XG4gICAgaWYgKGRlcHRoID49IG1heERlcHRoICYmIG1heERlcHRoID4gMCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNBcnJheShvYmopID8gJ1tBcnJheV0nIDogJ1tPYmplY3RdJztcbiAgICB9XG5cbiAgICB2YXIgaW5kZW50ID0gZ2V0SW5kZW50KG9wdHMsIGRlcHRoKTtcblxuICAgIGlmICh0eXBlb2Ygc2VlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VlbiA9IFtdO1xuICAgIH0gZWxzZSBpZiAoaW5kZXhPZihzZWVuLCBvYmopID49IDApIHtcbiAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnNwZWN0KHZhbHVlLCBmcm9tLCBub0luZGVudCkge1xuICAgICAgICBpZiAoZnJvbSkge1xuICAgICAgICAgICAgc2VlbiA9ICRhcnJTbGljZS5jYWxsKHNlZW4pO1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub0luZGVudCkge1xuICAgICAgICAgICAgdmFyIG5ld09wdHMgPSB7XG4gICAgICAgICAgICAgICAgZGVwdGg6IG9wdHMuZGVwdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGFzKG9wdHMsICdxdW90ZVN0eWxlJykpIHtcbiAgICAgICAgICAgICAgICBuZXdPcHRzLnF1b3RlU3R5bGUgPSBvcHRzLnF1b3RlU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdF8odmFsdWUsIG5ld09wdHMsIGRlcHRoICsgMSwgc2Vlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3BlY3RfKHZhbHVlLCBvcHRzLCBkZXB0aCArIDEsIHNlZW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nICYmICFpc1JlZ0V4cChvYmopKSB7IC8vIGluIG9sZGVyIGVuZ2luZXMsIHJlZ2V4ZXMgYXJlIGNhbGxhYmxlXG4gICAgICAgIHZhciBuYW1lID0gbmFtZU9mKG9iaik7XG4gICAgICAgIHZhciBrZXlzID0gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpO1xuICAgICAgICByZXR1cm4gJ1tGdW5jdGlvbicgKyAobmFtZSA/ICc6ICcgKyBuYW1lIDogJyAoYW5vbnltb3VzKScpICsgJ10nICsgKGtleXMubGVuZ3RoID4gMCA/ICcgeyAnICsgJGpvaW4uY2FsbChrZXlzLCAnLCAnKSArICcgfScgOiAnJyk7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChvYmopKSB7XG4gICAgICAgIHZhciBzeW1TdHJpbmcgPSBoYXNTaGFtbWVkU3ltYm9scyA/ICRyZXBsYWNlLmNhbGwoU3RyaW5nKG9iaiksIC9eKFN5bWJvbFxcKC4qXFwpKV9bXildKiQvLCAnJDEnKSA6IHN5bVRvU3RyaW5nLmNhbGwob2JqKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFoYXNTaGFtbWVkU3ltYm9scyA/IG1hcmtCb3hlZChzeW1TdHJpbmcpIDogc3ltU3RyaW5nO1xuICAgIH1cbiAgICBpZiAoaXNFbGVtZW50KG9iaikpIHtcbiAgICAgICAgdmFyIHMgPSAnPCcgKyAkdG9Mb3dlckNhc2UuY2FsbChTdHJpbmcob2JqLm5vZGVOYW1lKSk7XG4gICAgICAgIHZhciBhdHRycyA9IG9iai5hdHRyaWJ1dGVzIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzICs9ICcgJyArIGF0dHJzW2ldLm5hbWUgKyAnPScgKyB3cmFwUXVvdGVzKHF1b3RlKGF0dHJzW2ldLnZhbHVlKSwgJ2RvdWJsZScsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIHMgKz0gJz4nO1xuICAgICAgICBpZiAob2JqLmNoaWxkTm9kZXMgJiYgb2JqLmNoaWxkTm9kZXMubGVuZ3RoKSB7IHMgKz0gJy4uLic7IH1cbiAgICAgICAgcyArPSAnPC8nICsgJHRvTG93ZXJDYXNlLmNhbGwoU3RyaW5nKG9iai5ub2RlTmFtZSkpICsgJz4nO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJ1tdJzsgfVxuICAgICAgICB2YXIgeHMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIGlmIChpbmRlbnQgJiYgIXNpbmdsZUxpbmVWYWx1ZXMoeHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgaW5kZW50ZWRKb2luKHhzLCBpbmRlbnQpICsgJ10nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnWyAnICsgJGpvaW4uY2FsbCh4cywgJywgJykgKyAnIF0nO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcihvYmopKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgaWYgKCEoJ2NhdXNlJyBpbiBFcnJvci5wcm90b3R5cGUpICYmICdjYXVzZScgaW4gb2JqICYmICFpc0VudW1lcmFibGUuY2FsbChvYmosICdjYXVzZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3sgWycgKyBTdHJpbmcob2JqKSArICddICcgKyAkam9pbi5jYWxsKCRjb25jYXQuY2FsbCgnW2NhdXNlXTogJyArIGluc3BlY3Qob2JqLmNhdXNlKSwgcGFydHMpLCAnLCAnKSArICcgfSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJ1snICsgU3RyaW5nKG9iaikgKyAnXSc7IH1cbiAgICAgICAgcmV0dXJuICd7IFsnICsgU3RyaW5nKG9iaikgKyAnXSAnICsgJGpvaW4uY2FsbChwYXJ0cywgJywgJykgKyAnIH0nO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgY3VzdG9tSW5zcGVjdCkge1xuICAgICAgICBpZiAoaW5zcGVjdFN5bWJvbCAmJiB0eXBlb2Ygb2JqW2luc3BlY3RTeW1ib2xdID09PSAnZnVuY3Rpb24nICYmIHV0aWxJbnNwZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbEluc3BlY3Qob2JqLCB7IGRlcHRoOiBtYXhEZXB0aCAtIGRlcHRoIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGN1c3RvbUluc3BlY3QgIT09ICdzeW1ib2wnICYmIHR5cGVvZiBvYmouaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5pbnNwZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTWFwKG9iaikpIHtcbiAgICAgICAgdmFyIG1hcFBhcnRzID0gW107XG4gICAgICAgIGlmIChtYXBGb3JFYWNoKSB7XG4gICAgICAgICAgICBtYXBGb3JFYWNoLmNhbGwob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIG1hcFBhcnRzLnB1c2goaW5zcGVjdChrZXksIG9iaiwgdHJ1ZSkgKyAnID0+ICcgKyBpbnNwZWN0KHZhbHVlLCBvYmopKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uT2YoJ01hcCcsIG1hcFNpemUuY2FsbChvYmopLCBtYXBQYXJ0cywgaW5kZW50KTtcbiAgICB9XG4gICAgaWYgKGlzU2V0KG9iaikpIHtcbiAgICAgICAgdmFyIHNldFBhcnRzID0gW107XG4gICAgICAgIGlmIChzZXRGb3JFYWNoKSB7XG4gICAgICAgICAgICBzZXRGb3JFYWNoLmNhbGwob2JqLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzZXRQYXJ0cy5wdXNoKGluc3BlY3QodmFsdWUsIG9iaikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25PZignU2V0Jywgc2V0U2l6ZS5jYWxsKG9iaiksIHNldFBhcnRzLCBpbmRlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNXZWFrTWFwKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHdlYWtDb2xsZWN0aW9uT2YoJ1dlYWtNYXAnKTtcbiAgICB9XG4gICAgaWYgKGlzV2Vha1NldChvYmopKSB7XG4gICAgICAgIHJldHVybiB3ZWFrQ29sbGVjdGlvbk9mKCdXZWFrU2V0Jyk7XG4gICAgfVxuICAgIGlmIChpc1dlYWtSZWYob2JqKSkge1xuICAgICAgICByZXR1cm4gd2Vha0NvbGxlY3Rpb25PZignV2Vha1JlZicpO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGluc3BlY3QoTnVtYmVyKG9iaikpKTtcbiAgICB9XG4gICAgaWYgKGlzQmlnSW50KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChpbnNwZWN0KGJpZ0ludFZhbHVlT2YuY2FsbChvYmopKSk7XG4gICAgfVxuICAgIGlmIChpc0Jvb2xlYW4ob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGJvb2xlYW5WYWx1ZU9mLmNhbGwob2JqKSk7XG4gICAgfVxuICAgIGlmIChpc1N0cmluZyhvYmopKSB7XG4gICAgICAgIHJldHVybiBtYXJrQm94ZWQoaW5zcGVjdChTdHJpbmcob2JqKSkpO1xuICAgIH1cbiAgICAvLyBub3RlOiBpbiBJRSA4LCBzb21ldGltZXMgYGdsb2JhbCAhPT0gd2luZG93YCBidXQgYm90aCBhcmUgdGhlIHByb3RvdHlwZXMgb2YgZWFjaCBvdGhlclxuICAgIC8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBvYmogPT09IHdpbmRvdykge1xuICAgICAgICByZXR1cm4gJ3sgW29iamVjdCBXaW5kb3ddIH0nO1xuICAgIH1cbiAgICBpZiAob2JqID09PSBnbG9iYWwpIHtcbiAgICAgICAgcmV0dXJuICd7IFtvYmplY3QgZ2xvYmFsVGhpc10gfSc7XG4gICAgfVxuICAgIGlmICghaXNEYXRlKG9iaikgJiYgIWlzUmVnRXhwKG9iaikpIHtcbiAgICAgICAgdmFyIHlzID0gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpO1xuICAgICAgICB2YXIgaXNQbGFpbk9iamVjdCA9IGdQTyA/IGdQTyhvYmopID09PSBPYmplY3QucHJvdG90eXBlIDogb2JqIGluc3RhbmNlb2YgT2JqZWN0IHx8IG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICAgICAgICB2YXIgcHJvdG9UYWcgPSBvYmogaW5zdGFuY2VvZiBPYmplY3QgPyAnJyA6ICdudWxsIHByb3RvdHlwZSc7XG4gICAgICAgIHZhciBzdHJpbmdUYWcgPSAhaXNQbGFpbk9iamVjdCAmJiB0b1N0cmluZ1RhZyAmJiBPYmplY3Qob2JqKSA9PT0gb2JqICYmIHRvU3RyaW5nVGFnIGluIG9iaiA/ICRzbGljZS5jYWxsKHRvU3RyKG9iaiksIDgsIC0xKSA6IHByb3RvVGFnID8gJ09iamVjdCcgOiAnJztcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yVGFnID0gaXNQbGFpbk9iamVjdCB8fCB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nID8gJycgOiBvYmouY29uc3RydWN0b3IubmFtZSA/IG9iai5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnIDogJyc7XG4gICAgICAgIHZhciB0YWcgPSBjb25zdHJ1Y3RvclRhZyArIChzdHJpbmdUYWcgfHwgcHJvdG9UYWcgPyAnWycgKyAkam9pbi5jYWxsKCRjb25jYXQuY2FsbChbXSwgc3RyaW5nVGFnIHx8IFtdLCBwcm90b1RhZyB8fCBbXSksICc6ICcpICsgJ10gJyA6ICcnKTtcbiAgICAgICAgaWYgKHlzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gdGFnICsgJ3t9JzsgfVxuICAgICAgICBpZiAoaW5kZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFnICsgJ3snICsgaW5kZW50ZWRKb2luKHlzLCBpbmRlbnQpICsgJ30nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWcgKyAneyAnICsgJGpvaW4uY2FsbCh5cywgJywgJykgKyAnIH0nO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKG9iaik7XG59O1xuXG5mdW5jdGlvbiB3cmFwUXVvdGVzKHMsIGRlZmF1bHRTdHlsZSwgb3B0cykge1xuICAgIHZhciBxdW90ZUNoYXIgPSAob3B0cy5xdW90ZVN0eWxlIHx8IGRlZmF1bHRTdHlsZSkgPT09ICdkb3VibGUnID8gJ1wiJyA6IFwiJ1wiO1xuICAgIHJldHVybiBxdW90ZUNoYXIgKyBzICsgcXVvdGVDaGFyO1xufVxuXG5mdW5jdGlvbiBxdW90ZShzKSB7XG4gICAgcmV0dXJuICRyZXBsYWNlLmNhbGwoU3RyaW5nKHMpLCAvXCIvZywgJyZxdW90OycpO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzRGF0ZShvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc0Vycm9yKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc051bWJlcihvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNCb29sZWFuKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuXG4vLyBTeW1ib2wgYW5kIEJpZ0ludCBkbyBoYXZlIFN5bWJvbC50b1N0cmluZ1RhZyBieSBzcGVjLCBzbyB0aGF0IGNhbid0IGJlIHVzZWQgdG8gZWxpbWluYXRlIGZhbHNlIHBvc2l0aXZlc1xuZnVuY3Rpb24gaXNTeW1ib2wob2JqKSB7XG4gICAgaWYgKGhhc1NoYW1tZWRTeW1ib2xzKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqIGluc3RhbmNlb2YgU3ltYm9sO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8ICFzeW1Ub1N0cmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHN5bVRvU3RyaW5nLmNhbGwob2JqKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQmlnSW50KG9iaikge1xuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8ICFiaWdJbnRWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgYmlnSW50VmFsdWVPZi5jYWxsKG9iaik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgaW4gdGhpczsgfTtcbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICAgIHJldHVybiBoYXNPd24uY2FsbChvYmosIGtleSk7XG59XG5cbmZ1bmN0aW9uIHRvU3RyKG9iaikge1xuICAgIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKG9iaik7XG59XG5cbmZ1bmN0aW9uIG5hbWVPZihmKSB7XG4gICAgaWYgKGYubmFtZSkgeyByZXR1cm4gZi5uYW1lOyB9XG4gICAgdmFyIG0gPSAkbWF0Y2guY2FsbChmdW5jdGlvblRvU3RyaW5nLmNhbGwoZiksIC9eZnVuY3Rpb25cXHMqKFtcXHckXSspLyk7XG4gICAgaWYgKG0pIHsgcmV0dXJuIG1bMV07IH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICAgIGlmICh4cy5pbmRleE9mKSB7IHJldHVybiB4cy5pbmRleE9mKHgpOyB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHhzW2ldID09PSB4KSB7IHJldHVybiBpOyB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gaXNNYXAoeCkge1xuICAgIGlmICghbWFwU2l6ZSB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBtYXBTaXplLmNhbGwoeCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXRTaXplLmNhbGwoeCk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgTWFwOyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNXZWFrTWFwKHgpIHtcbiAgICBpZiAoIXdlYWtNYXBIYXMgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2Vha01hcEhhcy5jYWxsKHgsIHdlYWtNYXBIYXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2Vha1NldEhhcy5jYWxsKHgsIHdlYWtTZXRIYXMpO1xuICAgICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdlYWtNYXA7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dlYWtSZWYoeCkge1xuICAgIGlmICghd2Vha1JlZkRlcmVmIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHdlYWtSZWZEZXJlZi5jYWxsKHgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNTZXQoeCkge1xuICAgIGlmICghc2V0U2l6ZSB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBzZXRTaXplLmNhbGwoeCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXBTaXplLmNhbGwoeCk7XG4gICAgICAgIH0gY2F0Y2ggKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgU2V0OyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNXZWFrU2V0KHgpIHtcbiAgICBpZiAoIXdlYWtTZXRIYXMgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2Vha1NldEhhcy5jYWxsKHgsIHdlYWtTZXRIYXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2Vha01hcEhhcy5jYWxsKHgsIHdlYWtNYXBIYXMpO1xuICAgICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdlYWtTZXQ7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQoeCkge1xuICAgIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHgubm9kZU5hbWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB4LmdldEF0dHJpYnV0ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaW5zcGVjdFN0cmluZyhzdHIsIG9wdHMpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA+IG9wdHMubWF4U3RyaW5nTGVuZ3RoKSB7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSBzdHIubGVuZ3RoIC0gb3B0cy5tYXhTdHJpbmdMZW5ndGg7XG4gICAgICAgIHZhciB0cmFpbGVyID0gJy4uLiAnICsgcmVtYWluaW5nICsgJyBtb3JlIGNoYXJhY3RlcicgKyAocmVtYWluaW5nID4gMSA/ICdzJyA6ICcnKTtcbiAgICAgICAgcmV0dXJuIGluc3BlY3RTdHJpbmcoJHNsaWNlLmNhbGwoc3RyLCAwLCBvcHRzLm1heFN0cmluZ0xlbmd0aCksIG9wdHMpICsgdHJhaWxlcjtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICB2YXIgcyA9ICRyZXBsYWNlLmNhbGwoJHJlcGxhY2UuY2FsbChzdHIsIC8oWydcXFxcXSkvZywgJ1xcXFwkMScpLCAvW1xceDAwLVxceDFmXS9nLCBsb3dieXRlKTtcbiAgICByZXR1cm4gd3JhcFF1b3RlcyhzLCAnc2luZ2xlJywgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGxvd2J5dGUoYykge1xuICAgIHZhciBuID0gYy5jaGFyQ29kZUF0KDApO1xuICAgIHZhciB4ID0ge1xuICAgICAgICA4OiAnYicsXG4gICAgICAgIDk6ICd0JyxcbiAgICAgICAgMTA6ICduJyxcbiAgICAgICAgMTI6ICdmJyxcbiAgICAgICAgMTM6ICdyJ1xuICAgIH1bbl07XG4gICAgaWYgKHgpIHsgcmV0dXJuICdcXFxcJyArIHg7IH1cbiAgICByZXR1cm4gJ1xcXFx4JyArIChuIDwgMHgxMCA/ICcwJyA6ICcnKSArICR0b1VwcGVyQ2FzZS5jYWxsKG4udG9TdHJpbmcoMTYpKTtcbn1cblxuZnVuY3Rpb24gbWFya0JveGVkKHN0cikge1xuICAgIHJldHVybiAnT2JqZWN0KCcgKyBzdHIgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIHdlYWtDb2xsZWN0aW9uT2YodHlwZSkge1xuICAgIHJldHVybiB0eXBlICsgJyB7ID8gfSc7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25PZih0eXBlLCBzaXplLCBlbnRyaWVzLCBpbmRlbnQpIHtcbiAgICB2YXIgam9pbmVkRW50cmllcyA9IGluZGVudCA/IGluZGVudGVkSm9pbihlbnRyaWVzLCBpbmRlbnQpIDogJGpvaW4uY2FsbChlbnRyaWVzLCAnLCAnKTtcbiAgICByZXR1cm4gdHlwZSArICcgKCcgKyBzaXplICsgJykgeycgKyBqb2luZWRFbnRyaWVzICsgJ30nO1xufVxuXG5mdW5jdGlvbiBzaW5nbGVMaW5lVmFsdWVzKHhzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5kZXhPZih4c1tpXSwgJ1xcbicpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZW50KG9wdHMsIGRlcHRoKSB7XG4gICAgdmFyIGJhc2VJbmRlbnQ7XG4gICAgaWYgKG9wdHMuaW5kZW50ID09PSAnXFx0Jykge1xuICAgICAgICBiYXNlSW5kZW50ID0gJ1xcdCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5pbmRlbnQgPT09ICdudW1iZXInICYmIG9wdHMuaW5kZW50ID4gMCkge1xuICAgICAgICBiYXNlSW5kZW50ID0gJGpvaW4uY2FsbChBcnJheShvcHRzLmluZGVudCArIDEpLCAnICcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBiYXNlOiBiYXNlSW5kZW50LFxuICAgICAgICBwcmV2OiAkam9pbi5jYWxsKEFycmF5KGRlcHRoICsgMSksIGJhc2VJbmRlbnQpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZW50ZWRKb2luKHhzLCBpbmRlbnQpIHtcbiAgICBpZiAoeHMubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJzsgfVxuICAgIHZhciBsaW5lSm9pbmVyID0gJ1xcbicgKyBpbmRlbnQucHJldiArIGluZGVudC5iYXNlO1xuICAgIHJldHVybiBsaW5lSm9pbmVyICsgJGpvaW4uY2FsbCh4cywgJywnICsgbGluZUpvaW5lcikgKyAnXFxuJyArIGluZGVudC5wcmV2O1xufVxuXG5mdW5jdGlvbiBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCkge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqKTtcbiAgICB2YXIgeHMgPSBbXTtcbiAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgeHMubGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHhzW2ldID0gaGFzKG9iaiwgaSkgPyBpbnNwZWN0KG9ialtpXSwgb2JqKSA6ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzeW1zID0gdHlwZW9mIGdPUFMgPT09ICdmdW5jdGlvbicgPyBnT1BTKG9iaikgOiBbXTtcbiAgICB2YXIgc3ltTWFwO1xuICAgIGlmIChoYXNTaGFtbWVkU3ltYm9scykge1xuICAgICAgICBzeW1NYXAgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzeW1zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBzeW1NYXBbJyQnICsgc3ltc1trXV0gPSBzeW1zW2tdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIGlmICghaGFzKG9iaiwga2V5KSkgeyBjb250aW51ZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1jb250aW51ZVxuICAgICAgICBpZiAoaXNBcnIgJiYgU3RyaW5nKE51bWJlcihrZXkpKSA9PT0ga2V5ICYmIGtleSA8IG9iai5sZW5ndGgpIHsgY29udGludWU7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tY29udGludWVcbiAgICAgICAgaWYgKGhhc1NoYW1tZWRTeW1ib2xzICYmIHN5bU1hcFsnJCcgKyBrZXldIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRvIHByZXZlbnQgc2hhbW1lZCBTeW1ib2xzLCB3aGljaCBhcmUgc3RvcmVkIGFzIHN0cmluZ3MsIGZyb20gYmVpbmcgaW5jbHVkZWQgaW4gdGhlIHN0cmluZyBrZXkgc2VjdGlvblxuICAgICAgICAgICAgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoJHRlc3QuY2FsbCgvW15cXHckXS8sIGtleSkpIHtcbiAgICAgICAgICAgIHhzLnB1c2goaW5zcGVjdChrZXksIG9iaikgKyAnOiAnICsgaW5zcGVjdChvYmpba2V5XSwgb2JqKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4cy5wdXNoKGtleSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldLCBvYmopKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGdPUFMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzeW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoaXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW1zW2pdKSkge1xuICAgICAgICAgICAgICAgIHhzLnB1c2goJ1snICsgaW5zcGVjdChzeW1zW2pdKSArICddOiAnICsgaW5zcGVjdChvYmpbc3ltc1tqXV0sIG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4cztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmUgPSByZXF1aXJlKFwiQHBpeGkvY29yZVwiKSwgZmlsdGVyQWxwaGEgPSByZXF1aXJlKFwiQHBpeGkvZmlsdGVyLWFscGhhXCIpLCBmaWx0ZXJCbHVyID0gcmVxdWlyZShcIkBwaXhpL2ZpbHRlci1ibHVyXCIpLCBmaWx0ZXJDb2xvck1hdHJpeCA9IHJlcXVpcmUoXCJAcGl4aS9maWx0ZXItY29sb3ItbWF0cml4XCIpLCBmaWx0ZXJEaXNwbGFjZW1lbnQgPSByZXF1aXJlKFwiQHBpeGkvZmlsdGVyLWRpc3BsYWNlbWVudFwiKSwgZmlsdGVyRnhhYSA9IHJlcXVpcmUoXCJAcGl4aS9maWx0ZXItZnhhYVwiKSwgZmlsdGVyTm9pc2UgPSByZXF1aXJlKFwiQHBpeGkvZmlsdGVyLW5vaXNlXCIpO1xuY29uc3QgZmlsdGVycyA9IHtcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5BbHBoYUZpbHRlclxuICAgKi9cbiAgQWxwaGFGaWx0ZXI6IGZpbHRlckFscGhhLkFscGhhRmlsdGVyLFxuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4xLjBcbiAgICogQHNlZSBQSVhJLkJsdXJGaWx0ZXJcbiAgICovXG4gIEJsdXJGaWx0ZXI6IGZpbHRlckJsdXIuQmx1ckZpbHRlcixcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5CbHVyRmlsdGVyUGFzc1xuICAgKi9cbiAgQmx1ckZpbHRlclBhc3M6IGZpbHRlckJsdXIuQmx1ckZpbHRlclBhc3MsXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKiBAc2VlIFBJWEkuQ29sb3JNYXRyaXhGaWx0ZXJcbiAgICovXG4gIENvbG9yTWF0cml4RmlsdGVyOiBmaWx0ZXJDb2xvck1hdHJpeC5Db2xvck1hdHJpeEZpbHRlcixcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5EaXNwbGFjZW1lbnRGaWx0ZXJcbiAgICovXG4gIERpc3BsYWNlbWVudEZpbHRlcjogZmlsdGVyRGlzcGxhY2VtZW50LkRpc3BsYWNlbWVudEZpbHRlcixcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDcuMS4wXG4gICAqIEBzZWUgUElYSS5GWEFBRmlsdGVyXG4gICAqL1xuICBGWEFBRmlsdGVyOiBmaWx0ZXJGeGFhLkZYQUFGaWx0ZXIsXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjEuMFxuICAgKiBAc2VlIFBJWEkuTm9pc2VGaWx0ZXJcbiAgICovXG4gIE5vaXNlRmlsdGVyOiBmaWx0ZXJOb2lzZS5Ob2lzZUZpbHRlclxufTtcbk9iamVjdC5lbnRyaWVzKGZpbHRlcnMpLmZvckVhY2goKFtrZXksIEZpbHRlckNsYXNzXSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmlsdGVycywga2V5LCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGNvcmUudXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBgZmlsdGVycy4ke2tleX0gaGFzIG1vdmVkIHRvICR7a2V5fWApLCBGaWx0ZXJDbGFzcztcbiAgICB9XG4gIH0pO1xufSk7XG5leHBvcnRzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVycy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xucmVxdWlyZShcIkBwaXhpL21peGluLWNhY2hlLWFzLWJpdG1hcFwiKTtcbnJlcXVpcmUoXCJAcGl4aS9taXhpbi1nZXQtY2hpbGQtYnktbmFtZVwiKTtcbnJlcXVpcmUoXCJAcGl4aS9taXhpbi1nZXQtZ2xvYmFsLXBvc2l0aW9uXCIpO1xudmFyIGZpbHRlcnMgPSByZXF1aXJlKFwiLi9maWx0ZXJzLmpzXCIpLCBhY2Nlc3NpYmlsaXR5ID0gcmVxdWlyZShcIkBwaXhpL2FjY2Vzc2liaWxpdHlcIiksIGFwcCA9IHJlcXVpcmUoXCJAcGl4aS9hcHBcIiksIGFzc2V0cyA9IHJlcXVpcmUoXCJAcGl4aS9hc3NldHNcIiksIGNvbXByZXNzZWRUZXh0dXJlcyA9IHJlcXVpcmUoXCJAcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzXCIpLCBjb3JlID0gcmVxdWlyZShcIkBwaXhpL2NvcmVcIiksIGRpc3BsYXkgPSByZXF1aXJlKFwiQHBpeGkvZGlzcGxheVwiKSwgZXZlbnRzID0gcmVxdWlyZShcIkBwaXhpL2V2ZW50c1wiKSwgZXh0cmFjdCA9IHJlcXVpcmUoXCJAcGl4aS9leHRyYWN0XCIpLCBmaWx0ZXJBbHBoYSA9IHJlcXVpcmUoXCJAcGl4aS9maWx0ZXItYWxwaGFcIiksIGZpbHRlckJsdXIgPSByZXF1aXJlKFwiQHBpeGkvZmlsdGVyLWJsdXJcIiksIGZpbHRlckNvbG9yTWF0cml4ID0gcmVxdWlyZShcIkBwaXhpL2ZpbHRlci1jb2xvci1tYXRyaXhcIiksIGZpbHRlckRpc3BsYWNlbWVudCA9IHJlcXVpcmUoXCJAcGl4aS9maWx0ZXItZGlzcGxhY2VtZW50XCIpLCBmaWx0ZXJGeGFhID0gcmVxdWlyZShcIkBwaXhpL2ZpbHRlci1meGFhXCIpLCBmaWx0ZXJOb2lzZSA9IHJlcXVpcmUoXCJAcGl4aS9maWx0ZXItbm9pc2VcIiksIGdyYXBoaWNzID0gcmVxdWlyZShcIkBwaXhpL2dyYXBoaWNzXCIpLCBtZXNoID0gcmVxdWlyZShcIkBwaXhpL21lc2hcIiksIG1lc2hFeHRyYXMgPSByZXF1aXJlKFwiQHBpeGkvbWVzaC1leHRyYXNcIiksIHBhcnRpY2xlQ29udGFpbmVyID0gcmVxdWlyZShcIkBwaXhpL3BhcnRpY2xlLWNvbnRhaW5lclwiKSwgcHJlcGFyZSA9IHJlcXVpcmUoXCJAcGl4aS9wcmVwYXJlXCIpLCBzcHJpdGUgPSByZXF1aXJlKFwiQHBpeGkvc3ByaXRlXCIpLCBzcHJpdGVBbmltYXRlZCA9IHJlcXVpcmUoXCJAcGl4aS9zcHJpdGUtYW5pbWF0ZWRcIiksIHNwcml0ZVRpbGluZyA9IHJlcXVpcmUoXCJAcGl4aS9zcHJpdGUtdGlsaW5nXCIpLCBzcHJpdGVzaGVldCA9IHJlcXVpcmUoXCJAcGl4aS9zcHJpdGVzaGVldFwiKSwgdGV4dCA9IHJlcXVpcmUoXCJAcGl4aS90ZXh0XCIpLCB0ZXh0Qml0bWFwID0gcmVxdWlyZShcIkBwaXhpL3RleHQtYml0bWFwXCIpLCB0ZXh0SHRtbCA9IHJlcXVpcmUoXCJAcGl4aS90ZXh0LWh0bWxcIik7XG5leHBvcnRzLmZpbHRlcnMgPSBmaWx0ZXJzLmZpbHRlcnM7XG5PYmplY3Qua2V5cyhhY2Nlc3NpYmlsaXR5KS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgayAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBrKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWNjZXNzaWJpbGl0eVtrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhhcHApLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBrICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIGspICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhcHBba107XG4gICAgfVxuICB9KTtcbn0pO1xuT2JqZWN0LmtleXMoYXNzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgayAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBrKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXNzZXRzW2tdO1xuICAgIH1cbiAgfSk7XG59KTtcbk9iamVjdC5rZXlzKGNvbXByZXNzZWRUZXh0dXJlcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIGsgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgaykgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvbXByZXNzZWRUZXh0dXJlc1trXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhjb3JlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgayAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBrKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY29yZVtrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhkaXNwbGF5KS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgayAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBrKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGlzcGxheVtrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhldmVudHMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBrICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIGspICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBldmVudHNba107XG4gICAgfVxuICB9KTtcbn0pO1xuT2JqZWN0LmtleXMoZXh0cmFjdCkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIGsgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgaykgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dHJhY3Rba107XG4gICAgfVxuICB9KTtcbn0pO1xuT2JqZWN0LmtleXMoZmlsdGVyQWxwaGEpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBrICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIGspICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJBbHBoYVtrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhmaWx0ZXJCbHVyKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgayAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBrKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmlsdGVyQmx1cltrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhmaWx0ZXJDb2xvck1hdHJpeCkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIGsgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgaykgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZpbHRlckNvbG9yTWF0cml4W2tdO1xuICAgIH1cbiAgfSk7XG59KTtcbk9iamVjdC5rZXlzKGZpbHRlckRpc3BsYWNlbWVudCkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIGsgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgaykgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZpbHRlckRpc3BsYWNlbWVudFtrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhmaWx0ZXJGeGFhKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgayAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBrKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmlsdGVyRnhhYVtrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhmaWx0ZXJOb2lzZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIGsgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgaykgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZpbHRlck5vaXNlW2tdO1xuICAgIH1cbiAgfSk7XG59KTtcbk9iamVjdC5rZXlzKGdyYXBoaWNzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgayAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBrKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZ3JhcGhpY3Nba107XG4gICAgfVxuICB9KTtcbn0pO1xuT2JqZWN0LmtleXMobWVzaCkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIGsgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgaykgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1lc2hba107XG4gICAgfVxuICB9KTtcbn0pO1xuT2JqZWN0LmtleXMobWVzaEV4dHJhcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIGsgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgaykgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1lc2hFeHRyYXNba107XG4gICAgfVxuICB9KTtcbn0pO1xuT2JqZWN0LmtleXMocGFydGljbGVDb250YWluZXIpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBrICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIGspICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwYXJ0aWNsZUNvbnRhaW5lcltrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhwcmVwYXJlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgayAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBrKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcHJlcGFyZVtrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhzcHJpdGUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBrICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIGspICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzcHJpdGVba107XG4gICAgfVxuICB9KTtcbn0pO1xuT2JqZWN0LmtleXMoc3ByaXRlQW5pbWF0ZWQpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBrICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIGspICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzcHJpdGVBbmltYXRlZFtrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhzcHJpdGVUaWxpbmcpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBrICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIGspICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzcHJpdGVUaWxpbmdba107XG4gICAgfVxuICB9KTtcbn0pO1xuT2JqZWN0LmtleXMoc3ByaXRlc2hlZXQpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBrICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIGspICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzcHJpdGVzaGVldFtrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyh0ZXh0KS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgayAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBrKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGV4dFtrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyh0ZXh0Qml0bWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgayAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBrKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGV4dEJpdG1hcFtrXTtcbiAgICB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyh0ZXh0SHRtbCkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIGsgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgaykgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRleHRIdG1sW2tdO1xuICAgIH1cbiAgfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG52YXIgcGVyY2VudFR3ZW50aWVzID0gLyUyMC9nO1xuXG52YXIgRm9ybWF0ID0ge1xuICAgIFJGQzE3Mzg6ICdSRkMxNzM4JyxcbiAgICBSRkMzOTg2OiAnUkZDMzk4Nidcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdkZWZhdWx0JzogRm9ybWF0LlJGQzM5ODYsXG4gICAgZm9ybWF0dGVyczoge1xuICAgICAgICBSRkMxNzM4OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlLmNhbGwodmFsdWUsIHBlcmNlbnRUd2VudGllcywgJysnKTtcbiAgICAgICAgfSxcbiAgICAgICAgUkZDMzk4NjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgUkZDMTczODogRm9ybWF0LlJGQzE3MzgsXG4gICAgUkZDMzk4NjogRm9ybWF0LlJGQzM5ODZcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZm9ybWF0czogZm9ybWF0cyxcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgICBhbGxvd0RvdHM6IGZhbHNlLFxuICAgIGFsbG93UHJvdG90eXBlczogZmFsc2UsXG4gICAgYWxsb3dTcGFyc2U6IGZhbHNlLFxuICAgIGFycmF5TGltaXQ6IDIwLFxuICAgIGNoYXJzZXQ6ICd1dGYtOCcsXG4gICAgY2hhcnNldFNlbnRpbmVsOiBmYWxzZSxcbiAgICBjb21tYTogZmFsc2UsXG4gICAgZGVjb2RlcjogdXRpbHMuZGVjb2RlLFxuICAgIGRlbGltaXRlcjogJyYnLFxuICAgIGRlcHRoOiA1LFxuICAgIGlnbm9yZVF1ZXJ5UHJlZml4OiBmYWxzZSxcbiAgICBpbnRlcnByZXROdW1lcmljRW50aXRpZXM6IGZhbHNlLFxuICAgIHBhcmFtZXRlckxpbWl0OiAxMDAwLFxuICAgIHBhcnNlQXJyYXlzOiB0cnVlLFxuICAgIHBsYWluT2JqZWN0czogZmFsc2UsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZVxufTtcblxudmFyIGludGVycHJldE51bWVyaWNFbnRpdGllcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYjKFxcZCspOy9nLCBmdW5jdGlvbiAoJDAsIG51bWJlclN0cikge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChudW1iZXJTdHIsIDEwKSk7XG4gICAgfSk7XG59O1xuXG52YXIgcGFyc2VBcnJheVZhbHVlID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgb3B0aW9ucy5jb21tYSAmJiB2YWwuaW5kZXhPZignLCcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5zcGxpdCgnLCcpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG59O1xuXG4vLyBUaGlzIGlzIHdoYXQgYnJvd3NlcnMgd2lsbCBzdWJtaXQgd2hlbiB0aGUg4pyTIGNoYXJhY3RlciBvY2N1cnMgaW4gYW5cbi8vIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBib2R5IGFuZCB0aGUgZW5jb2Rpbmcgb2YgdGhlIHBhZ2UgY29udGFpbmluZ1xuLy8gdGhlIGZvcm0gaXMgaXNvLTg4NTktMSwgb3Igd2hlbiB0aGUgc3VibWl0dGVkIGZvcm0gaGFzIGFuIGFjY2VwdC1jaGFyc2V0XG4vLyBhdHRyaWJ1dGUgb2YgaXNvLTg4NTktMS4gUHJlc3VtYWJseSBhbHNvIHdpdGggb3RoZXIgY2hhcnNldHMgdGhhdCBkbyBub3QgY29udGFpblxuLy8gdGhlIOKckyBjaGFyYWN0ZXIsIHN1Y2ggYXMgdXMtYXNjaWkuXG52YXIgaXNvU2VudGluZWwgPSAndXRmOD0lMjYlMjMxMDAwMyUzQic7IC8vIGVuY29kZVVSSUNvbXBvbmVudCgnJiMxMDAwMzsnKVxuXG4vLyBUaGVzZSBhcmUgdGhlIHBlcmNlbnQtZW5jb2RlZCB1dGYtOCBvY3RldHMgcmVwcmVzZW50aW5nIGEgY2hlY2ttYXJrLCBpbmRpY2F0aW5nIHRoYXQgdGhlIHJlcXVlc3QgYWN0dWFsbHkgaXMgdXRmLTggZW5jb2RlZC5cbnZhciBjaGFyc2V0U2VudGluZWwgPSAndXRmOD0lRTIlOUMlOTMnOyAvLyBlbmNvZGVVUklDb21wb25lbnQoJ+KckycpXG5cbnZhciBwYXJzZVZhbHVlcyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdWYWx1ZXMoc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IHsgX19wcm90b19fOiBudWxsIH07XG5cbiAgICB2YXIgY2xlYW5TdHIgPSBvcHRpb25zLmlnbm9yZVF1ZXJ5UHJlZml4ID8gc3RyLnJlcGxhY2UoL15cXD8vLCAnJykgOiBzdHI7XG4gICAgdmFyIGxpbWl0ID0gb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBvcHRpb25zLnBhcmFtZXRlckxpbWl0O1xuICAgIHZhciBwYXJ0cyA9IGNsZWFuU3RyLnNwbGl0KG9wdGlvbnMuZGVsaW1pdGVyLCBsaW1pdCk7XG4gICAgdmFyIHNraXBJbmRleCA9IC0xOyAvLyBLZWVwIHRyYWNrIG9mIHdoZXJlIHRoZSB1dGY4IHNlbnRpbmVsIHdhcyBmb3VuZFxuICAgIHZhciBpO1xuXG4gICAgdmFyIGNoYXJzZXQgPSBvcHRpb25zLmNoYXJzZXQ7XG4gICAgaWYgKG9wdGlvbnMuY2hhcnNldFNlbnRpbmVsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHBhcnRzW2ldLmluZGV4T2YoJ3V0Zjg9JykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydHNbaV0gPT09IGNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gJ3V0Zi04JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRzW2ldID09PSBpc29TZW50aW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gJ2lzby04ODU5LTEnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGkgPSBwYXJ0cy5sZW5ndGg7IC8vIFRoZSBlc2xpbnQgc2V0dGluZ3MgZG8gbm90IGFsbG93IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChpID09PSBza2lwSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgdmFyIGJyYWNrZXRFcXVhbHNQb3MgPSBwYXJ0LmluZGV4T2YoJ109Jyk7XG4gICAgICAgIHZhciBwb3MgPSBicmFja2V0RXF1YWxzUG9zID09PSAtMSA/IHBhcnQuaW5kZXhPZignPScpIDogYnJhY2tldEVxdWFsc1BvcyArIDE7XG5cbiAgICAgICAgdmFyIGtleSwgdmFsO1xuICAgICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQsIGRlZmF1bHRzLmRlY29kZXIsIGNoYXJzZXQsICdrZXknKTtcbiAgICAgICAgICAgIHZhbCA9IG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID8gbnVsbCA6ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQuc2xpY2UoMCwgcG9zKSwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ2tleScpO1xuICAgICAgICAgICAgdmFsID0gdXRpbHMubWF5YmVNYXAoXG4gICAgICAgICAgICAgICAgcGFyc2VBcnJheVZhbHVlKHBhcnQuc2xpY2UocG9zICsgMSksIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbmNvZGVkVmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRlY29kZXIoZW5jb2RlZFZhbCwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ3ZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgJiYgb3B0aW9ucy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMgJiYgY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgICAgICB2YWwgPSBpbnRlcnByZXROdW1lcmljRW50aXRpZXModmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0LmluZGV4T2YoJ1tdPScpID4gLTEpIHtcbiAgICAgICAgICAgIHZhbCA9IGlzQXJyYXkodmFsKSA/IFt2YWxdIDogdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB1dGlscy5jb21iaW5lKG9ialtrZXldLCB2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIHBhcnNlT2JqZWN0ID0gZnVuY3Rpb24gKGNoYWluLCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCkge1xuICAgIHZhciBsZWFmID0gdmFsdWVzUGFyc2VkID8gdmFsIDogcGFyc2VBcnJheVZhbHVlKHZhbCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBpID0gY2hhaW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIG9iajtcbiAgICAgICAgdmFyIHJvb3QgPSBjaGFpbltpXTtcblxuICAgICAgICBpZiAocm9vdCA9PT0gJ1tdJyAmJiBvcHRpb25zLnBhcnNlQXJyYXlzKSB7XG4gICAgICAgICAgICBvYmogPSBbXS5jb25jYXQobGVhZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgICAgICAgIHZhciBjbGVhblJvb3QgPSByb290LmNoYXJBdCgwKSA9PT0gJ1snICYmIHJvb3QuY2hhckF0KHJvb3QubGVuZ3RoIC0gMSkgPT09ICddJyA/IHJvb3Quc2xpY2UoMSwgLTEpIDogcm9vdDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGNsZWFuUm9vdCwgMTApO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnBhcnNlQXJyYXlzICYmIGNsZWFuUm9vdCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBvYmogPSB7IDA6IGxlYWYgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgIWlzTmFOKGluZGV4KVxuICAgICAgICAgICAgICAgICYmIHJvb3QgIT09IGNsZWFuUm9vdFxuICAgICAgICAgICAgICAgICYmIFN0cmluZyhpbmRleCkgPT09IGNsZWFuUm9vdFxuICAgICAgICAgICAgICAgICYmIGluZGV4ID49IDBcbiAgICAgICAgICAgICAgICAmJiAob3B0aW9ucy5wYXJzZUFycmF5cyAmJiBpbmRleCA8PSBvcHRpb25zLmFycmF5TGltaXQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvYmogPSBbXTtcbiAgICAgICAgICAgICAgICBvYmpbaW5kZXhdID0gbGVhZjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xlYW5Sb290ICE9PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgICAgIG9ialtjbGVhblJvb3RdID0gbGVhZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxlYWYgPSBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlYWY7XG59O1xuXG52YXIgcGFyc2VLZXlzID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZ0tleXMoZ2l2ZW5LZXksIHZhbCwgb3B0aW9ucywgdmFsdWVzUGFyc2VkKSB7XG4gICAgaWYgKCFnaXZlbktleSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhbnNmb3JtIGRvdCBub3RhdGlvbiB0byBicmFja2V0IG5vdGF0aW9uXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuYWxsb3dEb3RzID8gZ2l2ZW5LZXkucmVwbGFjZSgvXFwuKFteLltdKykvZywgJ1skMV0nKSA6IGdpdmVuS2V5O1xuXG4gICAgLy8gVGhlIHJlZ2V4IGNodW5rc1xuXG4gICAgdmFyIGJyYWNrZXRzID0gLyhcXFtbXltcXF1dKl0pLztcbiAgICB2YXIgY2hpbGQgPSAvKFxcW1teW1xcXV0qXSkvZztcblxuICAgIC8vIEdldCB0aGUgcGFyZW50XG5cbiAgICB2YXIgc2VnbWVudCA9IG9wdGlvbnMuZGVwdGggPiAwICYmIGJyYWNrZXRzLmV4ZWMoa2V5KTtcbiAgICB2YXIgcGFyZW50ID0gc2VnbWVudCA/IGtleS5zbGljZSgwLCBzZWdtZW50LmluZGV4KSA6IGtleTtcblxuICAgIC8vIFN0YXNoIHRoZSBwYXJlbnQgaWYgaXQgZXhpc3RzXG5cbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHVzaW5nIHBsYWluIG9iamVjdHMsIG9wdGlvbmFsbHkgcHJlZml4IGtleXMgdGhhdCB3b3VsZCBvdmVyd3JpdGUgb2JqZWN0IHByb3RvdHlwZSBwcm9wZXJ0aWVzXG4gICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgcGFyZW50KSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93UHJvdG90eXBlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGtleXMucHVzaChwYXJlbnQpO1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBjaGlsZHJlbiBhcHBlbmRpbmcgdG8gdGhlIGFycmF5IHVudGlsIHdlIGhpdCBkZXB0aFxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChvcHRpb25zLmRlcHRoID4gMCAmJiAoc2VnbWVudCA9IGNoaWxkLmV4ZWMoa2V5KSkgIT09IG51bGwgJiYgaSA8IG9wdGlvbnMuZGVwdGgpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBpZiAoIW9wdGlvbnMucGxhaW5PYmplY3RzICYmIGhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNlZ21lbnRbMV0uc2xpY2UoMSwgLTEpKSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93UHJvdG90eXBlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrZXlzLnB1c2goc2VnbWVudFsxXSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUncyBhIHJlbWFpbmRlciwganVzdCBhZGQgd2hhdGV2ZXIgaXMgbGVmdFxuXG4gICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAga2V5cy5wdXNoKCdbJyArIGtleS5zbGljZShzZWdtZW50LmluZGV4KSArICddJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlT2JqZWN0KGtleXMsIHZhbCwgb3B0aW9ucywgdmFsdWVzUGFyc2VkKTtcbn07XG5cbnZhciBub3JtYWxpemVQYXJzZU9wdGlvbnMgPSBmdW5jdGlvbiBub3JtYWxpemVQYXJzZU9wdGlvbnMob3B0cykge1xuICAgIGlmICghb3B0cykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuZGVjb2RlciAhPT0gbnVsbCAmJiBvcHRzLmRlY29kZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0cy5kZWNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RlY29kZXIgaGFzIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLmNoYXJzZXQgIT09ICd1bmRlZmluZWQnICYmIG9wdHMuY2hhcnNldCAhPT0gJ3V0Zi04JyAmJiBvcHRzLmNoYXJzZXQgIT09ICdpc28tODg1OS0xJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2hhcnNldCBvcHRpb24gbXVzdCBiZSBlaXRoZXIgdXRmLTgsIGlzby04ODU5LTEsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICB2YXIgY2hhcnNldCA9IHR5cGVvZiBvcHRzLmNoYXJzZXQgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuY2hhcnNldCA6IG9wdHMuY2hhcnNldDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGFsbG93RG90czogdHlwZW9mIG9wdHMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmFsbG93RG90cyA6ICEhb3B0cy5hbGxvd0RvdHMsXG4gICAgICAgIGFsbG93UHJvdG90eXBlczogdHlwZW9mIG9wdHMuYWxsb3dQcm90b3R5cGVzID09PSAnYm9vbGVhbicgPyBvcHRzLmFsbG93UHJvdG90eXBlcyA6IGRlZmF1bHRzLmFsbG93UHJvdG90eXBlcyxcbiAgICAgICAgYWxsb3dTcGFyc2U6IHR5cGVvZiBvcHRzLmFsbG93U3BhcnNlID09PSAnYm9vbGVhbicgPyBvcHRzLmFsbG93U3BhcnNlIDogZGVmYXVsdHMuYWxsb3dTcGFyc2UsXG4gICAgICAgIGFycmF5TGltaXQ6IHR5cGVvZiBvcHRzLmFycmF5TGltaXQgPT09ICdudW1iZXInID8gb3B0cy5hcnJheUxpbWl0IDogZGVmYXVsdHMuYXJyYXlMaW1pdCxcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcbiAgICAgICAgY2hhcnNldFNlbnRpbmVsOiB0eXBlb2Ygb3B0cy5jaGFyc2V0U2VudGluZWwgPT09ICdib29sZWFuJyA/IG9wdHMuY2hhcnNldFNlbnRpbmVsIDogZGVmYXVsdHMuY2hhcnNldFNlbnRpbmVsLFxuICAgICAgICBjb21tYTogdHlwZW9mIG9wdHMuY29tbWEgPT09ICdib29sZWFuJyA/IG9wdHMuY29tbWEgOiBkZWZhdWx0cy5jb21tYSxcbiAgICAgICAgZGVjb2RlcjogdHlwZW9mIG9wdHMuZGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZGVjb2RlciA6IGRlZmF1bHRzLmRlY29kZXIsXG4gICAgICAgIGRlbGltaXRlcjogdHlwZW9mIG9wdHMuZGVsaW1pdGVyID09PSAnc3RyaW5nJyB8fCB1dGlscy5pc1JlZ0V4cChvcHRzLmRlbGltaXRlcikgPyBvcHRzLmRlbGltaXRlciA6IGRlZmF1bHRzLmRlbGltaXRlcixcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uLCBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgZGVwdGg6ICh0eXBlb2Ygb3B0cy5kZXB0aCA9PT0gJ251bWJlcicgfHwgb3B0cy5kZXB0aCA9PT0gZmFsc2UpID8gK29wdHMuZGVwdGggOiBkZWZhdWx0cy5kZXB0aCxcbiAgICAgICAgaWdub3JlUXVlcnlQcmVmaXg6IG9wdHMuaWdub3JlUXVlcnlQcmVmaXggPT09IHRydWUsXG4gICAgICAgIGludGVycHJldE51bWVyaWNFbnRpdGllczogdHlwZW9mIG9wdHMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzID09PSAnYm9vbGVhbicgPyBvcHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyA6IGRlZmF1bHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyxcbiAgICAgICAgcGFyYW1ldGVyTGltaXQ6IHR5cGVvZiBvcHRzLnBhcmFtZXRlckxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdHMucGFyYW1ldGVyTGltaXQgOiBkZWZhdWx0cy5wYXJhbWV0ZXJMaW1pdCxcbiAgICAgICAgcGFyc2VBcnJheXM6IG9wdHMucGFyc2VBcnJheXMgIT09IGZhbHNlLFxuICAgICAgICBwbGFpbk9iamVjdHM6IHR5cGVvZiBvcHRzLnBsYWluT2JqZWN0cyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5wbGFpbk9iamVjdHMgOiBkZWZhdWx0cy5wbGFpbk9iamVjdHMsXG4gICAgICAgIHN0cmljdE51bGxIYW5kbGluZzogdHlwZW9mIG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZ1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG5vcm1hbGl6ZVBhcnNlT3B0aW9ucyhvcHRzKTtcblxuICAgIGlmIChzdHIgPT09ICcnIHx8IHN0ciA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgfVxuXG4gICAgdmFyIHRlbXBPYmogPSB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHBhcnNlVmFsdWVzKHN0ciwgb3B0aW9ucykgOiBzdHI7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBrZXlzIGFuZCBzZXR1cCB0aGUgbmV3IG9iamVjdFxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0ZW1wT2JqKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciBuZXdPYmogPSBwYXJzZUtleXMoa2V5LCB0ZW1wT2JqW2tleV0sIG9wdGlvbnMsIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgb2JqID0gdXRpbHMubWVyZ2Uob2JqLCBuZXdPYmosIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFsbG93U3BhcnNlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLmNvbXBhY3Qob2JqKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXRTaWRlQ2hhbm5lbCA9IHJlcXVpcmUoJ3NpZGUtY2hhbm5lbCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXJyYXlQcmVmaXhHZW5lcmF0b3JzID0ge1xuICAgIGJyYWNrZXRzOiBmdW5jdGlvbiBicmFja2V0cyhwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbXSc7XG4gICAgfSxcbiAgICBjb21tYTogJ2NvbW1hJyxcbiAgICBpbmRpY2VzOiBmdW5jdGlvbiBpbmRpY2VzKHByZWZpeCwga2V5KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnWycgKyBrZXkgKyAnXSc7XG4gICAgfSxcbiAgICByZXBlYXQ6IGZ1bmN0aW9uIHJlcGVhdChwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICB9XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG52YXIgcHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xudmFyIHB1c2hUb0FycmF5ID0gZnVuY3Rpb24gKGFyciwgdmFsdWVPckFycmF5KSB7XG4gICAgcHVzaC5hcHBseShhcnIsIGlzQXJyYXkodmFsdWVPckFycmF5KSA/IHZhbHVlT3JBcnJheSA6IFt2YWx1ZU9yQXJyYXldKTtcbn07XG5cbnZhciB0b0lTTyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nO1xuXG52YXIgZGVmYXVsdEZvcm1hdCA9IGZvcm1hdHNbJ2RlZmF1bHQnXTtcbnZhciBkZWZhdWx0cyA9IHtcbiAgICBhZGRRdWVyeVByZWZpeDogZmFsc2UsXG4gICAgYWxsb3dEb3RzOiBmYWxzZSxcbiAgICBjaGFyc2V0OiAndXRmLTgnLFxuICAgIGNoYXJzZXRTZW50aW5lbDogZmFsc2UsXG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZW5jb2RlOiB0cnVlLFxuICAgIGVuY29kZXI6IHV0aWxzLmVuY29kZSxcbiAgICBlbmNvZGVWYWx1ZXNPbmx5OiBmYWxzZSxcbiAgICBmb3JtYXQ6IGRlZmF1bHRGb3JtYXQsXG4gICAgZm9ybWF0dGVyOiBmb3JtYXRzLmZvcm1hdHRlcnNbZGVmYXVsdEZvcm1hdF0sXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGluZGljZXM6IGZhbHNlLFxuICAgIHNlcmlhbGl6ZURhdGU6IGZ1bmN0aW9uIHNlcmlhbGl6ZURhdGUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gdG9JU08uY2FsbChkYXRlKTtcbiAgICB9LFxuICAgIHNraXBOdWxsczogZmFsc2UsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZVxufTtcblxudmFyIGlzTm9uTnVsbGlzaFByaW1pdGl2ZSA9IGZ1bmN0aW9uIGlzTm9uTnVsbGlzaFByaW1pdGl2ZSh2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAnc3RyaW5nJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcidcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdib29sZWFuJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ3N5bWJvbCdcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdiaWdpbnQnO1xufTtcblxudmFyIHNlbnRpbmVsID0ge307XG5cbnZhciBzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoXG4gICAgb2JqZWN0LFxuICAgIHByZWZpeCxcbiAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgIGNvbW1hUm91bmRUcmlwLFxuICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICBza2lwTnVsbHMsXG4gICAgZW5jb2RlcixcbiAgICBmaWx0ZXIsXG4gICAgc29ydCxcbiAgICBhbGxvd0RvdHMsXG4gICAgc2VyaWFsaXplRGF0ZSxcbiAgICBmb3JtYXQsXG4gICAgZm9ybWF0dGVyLFxuICAgIGVuY29kZVZhbHVlc09ubHksXG4gICAgY2hhcnNldCxcbiAgICBzaWRlQ2hhbm5lbFxuKSB7XG4gICAgdmFyIG9iaiA9IG9iamVjdDtcblxuICAgIHZhciB0bXBTYyA9IHNpZGVDaGFubmVsO1xuICAgIHZhciBzdGVwID0gMDtcbiAgICB2YXIgZmluZEZsYWcgPSBmYWxzZTtcbiAgICB3aGlsZSAoKHRtcFNjID0gdG1wU2MuZ2V0KHNlbnRpbmVsKSkgIT09IHZvaWQgdW5kZWZpbmVkICYmICFmaW5kRmxhZykge1xuICAgICAgICAvLyBXaGVyZSBvYmplY3QgbGFzdCBhcHBlYXJlZCBpbiB0aGUgcmVmIHRyZWVcbiAgICAgICAgdmFyIHBvcyA9IHRtcFNjLmdldChvYmplY3QpO1xuICAgICAgICBzdGVwICs9IDE7XG4gICAgICAgIGlmICh0eXBlb2YgcG9zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKHBvcyA9PT0gc3RlcCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDeWNsaWMgb2JqZWN0IHZhbHVlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbmRGbGFnID0gdHJ1ZTsgLy8gQnJlYWsgd2hpbGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRtcFNjLmdldChzZW50aW5lbCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzdGVwID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9iaiA9IGZpbHRlcihwcmVmaXgsIG9iaik7XG4gICAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIG9iaiA9IHNlcmlhbGl6ZURhdGUob2JqKTtcbiAgICB9IGVsc2UgaWYgKGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgaXNBcnJheShvYmopKSB7XG4gICAgICAgIG9iaiA9IHV0aWxzLm1heWJlTWFwKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZURhdGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIGlmIChzdHJpY3ROdWxsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVyICYmICFlbmNvZGVWYWx1ZXNPbmx5ID8gZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICdrZXknLCBmb3JtYXQpIDogcHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGlzTm9uTnVsbGlzaFByaW1pdGl2ZShvYmopIHx8IHV0aWxzLmlzQnVmZmVyKG9iaikpIHtcbiAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IGVuY29kZVZhbHVlc09ubHkgPyBwcmVmaXggOiBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ2tleScsIGZvcm1hdCk7XG4gICAgICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihrZXlWYWx1ZSkgKyAnPScgKyBmb3JtYXR0ZXIoZW5jb2RlcihvYmosIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICd2YWx1ZScsIGZvcm1hdCkpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihwcmVmaXgpICsgJz0nICsgZm9ybWF0dGVyKFN0cmluZyhvYmopKV07XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgdmFyIG9iaktleXM7XG4gICAgaWYgKGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgaXNBcnJheShvYmopKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gam9pbiBlbGVtZW50cyBpblxuICAgICAgICBpZiAoZW5jb2RlVmFsdWVzT25seSAmJiBlbmNvZGVyKSB7XG4gICAgICAgICAgICBvYmogPSB1dGlscy5tYXliZU1hcChvYmosIGVuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIG9iaktleXMgPSBbeyB2YWx1ZTogb2JqLmxlbmd0aCA+IDAgPyBvYmouam9pbignLCcpIHx8IG51bGwgOiB2b2lkIHVuZGVmaW5lZCB9XTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZmlsdGVyKSkge1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgb2JqS2V5cyA9IHNvcnQgPyBrZXlzLnNvcnQoc29ydCkgOiBrZXlzO1xuICAgIH1cblxuICAgIHZhciBhZGp1c3RlZFByZWZpeCA9IGNvbW1hUm91bmRUcmlwICYmIGlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID09PSAxID8gcHJlZml4ICsgJ1tdJyA6IHByZWZpeDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqS2V5cy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tqXTtcbiAgICAgICAgdmFyIHZhbHVlID0gdHlwZW9mIGtleSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGtleS52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyBrZXkudmFsdWUgOiBvYmpba2V5XTtcblxuICAgICAgICBpZiAoc2tpcE51bGxzICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXlQcmVmaXggPSBpc0FycmF5KG9iailcbiAgICAgICAgICAgID8gdHlwZW9mIGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdmdW5jdGlvbicgPyBnZW5lcmF0ZUFycmF5UHJlZml4KGFkanVzdGVkUHJlZml4LCBrZXkpIDogYWRqdXN0ZWRQcmVmaXhcbiAgICAgICAgICAgIDogYWRqdXN0ZWRQcmVmaXggKyAoYWxsb3dEb3RzID8gJy4nICsga2V5IDogJ1snICsga2V5ICsgJ10nKTtcblxuICAgICAgICBzaWRlQ2hhbm5lbC5zZXQob2JqZWN0LCBzdGVwKTtcbiAgICAgICAgdmFyIHZhbHVlU2lkZUNoYW5uZWwgPSBnZXRTaWRlQ2hhbm5lbCgpO1xuICAgICAgICB2YWx1ZVNpZGVDaGFubmVsLnNldChzZW50aW5lbCwgc2lkZUNoYW5uZWwpO1xuICAgICAgICBwdXNoVG9BcnJheSh2YWx1ZXMsIHN0cmluZ2lmeShcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAga2V5UHJlZml4LFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgIGNvbW1hUm91bmRUcmlwLFxuICAgICAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBlbmNvZGVWYWx1ZXNPbmx5ICYmIGlzQXJyYXkob2JqKSA/IG51bGwgOiBlbmNvZGVyLFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgIGFsbG93RG90cyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgY2hhcnNldCxcbiAgICAgICAgICAgIHZhbHVlU2lkZUNoYW5uZWxcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG5cbnZhciBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zID0gZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5naWZ5T3B0aW9ucyhvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5lbmNvZGVyICE9PSBudWxsICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5jb2RlciBoYXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhcnNldCA9IG9wdHMuY2hhcnNldCB8fCBkZWZhdWx0cy5jaGFyc2V0O1xuICAgIGlmICh0eXBlb2Ygb3B0cy5jaGFyc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmNoYXJzZXQgIT09ICd1dGYtOCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNoYXJzZXQgb3B0aW9uIG11c3QgYmUgZWl0aGVyIHV0Zi04LCBpc28tODg1OS0xLCBvciB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0ID0gZm9ybWF0c1snZGVmYXVsdCddO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5mb3JtYXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICghaGFzLmNhbGwoZm9ybWF0cy5mb3JtYXR0ZXJzLCBvcHRzLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZm9ybWF0IG9wdGlvbiBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3JtYXQgPSBvcHRzLmZvcm1hdDtcbiAgICB9XG4gICAgdmFyIGZvcm1hdHRlciA9IGZvcm1hdHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gICAgdmFyIGZpbHRlciA9IGRlZmF1bHRzLmZpbHRlcjtcbiAgICBpZiAodHlwZW9mIG9wdHMuZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8IGlzQXJyYXkob3B0cy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdHMuZmlsdGVyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZFF1ZXJ5UHJlZml4OiB0eXBlb2Ygb3B0cy5hZGRRdWVyeVByZWZpeCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5hZGRRdWVyeVByZWZpeCA6IGRlZmF1bHRzLmFkZFF1ZXJ5UHJlZml4LFxuICAgICAgICBhbGxvd0RvdHM6IHR5cGVvZiBvcHRzLmFsbG93RG90cyA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5hbGxvd0RvdHMgOiAhIW9wdHMuYWxsb3dEb3RzLFxuICAgICAgICBjaGFyc2V0OiBjaGFyc2V0LFxuICAgICAgICBjaGFyc2V0U2VudGluZWw6IHR5cGVvZiBvcHRzLmNoYXJzZXRTZW50aW5lbCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5jaGFyc2V0U2VudGluZWwgOiBkZWZhdWx0cy5jaGFyc2V0U2VudGluZWwsXG4gICAgICAgIGRlbGltaXRlcjogdHlwZW9mIG9wdHMuZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmRlbGltaXRlciA6IG9wdHMuZGVsaW1pdGVyLFxuICAgICAgICBlbmNvZGU6IHR5cGVvZiBvcHRzLmVuY29kZSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGUgOiBkZWZhdWx0cy5lbmNvZGUsXG4gICAgICAgIGVuY29kZXI6IHR5cGVvZiBvcHRzLmVuY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRzLmVuY29kZXIgOiBkZWZhdWx0cy5lbmNvZGVyLFxuICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5OiB0eXBlb2Ygb3B0cy5lbmNvZGVWYWx1ZXNPbmx5ID09PSAnYm9vbGVhbicgPyBvcHRzLmVuY29kZVZhbHVlc09ubHkgOiBkZWZhdWx0cy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICAgIGZvcm1hdHRlcjogZm9ybWF0dGVyLFxuICAgICAgICBzZXJpYWxpemVEYXRlOiB0eXBlb2Ygb3B0cy5zZXJpYWxpemVEYXRlID09PSAnZnVuY3Rpb24nID8gb3B0cy5zZXJpYWxpemVEYXRlIDogZGVmYXVsdHMuc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgc2tpcE51bGxzOiB0eXBlb2Ygb3B0cy5za2lwTnVsbHMgPT09ICdib29sZWFuJyA/IG9wdHMuc2tpcE51bGxzIDogZGVmYXVsdHMuc2tpcE51bGxzLFxuICAgICAgICBzb3J0OiB0eXBlb2Ygb3B0cy5zb3J0ID09PSAnZnVuY3Rpb24nID8gb3B0cy5zb3J0IDogbnVsbCxcbiAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nOiB0eXBlb2Ygb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nIDogZGVmYXVsdHMuc3RyaWN0TnVsbEhhbmRsaW5nXG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgb3B0cykge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zKG9wdHMpO1xuXG4gICAgdmFyIG9iaktleXM7XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIG9iaiA9IGZpbHRlcignJywgb2JqKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlGb3JtYXQ7XG4gICAgaWYgKG9wdHMgJiYgb3B0cy5hcnJheUZvcm1hdCBpbiBhcnJheVByZWZpeEdlbmVyYXRvcnMpIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRzLmFycmF5Rm9ybWF0O1xuICAgIH0gZWxzZSBpZiAob3B0cyAmJiAnaW5kaWNlcycgaW4gb3B0cykge1xuICAgICAgICBhcnJheUZvcm1hdCA9IG9wdHMuaW5kaWNlcyA/ICdpbmRpY2VzJyA6ICdyZXBlYXQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gJ2luZGljZXMnO1xuICAgIH1cblxuICAgIHZhciBnZW5lcmF0ZUFycmF5UHJlZml4ID0gYXJyYXlQcmVmaXhHZW5lcmF0b3JzW2FycmF5Rm9ybWF0XTtcbiAgICBpZiAob3B0cyAmJiAnY29tbWFSb3VuZFRyaXAnIGluIG9wdHMgJiYgdHlwZW9mIG9wdHMuY29tbWFSb3VuZFRyaXAgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgY29tbWFSb3VuZFRyaXBgIG11c3QgYmUgYSBib29sZWFuLCBvciBhYnNlbnQnKTtcbiAgICB9XG4gICAgdmFyIGNvbW1hUm91bmRUcmlwID0gZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBvcHRzICYmIG9wdHMuY29tbWFSb3VuZFRyaXA7XG5cbiAgICBpZiAoIW9iaktleXMpIHtcbiAgICAgICAgb2JqS2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgICAgICBvYmpLZXlzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgICB9XG5cbiAgICB2YXIgc2lkZUNoYW5uZWwgPSBnZXRTaWRlQ2hhbm5lbCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tpXTtcblxuICAgICAgICBpZiAob3B0aW9ucy5za2lwTnVsbHMgJiYgb2JqW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHB1c2hUb0FycmF5KGtleXMsIHN0cmluZ2lmeShcbiAgICAgICAgICAgIG9ialtrZXldLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgIGNvbW1hUm91bmRUcmlwLFxuICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICBvcHRpb25zLnNraXBOdWxscyxcbiAgICAgICAgICAgIG9wdGlvbnMuZW5jb2RlID8gb3B0aW9ucy5lbmNvZGVyIDogbnVsbCxcbiAgICAgICAgICAgIG9wdGlvbnMuZmlsdGVyLFxuICAgICAgICAgICAgb3B0aW9ucy5zb3J0LFxuICAgICAgICAgICAgb3B0aW9ucy5hbGxvd0RvdHMsXG4gICAgICAgICAgICBvcHRpb25zLnNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBvcHRpb25zLmZvcm1hdCxcbiAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0dGVyLFxuICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgb3B0aW9ucy5jaGFyc2V0LFxuICAgICAgICAgICAgc2lkZUNoYW5uZWxcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgdmFyIGpvaW5lZCA9IGtleXMuam9pbihvcHRpb25zLmRlbGltaXRlcik7XG4gICAgdmFyIHByZWZpeCA9IG9wdGlvbnMuYWRkUXVlcnlQcmVmaXggPT09IHRydWUgPyAnPycgOiAnJztcblxuICAgIGlmIChvcHRpb25zLmNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5jaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgICAgIC8vIGVuY29kZVVSSUNvbXBvbmVudCgnJiMxMDAwMzsnKSwgdGhlIFwibnVtZXJpYyBlbnRpdHlcIiByZXByZXNlbnRhdGlvbiBvZiBhIGNoZWNrbWFya1xuICAgICAgICAgICAgcHJlZml4ICs9ICd1dGY4PSUyNiUyMzEwMDAzJTNCJic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQoJ+KckycpXG4gICAgICAgICAgICBwcmVmaXggKz0gJ3V0Zjg9JUUyJTlDJTkzJic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gam9pbmVkLmxlbmd0aCA+IDAgPyBwcmVmaXggKyBqb2luZWQgOiAnJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG52YXIgaGV4VGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgYXJyYXkucHVzaCgnJScgKyAoKGkgPCAxNiA/ICcwJyA6ICcnKSArIGkudG9TdHJpbmcoMTYpKS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG59KCkpO1xuXG52YXIgY29tcGFjdFF1ZXVlID0gZnVuY3Rpb24gY29tcGFjdFF1ZXVlKHF1ZXVlKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgdmFyIGNvbXBhY3RlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iai5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2pdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChvYmpbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbS5vYmpbaXRlbS5wcm9wXSA9IGNvbXBhY3RlZDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBhcnJheVRvT2JqZWN0ID0gZnVuY3Rpb24gYXJyYXlUb09iamVjdChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0gb3B0aW9ucyAmJiBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9ialtpXSA9IHNvdXJjZVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgIC8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogMCAqL1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoKG9wdGlvbnMgJiYgKG9wdGlvbnMucGxhaW5PYmplY3RzIHx8IG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSkgfHwgIWhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbc291cmNlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3RhcmdldCwgc291cmNlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIFt0YXJnZXRdLmNvbmNhdChzb3VyY2UpO1xuICAgIH1cblxuICAgIHZhciBtZXJnZVRhcmdldCA9IHRhcmdldDtcbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmICFpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgbWVyZ2VUYXJnZXQgPSBhcnJheVRvT2JqZWN0KHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIGlmIChoYXMuY2FsbCh0YXJnZXQsIGkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEl0ZW0gPSB0YXJnZXRbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEl0ZW0gJiYgdHlwZW9mIHRhcmdldEl0ZW0gPT09ICdvYmplY3QnICYmIGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IG1lcmdlKHRhcmdldEl0ZW0sIGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICBpZiAoaGFzLmNhbGwoYWNjLCBrZXkpKSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IG1lcmdlKGFjY1trZXldLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgbWVyZ2VUYXJnZXQpO1xufTtcblxudmFyIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnblNpbmdsZVNvdXJjZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgYWNjW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB0YXJnZXQpO1xufTtcblxudmFyIGRlY29kZSA9IGZ1bmN0aW9uIChzdHIsIGRlY29kZXIsIGNoYXJzZXQpIHtcbiAgICB2YXIgc3RyV2l0aG91dFBsdXMgPSBzdHIucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICAvLyB1bmVzY2FwZSBuZXZlciB0aHJvd3MsIG5vIHRyeS4uLmNhdGNoIG5lZWRlZDpcbiAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRQbHVzLnJlcGxhY2UoLyVbMC05YS1mXXsyfS9naSwgdW5lc2NhcGUpO1xuICAgIH1cbiAgICAvLyB1dGYtOFxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyV2l0aG91dFBsdXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRQbHVzO1xuICAgIH1cbn07XG5cbnZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoc3RyLCBkZWZhdWx0RW5jb2RlciwgY2hhcnNldCwga2luZCwgZm9ybWF0KSB7XG4gICAgLy8gVGhpcyBjb2RlIHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gYnkgQnJpYW4gV2hpdGUgKG1zY2RleCkgZm9yIHRoZSBpby5qcyBjb3JlIHF1ZXJ5c3RyaW5nIGxpYnJhcnkuXG4gICAgLy8gSXQgaGFzIGJlZW4gYWRhcHRlZCBoZXJlIGZvciBzdHJpY3RlciBhZGhlcmVuY2UgdG8gUkZDIDM5ODZcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmcgPSBzdHI7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHN0cmluZyA9IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdHIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RyaW5nID0gU3RyaW5nKHN0cik7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICByZXR1cm4gZXNjYXBlKHN0cmluZykucmVwbGFjZSgvJXVbMC05YS1mXXs0fS9naSwgZnVuY3Rpb24gKCQwKSB7XG4gICAgICAgICAgICByZXR1cm4gJyUyNiUyMycgKyBwYXJzZUludCgkMC5zbGljZSgyKSwgMTYpICsgJyUzQic7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGMgPT09IDB4MkQgLy8gLVxuICAgICAgICAgICAgfHwgYyA9PT0gMHgyRSAvLyAuXG4gICAgICAgICAgICB8fCBjID09PSAweDVGIC8vIF9cbiAgICAgICAgICAgIHx8IGMgPT09IDB4N0UgLy8gflxuICAgICAgICAgICAgfHwgKGMgPj0gMHgzMCAmJiBjIDw9IDB4MzkpIC8vIDAtOVxuICAgICAgICAgICAgfHwgKGMgPj0gMHg0MSAmJiBjIDw9IDB4NUEpIC8vIGEtelxuICAgICAgICAgICAgfHwgKGMgPj0gMHg2MSAmJiBjIDw9IDB4N0EpIC8vIEEtWlxuICAgICAgICAgICAgfHwgKGZvcm1hdCA9PT0gZm9ybWF0cy5SRkMxNzM4ICYmIChjID09PSAweDI4IHx8IGMgPT09IDB4MjkpKSAvLyAoIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvdXQgKz0gc3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyBoZXhUYWJsZVtjXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgKGhleFRhYmxlWzB4QzAgfCAoYyA+PiA2KV0gKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID49IDB4RTAwMCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgKGhleFRhYmxlWzB4RTAgfCAoYyA+PiAxMildICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXSArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKChjICYgMHgzRkYpIDw8IDEwKSB8IChzdHJpbmcuY2hhckNvZGVBdChpKSAmIDB4M0ZGKSk7XG4gICAgICAgIC8qIGVzbGludCBvcGVyYXRvci1saW5lYnJlYWs6IFsyLCBcImJlZm9yZVwiXSAqL1xuICAgICAgICBvdXQgKz0gaGV4VGFibGVbMHhGMCB8IChjID4+IDE4KV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiAxMikgJiAweDNGKV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXVxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbnZhciBjb21wYWN0ID0gZnVuY3Rpb24gY29tcGFjdCh2YWx1ZSkge1xuICAgIHZhciBxdWV1ZSA9IFt7IG9iajogeyBvOiB2YWx1ZSB9LCBwcm9wOiAnbycgfV07XG4gICAgdmFyIHJlZnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZVtpXTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiByZWZzLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHsgb2JqOiBvYmosIHByb3A6IGtleSB9KTtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBhY3RRdWV1ZShxdWV1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgaXNSZWdFeHAgPSBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxudmFyIGlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhIShvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKTtcbn07XG5cbnZhciBjb21iaW5lID0gZnVuY3Rpb24gY29tYmluZShhLCBiKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChhLCBiKTtcbn07XG5cbnZhciBtYXliZU1hcCA9IGZ1bmN0aW9uIG1heWJlTWFwKHZhbCwgZm4pIHtcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG1hcHBlZC5wdXNoKGZuKHZhbFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfVxuICAgIHJldHVybiBmbih2YWwpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXJyYXlUb09iamVjdDogYXJyYXlUb09iamVjdCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBjb21iaW5lOiBjb21iaW5lLFxuICAgIGNvbXBhY3Q6IGNvbXBhY3QsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICAgIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgICBtYXliZU1hcDogbWF5YmVNYXAsXG4gICAgbWVyZ2U6IG1lcmdlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1kYXRhLXByb3BlcnR5Jyk7XG52YXIgaGFzRGVzY3JpcHRvcnMgPSByZXF1aXJlKCdoYXMtcHJvcGVydHktZGVzY3JpcHRvcnMnKSgpO1xudmFyIGdPUEQgPSByZXF1aXJlKCdnb3BkJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xudmFyICRmbG9vciA9IEdldEludHJpbnNpYygnJU1hdGguZmxvb3IlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0RnVuY3Rpb25MZW5ndGgoZm4sIGxlbmd0aCkge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BmbmAgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0fVxuXHRpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicgfHwgbGVuZ3RoIDwgMCB8fCBsZW5ndGggPiAweEZGRkZGRkZGIHx8ICRmbG9vcihsZW5ndGgpICE9PSBsZW5ndGgpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGxlbmd0aGAgbXVzdCBiZSBhIHBvc2l0aXZlIDMyLWJpdCBpbnRlZ2VyJyk7XG5cdH1cblxuXHR2YXIgbG9vc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiAhIWFyZ3VtZW50c1syXTtcblxuXHR2YXIgZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSA9IHRydWU7XG5cdHZhciBmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUgPSB0cnVlO1xuXHRpZiAoJ2xlbmd0aCcgaW4gZm4gJiYgZ09QRCkge1xuXHRcdHZhciBkZXNjID0gZ09QRChmbiwgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0ZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoZGVzYyAmJiAhZGVzYy53cml0YWJsZSkge1xuXHRcdFx0ZnVuY3Rpb25MZW5ndGhJc1dyaXRhYmxlID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgfHwgZnVuY3Rpb25MZW5ndGhJc1dyaXRhYmxlIHx8ICFsb29zZSkge1xuXHRcdGlmIChoYXNEZXNjcmlwdG9ycykge1xuXHRcdFx0ZGVmaW5lKGZuLCAnbGVuZ3RoJywgbGVuZ3RoLCB0cnVlLCB0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVmaW5lKGZuLCAnbGVuZ3RoJywgbGVuZ3RoKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZuO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJ29iamVjdC1pbnNwZWN0Jyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xudmFyICRXZWFrTWFwID0gR2V0SW50cmluc2ljKCclV2Vha01hcCUnLCB0cnVlKTtcbnZhciAkTWFwID0gR2V0SW50cmluc2ljKCclTWFwJScsIHRydWUpO1xuXG52YXIgJHdlYWtNYXBHZXQgPSBjYWxsQm91bmQoJ1dlYWtNYXAucHJvdG90eXBlLmdldCcsIHRydWUpO1xudmFyICR3ZWFrTWFwU2V0ID0gY2FsbEJvdW5kKCdXZWFrTWFwLnByb3RvdHlwZS5zZXQnLCB0cnVlKTtcbnZhciAkd2Vha01hcEhhcyA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuaGFzJywgdHJ1ZSk7XG52YXIgJG1hcEdldCA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5nZXQnLCB0cnVlKTtcbnZhciAkbWFwU2V0ID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLnNldCcsIHRydWUpO1xudmFyICRtYXBIYXMgPSBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuaGFzJywgdHJ1ZSk7XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIHRyYXZlcnNlcyB0aGUgbGlzdCByZXR1cm5pbmcgdGhlIG5vZGUgY29ycmVzcG9uZGluZyB0byB0aGVcbiAqIGdpdmVuIGtleS5cbiAqXG4gKiBUaGF0IG5vZGUgaXMgYWxzbyBtb3ZlZCB0byB0aGUgaGVhZCBvZiB0aGUgbGlzdCwgc28gdGhhdCBpZiBpdCdzIGFjY2Vzc2VkXG4gKiBhZ2FpbiB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSB3aG9sZSBsaXN0LiBCeSBkb2luZyBzbywgYWxsIHRoZSByZWNlbnRseVxuICogdXNlZCBub2RlcyBjYW4gYmUgYWNjZXNzZWQgcmVsYXRpdmVseSBxdWlja2x5LlxuICovXG52YXIgbGlzdEdldE5vZGUgPSBmdW5jdGlvbiAobGlzdCwga2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0Zm9yICh2YXIgcHJldiA9IGxpc3QsIGN1cnI7IChjdXJyID0gcHJldi5uZXh0KSAhPT0gbnVsbDsgcHJldiA9IGN1cnIpIHtcblx0XHRpZiAoY3Vyci5rZXkgPT09IGtleSkge1xuXHRcdFx0cHJldi5uZXh0ID0gY3Vyci5uZXh0O1xuXHRcdFx0Y3Vyci5uZXh0ID0gbGlzdC5uZXh0O1xuXHRcdFx0bGlzdC5uZXh0ID0gY3VycjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHRcdFx0cmV0dXJuIGN1cnI7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgbGlzdEdldCA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXkpIHtcblx0dmFyIG5vZGUgPSBsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xuXHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlO1xufTtcbnZhciBsaXN0U2V0ID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSwgdmFsdWUpIHtcblx0dmFyIG5vZGUgPSBsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xuXHRpZiAobm9kZSkge1xuXHRcdG5vZGUudmFsdWUgPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHQvLyBQcmVwZW5kIHRoZSBuZXcgbm9kZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cdFx0b2JqZWN0cy5uZXh0ID0geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdFx0XHRrZXk6IGtleSxcblx0XHRcdG5leHQ6IG9iamVjdHMubmV4dCxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cbn07XG52YXIgbGlzdEhhcyA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXkpIHtcblx0cmV0dXJuICEhbGlzdEdldE5vZGUob2JqZWN0cywga2V5KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0U2lkZUNoYW5uZWwoKSB7XG5cdHZhciAkd207XG5cdHZhciAkbTtcblx0dmFyICRvO1xuXHR2YXIgY2hhbm5lbCA9IHtcblx0XHRhc3NlcnQ6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdGlmICghY2hhbm5lbC5oYXMoa2V5KSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignU2lkZSBjaGFubmVsIGRvZXMgbm90IGNvbnRhaW4gJyArIGluc3BlY3Qoa2V5KSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnZXQ6IGZ1bmN0aW9uIChrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHRcdFx0aWYgKCRXZWFrTWFwICYmIGtleSAmJiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0aWYgKCR3bSkge1xuXHRcdFx0XHRcdHJldHVybiAkd2Vha01hcEdldCgkd20sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoJE1hcCkge1xuXHRcdFx0XHRpZiAoJG0pIHtcblx0XHRcdFx0XHRyZXR1cm4gJG1hcEdldCgkbSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCRvKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9uZWx5LWlmXG5cdFx0XHRcdFx0cmV0dXJuIGxpc3RHZXQoJG8sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGhhczogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKCRXZWFrTWFwICYmIGtleSAmJiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0aWYgKCR3bSkge1xuXHRcdFx0XHRcdHJldHVybiAkd2Vha01hcEhhcygkd20sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoJE1hcCkge1xuXHRcdFx0XHRpZiAoJG0pIHtcblx0XHRcdFx0XHRyZXR1cm4gJG1hcEhhcygkbSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCRvKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9uZWx5LWlmXG5cdFx0XHRcdFx0cmV0dXJuIGxpc3RIYXMoJG8sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdGlmICgkV2Vha01hcCAmJiBrZXkgJiYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHRcdGlmICghJHdtKSB7XG5cdFx0XHRcdFx0JHdtID0gbmV3ICRXZWFrTWFwKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0JHdlYWtNYXBTZXQoJHdtLCBrZXksIHZhbHVlKTtcblx0XHRcdH0gZWxzZSBpZiAoJE1hcCkge1xuXHRcdFx0XHRpZiAoISRtKSB7XG5cdFx0XHRcdFx0JG0gPSBuZXcgJE1hcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCRtYXBTZXQoJG0sIGtleSwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCEkbykge1xuXHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0ICogSW5pdGlhbGl6ZSB0aGUgbGlua2VkIGxpc3QgYXMgYW4gZW1wdHkgbm9kZSwgc28gdGhhdCB3ZSBkb24ndCBoYXZlXG5cdFx0XHRcdFx0ICogdG8gc3BlY2lhbC1jYXNlIGhhbmRsaW5nIG9mIHRoZSBmaXJzdCBub2RlOiB3ZSBjYW4gYWx3YXlzIHJlZmVyIHRvXG5cdFx0XHRcdFx0ICogaXQgYXMgKHByZXZpb3VzIG5vZGUpLm5leHQsIGluc3RlYWQgb2Ygc29tZXRoaW5nIGxpa2UgKGxpc3QpLmhlYWRcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHQkbyA9IHsga2V5OiB7fSwgbmV4dDogbnVsbCB9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3RTZXQoJG8sIGtleSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGNoYW5uZWw7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvcnRDb250cm9sbGVyID0gdm9pZCAwO1xuY2xhc3MgUG9ydENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcnQsIHBvcnRWaWV3KSB7XG4gICAgICAgIHRoaXMucG9ydCA9IHBvcnQ7XG4gICAgICAgIHRoaXMucG9ydFZpZXcgPSBwb3J0VmlldztcbiAgICB9XG4gICAgcHJvY2Vzc1NoaXAoc2hpcCkge1xuICAgICAgICBjb25zdCBkb2NrID0gdGhpcy5wb3J0LmZpbmRFbXB0eURvY2soKTtcbiAgICAgICAgaWYgKGRvY2spIHtcbiAgICAgICAgICAgIGRvY2sub2NjdXB5KCk7XG4gICAgICAgICAgICBzaGlwLnByb2Nlc3NBdERvY2soZG9jayk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBkb2NrLnJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICBkb2NrLnNldENhcmdvKHNoaXAudHlwZSA9PT0gJ3JlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9ydFZpZXcudXBkYXRlKCk7XG4gICAgICAgICAgICB9LCA1MDAwKTsgLy8g0KfQsNGBINC/0LXRgNC10LHRg9Cy0LDQvdC90Y8g0LrQvtGA0LDQsdC70Y8g0YMg0L/QvtGA0YLRg1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbkFjY2VwdFNoaXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcnQuZmluZEVtcHR5RG9jaygpICE9PSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9ydENvbnRyb2xsZXIgPSBQb3J0Q29udHJvbGxlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5RdWV1ZU1hbmFnZXIgPSB2b2lkIDA7XG5jbGFzcyBRdWV1ZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxvYWRpbmdRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnVubG9hZGluZ1F1ZXVlID0gW107XG4gICAgfVxuICAgIGFkZFRvUXVldWUoc2hpcCkge1xuICAgICAgICBpZiAoc2hpcC50eXBlID09PSAnZ3JlZW4nKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdRdWV1ZS5wdXNoKHNoaXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bmxvYWRpbmdRdWV1ZS5wdXNoKHNoaXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE5leHRTaGlwKCkge1xuICAgICAgICBpZiAodGhpcy51bmxvYWRpbmdRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmxvYWRpbmdRdWV1ZS5zaGlmdCgpIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5sb2FkaW5nUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZ1F1ZXVlLnNoaWZ0KCkgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaGFzU2hpcHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRpbmdRdWV1ZS5sZW5ndGggPiAwIHx8IHRoaXMudW5sb2FkaW5nUXVldWUubGVuZ3RoID4gMDtcbiAgICB9XG59XG5leHBvcnRzLlF1ZXVlTWFuYWdlciA9IFF1ZXVlTWFuYWdlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZWFDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgcGl4aV9qc18xID0gcmVxdWlyZShcInBpeGkuanNcIik7XG5jb25zdCBTaGlwXzEgPSByZXF1aXJlKFwiLi4vbW9kZWxzL1NoaXBcIik7XG5jb25zdCBTaGlwVmlld18xID0gcmVxdWlyZShcIi4uL3ZpZXdzL1NoaXBWaWV3XCIpO1xuY29uc3QgU2hpcENvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL1NoaXBDb250cm9sbGVyXCIpO1xuY29uc3QgUXVldWVNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9RdWV1ZU1hbmFnZXJcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgdHdlZW5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHR3ZWVuanMvdHdlZW4uanNcIikpO1xuY29uc3QgU2VhVmlld18xID0gcmVxdWlyZShcIi4uL3ZpZXdzL1NlYVZpZXdcIik7XG4vLyBpbnRlcmZhY2UgU2hpcFR5cGUge1xuLy8gICAgIHNoaXA6IFNoaXA7XG4vLyAgICAgc2hpcFZpZXc6IFNoaXBWaWV3O1xuLy8gICAgIHNoaXBDb250cm9sbGVyOiBTaGlwQ29udHJvbGxlcjtcbi8vIH1cbmNsYXNzIFNlYUNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNoaXBzID0gW107XG4gICAgICAgIHRoaXMucXVldWVNYW5hZ2VyID0gbmV3IFF1ZXVlTWFuYWdlcl8xLlF1ZXVlTWFuYWdlcigpO1xuICAgICAgICB0aGlzLnNlYVZpZXcgPSBuZXcgU2VhVmlld18xLlNlYVZpZXcoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVTaGlwcygpO1xuICAgICAgICB0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuICAgIH1cbiAgICAvLyBwcml2YXRlIHNldFRvU2hpcHNMaXN0KHNoaXBNb2RlbDogU2hpcFR5cGUpIHtcbiAgICAvLyAgICAgdGhpcy5zaGlwcy5wdXNoKHNoaXBNb2RlbCk7XG4gICAgLy8gfVxuICAgIGNyZWF0ZVNoaXBzKCkge1xuICAgICAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaGlwVHlwZSA9IHV0aWxzXzEuVXRpbHMucmFuZG9tSW50KDAsIDEpID09PSAwID8gJ2dyZWVuJyA6ICdyZWQnO1xuICAgICAgICAgICAgY29uc3Qgc2hpcCA9IG5ldyBTaGlwXzEuU2hpcChzaGlwVHlwZSk7XG4gICAgICAgICAgICBjb25zdCBzaGlwVmlldyA9IG5ldyBTaGlwVmlld18xLlNoaXBWaWV3KHNoaXApO1xuICAgICAgICAgICAgY29uc3Qgc2hpcENvbnRyb2xsZXIgPSBuZXcgU2hpcENvbnRyb2xsZXJfMS5TaGlwQ29udHJvbGxlcihzaGlwLCBzaGlwVmlldywgdGhpcy5zZWFWaWV3LmdldFBvcnRDb250cm9sbGVyKCkpO1xuICAgICAgICAgICAgLy8g0JLQuNC30L3QsNGH0LDRlNC80L4g0L/QvtGH0LDRgtC60L7QstGDINC/0L7Qt9C40YbRltGOINC60L7RgNCw0LHQu9GPXG4gICAgICAgICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gbmV3IHBpeGlfanNfMS5Qb2ludCgtNTAwLCB1dGlsc18xLlV0aWxzLnJhbmRvbUludCgyMDAsIDUwMCkpO1xuICAgICAgICAgICAgc2hpcFZpZXcuc2V0UG9zaXRpb24oc3RhcnRQb3NpdGlvbik7XG4gICAgICAgICAgICAvLyDQlNC+0LTQsNGU0LzQviDQutC+0YDQsNCx0LXQu9GMINC00L4g0YfQtdGA0LPQuFxuICAgICAgICAgICAgLy8g0JDQvdGW0LzQsNGG0ZbRjyDRgNGD0YXRgyDQutC+0YDQsNCx0LvRjyDQtNC+INC+0YfRltC60YPQstCw0L3QvtGXINC/0L7Qt9C40YbRltGXINCx0ZbQu9GPINC/0L7RgNGC0YNcbiAgICAgICAgICAgIGNvbnN0IHBvcnRQb3NpdGlvbiA9IG5ldyBwaXhpX2pzXzEuUG9pbnQoMjAwLCB1dGlsc18xLlV0aWxzLnJhbmRvbUludCgxMDAsIDMwMCkpO1xuICAgICAgICAgICAgc2hpcENvbnRyb2xsZXIubW92ZVRvUG9ydChwb3J0UG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5xdWV1ZU1hbmFnZXIuYWRkVG9RdWV1ZShzaGlwKTtcbiAgICAgICAgICAgIHRoaXMuc2hpcHMucHVzaChzaGlwQ29udHJvbGxlcik7XG4gICAgICAgIH0sIDUwMDApOyAvLyDQp9Cw0YHRgtC+0YLQsCDQv9C+0Y/QstC4INC60L7RgNCw0LHQu9GW0LJcbiAgICB9XG4gICAgcHJvY2Vzc1F1ZXVlKCkge1xuICAgICAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBpZiAodGhpcy5zZWFWaWV3LmdldFBvcnRDb250cm9sbGVyKCkuY2FuQWNjZXB0U2hpcCgpICYmIHRoaXMucXVldWVNYW5hZ2VyLmhhc1NoaXBzKCkpIHtcbiAgICAgICAgICAgIC8vICAgICBjb25zdCBzaGlwID0gdGhpcy5xdWV1ZU1hbmFnZXIuZ2V0TmV4dFNoaXAoKTtcbiAgICAgICAgICAgIC8vICAgICBpZiAoc2hpcCkge1xuICAgICAgICAgICAgLy8gICAgICAgICB0aGlzLnNlYVZpZXcuZ2V0UG9ydENvbnRyb2xsZXIoKS5wcm9jZXNzU2hpcChzaGlwKTtcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBjb25zdCBzaGlwID0gdGhpcy5xdWV1ZU1hbmFnZXIuZ2V0TmV4dFNoaXAoKTtcbiAgICAgICAgICAgIGlmIChzaGlwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFWaWV3LmdldFBvcnRDb250cm9sbGVyKCkucHJvY2Vzc1NoaXAoc2hpcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMDApOyAvLyDQn9C10YDRltC+0LTQuNGH0L3QsCDQv9C10YDQtdCy0ZbRgNC60LAg0YfQtdGA0LPQuFxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgLy8gdGhpcy5hcHAudGlja2VyLmFkZChkZWx0YSA9PiB0aGlzLmdhbWVVcGRhdGUoZGVsdGEpKTtcbiAgICAgICAgdGhpcy5zZWFWaWV3LmdldEFwcFBhcmFtcygpLnRpY2tlci5hZGQoKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdhbWVVcGRhdGUoZGVsdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2FtZVVwZGF0ZShkZWx0YSkge1xuICAgICAgICB0d2Vlbl9qc18xLmRlZmF1bHQudXBkYXRlKCk7XG4gICAgICAgIC8vIEdhbWUgbG9naWMgdXBkYXRlc1xuICAgIH1cbn1cbmV4cG9ydHMuU2VhQ29udHJvbGxlciA9IFNlYUNvbnRyb2xsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2hpcENvbnRyb2xsZXIgPSB2b2lkIDA7XG5jbGFzcyBTaGlwQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3Ioc2hpcCwgc2hpcFZpZXcsIHBvcnRDb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuc2hpcCA9IHNoaXA7XG4gICAgICAgIHRoaXMuc2hpcFZpZXcgPSBzaGlwVmlldztcbiAgICAgICAgdGhpcy5wb3J0Q29udHJvbGxlciA9IHBvcnRDb250cm9sbGVyO1xuICAgIH1cbiAgICBtb3ZlVG9Qb3J0KHBvcnRQb3NpdGlvbikge1xuICAgICAgICB0aGlzLnNoaXBWaWV3LmFuaW1hdGVNb3ZlbWVudChwb3J0UG9zaXRpb24pO1xuICAgICAgICAvLyDQlNC+0LTQsNGC0LrQvtCy0LAg0LvQvtCz0ZbQutCwINC00LvRjyDQstC30LDRlNC80L7QtNGW0Zcg0Lcg0L/QvtGA0YLQvtC8XG4gICAgfVxuICAgIGxlYXZlUG9ydCgpIHtcbiAgICAgICAgdGhpcy5zaGlwLmxlYXZlRG9jaygpO1xuICAgICAgICAvLyDQm9C+0LPRltC60LAg0LTQu9GPINCy0LjRhdC+0LTRgyDQutC+0YDQsNCx0LvRjyDQtyDQv9C+0YDRgtGDXG4gICAgfVxufVxuZXhwb3J0cy5TaGlwQ29udHJvbGxlciA9IFNoaXBDb250cm9sbGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRvY2sgPSB2b2lkIDA7XG5jbGFzcyBEb2NrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vY2N1cGllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhcmdvID0gZmFsc2U7XG4gICAgfVxuICAgIG9jY3VweSgpIHtcbiAgICAgICAgdGhpcy5vY2N1cGllZCA9IHRydWU7XG4gICAgfVxuICAgIHJlbGVhc2UoKSB7XG4gICAgICAgIHRoaXMub2NjdXBpZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaXNPY2N1cGllZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2NjdXBpZWQ7XG4gICAgfVxuICAgIHNldENhcmdvKGNhcmdvKSB7XG4gICAgICAgIHRoaXMuY2FyZ28gPSBjYXJnbztcbiAgICB9XG4gICAgaGFzQ2FyZ28oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhcmdvO1xuICAgIH1cbn1cbmV4cG9ydHMuRG9jayA9IERvY2s7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9ydCA9IHZvaWQgMDtcbmNvbnN0IERvY2tfMSA9IHJlcXVpcmUoXCIuL0RvY2tcIik7XG5jbGFzcyBQb3J0IHtcbiAgICBjb25zdHJ1Y3Rvcihkb2NrQ291bnQpIHtcbiAgICAgICAgdGhpcy5kb2NrcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvY2tDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRvY2tzLnB1c2gobmV3IERvY2tfMS5Eb2NrKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldERvY2tzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NrcztcbiAgICB9XG4gICAgZmluZEVtcHR5RG9jaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9ja3MuZmluZChkb2NrID0+ICFkb2NrLmlzT2NjdXBpZWQoKSkgfHwgbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLlBvcnQgPSBQb3J0O1xuLy8gc3JjL21vZGVscy9Qb3J0LnRzXG4vLyBpbXBvcnQgeyBEb2NrIH0gZnJvbSAnLi9Eb2NrJztcbi8vIGltcG9ydCB7IFNoaXAsIFNoaXBUeXBlIH0gZnJvbSAnLi9TaGlwJztcbi8vIGV4cG9ydCBjbGFzcyBQb3J0IHtcbi8vICAgICBkb2NrczogRG9ja1tdO1xuLy8gICAgIGdyZWVuUXVldWU6IFNoaXBbXTtcbi8vICAgICByZWRRdWV1ZTogU2hpcFtdO1xuLy8gICAgIGNvbnN0cnVjdG9yKGRvY2tzOiBEb2NrW10pIHtcbi8vICAgICAgICAgdGhpcy5kb2NrcyA9IGRvY2tzO1xuLy8gICAgICAgICB0aGlzLmdyZWVuUXVldWUgPSBbXTtcbi8vICAgICAgICAgdGhpcy5yZWRRdWV1ZSA9IFtdO1xuLy8gICAgIH1cbi8vICAgICAvLyDQnNC10YLQvtC00Lgg0LTQu9GPINGD0L/RgNCw0LLQu9GW0L3QvdGPINC/0L7RgNGC0L7QvCDRgtCwINGA0L7Qt9C/0L7QtNGW0LvRgyDQutC+0YDQsNCx0LvRltCyXG4vLyB9XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2hpcCA9IHZvaWQgMDtcbmNsYXNzIFNoaXAge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICAgICAgdGhpcy5kb2NrID0gbnVsbDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgcHJvY2Vzc0F0RG9jayhkb2NrKSB7XG4gICAgICAgIHRoaXMuZG9jayA9IGRvY2s7XG4gICAgICAgIC8vINCb0L7Qs9GW0LrQsCDQvtCx0YDQvtCx0LrQuCDQutC+0YDQsNCx0LvRjyDQvdCwINC/0YDQuNGB0YLQsNC90ZZcbiAgICB9XG4gICAgbGVhdmVEb2NrKCkge1xuICAgICAgICB0aGlzLmRvY2sgPSBudWxsO1xuICAgIH1cbiAgICBpc0F0RG9jaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jayAhPT0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLlNoaXAgPSBTaGlwO1xuLy8gc3JjL21vZGVscy9TaGlwLnRzXG4vLyBleHBvcnQgZW51bSBTaGlwVHlwZSB7XG4vLyAgICAgR3JlZW4sIC8vINCX0LXQu9C10L3QuNC5IC0g0L/RgNC40YXQvtC00LjRgtGMINC30LAg0LLQsNC90YLQsNC20LXQvFxuLy8gICAgIFJlZCAgICAvLyDQp9C10YDQstC+0L3QuNC5IC0g0L/RgNC40YXQvtC00LjRgtGMINC3INCy0LDQvdGC0LDQttC10Lxcbi8vIH1cbi8vIGV4cG9ydCBjbGFzcyBTaGlwIHtcbi8vICAgICB0eXBlOiBTaGlwVHlwZTtcbi8vICAgICBpc0xvYWRlZDogYm9vbGVhbjtcbi8vICAgICBjYXBhY2l0eTogbnVtYmVyO1xuLy8gICAgIHBvc2l0aW9uOiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH07XG4vLyAgICAgY29uc3RydWN0b3IodHlwZTogU2hpcFR5cGUsIGNhcGFjaXR5OiBudW1iZXIsIHBvc2l0aW9uOiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH0pIHtcbi8vICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbi8vICAgICAgICAgdGhpcy5pc0xvYWRlZCA9IHR5cGUgPT09IFNoaXBUeXBlLlJlZDtcbi8vICAgICAgICAgdGhpcy5jYXBhY2l0eSA9IGNhcGFjaXR5O1xuLy8gICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4vLyAgICAgfVxuLy8gICAgIC8vINCc0LXRgtC+0LTQuCDQtNC70Y8g0YPQv9GA0LDQstC70ZbQvdC90Y8g0YHRgtCw0L3QvtC8INC60L7RgNCw0LHQu9GPXG4vLyB9XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVXRpbHMgPSB2b2lkIDA7XG5jbGFzcyBVdGlscyB7XG4gICAgc3RhdGljIHJhbmRvbUludChtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcbiAgICB9XG59XG5leHBvcnRzLlV0aWxzID0gVXRpbHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRG9ja1ZpZXcgPSB2b2lkIDA7XG4vLyBzcmMvdmlld3MvRG9ja1ZpZXcudHNcbmNvbnN0IHBpeGlfanNfMSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xuY2xhc3MgRG9ja1ZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGRvY2ssIHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZG9jayA9IGRvY2s7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MgPSBuZXcgcGl4aV9qc18xLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgfVxuICAgIGRyYXcoKSB7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuY2xlYXIoKTtcbiAgICAgICAgLy8g0JLRgdGC0LDQvdC+0LLQu9GO0ZTQvNC+INC60L7Qu9GW0YAg0LfQsNC70LXQttC90L4g0LLRltC0INGB0YLQsNGC0YPRgdGDINC/0YDQuNGB0YLQsNC90ZZcbiAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLmRvY2suaXNPY2N1cGllZCgpID8gMHgwMDAwRkYgOiAweENDQ0NDQzsgLy8g0KHQuNC90ZbQuSwg0Y/QutGJ0L4g0LfQsNC50L3Rj9GC0L4sINGW0L3QsNC60YjQtSAtINGB0LLRltGC0LvQvi3RgdGW0YDQuNC5XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuYmVnaW5GaWxsKGNvbG9yKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lU3R5bGUoMSwgMSwgMSwgMSk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QodGhpcy5wb3NpdGlvbi54ICsgMTAsIHRoaXMucG9zaXRpb24ueSArIDEwLCA4MCwgNTApOyAvLyDQoNC+0LfQvNGW0YDQuCDQv9GA0LjRgdGC0LDQvdGWXG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgIH1cbiAgICAvLyDQntC90L7QstC70LXQvdC90Y8g0LLRltC00L7QsdGA0LDQttC10L3QvdGPINC/0YDQuCDQt9C80ZbQvdGWINGB0YLQsNGC0YPRgdGDINC/0YDQuNGB0YLQsNC90ZZcbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuZHJhdygpO1xuICAgIH1cbn1cbmV4cG9ydHMuRG9ja1ZpZXcgPSBEb2NrVmlldztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb3J0VmlldyA9IHZvaWQgMDtcbmNvbnN0IHBpeGlfanNfMSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xuY29uc3QgRG9ja1ZpZXdfMSA9IHJlcXVpcmUoXCIuL0RvY2tWaWV3XCIpO1xuY2xhc3MgUG9ydFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHBvcnQsIGFwcCkge1xuICAgICAgICB0aGlzLmRvY2tWaWV3cyA9IFtdO1xuICAgICAgICB0aGlzLnBvcnQgPSBwb3J0O1xuICAgICAgICB0aGlzLnBvcnRHcmFwaGljcyA9IG5ldyBwaXhpX2pzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMucG9ydEdyYXBoaWNzKTtcbiAgICAgICAgdGhpcy5hcHBTdGFnZSA9IGFwcDtcbiAgICAgICAgLy8gdGhpcy5kb2NrR3JhcGhpY3MgPSBuZXcgR3JhcGhpY3MoKTtcbiAgICAgICAgLy8gdGhpcy5kb2NrR3JhcGhpY3MuYWRkQ2hpbGQobmV3IENvbnRhaW5lcigpKVxuICAgICAgICAvLyBhcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy5kb2NrR3JhcGhpY3MpO1xuICAgICAgICB0aGlzLmRyYXdQb3J0KCk7XG4gICAgICAgIHRoaXMuZHJhd0RvY2tzKHRoaXMuZG9ja1ZpZXdzLCB0aGlzLmFwcFN0YWdlKTtcbiAgICB9XG4gICAgZHJhd1BvcnQoKSB7XG4gICAgICAgIHRoaXMucG9ydEdyYXBoaWNzLmNsZWFyKCk7XG4gICAgICAgIC8vIHRoaXMucG9ydEdyYXBoaWNzLndpZHRoID0gdGhpcy5hcHBTdGFnZS5zY3JlZW4ud2lkdGggLyAyO1xuICAgICAgICAvLyB0aGlzLmFwcFN0YWdlLnNjcmVlbi5oZWlnaHQgPSBhcHAuc2NyZWVuLmhlaWdodCAvIDI7XG4gICAgICAgIC8vIHRoaXMucG9ydEdyYXBoaWNzLmJlZ2luRmlsbCgweGZmZmYwMCk7IC8vINCa0L7Qu9GW0YAg0L/QvtGA0YLRg1xuICAgICAgICB0aGlzLnBvcnRHcmFwaGljcy5saW5lU3R5bGUoMi41LCAweDJlOGI1Nyk7IC8vINCi0LjQvyDQu9GW0L3vv73vv73Rl1xuICAgICAgICB0aGlzLnBvcnRHcmFwaGljcy5kcmF3UmVjdCgxMDAsIDEwMCwgMzUwLCA0MDApOyAvLyDQoNC+0LfQvNGW0YDQuCDQv9C+0YDRgtGDXG4gICAgICAgIHRoaXMucG9ydEdyYXBoaWNzLmVuZEZpbGwoKTtcbiAgICB9XG4gICAgZHJhd0RvY2tzKGRvY2tWaWV3cywgYXBwKSB7XG4gICAgICAgIC8vIHRoaXMucG9ydC5nZXREb2NrcygpLmZvckVhY2goKGRvY2ssIGluZGV4KSA9PiB7XG4gICAgICAgIC8vICAgICB0aGlzLmRvY2tHcmFwaGljcy5iZWdpbkZpbGwoZG9jay5oYXNDYXJnbygpID8gMHgwMDAwZmYgOiAweGZmZmZmZiwgZG9jay5pc09jY3VwaWVkKCkgPyAxIDogMC41KTtcbiAgICAgICAgLy8gICAgIC8vIHRoaXMuZG9ja0dyYXBoaWNzLnNjYWxlLnggPSAtMC4yOyAvLyDQn9C10YDQtdCy0LXRgNGC0LDRlNC80L4g0LrQvtC90YLQtdC50L3QtdGAXG4gICAgICAgIC8vICAgICB0aGlzLmRvY2tHcmFwaGljcy5wb3NpdGlvbi54ID0gMTAwO1xuICAgICAgICAvLyAgICAgdGhpcy5kb2NrR3JhcGhpY3MubGluZVN0eWxlKDUsIDUpO1xuICAgICAgICAvLyAgICAgdGhpcy5kb2NrR3JhcGhpY3MucG9zaXRpb24ueSA9IDEwMDtcbiAgICAgICAgLy8gICAgIHRoaXMuZG9ja0dyYXBoaWNzLmRyYXdSZWN0KDEwMCArIGluZGV4ICogMTAwLCAxMDAsIDgwLCAxMDApO1xuICAgICAgICAvLyAgICAgdGhpcy5kb2NrR3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgdGhpcy5wb3J0LmdldERvY2tzKCkuZm9yRWFjaCgoZG9jaywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRvY2tWaWV3ID0gbmV3IERvY2tWaWV3XzEuRG9ja1ZpZXcoZG9jaywgeyB4OiAxMDAsIHk6IDEwMCArIChpbmRleCArIDAuNSkgKiA4MCB9KTtcbiAgICAgICAgICAgIGRvY2tWaWV3cy5wdXNoKGRvY2tWaWV3KTtcbiAgICAgICAgICAgIGFwcC5zdGFnZS5hZGRDaGlsZChkb2NrVmlldy5ncmFwaGljcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuZHJhd0RvY2tzKHRoaXMuZG9ja1ZpZXdzLCB0aGlzLmFwcFN0YWdlKTtcbiAgICB9XG59XG5leHBvcnRzLlBvcnRWaWV3ID0gUG9ydFZpZXc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2VhVmlldyA9IHZvaWQgMDtcbmNvbnN0IHBpeGlfanNfMSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xuY29uc3QgUG9ydF8xID0gcmVxdWlyZShcIi4uL21vZGVscy9Qb3J0XCIpO1xuY29uc3QgUG9ydFZpZXdfMSA9IHJlcXVpcmUoXCIuLi92aWV3cy9Qb3J0Vmlld1wiKTtcbmNvbnN0IFBvcnRDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vY29udHJvbGxlcnMvUG9ydENvbnRyb2xsZXJcIik7XG5jbGFzcyBTZWFWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hcHAgPSBuZXcgcGl4aV9qc18xLkFwcGxpY2F0aW9uKHsgd2lkdGg6IDgwMCwgaGVpZ2h0OiA2MDAsIGJhY2tncm91bmRDb2xvcjogMHgxMDk5YmIgfSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5hcHAudmlldyk7XG4gICAgICAgIHRoaXMucG9ydCA9IG5ldyBQb3J0XzEuUG9ydCg0KTsgLy8gNCDQv9GA0LjRgdGC0LDQvdGWXG4gICAgICAgIHRoaXMucG9ydFZpZXcgPSBuZXcgUG9ydFZpZXdfMS5Qb3J0Vmlldyh0aGlzLnBvcnQsIHRoaXMuYXBwKTtcbiAgICAgICAgdGhpcy5wb3J0Q29udHJvbGxlciA9IG5ldyBQb3J0Q29udHJvbGxlcl8xLlBvcnRDb250cm9sbGVyKHRoaXMucG9ydCwgdGhpcy5wb3J0Vmlldyk7XG4gICAgICAgIC8vIGNvbnN0IGRvY2tWaWV3czogRG9ja1ZpZXdbXSA9IFtdO1xuICAgICAgICAvLyB0aGlzLnBvcnQuZ2V0RG9ja3MoKS5mb3JFYWNoKChkb2NrLCBpbmRleCkgPT4ge1xuICAgICAgICAvLyAgICAgY29uc3QgZG9ja1ZpZXcgPSBuZXcgRG9ja1ZpZXcoZG9jaywgeyB4OiAxMDAsIHk6IDEwMCArIGluZGV4ICogNjAgfSk7XG4gICAgICAgIC8vICAgICBkb2NrVmlld3MucHVzaChkb2NrVmlldyk7XG4gICAgICAgIC8vICAgICB0aGlzLmFwcC5zdGFnZS5hZGRDaGlsZChkb2NrVmlldy5ncmFwaGljcyk7XG4gICAgICAgIC8vIH0pO1xuICAgIH1cbiAgICBnZXRQb3J0Q29udHJvbGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9ydENvbnRyb2xsZXI7XG4gICAgfVxuICAgIGdldEFwcFBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VhVmlldyA9IFNlYVZpZXc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2hpcFZpZXcgPSB2b2lkIDA7XG5jb25zdCBwaXhpX2pzXzEgPSByZXF1aXJlKFwicGl4aS5qc1wiKTtcbnZhciBUV0VFTiA9IHJlcXVpcmUoJ0B0d2VlbmpzL3R3ZWVuLmpzJyk7XG5jbGFzcyBTaGlwVmlldyB7XG4gICAgY29uc3RydWN0b3Ioc2hpcE1vZGVsKSB7XG4gICAgICAgIHRoaXMuc2hpcE1vZGVsID0gc2hpcE1vZGVsO1xuICAgICAgICB0aGlzLnNoaXBHcmFwaGljcyA9IG5ldyBwaXhpX2pzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgdGhpcy5zaGlwU3ByaXRlID0gbmV3IHBpeGlfanNfMS5TcHJpdGUocGl4aV9qc18xLlRleHR1cmUuV0hJVEUpO1xuICAgICAgICAvLyB0aGlzLnNoaXBTcHJpdGUudGludCA9IHRoaXMuc2hpcE1vZGVsLnR5cGUgPT09ICdncmVlbicgPyAweDAwZmYwMCA6IDB4ZmYwMDAwO1xuICAgICAgICAvLyB0aGlzLnNoaXBTcHJpdGUud2lkdGggPSA1MDsgLy8g0J/RgNC40L/Rg9GB0YLQuNC80L4sINGJ0L4g0YDQvtC30LzRltGAINC60L7RgNCw0LHQu9GPIC0gNTB4MjBcbiAgICAgICAgLy8gdGhpcy5zaGlwU3ByaXRlLmhlaWdodCA9IDIwO1xuICAgICAgICB0aGlzLnNoaXBHcmFwaGljcy5jbGVhcigpO1xuICAgICAgICAvLyDQktGB0YLQsNC90L7QstC70Y7RlNC80L4g0LrQvtC70ZbRgCDQt9Cw0LvQtdC20L3QviDQstGW0LQg0YHRgtCw0YLRg9GB0YMg0L/RgNC40YHRgtCw0L3RllxuICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuc2hpcE1vZGVsLnR5cGUgPT09ICdncmVlbicgPyAweDAwZmYwMCA6IDB4ZmYwMDAwO1xuICAgICAgICB0aGlzLnNoaXBHcmFwaGljcy5iZWdpbkZpbGwoY29sb3IpO1xuICAgICAgICB0aGlzLnNoaXBHcmFwaGljcy5saW5lU3R5bGUoMSwgMSwgMSwgMSk7XG4gICAgICAgIHRoaXMuc2hpcEdyYXBoaWNzLmRyYXdSZWN0KHRoaXMuc2hpcEdyYXBoaWNzLnBvc2l0aW9uLnggKyA1LCB0aGlzLnNoaXBHcmFwaGljcy5wb3NpdGlvbi55ICsgNSwgNDAsIDIwKTsgLy8g0KDQvtC30LzRltGA0Lgg0L/RgNC40YHRgtCw0L3RllxuICAgICAgICB0aGlzLnNoaXBHcmFwaGljcy5lbmRGaWxsKCk7XG4gICAgfVxuICAgIHNldFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuc2hpcFNwcml0ZS54ID0gcG9zaXRpb24ueDtcbiAgICAgICAgdGhpcy5zaGlwU3ByaXRlLnkgPSBwb3NpdGlvbi55O1xuICAgIH1cbiAgICBhbmltYXRlTW92ZW1lbnQoZGVzdGluYXRpb24pIHtcbiAgICAgICAgbmV3IFRXRUVOLlR3ZWVuKHRoaXMuc2hpcEdyYXBoaWNzLnBvc2l0aW9uKVxuICAgICAgICAgICAgLnRvKHsgeDogZGVzdGluYXRpb24ueCwgeTogZGVzdGluYXRpb24ueSB9LCA1MDAwKVxuICAgICAgICAgICAgLmVhc2luZyhUV0VFTi5FYXNpbmcuUXVhZHJhdGljLk91dClcbiAgICAgICAgICAgIC5zdGFydCgpO1xuICAgIH1cbiAgICBnZXQgdmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hpcFNwcml0ZTtcbiAgICB9XG59XG5leHBvcnRzLlNoaXBWaWV3ID0gU2hpcFZpZXc7XG4vLyBzcmMvdmlld3MvU2hpcFZpZXcudHNcbi8vIGltcG9ydCAqIGFzIFBJWEkgZnJvbSAncGl4aS5qcyc7XG4vLyBpbXBvcnQgeyBTaGlwLCBTaGlwVHlwZSB9IGZyb20gJy4uL21vZGVscy9TaGlwJztcbi8vIGV4cG9ydCBjbGFzcyBTaGlwVmlldyB7XG4vLyAgICAgc2hpcDogU2hpcDtcbi8vICAgICBncmFwaGljczogUElYSS5HcmFwaGljcztcbi8vICAgICBjb25zdHJ1Y3RvcihzaGlwOiBTaGlwLCBhcHA6IFBJWEkuQXBwbGljYXRpb24pIHtcbi8vICAgICAgICAgdGhpcy5zaGlwID0gc2hpcDtcbi8vICAgICAgICAgdGhpcy5ncmFwaGljcyA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG4vLyAgICAgICAgIHRoaXMuZHJhd1NoaXAoKTtcbi8vICAgICAgICAgYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMuZ3JhcGhpY3MpO1xuLy8gICAgIH1cbi8vICAgICBkcmF3U2hpcCgpIHtcbi8vICAgICAgICAgdGhpcy5ncmFwaGljcy5jbGVhcigpO1xuLy8gICAgICAgICB0aGlzLmdyYXBoaWNzLmJlZ2luRmlsbCh0aGlzLnNoaXAudHlwZSA9PT0gU2hpcFR5cGUuR3JlZW4gPyAweDAwZmYwMCA6IDB4ZmYwMDAwKTtcbi8vICAgICAgICAgdGhpcy5ncmFwaGljcy5kcmF3UmVjdCh0aGlzLnNoaXAucG9zaXRpb24ueCwgdGhpcy5zaGlwLnBvc2l0aW9uLnksIDUwLCAyMCk7IC8vINCf0YDQuNC/0YPRgdGC0LjQvNGWINGA0L7Qt9C80ZbRgNC4INC60L7RgNCw0LHQu9GPXG4vLyAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZW5kRmlsbCgpO1xuLy8gICAgIH1cbi8vICAgICAvLyDQnNC10YLQvtC00Lgg0LTQu9GPINCw0L3RltC80LDRhtGW0Zcg0YLQsCDQvtC90L7QstC70LXQvdC90Y8g0LLRltC30YPQsNC70ZbQt9Cw0YbRltGXINC60L7RgNCw0LHQu9GPXG4vLyB9XG4iLCIvKlxuICogQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuICogcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4gKiBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuICogTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4gKiBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcbiAqIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbiAqIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vKlxuICogZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbiAqIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxuICovXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAvKlxuICAgKiBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgKiBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgKi9cbiAgZGVsaW1zID0gW1xuICAgICc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J1xuICBdLFxuXG4gIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gIHVud2lzZSA9IFtcbiAgICAneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXG4gIF0uY29uY2F0KGRlbGltcyksXG5cbiAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgLypcbiAgICogQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICogTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgKiBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICogdGhlbS5cbiAgICovXG4gIG5vbkhvc3RDaGFycyA9IFtcbiAgICAnJScsICcvJywgJz8nLCAnOycsICcjJ1xuICBdLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgaG9zdEVuZGluZ0NoYXJzID0gW1xuICAgICcvJywgJz8nLCAnIydcbiAgXSxcbiAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgamF2YXNjcmlwdDogdHJ1ZSxcbiAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gIH0sXG4gIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICBqYXZhc2NyaXB0OiB0cnVlLFxuICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgfSxcbiAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICBodHRwOiB0cnVlLFxuICAgIGh0dHBzOiB0cnVlLFxuICAgIGZ0cDogdHJ1ZSxcbiAgICBnb3BoZXI6IHRydWUsXG4gICAgZmlsZTogdHJ1ZSxcbiAgICAnaHR0cDonOiB0cnVlLFxuICAgICdodHRwczonOiB0cnVlLFxuICAgICdmdHA6JzogdHJ1ZSxcbiAgICAnZ29waGVyOic6IHRydWUsXG4gICAgJ2ZpbGU6JzogdHJ1ZVxuICB9LFxuICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3FzJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0JyAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHsgcmV0dXJuIHVybDsgfVxuXG4gIHZhciB1ID0gbmV3IFVybCgpO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvKlxuICAgKiBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgICogQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gICAqIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gICAqL1xuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgc3BsaXR0ZXIgPSBxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSA/ICc/JyA6ICcjJyxcbiAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLypcbiAgICogdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICogVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICAgKi9cbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8qXG4gICAqIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gICAqIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgICogcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAgKiBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgICovXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AL10rQFteQC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvKlxuICAgICAqIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAgKiB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgICAqXG4gICAgICogSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgICAqIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgICogY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAgKiBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgICpcbiAgICAgKiBleDpcbiAgICAgKiBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgICAqIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcbiAgICAgKi9cblxuICAgIC8qXG4gICAgICogdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgICAqIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG4gICAgICovXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7IGhvc3RFbmQgPSBoZWM7IH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgICAqIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgICAqL1xuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKlxuICAgICAgICogYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgICogaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgICAqL1xuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgICogUHVsbCB0aGF0IG9mZi5cbiAgICAgKi9cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkgeyBob3N0RW5kID0gaGVjOyB9XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHsgaG9zdEVuZCA9IHJlc3QubGVuZ3RoOyB9XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLypcbiAgICAgKiB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgICAqIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgICovXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvKlxuICAgICAqIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgICogYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgICovXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJiB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgeyBjb250aW51ZTsgfVxuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICogd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAqIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgICogYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvKlxuICAgICAgICogSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAgKiBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAgKiBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAgKiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgICovXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLypcbiAgICAgKiBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgICogdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICAgKi9cbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gICAqIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgICovXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8qXG4gICAgICogRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgICAqIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgICAqIG5lZWQgdG8gYmUuXG4gICAgICovXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSkgeyBjb250aW51ZTsgfVxuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHsgdGhpcy5wYXRobmFtZSA9IHJlc3Q7IH1cbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJiB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8qXG4gICAqIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gICAqIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gICAqIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgICogdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgICovXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykgeyBvYmogPSB1cmxQYXJzZShvYmopOyB9XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHsgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTsgfVxuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgaG9zdCA9IGZhbHNlLFxuICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgPyB0aGlzLmhvc3RuYW1lIDogJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiYgdHlwZW9mIHRoaXMucXVlcnkgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnksIHtcbiAgICAgIGFycmF5Rm9ybWF0OiAncmVwZWF0JyxcbiAgICAgIGFkZFF1ZXJ5UHJlZml4OiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSB7IHByb3RvY29sICs9ICc6JzsgfVxuXG4gIC8qXG4gICAqIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAgKiB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICAgKi9cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fCAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7IHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7IH1cbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIHsgaGFzaCA9ICcjJyArIGhhc2g7IH1cbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHsgc2VhcmNoID0gJz8nICsgc2VhcmNoOyB9XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSB7IHJldHVybiByZWxhdGl2ZTsgfVxuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uIChyZWxhdGl2ZSkge1xuICBpZiAodHlwZW9mIHJlbGF0aXZlID09PSAnc3RyaW5nJykge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvKlxuICAgKiBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgICogZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gICAqL1xuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJykgeyByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTsgfVxuICAgIH1cblxuICAgIC8vIHVybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJiByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWU7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLypcbiAgICAgKiBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgICogdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgICogZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgICogYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAgKiB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgICogaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAgKiBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAgKiBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgICovXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpIHsgfVxuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSB7IHJlbGF0aXZlLmhvc3QgPSAnJzsgfVxuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgeyByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnOyB9XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHsgcmVsUGF0aC51bnNoaWZ0KCcnKTsgfVxuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgeyByZWxQYXRoLnVuc2hpZnQoJycpOyB9XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsXG4gICAgaXNSZWxBYnMgPSByZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLFxuICAgIG11c3RFbmRBYnMgPSBpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fCAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpLFxuICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvKlxuICAgKiBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gICAqIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgICogdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAgKiByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAgKiBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgICovXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHsgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0OyB9IGVsc2UgeyBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpOyB9XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgeyByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDsgfSBlbHNlIHsgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpOyB9XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnID8gcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJyA/IHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvKlxuICAgICAqIGl0J3MgcmVsYXRpdmVcbiAgICAgKiB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICAgKi9cbiAgICBpZiAoIXNyY1BhdGgpIHsgc3JjUGF0aCA9IFtdOyB9XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmIChyZWxhdGl2ZS5zZWFyY2ggIT0gbnVsbCkge1xuICAgIC8qXG4gICAgICoganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgICAqIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgICogUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgICovXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdDtcbiAgICAgIC8qXG4gICAgICAgKiBvY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgICogdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgICogdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICAgKi9cbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/IHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSAhPT0gbnVsbCB8fCByZXN1bHQuc2VhcmNoICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgKyAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLypcbiAgICAgKiBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgICogd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICAgKi9cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLypcbiAgICogaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gICAqIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAgKiB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgKi9cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJyc7XG5cbiAgLypcbiAgICogc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAgKiBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICAgKi9cbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8IChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSBpc0Fic29sdXRlID8gJycgOiBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lO1xuICAgIC8qXG4gICAgICogb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgKiB0aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICogdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICovXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID8gcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKHNyY1BhdGgubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9XG5cbiAgLy8gdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKHJlc3VsdC5wYXRobmFtZSAhPT0gbnVsbCB8fCByZXN1bHQuc2VhcmNoICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICsgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHsgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7IH1cbn07XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuIiwiLyogKGlnbm9yZWQpICovIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0bG9hZGVkOiBmYWxzZSxcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU2VhQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4vY29udHJvbGxlcnMvU2VhQ29udHJvbGxlclwiKTtcbndpbmRvdy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgY29uc3QgYXBwUmVuZGVyID0gbmV3IFNlYUNvbnRyb2xsZXJfMS5TZWFDb250cm9sbGVyKCk7XG4gICAgYXBwUmVuZGVyLnN0YXJ0KCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9